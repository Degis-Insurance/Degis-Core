{
  "language": "Solidity",
  "sources": {
    "contracts/chainlinkMock/FlightOracleMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../miserable-flight/interfaces/IPolicyFlow.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @title  Flight Oracle Mock\n * @notice Mock oracle contract for test.\n */\ncontract FlightOracleMock is Ownable {\n    IPolicyFlow public policyFlow;\n\n    uint256 public delayResult; // For test\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PolicyFlowChanged(address newPolicyFlow);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Need the address of LINK token on specific network\n     */\n    constructor(address _policyFlow) Ownable(msg.sender) {\n        policyFlow = IPolicyFlow(_policyFlow);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Only the policyFlow can call some functions\n    modifier onlyPolicyFlow() {\n        require(\n            msg.sender == address(policyFlow),\n            \"Only the policyflow can call this function\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Change the policy flow contract address\n     */\n    function setPolicyFlow(address _policyFlow) external onlyOwner {\n        policyFlow = IPolicyFlow(_policyFlow);\n        emit PolicyFlowChanged(_policyFlow);\n    }\n\n    function setResult(uint256 _delayResult) external {\n        delayResult = _delayResult;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Creates a request to the specified Oracle contract address\n     * @dev This function ignores the stored Oracle contract address and\n     *      will instead send the request to the address specified\n     * @param _payment Payment to the oracle\n     * @param _url The URL to fetch data from\n     * @param _path The dot-delimited path to parse of the response\n     * @param _times The number to multiply the result by\n     */\n    function newOracleRequest(\n        uint256 _payment,\n        string memory _url,\n        string memory _path,\n        int256 _times\n    ) public view onlyPolicyFlow returns (bytes32 requestId) {\n        requestId = keccak256(abi.encodePacked(_payment, _url, _path, _times));\n\n        // fulfill(test_hash, delayResult);\n        return requestId;\n    }\n\n    /**\n     * @notice The fulfill method from requests created by this contract\n     * @dev The recordChainlinkFulfillment protects this function from being called\n     *      by anyone other than the oracle address that the request was sent to\n     * @param _requestId The ID that was generated for the request\n     */\n    function fulfill(bytes32 _requestId) public {\n        policyFlow.finalSettlement(_requestId, delayResult);\n    }\n}\n"
    },
    "contracts/miserable-flight/interfaces/IPolicyFlow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./IPolicyStruct.sol\";\n\n/**\n * @title  IPolicyFlow\n * @notice This is the interface of PolicyFlow contract.\n *         Contains some type definations, event list and function declarations.\n */\ninterface IPolicyFlow is IPolicyStruct {\n    /// @notice Function declarations\n\n    /// @notice Apply for a new policy\n    function newApplication(\n        uint256 _productId,\n        string memory _flightNumber,\n        uint256 _premium,\n        uint256 _departureTimestamp,\n        uint256 _landingTimestamp,\n        uint256 _deadline,\n        bytes calldata signature\n    ) external returns (uint256 policyId);\n\n    /// @notice Start a new claim request\n    function newClaimRequest(\n        uint256 _policyId,\n        string memory _flightNumber,\n        string memory _timestamp,\n        string memory _path,\n        bool _forceUpdate\n    ) external;\n\n    /// @notice View a user's policy info\n    function viewUserPolicy(address)\n        external\n        view\n        returns (PolicyInfo[] memory);\n\n    /// @notice Get the policy info by its policyId\n    function getPolicyInfoById(uint256)\n        external\n        view\n        returns (PolicyInfo memory);\n\n    /// @notice Update when the policy token is transferred to another owner\n    function policyOwnerTransfer(\n        uint256,\n        address,\n        address\n    ) external;\n\n    /// @notice Do the final settlement when receiving the oracle result\n    function finalSettlement(bytes32 _requestId, uint256 _result) external;\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./Context.sol\";\n\n/**\n * @dev The owner can be set during deployment, not default to be msg.sender\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor(address _initialOwner) {\n        _transferOwnership(_initialOwner);\n    }\n\n    /**\n     * @notice Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @notice Leaves the contract without owner. It will not be possible to call\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * @dev    Renouncing ownership will leave the contract without an owner,\n     *         thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Can only be called by the current owner.\n     * @param  newOwner Address of the new owner\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Internal function without access restriction.\n     * @param  newOwner Address of the new owner\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/miserable-flight/interfaces/IPolicyStruct.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IPolicyStruct {\n    enum PolicyStatus {\n        INI,\n        SOLD,\n        EXPIRED,\n        CLAIMED\n    }\n\n    struct PolicyInfo {\n        uint256 productId;\n        address buyerAddress;\n        uint256 policyId;\n        string flightNumber;\n        uint256 premium;\n        uint256 payoff;\n        uint256 purchaseTimestamp;\n        uint256 departureTimestamp;\n        uint256 landingTimestamp;\n        PolicyStatus status;\n        bool alreadySettled;\n        uint256 delayResult;\n    }\n}\n"
    },
    "contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/staking/StakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport {Ownable} from \"../utils/Ownable.sol\";\nimport {IPool} from \"./interfaces/IPool.sol\";\nimport {BasePool, CoreStakingPool} from \"./CoreStakingPool.sol\";\nimport {IDegisToken} from \"../tokens/interfaces/IDegisToken.sol\";\n\ncontract StakingPoolFactory is Ownable {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Pool data info\n    struct PoolData {\n        address poolToken; // pool token address (Degis / Degis LP Token)\n        address poolAddress; // pool address (deployed by factory)\n        uint256 startTimestamp; // pool start timestamp\n        uint256 degisPerSecond; // reward speed\n    }\n\n    address public degisToken;\n\n    // Pool token address  => pool address\n    mapping(address => address) public pools;\n\n    // Pool address -> whether exists\n    mapping(address => bool) public poolExists;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PoolRegistered(\n        address indexed by,\n        address indexed poolToken,\n        address indexed poolAddress,\n        uint256 degisPerSecond\n    );\n\n    event DegisPerSecondChanged(address pool, uint256 degisPerSecond);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(address _degisToken) Ownable(msg.sender) {\n        degisToken = _degisToken;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the pool address from pool token address\n     * @param _poolToken Pool token address\n     */\n    function getPoolAddress(address _poolToken)\n        external\n        view\n        returns (address)\n    {\n        return pools[_poolToken];\n    }\n\n    /**\n     * @notice Get pool data from pool token address\n     * @param _poolToken Pool token address\n     * @return poolData Pool data struct\n     */\n    function getPoolData(address _poolToken)\n        public\n        view\n        returns (PoolData memory)\n    {\n        // get the pool address from the mapping\n        address poolAddr = pools[_poolToken];\n\n        // throw if there is no pool registered for the token specified\n        require(poolAddr != address(0), \"pool not found\");\n\n        // read pool information from the pool smart contract\n        // via the pool interface (IPool)\n        address poolToken = IPool(poolAddr).poolToken();\n        uint256 startTimestamp = IPool(poolAddr).startTimestamp();\n        uint256 degisPerSecond = IPool(poolAddr).degisPerSecond();\n\n        // create the in-memory structure and return it\n        return\n            PoolData({\n                poolToken: poolToken,\n                poolAddress: poolAddr,\n                startTimestamp: startTimestamp,\n                degisPerSecond: degisPerSecond\n            });\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set degis per second for a pool\n     * @param _pool Address of the staking pool\n     * @param _degisPerSecond Degis reward per second\n     */\n    function setDegisPerSecond(address _pool, uint256 _degisPerSecond)\n        external\n        onlyOwner\n    {\n        BasePool(_pool).setDegisPerSecond(_degisPerSecond);\n\n        emit DegisPerSecondChanged(_pool, _degisPerSecond);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Creates a staking pool and registers it within the factory\n     * @dev Only called by the owner\n     * @param _poolToken Pool token address\n     * @param _startTimestamp Start timestamp for reward\n     * @param _degisPerSecond Reward speed\n     */\n    function createPool(\n        address _poolToken,\n        uint256 _startTimestamp,\n        uint256 _degisPerSecond\n    ) external onlyOwner {\n        // create/deploy new core pool instance\n        IPool pool = new CoreStakingPool(\n            degisToken,\n            _poolToken,\n            address(this),\n            _startTimestamp,\n            _degisPerSecond\n        );\n\n        // register it within a factory\n        _registerPool(address(pool));\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Register a deployed pool instance within the factory\n     * @param _poolAddr Address of the already deployed pool instance\n     */\n    function _registerPool(address _poolAddr) internal {\n        // Read pool information from the pool smart contract\n        // via the pool interface (IPool)\n        address poolToken = IPool(_poolAddr).poolToken();\n        uint256 degisPerSecond = IPool(_poolAddr).degisPerSecond();\n\n        // Ensure that the pool is not already registered within the factory\n        require(\n            pools[poolToken] == address(0),\n            \"This pool is already registered\"\n        );\n\n        // Record\n        pools[poolToken] = _poolAddr;\n        poolExists[_poolAddr] = true;\n\n        emit PoolRegistered(\n            msg.sender,\n            poolToken,\n            _poolAddr,\n            degisPerSecond\n        );\n    }\n\n    /**\n     * @notice Mint degis tokens as reward\n     * @dev With this function, we only need to add factory contract into minterList\n     * @param _to The address to mint tokens to\n     * @param _amount Amount of degis tokens to mint\n     */\n    function mintReward(address _to, uint256 _amount) external {\n        // Verify that sender is a pool registered withing the factory\n        require(poolExists[msg.sender], \"Only called from pool\");\n\n        // Mint degis tokens as required\n        IDegisToken(degisToken).mintDegis(_to, _amount);\n    }\n}\n"
    },
    "contracts/staking/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n/**\n * @title Illuvium Pool\n *\n * @notice An abstraction representing a pool, see IlluviumPoolBase for details\n *\n * @author Pedro Bergamini, reviewed by Basil Gorin\n */\ninterface IPool {\n    /**\n     * @dev Deposit is a key data structure used in staking,\n     *      it represents a unit of stake with its amount, weight and term (time interval)\n     */\n    struct Deposit {\n        // @dev token amount staked\n        uint256 tokenAmount;\n        // @dev stake weight\n        uint256 weight;\n        // @dev locking period - from\n        uint256 lockedFrom;\n        // @dev locking period - until\n        uint256 lockedUntil;\n    }\n\n    // for the rest of the functions see Soldoc in IlluviumPoolBase\n\n    function degisToken() external view returns (address);\n\n    function poolToken() external view returns (address);\n\n    function startTimestamp() external view returns (uint256);\n\n    function degisPerSecond() external view returns (uint256);\n\n    function totalWeight() external view returns (uint256);\n\n    function accDegisPerWeight() external view returns (uint256);\n\n    function pendingReward(address _user) external view returns (uint256);\n\n    function setDegisPerSecond(uint256 _degisPerSecond) external;\n}\n"
    },
    "contracts/staking/CoreStakingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport {Ownable} from \"../utils/Ownable.sol\";\nimport {BasePool} from \"./abstracts/BasePool.sol\";\n\ncontract CoreStakingPool is Ownable, BasePool {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _degisToken,\n        address _poolToken,\n        address _factory,\n        uint256 _startTimestamp,\n        uint256 _degisPerSecond\n    )\n        Ownable(msg.sender)\n        BasePool(\n            _degisToken,\n            _poolToken,\n            _factory,\n            _startTimestamp,\n            _degisPerSecond\n        )\n    {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Stake function, will call the stake in BasePool\n     * @param _user User address\n     * @param _amount Amount to stake\n     * @param _lockUntil Lock until timestamp (0 means flexible staking)\n     */\n    function _stake(\n        address _user,\n        uint256 _amount,\n        uint256 _lockUntil\n    ) internal override {\n        super._stake(_user, _amount, _lockUntil);\n    }\n\n    /**\n     * @notice Unstake function, will check some conditions and call the unstake in BasePool\n     * @param _user User address\n     * @param _depositId Deposit id\n     * @param _amount Amount to unstake\n     */\n    function _unstake(\n        address _user,\n        uint256 _depositId,\n        uint256 _amount\n    ) internal override {\n        UserInfo storage user = users[_msgSender()];\n        Deposit memory stakeDeposit = user.deposits[_depositId];\n        require(\n            stakeDeposit.lockedFrom == 0 ||\n                block.timestamp >= stakeDeposit.lockedUntil,\n            \"Deposit not yet unlocked\"\n        );\n\n        super._unstake(_user, _depositId, _amount);\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IDegisToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDegisToken is IERC20, IERC20Permit {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Functions ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    function CAP() external view returns (uint256);\n\n    /**\n     * @notice Mint degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintDegis(address _account, uint256 _amount) external;\n\n    /**\n     * @notice Burn degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnDegis(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/staking/abstracts/BasePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/IStakingPoolFactory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nabstract contract BasePool is IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    struct UserInfo {\n        uint256 tokenAmount;\n        uint256 totalWeight;\n        uint256 rewardDebt;\n        // An array of holder's deposits\n        Deposit[] deposits;\n    }\n    mapping(address => UserInfo) public users;\n\n    // Token address staked in this pool\n    address public poolToken;\n\n    // Reward token: degis\n    address public degisToken;\n\n    // Reward start timestamp\n    uint256 public startTimestamp;\n\n    // Degis reward speed\n    uint256 public degisPerSecond;\n\n    // Last check point\n    uint256 public lastRewardTimestamp;\n\n    // Accumulated degis per weight till now\n    uint256 public accDegisPerWeight;\n\n    // Total weight in the pool\n    uint256 public totalWeight;\n\n    // Factory contract address\n    address public factory;\n\n    // Fees are paid to the previous stakers\n    uint256 public constant fee = 2;\n\n    // Weight multiplier constants\n    uint256 internal constant WEIGHT_MULTIPLIER = 1e6;\n\n    uint256 internal constant YEAR_STAKE_WEIGHT_MULTIPLIER =\n        2 * WEIGHT_MULTIPLIER;\n\n    uint256 internal constant REWARD_PER_WEIGHT_MULTIPLIER = 1e12;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Stake(address user, uint256 amount, uint256 lockUntil);\n\n    event Unstake(address user, uint256 amount);\n\n    event Harvest(address user, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor\n     */\n    constructor(\n        address _degisToken,\n        address _poolToken,\n        address _factory,\n        uint256 _startTimestamp,\n        uint256 _degisPerSecond\n    ) {\n        degisToken = _degisToken;\n        poolToken = _poolToken;\n        factory = _factory;\n\n        degisPerSecond = _degisPerSecond;\n\n        startTimestamp = _startTimestamp;\n\n        lastRewardTimestamp = block.timestamp > _startTimestamp\n            ? block.timestamp\n            : _startTimestamp;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only the factory can call some functions\n     */\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Only factory\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get a user's deposit info\n     * @param _user User address\n     * @return deposits[] User's deposit info\n     */\n    function getUserDeposits(address _user)\n        external\n        view\n        returns (Deposit[] memory)\n    {\n        return users[_user].deposits;\n    }\n\n    /**\n     * @notice Get pending rewards\n     * @param _user User address\n     * @return pendingReward User's pending rewards\n     */\n    function pendingReward(address _user) external view returns (uint256) {\n        if (\n            block.timestamp < lastRewardTimestamp ||\n            block.timestamp < startTimestamp ||\n            totalWeight == 0\n        ) return 0;\n\n        uint256 blocks = block.timestamp - lastRewardTimestamp;\n        uint256 degisReward = blocks * degisPerSecond;\n\n        // recalculated value for `yieldRewardsPerWeight`\n        uint256 newDegisPerWeight = rewardToWeight(degisReward, totalWeight) +\n            accDegisPerWeight;\n\n        // based on the rewards per weight value, calculate pending rewards;\n        UserInfo memory user = users[_user];\n\n        uint256 pending = weightToReward(user.totalWeight, newDegisPerWeight) -\n            user.rewardDebt;\n\n        return pending;\n    }\n\n    function rewardToWeight(uint256 reward, uint256 rewardPerWeight)\n        public\n        pure\n        returns (uint256)\n    {\n        return (reward * REWARD_PER_WEIGHT_MULTIPLIER) / rewardPerWeight;\n    }\n\n    function weightToReward(uint256 weight, uint256 rewardPerWeight)\n        public\n        pure\n        returns (uint256)\n    {\n        return (weight * rewardPerWeight) / REWARD_PER_WEIGHT_MULTIPLIER;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n    function setDegisPerSecond(uint256 _degisPerSecond) external onlyFactory {\n        degisPerSecond = _degisPerSecond;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Stake tokens\n     * @param _amount Amount of tokens to stake\n     * @param _lockUntil Lock until timestamp\n     */\n    function stake(uint256 _amount, uint256 _lockUntil) external {\n        _stake(msg.sender, _amount, _lockUntil);\n    }\n\n    /**\n     * @notice Unstake tokens\n     * @param _depositId Deposit id to be unstaked\n     * @param _amount Amount of tokens to unstake\n     */\n    function unstake(uint256 _depositId, uint256 _amount) external {\n        _unstake(msg.sender, _depositId, _amount);\n    }\n\n    /**\n     * @notice Harvest your staking rewards\n     */\n    function harvest() external {\n        // First update the pool\n        updatePool();\n\n        UserInfo storage user = users[msg.sender];\n\n        // calculate pending yield rewards, this value will be returned\n        uint256 pending = _pendingReward(msg.sender);\n\n        if (pending == 0) return;\n\n        _safeDegisTransfer(msg.sender, pending);\n\n        user.rewardDebt = weightToReward(user.totalWeight, accDegisPerWeight);\n\n        emit Harvest(msg.sender, pending);\n    }\n\n    /**\n     * @notice Update the pool without fee\n     */\n    function updatePool() public {\n        _updatePoolWithFee(0);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update pool status with fee (if any)\n     * @param _fee Fee to be distributed\n     */\n    function _updatePoolWithFee(uint256 _fee) internal {\n        if (block.timestamp <= lastRewardTimestamp) return;\n\n        uint256 balance = IERC20(poolToken).balanceOf(address(this));\n\n        if (balance == 0) {\n            lastRewardTimestamp = block.timestamp;\n            return;\n        }\n\n        uint256 timePassed = block.timestamp - lastRewardTimestamp;\n\n        // There is _fee when staking\n        uint256 degisReward = timePassed * degisPerSecond + _fee;\n\n        // Mint reward to this staking pool\n        IStakingPoolFactory(factory).mintReward(address(this), degisReward);\n\n        accDegisPerWeight += rewardToWeight(degisReward, totalWeight);\n\n        lastRewardTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Finish stake process\n     * @param _user User address\n     * @param _amount Amount of tokens to stake\n     * @param _lockUntil Lock until timestamp\n     */\n    function _stake(\n        address _user,\n        uint256 _amount,\n        uint256 _lockUntil\n    ) internal virtual nonReentrant {\n        require(block.timestamp > startTimestamp, \"Pool not started yet\");\n        require(_amount > 0, \"Zero amount\");\n        require(\n            _lockUntil == 0 || (_lockUntil > block.timestamp),\n            \"Invalid lock interval\"\n        );\n        if (_lockUntil >= block.timestamp + 365 days)\n            _lockUntil = block.timestamp + 365 days;\n\n        uint256 depositFee;\n        if (IERC20(poolToken).balanceOf(address(this)) > 0) {\n            // Charge deposit fee and distribute to previous stakers\n            depositFee = (_amount * fee) / 100;\n            _updatePoolWithFee(depositFee);\n        } else updatePool();\n\n        UserInfo storage user = users[_user];\n\n        if (user.tokenAmount > 0) {\n            _distributeReward(_user);\n        }\n\n        uint256 previousBalance = IERC20(poolToken).balanceOf(address(this));\n        transferPoolTokenFrom(msg.sender, address(this), _amount);\n        uint256 newBalance = IERC20(poolToken).balanceOf(address(this));\n\n        // Actual amount is without the fee\n        uint256 addedAmount = newBalance - previousBalance - depositFee;\n\n        uint256 lockFrom = _lockUntil > 0 ? block.timestamp : 0;\n        uint256 lockUntil = _lockUntil;\n\n        uint256 stakeWeight = timeToWeight(lockUntil - lockFrom) * addedAmount;\n\n        // makes sure stakeWeight is valid\n        assert(stakeWeight > 0);\n\n        // create and save the deposit (append it to deposits array)\n        Deposit memory deposit = Deposit({\n            tokenAmount: addedAmount,\n            weight: stakeWeight,\n            lockedFrom: lockFrom,\n            lockedUntil: lockUntil\n        });\n        // deposit ID is an index of the deposit in `deposits` array\n        user.deposits.push(deposit);\n\n        // update user record\n        user.tokenAmount += addedAmount;\n        user.totalWeight += stakeWeight;\n        user.rewardDebt = weightToReward(user.totalWeight, accDegisPerWeight);\n\n        // update global variable\n        totalWeight += stakeWeight;\n\n        // emit an event\n        emit Stake(msg.sender, _amount, _lockUntil);\n    }\n\n    /**\n     * @notice Finish unstake process\n     * @param _user User address\n     * @param _depositId deposit ID to unstake from, zero-indexed\n     * @param _amount amount of tokens to unstake\n     */\n    function _unstake(\n        address _user,\n        uint256 _depositId,\n        uint256 _amount\n    ) internal virtual nonReentrant {\n        // verify an amount is set\n        require(_amount > 0, \"zero amount\");\n\n        UserInfo storage user = users[_user];\n\n        Deposit storage stakeDeposit = user.deposits[_depositId];\n\n        // verify available balance\n        // if staker address ot deposit doesn't exist this check will fail as well\n        require(stakeDeposit.tokenAmount >= _amount, \"amount exceeds stake\");\n\n        // update smart contract state\n        updatePool();\n        // and process current pending rewards if any\n        _distributeReward(_user);\n\n        // recalculate deposit weight\n        uint256 previousWeight = stakeDeposit.weight;\n\n        uint256 newWeight = timeToWeight(\n            stakeDeposit.lockedUntil - stakeDeposit.lockedFrom\n        ) * (stakeDeposit.tokenAmount - _amount);\n\n        // update the deposit, or delete it if its depleted\n        if (stakeDeposit.tokenAmount - _amount == 0) {\n            delete user.deposits[_depositId];\n        } else {\n            stakeDeposit.tokenAmount -= _amount;\n            stakeDeposit.weight = newWeight;\n        }\n\n        // update user record\n        user.tokenAmount -= _amount;\n        user.totalWeight = user.totalWeight - previousWeight + newWeight;\n        user.rewardDebt = weightToReward(user.totalWeight, accDegisPerWeight);\n\n        // update global variable\n        totalWeight -= (previousWeight - newWeight);\n\n        // otherwise just return tokens back to holder\n        transferPoolToken(msg.sender, _amount);\n\n        // emit an event\n        emit Unstake(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Lock time => Lock weight\n     * @dev 1 year = 2e6\n     *      1 week = 1e6\n     *      2 weeks = 1e6 * ( 1 + 1 / 365)\n     */\n    function timeToWeight(uint256 _length)\n        public\n        pure\n        returns (uint256 _weight)\n    {\n        _weight =\n            ((_length * WEIGHT_MULTIPLIER) / 365 days) +\n            WEIGHT_MULTIPLIER;\n    }\n\n    /**\n     * @notice Check pending reward after update\n     * @param _user User address\n     */\n    function _pendingReward(address _user)\n        internal\n        view\n        returns (uint256 pending)\n    {\n        // read user data structure into memory\n        UserInfo memory user = users[_user];\n\n        // and perform the calculation using the values read\n        return\n            weightToReward(user.totalWeight, accDegisPerWeight) -\n            user.rewardDebt;\n    }\n\n    /**\n     * @notice Distribute reward to staker\n     * @param _user User address\n     */\n    function _distributeReward(address _user) internal {\n        uint256 pending = _pendingReward(_user);\n\n        if (pending == 0) return;\n        else {\n            _safeDegisTransfer(_user, pending);\n        }\n    }\n\n    /**\n     * @notice Transfer pool token from pool to user\n     */\n    function transferPoolToken(address _to, uint256 _value) internal {\n        // just delegate call to the target\n        IERC20(poolToken).safeTransfer(_to, _value);\n    }\n\n    /**\n     * @notice Transfer pool token from user to pool\n     * @param _from User address\n     * @param _to Pool address\n     * @param _value Amount of tokens to transfer\n     */\n    function transferPoolTokenFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        IERC20(poolToken).safeTransferFrom(_from, _to, _value);\n    }\n\n    /**\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\n     * @param _to User's address\n     * @param _amount Amount to transfer\n     */\n    function _safeDegisTransfer(address _to, uint256 _amount) internal {\n        uint256 totalDegis = IERC20(degisToken).balanceOf(address(this));\n        if (_amount > totalDegis) {\n            IERC20(degisToken).safeTransfer(_to, totalDegis);\n        } else {\n            IERC20(degisToken).safeTransfer(_to, _amount);\n        }\n    }\n}\n"
    },
    "contracts/staking/interfaces/IStakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IStakingPoolFactory {\n    function createPool(\n        address _poolToken,\n        uint256 _startBlock,\n        uint256 _degisPerBlock\n    ) external;\n\n    function mintReward(address _to, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/tokens/DegisToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IDegisToken.sol\";\nimport \"../utils/ERC20PermitWithMultipleMinters.sol\";\n\n/**@title  Degis Token\n * @notice DegisToken inherits from ERC20 Permit which contains the basic ERC20 implementation.\n *         DegisToken can use the permit function rather than approve + transferFrom.\n *\n *         DegisToken has an owner, a minterList and a burnerList.\n *         When lauched on mainnet, the owner may be removed or tranferred to a multisig.\n *         By default, the owner & the first minter will be the one that deploys the contract.\n *         The minterList should contain FarmingPool and PurchaseIncentiveVault.\n *         The burnerList should contain EmergencyPool.\n */\ncontract DegisToken is ERC20PermitWithMultipleMinters {\n    // Degis has a total supply of 100 million\n    uint256 public constant CAP = 1e8 ether;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Constructor *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() ERC20PermitWithMultipleMinters(\"DegisToken\", \"DEG\") {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Modifiers **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Degis token has a hard cap of 100 million\n    modifier notExceedCap(uint256 _amount) {\n        require(\n            totalSupply() + _amount <= CAP,\n            \"Exceeds the DEG cap (100 million)\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintDegis(address _account, uint256 _amount)\n        external\n        notExceedCap(_amount)\n    {\n        mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnDegis(address _account, uint256 _amount) external {\n        burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/utils/ERC20PermitWithMultipleMinters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"./OwnableWithoutContext.sol\";\n\n/**\n * @title  ERC20 with Multiple Minters and Burners\n * @notice This is contract used for ERC20 tokens that has multiple minters and burners.\n * @dev    The minters and burners are some contracts in Degis that need to issue DEG.\n *         It has basic implementations for ERC20 and also the owner control.\n *         Even if the owner is renounced to zero address, the token can still be minted/burned.\n *         DegisToken and BuyerToken are both this kind ERC20 token.\n */\ncontract ERC20PermitWithMultipleMinters is ERC20Permit, OwnableWithoutContext {\n    // List of all minters\n    mapping(address => bool) public isMinter;\n\n    // List of all burners\n    mapping(address => bool) public isBurner;\n\n    event MinterAdded(address newMinter);\n    event MinterRemoved(address oldMinter);\n\n    event BurnerAdded(address newBurner);\n    event BurnerRemoved(address oldBurner);\n\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    constructor(string memory name, string memory symbol)\n        ERC20(name, symbol)\n        ERC20Permit(name)\n        OwnableWithoutContext(msg.sender)\n    {\n        // After the owner is transferred to multisig governance\n        // This initial minter should be removed\n        isMinter[_msgSender()] = true;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Modifiers ****************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     *@notice Check if the msg.sender is in the minter list\n     */\n    modifier validMinter(address _sender) {\n        require(isMinter[_sender], \"Invalid minter\");\n        _;\n    }\n\n    /**\n     * @notice Check if the msg.sender is in the burner list\n     */\n    modifier validBurner(address _sender) {\n        require(isBurner[_sender], \"Invalid burner\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Admin Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new minter into the minterList\n     * @param _newMinter Address of the new minter\n     */\n    function addMinter(address _newMinter) external onlyOwner {\n        require(!isMinter[_newMinter], \"Already a minter\");\n\n        isMinter[_newMinter] = true;\n\n        emit MinterAdded(_newMinter);\n    }\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldMinter Address of the minter to be removed\n     */\n    function removeMinter(address _oldMinter) external onlyOwner {\n        require(isMinter[_oldMinter], \"Not a minter\");\n\n        isMinter[_oldMinter] = false;\n\n        emit MinterRemoved(_oldMinter);\n    }\n\n    /**\n     * @notice Add a new burner into the burnerList\n     * @param _newBurner Address of the new burner\n     */\n    function addBurner(address _newBurner) external onlyOwner {\n        require(!isBurner[_newBurner], \"Already a burner\");\n\n        isBurner[_newBurner] = true;\n\n        emit BurnerAdded(_newBurner);\n    }\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldBurner Address of the minter to be removed\n     */\n    function removeBurner(address _oldBurner) external onlyOwner {\n        require(isMinter[_oldBurner], \"Not a burner\");\n\n        isBurner[_oldBurner] = false;\n\n        emit BurnerRemoved(_oldBurner);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint tokens\n     * @param _account Receiver's address\n     * @param _amount Amount to be minted\n     */\n    function mint(address _account, uint256 _amount)\n        internal\n        validMinter(_msgSender())\n    {\n        _mint(_account, _amount); // ERC20 method with an event\n        emit Mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn tokens\n     * @param _account address\n     * @param _amount amount to be burned\n     */\n    function burn(address _account, uint256 _amount)\n        internal\n        validBurner(_msgSender())\n    {\n        _burn(_account, _amount);\n        emit Burn(_account, _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "contracts/utils/OwnableWithoutContext.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n/**\n * @dev The owner can be set during deployment, not default to be msg.sender\n */\nabstract contract OwnableWithoutContext {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor(address _initialOwner) {\n        _transferOwnership(_initialOwner);\n    }\n\n    /**\n     * @notice Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @notice Leaves the contract without owner. It will not be possible to call\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * @dev    Renouncing ownership will leave the contract without an owner,\n     *         thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Can only be called by the current owner.\n     * @param  newOwner Address of the new owner\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Internal function without access restriction.\n     * @param  newOwner Address of the new owner\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/miserable-flight/InsurancePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../libraries/SafePRBMath.sol\";\nimport \"../lucky-box/interfaces/IDegisLottery.sol\";\nimport \"../utils/OwnableWithoutContext.sol\";\nimport \"./abstracts/InsurancePoolStore.sol\";\n\n/**\n * @title  Insurance Pool\n * @notice Insurance pool is the reserved risk pool for flight delay product.\n *         For simplicity, some state variables are in the InsurancePoolStore contract.\n */\ncontract InsurancePool is\n    ERC20(\"Degis FlightDelay LPToken\", \"DLP\"),\n    InsurancePoolStore,\n    OwnableWithoutContext,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n    using SafePRBMath for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Other Contracts ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    IERC20 public USDToken;\n    IDegisLottery public degisLottery;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor function\n     * @param _emergencyPool Emergency pool address\n     * @param _degisLottery Lottery address\n     * @param _usdAddress USDToken address\n     */\n    constructor(\n        address _emergencyPool,\n        address _degisLottery,\n        address _usdAddress\n    ) OwnableWithoutContext(msg.sender) {\n        // Initialize some factors\n        collateralFactor = 1e18;\n        lockedRatio = 1e18;\n        LPValue = 1e18;\n\n        emergencyPool = _emergencyPool;\n\n        USDToken = IERC20(_usdAddress);\n\n        degisLottery = IDegisLottery(_degisLottery);\n\n        // Initial distribution, 0: LP 1: Lottery 2: Emergency\n        rewardDistribution[0] = 50;\n        rewardDistribution[1] = 40;\n        rewardDistribution[2] = 10;\n\n        frozenTime = 7 days;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only the policyFlow contract can call some functions\n     */\n    modifier onlyPolicyFlow() {\n        require(\n            _msgSender() == policyFlow,\n            \"Only the policyFlow contract can call this function\"\n        );\n        _;\n    }\n\n    /**\n     * @notice The address can not be zero\n     */\n    modifier notZeroAddress(address _address) {\n        assert(_address != address(0));\n        _;\n    }\n\n    /**\n     * @notice There is a frozen time for unstaking\n     */\n    modifier afterFrozenTime(address _user) {\n        require(\n            block.timestamp >= userInfo[_user].depositTime + frozenTime,\n            \"Can not withdraw until the fronzen time\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the real balance: LPValue * LP_Num\n     * @dev Used in many places so give it a seperate function\n     * @param _user User's address\n     * @return _userBalance Real balance of this user\n     */\n    function getUserBalance(address _user)\n        public\n        view\n        returns (uint256 _userBalance)\n    {\n        uint256 lp_num = balanceOf(_user);\n        _userBalance = lp_num.mul(LPValue);\n    }\n\n    /**\n     * @notice Get the balance that one user(LP) can unlock\n     * @param _user User's address\n     * @return _unlockedAmount Unlocked amount of the user\n     */\n    function getUnlockedFor(address _user)\n        public\n        view\n        returns (uint256 _unlockedAmount)\n    {\n        uint256 userBalance = getUserBalance(_user);\n        _unlockedAmount = availableCapacity >= userBalance\n            ? userBalance\n            : availableCapacity;\n    }\n\n    /**\n     * @notice Check the conditions when receive new buying request\n     * @param _payoff Payoff of the policy to be bought\n     * @return Whether there is enough capacity in the pool for this payoff\n     */\n    function checkCapacity(uint256 _payoff) external view returns (bool) {\n        return availableCapacity >= _payoff;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Owner Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set a new frozen time\n     * @param _newFrozenTime New frozen time, in timestamp(s)\n     */\n    function setFrozenTime(uint256 _newFrozenTime) external onlyOwner {\n        frozenTime = _newFrozenTime;\n        emit FrozenTimeChanged(_newFrozenTime);\n    }\n\n    /**\n     * @notice Set the address of policyFlow\n     */\n    function setPolicyFlow(address _policyFlowAddress)\n        public\n        onlyOwner\n        notZeroAddress(_policyFlowAddress)\n    {\n        policyFlow = _policyFlowAddress;\n        emit PolicyFlowChanged(_policyFlowAddress);\n    }\n\n    /**\n     * @notice Set the premium reward distribution\n     * @param _newDistribution New distribution [LP, Lottery, Emergency]\n     */\n    function setRewardDistribution(uint256[3] memory _newDistribution)\n        public\n        onlyOwner\n    {\n        uint256 sum = _newDistribution[0] +\n            _newDistribution[1] +\n            _newDistribution[2];\n        require(sum == 100, \"Reward distribution must sum to 100\");\n\n        for (uint256 i = 0; i < 3; i++) {\n            rewardDistribution[i] = _newDistribution[i];\n        }\n        emit RewardDistributionChanged(\n            _newDistribution[0],\n            _newDistribution[1],\n            _newDistribution[2]\n        );\n    }\n\n    /**\n     * @notice Change the collateral factor\n     * @param _factor The new collateral factor\n     */\n    function setCollateralFactor(uint256 _factor) public onlyOwner {\n        require(_factor > 0, \"Collateral Factor should be larger than 0\");\n        uint256 oldFactor = collateralFactor;\n        collateralFactor = _factor.div(100);\n        emit CollateralFactorChanged(oldFactor, _factor);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice LPs stake assets into the pool\n     * @param _amount The amount that the user want to stake\n     */\n    function stake(uint256 _amount) external nonReentrant {\n        require(_amount > 0, \"Zero Amount\");\n        require(\n            IERC20(USDToken).balanceOf(_msgSender()) >= _amount,\n            \"Not enough USD\"\n        );\n\n        _updateLPValue();\n\n        _deposit(_msgSender(), _amount);\n    }\n\n    /**\n     * @notice Unstake from the pool (May fail if a claim happens before this operation)\n     * @dev Only unstake by yourself\n     * @param _amount The amount that the user want to unstake\n     */\n    function unstake(uint256 _amount)\n        external\n        afterFrozenTime(_msgSender())\n        nonReentrant\n    {\n        require(totalStakingBalance - lockedBalance > 0, \"All locked\");\n\n        address _user = _msgSender();\n\n        _updateLPValue();\n\n        uint256 userBalance = getUserBalance(_user);\n        require(\n            _amount <= userBalance && _amount > 0,\n            \"Not enough balance to be unlocked or your withdraw amount is 0\"\n        );\n\n        uint256 unlocked = totalStakingBalance - lockedBalance;\n        uint256 unstakeAmount = _amount;\n\n        // Will jump this part when the pool has enough liquidity\n        if (_amount > unlocked) unstakeAmount = unlocked; // only withdraw the unlocked value\n\n        if (unstakeAmount > 0) _withdraw(_user, unstakeAmount);\n    }\n\n    /**\n     * @notice Unstake the max amount of a user\n     */\n    function unstakeMax() external afterFrozenTime(_msgSender()) nonReentrant {\n        require(totalStakingBalance - lockedBalance > 0, \"All locked\");\n\n        address _user = _msgSender();\n\n        _updateLPValue();\n\n        uint256 userBalance = getUserBalance(_user);\n\n        uint256 unlocked = totalStakingBalance - lockedBalance;\n        uint256 unstakeAmount = userBalance;\n\n        // Will jump this part when the pool has enough liquidity\n        if (userBalance > unlocked) unstakeAmount = unlocked; // only withdraw the unlocked value\n\n        _withdraw(_user, unstakeAmount);\n    }\n\n    /**\n     * @notice Update the pool variables when buying policies\n     * @dev Capacity check is done before calling this function\n     * @param _premium Policy's premium\n     * @param _payoff Policy's payoff (max payoff)\n     * @param _user Address of the buyer\n     */\n    function updateWhenBuy(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user\n    ) external onlyPolicyFlow {\n        // Update pool status\n        lockedBalance += _payoff;\n        activePremiums += _premium;\n        availableCapacity -= _payoff;\n\n        // Update lockedRatio\n        _updateLockedRatio();\n\n        // Remember approval\n        USDToken.safeTransferFrom(_user, address(this), _premium);\n\n        emit NewPolicyBought(_user, _premium, _payoff);\n    }\n\n    /**\n     * @notice Update the status when a policy expires\n     * @param _premium Policy's premium\n     * @param _payoff Policy's payoff (max payoff)\n     */\n    function updateWhenExpire(uint256 _premium, uint256 _payoff)\n        external\n        onlyPolicyFlow\n    {\n        // Distribute the premium\n        uint256 remainingPremium = _distributePremium(_premium);\n\n        // Update pool status\n        activePremiums -= _premium;\n        lockedBalance -= _payoff;\n\n        availableCapacity += _payoff + remainingPremium;\n        totalStakingBalance += remainingPremium;\n\n        _updateLPValue();\n    }\n\n    /**\n     * @notice Pay a claim\n     * @param _premium Premium of the policy\n     * @param _payoff Max payoff of the policy\n     * @param _realPayoff Real payoff of the policy\n     * @param _user Address of the policy claimer\n     */\n    function payClaim(\n        uint256 _premium,\n        uint256 _payoff,\n        uint256 _realPayoff,\n        address _user\n    ) external onlyPolicyFlow notZeroAddress(_user) {\n        // Distribute the premium\n        uint256 remainingPremium = _distributePremium(_premium);\n\n        // Update the pool status\n        lockedBalance -= _payoff;\n\n        totalStakingBalance =\n            totalStakingBalance -\n            _realPayoff +\n            remainingPremium;\n\n        availableCapacity += (_payoff - _realPayoff + remainingPremium);\n\n        activePremiums -= _premium;\n\n        // Pay the claim\n        USDToken.safeTransfer(_user, _realPayoff);\n\n        _updateLPValue();\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ********************************** Internal Functions ********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Finish the deposit process\n     * @dev LPValue will not change during deposit\n     * @param _user Address of the user who deposits\n     * @param _amount Amount he deposits\n     */\n    function _deposit(address _user, uint256 _amount) internal {\n        uint256 amountWithFactor = _amount.mul(collateralFactor);\n\n        // Update the pool's status\n        totalStakingBalance += _amount;\n        availableCapacity += amountWithFactor;\n\n        _updateLockedRatio();\n\n        // msg.sender always pays\n        USDToken.safeTransferFrom(_user, address(this), _amount);\n\n        // LP Token number need to be newly minted\n        uint256 lp_num = _amount.div(LPValue);\n        _mint(_user, lp_num);\n\n        userInfo[_user].depositTime = block.timestamp;\n\n        emit Stake(_user, _amount);\n    }\n\n    /**\n     * @notice _withdraw: finish the withdraw action, only when meeting the conditions\n     * @dev LPValue will not change during withdraw\n     * @param _user address of the user who withdraws\n     * @param _amount the amount he withdraws\n     */\n    function _withdraw(address _user, uint256 _amount) internal {\n        uint256 amountWithFactor = _amount.mul(collateralFactor);\n        // Update the pool's status\n        totalStakingBalance -= _amount;\n        availableCapacity -= amountWithFactor;\n\n        _updateLockedRatio();\n\n        USDToken.safeTransfer(_user, _amount);\n\n        uint256 lp_num = _amount.div(LPValue);\n        _burn(_user, lp_num);\n\n        emit Unstake(_user, _amount);\n    }\n\n    /**\n     * @notice Distribute the premium to lottery and emergency pool\n     * @param _premium Premium amount to be distributed\n     */\n    function _distributePremium(uint256 _premium) internal returns (uint256) {\n        uint256 premiumToLottery = _premium.mul(rewardDistribution[1].div(100));\n\n        uint256 premiumToEmergency = _premium.mul(\n            rewardDistribution[2].div(100)\n        );\n\n        // Transfer some reward to emergency pool\n        USDToken.safeTransfer(emergencyPool, premiumToEmergency);\n\n        // Transfer some reward to lottery\n        USDToken.safeTransfer(address(degisLottery), premiumToLottery);\n\n        emit PremiumDistributed(premiumToEmergency, premiumToLottery);\n\n        return _premium - premiumToEmergency - premiumToLottery;\n    }\n\n    /**\n     * @notice Update the value of each lp token\n     * @dev Normally it will update when claim or expire\n     */\n    function _updateLPValue() internal {\n        uint256 totalLP = totalSupply();\n\n        if (totalLP == 0) return;\n        else {\n            uint256 totalBalance = IERC20(USDToken).balanceOf(address(this));\n\n            LPValue = (totalBalance - activePremiums).div(totalLP);\n        }\n    }\n\n    /**\n     * @notice Update the pool's locked ratio\n     */\n    function _updateLockedRatio() internal {\n        if (lockedBalance == 0) lockedRatio = 0;\n        else lockedRatio = lockedBalance.div(totalStakingBalance);\n    }\n}\n"
    },
    "contracts/libraries/SafePRBMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"prb-math/contracts/PRBMath.sol\";\n\n/**\n * @notice This prb-math version is 2.4.1\n *         https://github.com/hifi-finance/prb-math\n */\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary SafePRBMath {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    },
    "contracts/lucky-box/interfaces/IDegisLottery.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IDegisLottery {\n    /**\n     * @notice Inject funds\n     * @param _amount amount to inject in USD\n     * @dev Callable by operator\n     */\n    function injectFunds(uint256 _amount) external;\n\n    /**\n     * @notice View current lottery id\n     */\n    function currentLotteryId() external view returns (uint256);\n}\n"
    },
    "contracts/miserable-flight/abstracts/InsurancePoolStore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nabstract contract InsurancePoolStore {\n    address public policyFlow;\n    address public emergencyPool;\n\n    uint256 public frozenTime; // default as 7 days\n\n    struct UserInfo {\n        uint256 depositTime;\n        uint256 pendingBalance; // the amount in the unstake queue\n    }\n    mapping(address => UserInfo) public userInfo;\n\n    // 1 LP = LPValue(USD)\n    uint256 public LPValue;\n\n    // Total staking balance of the pool\n    uint256 public totalStakingBalance;\n\n    // Locked balance is for potiential payoff\n    uint256 public lockedBalance;\n\n    // locked relation = locked balance / totalStakingBalance\n    uint256 public lockedRatio; //  1e18 = 1  1e17 = 0.1  1e19 = 10\n    uint256 public collateralFactor; //  1e18 = 1  1e17 = 0.1  1e19 = 10\n\n    // Available capacity for taking new\n    uint256 public availableCapacity;\n\n    // Premiums have been paid but the policies haven't expired\n    uint256 public activePremiums;\n\n    // [0]: LP, [1]: Lottery, [2]: Emergency\n    uint256[3] public rewardDistribution;\n\n    // events\n    event Stake(address indexed userAddress, uint256 amount);\n    event Unstake(address indexed userAddress, uint256 amount);\n\n    event CollateralFactorChanged(uint256 oldFactor, uint256 newFactor);\n\n    event PolicyFlowChanged(address policyFlowAddress);\n\n    event NewPolicyBought(\n        address indexed userAddress,\n        uint256 premium,\n        uint256 payout\n    );\n    event RewardDistributionChanged(\n        uint256 toLP,\n        uint256 toLottery,\n        uint256 toEmergency\n    );\n\n    event FrozenTimeChanged(uint256 _newFrozenTime);\n\n    event PremiumDistributed(\n        uint256 _premiumToEmergency,\n        uint256 _premiumToLottery\n    );\n}\n"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the closest power of two that is higher than x.\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "contracts/lucky-box/RandomNumberGenerator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../libraries/StringsUtils.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\nimport \"./interfaces/IDegisLottery.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract RandomNumberGenerator is VRFConsumerBase, Ownable {\n    using StringsUtils for uint256;\n    using SafeERC20 for IERC20;\n\n    IDegisLottery public DegisLottery;\n\n    bytes32 public keyHash;\n    bytes32 public latestRequestId;\n    uint256 public randomResult;\n    uint256 public fee;\n\n    uint256 public latestLotteryId;\n\n    /**\n     * @notice Constructor\n     * @dev RandomNumberGenerator must be deployed before the lottery.\n     * Once the lottery contract is deployed, setLotteryAddress must be called.\n     * https://docs.chain.link/docs/vrf-contracts/\n     * @param _vrfCoordinator address of the VRF coordinator\n     * @param _linkToken address of the LINK token\n     */\n    constructor(\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _keyHash\n    ) Ownable(msg.sender) VRFConsumerBase(_vrfCoordinator, _linkToken) {\n        keyHash = _keyHash;\n        fee = 0.1 * 10e18;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Change the fee\n     * @param _fee new fee (in LINK)\n     */\n    function setFee(uint256 _fee) external onlyOwner {\n        fee = _fee;\n    }\n\n    /**\n     * @notice Change the keyHash\n     * @param _keyHash new keyHash\n     */\n    function setKeyHash(bytes32 _keyHash) external onlyOwner {\n        keyHash = _keyHash;\n    }\n\n    /**\n     * @notice Set the address for the DegisLottery\n     * @param _degisLottery address of the PancakeSwap lottery\n     */\n    function setLotteryAddress(address _degisLottery) external onlyOwner {\n        DegisLottery = IDegisLottery(_degisLottery);\n    }\n\n    /**\n     * @notice It allows the admin to withdraw tokens sent to the contract\n     * @param _tokenAddress the address of the token to withdraw\n     * @param _tokenAmount the number of token amount to withdraw\n     * @dev Only callable by owner.\n     */\n    function withdrawTokens(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        IERC20(_tokenAddress).safeTransfer(_msgSender(), _tokenAmount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Request randomness from Chainlink VRF\n     */\n    function getRandomNumber() external {\n        require(_msgSender() == address(DegisLottery), \"Only DegisLottery\");\n\n        require(keyHash != bytes32(0), \"Must have valid key hash\");\n        // require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK tokens\");\n\n        //*********************************//\n        // TODO: This part is only for test on Fuji Testnet because there is no VRF currently\n        string memory randInput = string(\n            abi.encodePacked(\n                block.timestamp.uintToString(),\n                blockhash(block.number - (block.timestamp % 64)),\n                address(this)\n            )\n        );\n        randomResult = _rand(randInput) % 10000;\n\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\n        //*********************************//\n\n        // latestRequestId = requestRandomness(keyHash, fee);\n    }\n\n    /**\n     * @notice Get the random number\n     * @return randomNumber the random result\n     */\n    function _rand(string memory input) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(input)));\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Callback function used by ChainLink's VRF Coordinator\n     */\n    // TODO: On Fuji testnet, we use fake random numbers\n    function fulfillRandomness(bytes32 requestId, uint256 randomness)\n        internal\n        override\n    {\n        require(latestRequestId == requestId, \"Wrong requestId\");\n        randomResult = randomness % 10000;\n\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\n    }\n}\n"
    },
    "contracts/libraries/StringsUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUtils {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @notice Bytes to string (not human-readable form)\n     * @param _bytes Input bytes\n     * @return stringBytes String form of the bytes\n     */\n    function byToString(bytes32 _bytes) internal pure returns (string memory) {\n        return uintToHexString(uint256(_bytes), 32);\n    }\n\n    /**\n     * @notice Transfer address to string (not change the content)\n     * @param _addr Input address\n     * @return stringAddress String form of the address\n     */\n    function addressToString(address _addr)\n        internal\n        pure\n        returns (string memory)\n    {\n        return uintToHexString(uint256(uint160(_addr)), 20);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function uintToString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function uintToHexString(uint256 value)\n        internal\n        pure\n        returns (string memory)\n    {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return uintToHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function uintToHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\n\n  /**\n   * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash] + 1;\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface internal immutable LINK;\n  address private immutable vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\n    private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  constructor(address _vrfCoordinator, address _link) {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "contracts/lucky-box/DegisLotteryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/IRandomNumberGenerator.sol\";\nimport \"./MathLib.sol\";\n\ncontract DegisLotteryV2 is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n    using MathLib for uint256;\n    using MathLib for int128;\n\n    address public injectorAddress;\n    address public operatorAddress;\n    address public treasuryAddress; // Currently no treasury fee\n\n    uint256 public currentLotteryId; // Total Rounds\n    uint256 public currentTicketId; // Total Tickets\n\n    uint256 public maxNumberTicketsPerBuyOrClaim = 10000;\n    uint256 public maxNumberTicketsPerRedeem = 10000;\n\n    uint256 public ticketPrice;\n\n    uint256 public pendingInjectionNextLottery;\n\n    uint256 public constant MIN_LENGTH_LOTTERY = 1 hours - 5 minutes; // 1 hours\n    uint256 public constant MAX_LENGTH_LOTTERY = 365 days + 5 minutes; // 365 days\n    uint256 public constant MAX_TREASURY_FEE = 3000; // 30%\n    uint32 public constant MIN_TICKET_NUMBER = 10000;\n    uint32 public constant MAX_TICKET_NUMBER = 19999;\n\n    IERC20 public DegisToken;\n    IERC20 public USDCToken;\n    IRandomNumberGenerator public randomGenerator;\n\n    enum Status {\n        Pending,\n        Open,\n        Close,\n        Claimable\n    }\n\n    struct Lottery {\n        Status status;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 ticketPrice; // 10\n        uint256[4] rewardsBreakdown; // 0: 1 matching number // 3: 4 matching numbers\n        uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%\n        uint256[4] rewardPerTicketInBracket;\n        uint256[4] countWinnersPerBracket;\n        uint256[4] countWinnersPerBracketWW;\n        uint256 amountCollected;\n        uint256 pendingAwards;\n        uint32 finalNumber;\n    }\n\n    struct Ticket {\n        uint32 number;\n        bool isRedeemed;\n        uint256 buyLotteryId;\n        uint256 redeemLotteryId;\n        uint256 priceTicket;\n        address owner;\n    }\n\n    // ticketId => (LotteryId => Whether claimed)\n    mapping(uint256 => mapping(uint256 => bool)) private _ticketsClaimed;\n\n    // lotteryId => Lottery Info\n    mapping(uint256 => Lottery) private _lotteries;\n\n    // ticketId => Ticket Info\n    mapping(uint256 => Ticket) private _tickets;\n\n    // Bracket calculator is used for verifying claims for ticket prizes\n    mapping(uint32 => uint32) private _bracketCalculator;\n\n    // lotteryId => (Lucky Number => Total Amount of this number)\n    // e.g. in lottery round 3, 10 Tickets are sold with \"1234\": 3 => (1234 => 10)\n    mapping(uint256 => mapping(uint32 => uint256))\n        private _numberTicketsPerLotteryId;\n\n    // Keep track of user ticket ids for a given lotteryId\n\n    // userAddress => all tickets he bought in this round\n    mapping(address => uint256[]) private _userTicketIds;\n\n    // only user address\n    modifier notContract() {\n        require(!_isContract(msg.sender), \"Contract not allowed\");\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(msg.sender == operatorAddress, \"Not operator\");\n        _;\n    }\n\n    modifier onlyOwnerOrInjector() {\n        require(\n            (msg.sender == owner()) || (msg.sender == injectorAddress),\n            \"Not owner or injector\"\n        );\n        _;\n    }\n\n    event AdminTokenRecovery(address token, uint256 amount);\n    event LotteryClose(uint256 indexed lotteryId);\n    event LotteryInjection(uint256 indexed lotteryId, uint256 injectedAmount);\n    event LotteryOpen(\n        uint256 indexed lotteryId,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 priceTicketInDegis,\n        uint256 injectedAmount\n    );\n    event LotteryNumberDrawn(\n        uint256 indexed lotteryId,\n        uint256 finalNumber,\n        uint256 countWinningTickets\n    );\n    event NewOperatorAndTreasuryAndInjectorAddresses(\n        address operator,\n        address treasury,\n        address injector\n    );\n\n    event NewRandomGenerator(address indexed randomGenerator);\n    event TicketsPurchase(\n        address indexed buyer,\n        uint256 indexed lotteryId,\n        uint256 numberTickets\n    );\n    event TicketsRedeem(\n        address indexed redeemer,\n        uint256 indexed lotteryId,\n        uint256 numberTickets\n    );\n    event TicketsClaim(\n        address indexed claimer,\n        uint256 amount,\n        uint256 indexed lotteryId\n    );\n\n    /**\n     * @notice Constructor function\n     * @dev RandomNumberGenerator must be deployed prior to this contract\n     * @param _degisTokenAddress Address of the DEGIS token (for buying tickets)\n     * @param _usdcTokenAddress Address of the USDC token (for prize distribution)\n     * @param _randomGeneratorAddress Address of the RandomGenerator contract used to work with ChainLink VRF\n     */\n    constructor(\n        address _degisTokenAddress,\n        address _usdcTokenAddress,\n        address _randomGeneratorAddress\n    ) {\n        DegisToken = IERC20(_degisTokenAddress);\n        USDCToken = IERC20(_usdcTokenAddress);\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\n\n        // Initializes the bracketCalculator, constant numbers\n        _bracketCalculator[0] = 1;\n        _bracketCalculator[1] = 11;\n        _bracketCalculator[2] = 111;\n        _bracketCalculator[3] = 1111;\n    }\n\n    function initialize() public {\n        ticketPrice = 10 ether;\n    }\n\n    /**\n     * @notice Buy tickets for the current lottery round\n     * @dev You need to transfer the 4-digit number to a 5-digit number to be used here (+10000)\n     * @dev Can not be called by a smart contract\n     * @param _ticketNumbers array of ticket numbers between 10,000 and 19,999\n     */\n    function buyTickets(uint32[] calldata _ticketNumbers)\n        external\n        notContract\n        nonReentrant\n    {\n        require(_ticketNumbers.length != 0, \"No tickets are being bought\");\n        require(\n            _ticketNumbers.length <= maxNumberTicketsPerBuyOrClaim,\n            \"too many tickets are being bought at one time\"\n        );\n\n        uint256 currentId = currentLotteryId;\n        require(\n            _lotteries[currentId].status == Status.Open,\n            \"Sorry, current lottery is not open\"\n        );\n\n        uint256 amountToBuy = _ticketNumbers.length;\n\n        // Calculate number of Degis that the user need to pay\n        uint256 amountDegisToTransfer = _lotteries[currentId].ticketPrice *\n            amountToBuy;\n\n        // Transfer degis tokens to this contract (need approval)\n        DegisToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            amountDegisToTransfer\n        );\n\n        for (uint256 i = 0; i < amountToBuy; i++) {\n            uint32 currentTicketNumber = _ticketNumbers[i];\n\n            require(\n                (currentTicketNumber >= MIN_TICKET_NUMBER) &&\n                    (currentTicketNumber <= MAX_TICKET_NUMBER),\n                \"Ticket number is outside the range\"\n            );\n\n            // used when drawing the prize\n            _numberTicketsPerLotteryId[currentId][\n                1 + (currentTicketNumber % 10)\n            ]++;\n            _numberTicketsPerLotteryId[currentId][\n                11 + (currentTicketNumber % 100)\n            ]++;\n            _numberTicketsPerLotteryId[currentId][\n                111 + (currentTicketNumber % 1000)\n            ]++;\n            _numberTicketsPerLotteryId[currentId][\n                1111 + (currentTicketNumber % 10000)\n            ]++;\n\n            // Store this ticket number to the user's record\n            _userTicketIds[msg.sender].push(currentId);\n\n            // Store this ticket number to global ticket state\n            _tickets[currentTicketId] = Ticket({\n                number: currentTicketNumber,\n                owner: msg.sender,\n                buyLotteryId: currentLotteryId,\n                isRedeemed: false,\n                redeemLotteryId: 0,\n                priceTicket: _lotteries[currentId].ticketPrice\n            });\n\n            _ticketsClaimed[currentTicketId][currentLotteryId] = false;\n\n            // Increase total lottery ticket number\n            currentTicketId++;\n        }\n\n        emit TicketsPurchase(msg.sender, currentLotteryId, amountToBuy);\n    }\n\n    /**\n     * @notice Redeem tickets for all lottery\n     * @param _ticketIds Array of ticket ids\n     * @dev Callable by users\n     */\n    function redeemTickets(uint256[] calldata _ticketIds)\n        external\n        notContract\n        nonReentrant\n    {\n        require(_ticketIds.length != 0, \"no tickets are being bought\");\n        require(\n            _ticketIds.length <= maxNumberTicketsPerRedeem,\n            \"Too many tickets are being remeeded at one time\"\n        );\n        require(\n            _lotteries[currentLotteryId].status == Status.Open,\n            \"Sorry, current lottery is not open\"\n        );\n        // require(\n        //     block.timestamp < _lotteries[currentLotteryId].endTime,\n        //     \"sorry, current lottery is over\"\n        // );\n\n        uint256 amountDegisToTransfer = 0;\n        for (uint256 i = 0; i < _ticketIds.length; i++) {\n            uint256 thisTicketId = _ticketIds[i];\n            require(currentTicketId > thisTicketId, \"ticketId is too large\");\n            require(\n                msg.sender == _tickets[thisTicketId].owner,\n                \"you are not the owner of this ticket\"\n            );\n            require(\n                _tickets[thisTicketId].isRedeemed == false,\n                \"ticket has been redeemed\"\n            );\n\n            _tickets[thisTicketId].isRedeemed = true;\n            _tickets[thisTicketId].redeemLotteryId = currentLotteryId;\n            amountDegisToTransfer += _tickets[thisTicketId].priceTicket;\n\n            uint32 currentTicketNumber = _tickets[thisTicketId].number;\n\n            // used when drawing the prize\n            _numberTicketsPerLotteryId[_tickets[thisTicketId].buyLotteryId][\n                1 + (currentTicketNumber % 10)\n            ]--;\n            _numberTicketsPerLotteryId[_tickets[thisTicketId].buyLotteryId][\n                11 + (currentTicketNumber % 100)\n            ]--;\n            _numberTicketsPerLotteryId[_tickets[thisTicketId].buyLotteryId][\n                111 + (currentTicketNumber % 1000)\n            ]--;\n            _numberTicketsPerLotteryId[_tickets[thisTicketId].buyLotteryId][\n                1111 + (currentTicketNumber % 10000)\n            ]--;\n        }\n\n        DegisToken.safeTransfer(address(msg.sender), amountDegisToTransfer);\n\n        emit TicketsRedeem(msg.sender, currentLotteryId, _ticketIds.length);\n    }\n\n    /**\n     * @notice Claim a set of winning tickets for a lottery\n     * @param _lotteryId lottery id\n     * @dev Callable by users only, not contract!\n     */\n    function claimTickets(uint256 _lotteryId, uint256[] calldata _ticketIds)\n        external\n        notContract\n        nonReentrant\n    {\n        require(\n            _lotteries[_lotteryId].status == Status.Claimable,\n            \"this round of lottery are not ready for claiming\"\n        );\n        require(_ticketIds.length != 0, \"no ticketIds given\");\n        require(\n            _ticketIds.length <= maxNumberTicketsPerBuyOrClaim,\n            \"too many tickets to claim at one time\"\n        );\n\n        uint256 rewardToTransfer;\n\n        for (uint256 i = 0; i < _ticketIds.length; i++) {\n            uint256 thisTicketId = _ticketIds[i];\n\n            require(\n                msg.sender == _tickets[thisTicketId].owner,\n                \"you are not the owner of this ticket\"\n            );\n            require(\n                _tickets[thisTicketId].buyLotteryId <= _lotteryId,\n                \"ticketId is too large\"\n            );\n\n            if (_tickets[thisTicketId].isRedeemed == true) {\n                require(\n                    _tickets[thisTicketId].redeemLotteryId > _lotteryId,\n                    \"ticketId was redeemed\"\n                );\n            }\n\n            require(\n                _ticketsClaimed[thisTicketId][_lotteryId] == false,\n                \"prize received\"\n            );\n\n            uint256 rewardForTicketId = _calculateRewardsForTicketId(\n                _lotteryId,\n                thisTicketId\n            );\n\n            require(rewardForTicketId != 0, \"no prize for this bracket\");\n\n            _ticketsClaimed[thisTicketId][_lotteryId] = true;\n\n            // Increase the reward to transfer\n            rewardToTransfer += rewardForTicketId;\n        }\n\n        // Transfer the prize to winner\n        USDCToken.safeTransfer(msg.sender, rewardToTransfer);\n        _lotteries[_lotteryId].pendingAwards -= rewardToTransfer;\n\n        emit TicketsClaim(msg.sender, rewardToTransfer, _lotteryId);\n    }\n\n    /**\n     * @notice Claim all winning tickets for a lottery\n     * @param _lotteryId lottery id\n     * @dev Callable by users only, not contract!\n     */\n    function claimAllTickets(uint256 _lotteryId)\n        external\n        notContract\n        nonReentrant\n    {\n        require(\n            _lotteries[_lotteryId].status == Status.Claimable,\n            \"this round of lottery are not ready for claiming\"\n        );\n\n        uint256 rewardToTransfer;\n\n        for (uint256 i = 0; i < _userTicketIds[msg.sender].length; i++) {\n            uint256 thisTicketId = _userTicketIds[msg.sender][i];\n\n            require(\n                msg.sender == _tickets[thisTicketId].owner,\n                \"you are not the owner of this ticket\"\n            );\n\n            if (_tickets[thisTicketId].buyLotteryId > _lotteryId) {\n                continue;\n            }\n\n            if (_tickets[thisTicketId].isRedeemed == true) {\n                if (_tickets[thisTicketId].redeemLotteryId <= _lotteryId) {\n                    continue;\n                }\n            }\n\n            if (_ticketsClaimed[thisTicketId][_lotteryId] == true) {\n                continue;\n            }\n\n            uint256 rewardForTicketId = _calculateRewardsForTicketId(\n                _lotteryId,\n                thisTicketId\n            );\n\n            if (rewardForTicketId == 0) {\n                continue;\n            }\n\n            _ticketsClaimed[thisTicketId][_lotteryId] = true;\n\n            // Increase the reward to transfer\n            rewardToTransfer += rewardForTicketId;\n        }\n\n        require(rewardToTransfer != 0, \"no prize\");\n\n        // Transfer the prize to winner\n        USDCToken.safeTransfer(msg.sender, rewardToTransfer);\n        _lotteries[_lotteryId].pendingAwards -= rewardToTransfer;\n\n        emit TicketsClaim(msg.sender, rewardToTransfer, _lotteryId);\n    }\n\n    /**\n     * @notice Close a lottery\n     * @param _lotteryId lottery round\n     * @dev Callable only by the operator\n     */\n    function closeLottery(uint256 _lotteryId)\n        external\n        onlyOperator\n        nonReentrant\n    {\n        require(\n            _lotteries[_lotteryId].status == Status.Open,\n            \"this lottery is not open currently\"\n        );\n\n        // require(\n        //     block.timestamp > _lotteries[_lotteryId].endTime,\n        //     \"this lottery has not reached the end time, only can be closed after the end time\"\n        // );\n\n        // Request a random number from the generator\n        randomGenerator.getRandomNumber();\n\n        // Update the lottery status to \"Close\"\n        _lotteries[_lotteryId].status = Status.Close;\n\n        emit LotteryClose(_lotteryId);\n    }\n\n    function int2ln(uint256 x) internal pure returns (uint256) {\n        // return (x-1)*10000;\n        uint256 y = 10000;\n        int128 x_128 = x.fromUInt();\n        int128 y_128 = y.fromUInt();\n        int128 ln_x_128 = x_128.ln();\n        ln_x_128 = ln_x_128.mul(y_128);\n        return ln_x_128.toUInt();\n    }\n\n    \n\n    uint256 numberAddressesInPreviousBracketWW = 0;\n    uint256 numberTicketsWW = 0;\n\n    /**\n     * @notice Draw the final number, calculate reward in Degis for each group, \n               and make this lottery claimable (need to wait for the random generator)\n     * @param _lotteryId lottery round\n     * @param _autoInjection reinjects funds into next lottery \n     * @dev Callable only by the operator\n     */\n    function drawFinalNumberAndMakeLotteryClaimable(\n        uint256 _lotteryId,\n        bool _autoInjection\n    ) external onlyOperator nonReentrant {\n        require(\n            _lotteries[_lotteryId].status == Status.Close,\n            \"this lottery has not closed, you should first close it\"\n        );\n        require(\n            _lotteryId == randomGenerator.latestLotteryId(),\n            \"the final lucky numbers have not been drawn\"\n        );\n\n        // Get the final lucky numbers from randomGenerator\n        uint32 finalNumber = randomGenerator.randomResult();\n\n        // Calculate the prize amount given to winners\n        // Currently treasuryFee = 0 => amountToWinners = amountCollected\n        uint256 amountToWinners = (\n            ((_lotteries[_lotteryId].amountCollected) *\n                (10000 - _lotteries[_lotteryId].treasuryFee))\n        ) / 10000;\n\n        // Calculate prizes for each bracket, starting from the highest one\n\n        // Initialize a number to count addresses in all the previous bracket\n        // Ensure that a ticket is not counted several times in different brackets\n        uint256 numberAddressesInPreviousBracket;\n        numberAddressesInPreviousBracketWW = 0;\n        _lotteries[_lotteryId].pendingAwards = 0;\n\n        for (uint32 i = 0; i < 4; i++) {\n            uint32 j = 3 - i;\n            // Get transformed winning number\n            uint32 transformedWinningNumber = _bracketCalculator[j] +\n                (finalNumber % (uint32(10)**(j + 1)));\n\n            uint256 numberTickets = 0;\n            numberTicketsWW = 0;\n            for (uint32 k = 1; k <= _lotteryId; k++) {\n                numberTickets +=\n                    _numberTicketsPerLotteryId[k][transformedWinningNumber] *\n                    (int2ln(_lotteryId - k + 1) + 10000);\n\n                numberTicketsWW += _numberTicketsPerLotteryId[k][\n                    transformedWinningNumber\n                ];\n            }\n\n            _lotteries[_lotteryId].countWinnersPerBracket[j] =\n                numberTickets -\n                numberAddressesInPreviousBracket;\n            _lotteries[_lotteryId].countWinnersPerBracketWW[j] =\n                numberTicketsWW -\n                numberAddressesInPreviousBracketWW;\n\n            // If there are winners for this _bracket\n            if (numberTickets - numberAddressesInPreviousBracket != 0) {\n                // B. If rewards at this bracket are > 0, calculate, else, report the numberAddresses from previous bracket\n                if (_lotteries[_lotteryId].rewardsBreakdown[j] != 0) {\n                    _lotteries[_lotteryId].rewardPerTicketInBracket[j] =\n                        ((_lotteries[_lotteryId].rewardsBreakdown[j] *\n                            amountToWinners) /\n                            (numberTickets -\n                                numberAddressesInPreviousBracket)) /\n                        10000;\n                    _lotteries[_lotteryId].pendingAwards +=\n                        (_lotteries[_lotteryId].rewardsBreakdown[j] *\n                            amountToWinners) /\n                        10000;\n                }\n                // No winners, prize added to the amount to withdraw to treasury\n            } else {\n                _lotteries[_lotteryId].rewardPerTicketInBracket[j] = 0;\n            }\n\n            // Update numberAddressesInPreviousBracket\n            numberAddressesInPreviousBracket = numberTickets;\n            numberAddressesInPreviousBracketWW = numberTicketsWW;\n        }\n\n        // Update internal statuses for this lottery round\n        _lotteries[_lotteryId].finalNumber = finalNumber;\n        _lotteries[_lotteryId].status = Status.Claimable;\n\n        uint256 amountToTreasury = 0;\n        amountToTreasury =\n            amountToWinners -\n            _lotteries[_lotteryId].pendingAwards;\n\n        // If autoInjection, all unused prize will be rolled to next round\n        if (_autoInjection) {\n            pendingInjectionNextLottery = amountToTreasury;\n            amountToTreasury = 0;\n        }\n\n        // Amount to treasury from the treasuryFee part\n        amountToTreasury += (_lotteries[_lotteryId].amountCollected -\n            amountToWinners);\n\n        // Transfer prize to treasury address\n        if (amountToTreasury > 0) {\n            USDCToken.safeTransfer(treasuryAddress, amountToTreasury);\n        }\n\n        require(\n            _calculateTotalAwards() == USDCToken.balanceOf(address(this)),\n            \"USDC not balance\"\n        );\n\n        emit LotteryNumberDrawn(\n            currentLotteryId,\n            finalNumber, // final result for this round\n            numberAddressesInPreviousBracket // total winners\n        );\n    }\n\n    /**\n     * @notice Change the random generator contract address\n     * @dev The calls to functions are used to verify the new generator implements them properly.\n     * It is necessary to wait for the VRF response before starting a round.\n     * Callable only by the contract owner\n     * @param _randomGeneratorAddress address of the random generator\n     */\n    function changeRandomGenerator(address _randomGeneratorAddress)\n        external\n        onlyOwner\n    {\n        require(\n            _lotteries[currentLotteryId].status == Status.Claimable,\n            \"current lottery is not claimable\"\n        );\n\n        // Request a random number from the new generator\n        IRandomNumberGenerator(_randomGeneratorAddress).getRandomNumber();\n\n        // Get the finalNumber based on the randomResult\n        IRandomNumberGenerator(_randomGeneratorAddress).randomResult();\n\n        // Set the new address\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\n\n        emit NewRandomGenerator(_randomGeneratorAddress);\n    }\n\n    /**\n     * @notice Inject funds\n     * @param _amount amount to inject\n     */\n    function injectFunds(uint256 _amount) external onlyOwnerOrInjector {\n        uint256 currentId = currentLotteryId;\n        require(_lotteries[currentId].status == Status.Open, \"Round not open\");\n\n        // Transfer usd tokens to this contract (need approval)\n        USDCToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n\n        uint256 USDC_Balance = USDCToken.balanceOf(address(this));\n        _lotteries[currentId].amountCollected += _amount;\n\n        require(_calculateTotalAwards() <= USDC_Balance, \"the amount is wrong\");\n\n        emit LotteryInjection(currentId, _amount);\n    }\n\n    /**\n     * @notice Start the lottery\n     * @dev Callable only by operator\n     * @param _endTime endTime of the lottery (timestamp in s)\n     * @param _rewardsBreakdown breakdown of rewards per bracket (must sum to 10,000)(100 <=> 1)\n     * @param _treasuryFee treasury fee (10,000 = 100%, 100 = 1%) (set as 0)\n     */\n    function startLottery(\n        uint256 _endTime,\n        uint256[4] calldata _rewardsBreakdown,\n        uint256 _treasuryFee\n    ) external onlyOperator {\n        require(\n            (currentLotteryId == 0) ||\n                (_lotteries[currentLotteryId].status == Status.Claimable),\n            \"Not time to start lottery\"\n        );\n\n        uint256 price = ticketPrice;\n\n        require(_treasuryFee <= MAX_TREASURY_FEE, \"treasury fee is too high\");\n\n        require(\n            (_rewardsBreakdown[0] +\n                _rewardsBreakdown[1] +\n                _rewardsBreakdown[2] +\n                _rewardsBreakdown[3]) <= 10000,\n            \"total rewards of each bracket must less than or equal to 10000\"\n        );\n\n        uint256 currentId = ++currentLotteryId;\n\n        Lottery storage newLottery = _lotteries[currentId];\n\n        newLottery.status = Status.Open;\n        newLottery.startTime = block.timestamp;\n        newLottery.endTime = _endTime;\n        newLottery.ticketPrice = price;\n        newLottery.rewardsBreakdown = _rewardsBreakdown;\n        newLottery.treasuryFee = _treasuryFee;\n        newLottery.amountCollected = pendingInjectionNextLottery;\n\n        emit LotteryOpen(\n            currentId,\n            block.timestamp,\n            _endTime,\n            price,\n            pendingInjectionNextLottery\n        );\n\n        pendingInjectionNextLottery = 0;\n    }\n\n    /**\n     * @notice Recover wrong tokens sent to the contract, only by the owner\n               All tokens except Degis and USDC are wrong tokens\n     * @param _tokenAddress the address of the token to withdraw\n     * @param _tokenAmount token amount to withdraw\n     */\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(_tokenAddress != address(DegisToken), \"Cannot be DEGIS token\");\n\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\n\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\n    }\n\n    error DLT__ZeroPrice();\n    event TicketPriceChanged(uint256 oldPrice, uint256 newPrice);\n\n    /**\n     * @notice Set the ticket price\n     * @dev Only callable by the owner\n     * @param _price New ticket price\n     */\n    function setTicketPrice(uint256 _price) external onlyOwner {\n        if (_price == 0) revert DLT__ZeroPrice();\n\n        emit TicketPriceChanged(ticketPrice, _price);\n\n        ticketPrice = _price;\n    }\n\n    /**\n     * @notice Set max number of tickets that a user can buy/claim at one time\n     * @dev Only callable by the owner\n     */\n    function setMaxNumberTicketsPeyBuyOrClaim(uint256 _maxNumber)\n        external\n        onlyOwner\n    {\n        require(_maxNumber != 0, \"Must be > 0\");\n        maxNumberTicketsPerBuyOrClaim = _maxNumber;\n    }\n\n    /**\n     * @notice Set operator, treasury, and injector addresses\n     * @dev Only callable by the owner\n     * @param _operatorAddress address of the operator\n     * @param _treasuryAddress address of the treasury\n     * @param _injectorAddress address of the injector\n     */\n    function setOperatorAndTreasuryAndInjectorAddresses(\n        address _operatorAddress,\n        address _treasuryAddress,\n        address _injectorAddress\n    ) external onlyOwner {\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\n        require(_treasuryAddress != address(0), \"Cannot be zero address\");\n        require(_injectorAddress != address(0), \"Cannot be zero address\");\n\n        operatorAddress = _operatorAddress;\n        treasuryAddress = _treasuryAddress;\n        injectorAddress = _injectorAddress;\n\n        emit NewOperatorAndTreasuryAndInjectorAddresses(\n            _operatorAddress,\n            _treasuryAddress,\n            _injectorAddress\n        );\n    }\n\n    /**\n     * @notice Calculate the total price of a set of tickets\n     * @param _price Price per ticket (in Degis)\n     * @param _amount Number of tickets to buy\n     */\n    function calculateTotalPriceForBulkTickets(uint256 _price, uint256 _amount)\n        external\n        pure\n        returns (uint256)\n    {\n        require(_amount != 0, \"number of tickets must be > 0\");\n\n        return _price * _amount;\n    }\n\n    /**\n     * @notice View current lottery id\n     */\n    function viewCurrentLotteryId() external view returns (uint256) {\n        return currentLotteryId;\n    }\n\n    /**\n     * @notice View lottery information\n     * @param _lotteryId: lottery id\n     */\n    function viewLottery(uint256 _lotteryId)\n        external\n        view\n        returns (Lottery memory)\n    {\n        return _lotteries[_lotteryId];\n    }\n\n    /**\n     * @notice View lottery information\n     */\n    function viewAllLottery() external view returns (Lottery[] memory) {\n        Lottery[] memory allLottery = new Lottery[](currentLotteryId);\n        for (uint256 i = 1; i <= currentLotteryId; i++) {\n            allLottery[i - 1] = _lotteries[i];\n        }\n        return allLottery;\n    }\n\n    /**\n     * @notice View ticker statuses and numbers for an array of ticket ids\n     * @param _ticketIds: array of _ticketId\n     */\n    function viewNumbersAndStatusesForTicketIds(uint256[] calldata _ticketIds)\n        external\n        view\n        returns (uint32[] memory, bool[] memory)\n    {\n        uint256 length = _ticketIds.length;\n        uint32[] memory ticketNumbers = new uint32[](length);\n        bool[] memory ticketStatuses = new bool[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            ticketNumbers[i] = _tickets[_ticketIds[i]].number;\n            ticketStatuses[i] = _tickets[_ticketIds[i]].isRedeemed;\n        }\n\n        return (ticketNumbers, ticketStatuses);\n    }\n\n    /**\n     * @notice View rewards for a given ticket, providing a bracket, and lottery id\n     * @dev Computations are mostly offchain. This is used to verify a ticket!\n     * @param _lotteryId: lottery round\n     * @param _ticketId: ticket id\n     */\n    function viewRewardsForTicketId(uint256 _lotteryId, uint256 _ticketId)\n        external\n        view\n        returns (uint256)\n    {\n        // Check lottery is in claimable status\n        if (_lotteries[_lotteryId].status != Status.Claimable) {\n            return 0;\n        }\n\n        require(\n            _tickets[_ticketId].buyLotteryId <= _lotteryId,\n            \"ticketId is too large\"\n        );\n        if (_tickets[_ticketId].isRedeemed == true) {\n            require(\n                _tickets[_ticketId].redeemLotteryId > _lotteryId,\n                \"ticketId was redeemed\"\n            );\n        }\n        require(\n            _ticketsClaimed[_ticketId][_lotteryId] == false,\n            \"prize received\"\n        );\n\n        // Check ticketId is within range\n        if (\n            (_tickets[_ticketId].buyLotteryId > _lotteryId) ||\n            (_tickets[_ticketId].isRedeemed == true &&\n                (_tickets[_ticketId].redeemLotteryId <= _lotteryId)) ||\n            (_ticketsClaimed[_ticketId][_lotteryId] == true)\n        ) {\n            return 0;\n        }\n\n        return _calculateRewardsForTicketId(_lotteryId, _ticketId);\n    }\n\n    /**\n     * @notice View user ticket ids, numbers, and statuses of user for a given lottery\n     * @param _user: user address\n     * @param _lotteryId: lottery round\n     * @param _cursor: cursor to start where to retrieve the tickets\n     * @param _size: the number of tickets to retrieve\n     */\n    // e.g. Alice, round 10, check her ticket-30 to ticket-35\n    function viewUserInfoForLotteryId(\n        address _user,\n        uint256 _lotteryId,\n        uint256 _cursor,\n        uint256 _size\n    )\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint32[] memory,\n            bool[] memory,\n            uint256\n        )\n    {\n        uint256 length = _size;\n        uint256 numberTicketsBoughtAtLotteryId = _userTicketIds[_user].length;\n\n        if (length > (numberTicketsBoughtAtLotteryId - _cursor)) {\n            length = numberTicketsBoughtAtLotteryId - _cursor;\n        }\n\n        uint256[] memory lotteryTicketIds = new uint256[](length);\n        uint32[] memory ticketNumbers = new uint32[](length);\n        bool[] memory ticketStatuses = new bool[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            lotteryTicketIds[i] = _userTicketIds[_user][i + _cursor];\n            ticketNumbers[i] = _tickets[lotteryTicketIds[i]].number;\n            ticketStatuses[i] = _tickets[lotteryTicketIds[i]].isRedeemed;\n        }\n\n        return (\n            lotteryTicketIds,\n            ticketNumbers,\n            ticketStatuses,\n            _cursor + length\n        );\n    }\n\n    /**\n     * @notice View user ticket ids, numbers, and statuses of user for a given lottery\n     * @param _user: user address\n     */\n    // e.g. Alice, round 10, check her ticket-30 to ticket-35\n    function viewUserInfo(address _user)\n        external\n        view\n        returns (uint256[] memory, Ticket[] memory)\n    {\n        uint256 length = _userTicketIds[_user].length;\n\n        uint256[] memory ticketIds = new uint256[](length);\n        Ticket[] memory userTickets = new Ticket[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            ticketIds[i] = _userTicketIds[_user][i];\n            userTickets[i] = _tickets[ticketIds[i]];\n        }\n\n        return (ticketIds, userTickets);\n    }\n\n    /**\n     * @notice Claim all winning tickets for a lottery\n     * @param _lotteryId: lottery id\n     * @dev Callable by users only, not contract!\n     */\n    struct viewClaimAllTicketInfo {\n        uint256 ticketId;\n        uint256 ticketNumber;\n        uint256 ticketReward;\n        bool ticketClaimed;\n    }\n\n    function viewClaimAllTickets(uint256 _lotteryId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            viewClaimAllTicketInfo[] memory\n        )\n    {\n        require(\n            _lotteries[_lotteryId].status == Status.Claimable,\n            \"this round of lottery are not ready for claiming\"\n        );\n\n        uint256 length = _userTicketIds[msg.sender].length;\n        uint256 rewardToTransfer = 0;\n        viewClaimAllTicketInfo[]\n            memory tmpTicketInfo = new viewClaimAllTicketInfo[](length);\n\n        uint256 num = 0;\n        for (uint256 i = 0; i < _userTicketIds[msg.sender].length; i++) {\n            uint256 thisTicketId = _userTicketIds[msg.sender][i];\n\n            require(\n                msg.sender == _tickets[thisTicketId].owner,\n                \"you are not the owner of this ticket\"\n            );\n\n            if (_tickets[thisTicketId].buyLotteryId > _lotteryId) {\n                continue;\n            }\n\n            if (_tickets[thisTicketId].isRedeemed == true) {\n                if (_tickets[thisTicketId].redeemLotteryId <= _lotteryId) {\n                    continue;\n                }\n            }\n\n            if (_ticketsClaimed[thisTicketId][_lotteryId] == true) {\n                continue;\n            }\n\n            uint256 rewardForTicketId = _calculateRewardsForTicketId(\n                _lotteryId,\n                thisTicketId\n            );\n\n            if (rewardForTicketId == 0) {\n                continue;\n            }\n\n            tmpTicketInfo[num].ticketId = thisTicketId;\n            tmpTicketInfo[num].ticketNumber = _tickets[thisTicketId].number;\n            tmpTicketInfo[num].ticketReward = rewardForTicketId;\n            tmpTicketInfo[num].ticketClaimed = _ticketsClaimed[thisTicketId][\n                _lotteryId\n            ];\n            num += 1;\n\n            // Increase the reward to transfer\n            rewardToTransfer += rewardForTicketId;\n        }\n\n        viewClaimAllTicketInfo[]\n            memory ticketInfo = new viewClaimAllTicketInfo[](num);\n\n        for (uint256 i = 0; i < num; i++) {\n            ticketInfo[i] = tmpTicketInfo[i];\n        }\n\n        return (_lotteryId, rewardToTransfer, ticketInfo);\n    }\n\n    /**\n     * @notice Calculate rewards for a given ticket, in given round and given bracket\n     * @param _lotteryId: lottery round\n     * @param _ticketId: ticket id\n     */\n    function _calculateRewardsForTicketId(uint256 _lotteryId, uint256 _ticketId)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_tickets[_ticketId].buyLotteryId > _lotteryId) {\n            return 0;\n        }\n\n        if (_tickets[_ticketId].isRedeemed == true) {\n            if (_tickets[_ticketId].redeemLotteryId <= _lotteryId) {\n                return 0;\n            }\n        }\n\n        if (_ticketsClaimed[_ticketId][_lotteryId] == true) {\n            return 0;\n        }\n\n        // Retrieve the user number combination from the ticketId\n        uint32 userNumber = _tickets[_ticketId].number;\n\n        // Retrieve the winning number combination\n        uint32 winningTicketNumber = _lotteries[_lotteryId].finalNumber;\n\n        uint32 _bracket = 5;\n        for (uint32 i = 1; i <= 4; i++) {\n            if (\n                winningTicketNumber % (uint32(10)**i) ==\n                userNumber % (uint32(10)**i)\n            ) {\n                _bracket = i - 1;\n            }\n        }\n\n        if (_bracket == 5) {\n            return 0;\n        }\n\n        // Apply transformation to verify the claim provided by the user is true\n        uint32 transformedWinningNumber = _bracketCalculator[_bracket] +\n            (winningTicketNumber % (uint32(10)**(_bracket + 1)));\n\n        uint32 transformedUserNumber = _bracketCalculator[_bracket] +\n            (userNumber % (uint32(10)**(_bracket + 1)));\n\n        // Confirm that the two transformed numbers are the same\n        if (transformedWinningNumber == transformedUserNumber) {\n            return\n                _lotteries[_lotteryId].rewardPerTicketInBracket[_bracket] *\n                (int2ln(_lotteryId - _tickets[_ticketId].buyLotteryId + 1) +\n                    10000);\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Calculate all awards\n     */\n    function _calculateTotalAwards() internal view returns (uint256) {\n        uint256 amount = 0;\n\n        for (uint256 i = 0; i < currentLotteryId; i++) {\n            amount += _lotteries[i].pendingAwards;\n        }\n\n        if (_lotteries[currentLotteryId].status == Status.Claimable) {\n            amount +=\n                _lotteries[currentLotteryId].pendingAwards +\n                pendingInjectionNextLottery;\n        } else {\n            amount += _lotteries[currentLotteryId].amountCollected;\n        }\n\n        return amount;\n    }\n\n    /**\n     * @notice Check if an address is a contract\n     */\n    function _isContract(address _addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return size > 0;\n    }\n\n    \n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/lucky-box/interfaces/IRandomNumberGenerator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IRandomNumberGenerator {\n    /**\n     * @notice Views random result\n     */\n    function getRandomNumber() external;\n\n    function randomResult() external view returns (uint32);\n\n    function latestLotteryId() external view returns (uint256);\n}\n"
    },
    "contracts/lucky-box/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary MathLib {\n    /*\n     * Minimum value signed 64.64-bit fixed point number may have.\n     */\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n    /*\n     * Maximum value signed 64.64-bit fixed point number may have.\n     */\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    function log_2(int128 x) internal pure returns (int128) {\n        unchecked {\n            require(x > 0);\n\n            int256 msb = 0;\n            int256 xc = x;\n            if (xc >= 0x10000000000000000) {\n                xc >>= 64;\n                msb += 64;\n            }\n            if (xc >= 0x100000000) {\n                xc >>= 32;\n                msb += 32;\n            }\n            if (xc >= 0x10000) {\n                xc >>= 16;\n                msb += 16;\n            }\n            if (xc >= 0x100) {\n                xc >>= 8;\n                msb += 8;\n            }\n            if (xc >= 0x10) {\n                xc >>= 4;\n                msb += 4;\n            }\n            if (xc >= 0x4) {\n                xc >>= 2;\n                msb += 2;\n            }\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\n\n            int256 result = (msb - 64) << 64;\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n                ux *= ux;\n                uint256 b = ux >> 255;\n                ux >>= 127 + b;\n                result += bit * int256(b);\n            }\n\n            return int128(result);\n        }\n    }\n\n    function mul(int128 x, int128 y) internal pure returns (int128) {\n        unchecked {\n            int256 result = (int256(x) * y) >> 64;\n            require(result >= MIN_64x64 && result <= MAX_64x64);\n            return int128(result);\n        }\n    }\n\n    /**\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x unsigned 256-bit integer number\n     * @return signed 64.64-bit fixed point number\n     */\n    function fromUInt(uint256 x) internal pure returns (int128) {\n        unchecked {\n            require(x <= 0x7FFFFFFFFFFFFFFF);\n            return int128(int256(x << 64));\n        }\n    }\n\n    /**\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n     * number rounding down.  Revert on underflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return unsigned 64-bit integer number\n     */\n    function toUInt(int128 x) internal pure returns (uint64) {\n        unchecked {\n            require(x >= 0);\n            return uint64(uint128(x >> 64));\n        }\n    }\n\n    function ln(int128 x) internal pure returns (int128) {\n        unchecked {\n            require(x > 0);\n\n            return\n                int128(\n                    int256(\n                        (uint256(int256(log_2(x))) *\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\n                    )\n                );\n        }\n    }\n}\n"
    },
    "contracts/lucky-box/DegisLottery.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/IRandomNumberGenerator.sol\";\n\ncontract DegisLottery is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    IERC20 public DEGToken;\n    IERC20 public USDToken;\n    IRandomNumberGenerator public randomGenerator;\n\n    address public operatorAddress;\n\n    uint256 public constant TICKET_PRICE = 10 ether;\n\n    struct Tickets {\n        mapping(uint256 => uint256) ticketsWeight;\n        mapping(uint256 => uint256) ticketsAmount;\n    }\n    Tickets poolTickets;\n    mapping(address => Tickets) usersTickets;\n\n    enum Status {\n        Pending,\n        Open,\n        Close,\n        Claimable\n    }\n    struct LotteryInfo {\n        Status status;\n        uint256 startTime;\n        uint256 endTime;\n        uint256[4] stageProportion;\n        uint256[4] stageReward;\n        uint256[4] stageAmount;\n        uint256[4] stageWeight;\n        uint256 totalRewards;\n        uint256 pendingRewards;\n        uint256 finalNumber;\n    }\n    mapping(uint256 => LotteryInfo) public lotteries;\n\n    uint256 public rewardsToNextLottery;\n\n    uint256 public allPendingRewards;\n\n    uint256 public rewardBalance;\n\n    uint256 public currentLotteryId; // Total Rounds\n\n    mapping(address => uint256) public checkPoint;\n    mapping(address => uint256) public usersTotalRewards;\n\n    mapping(address => mapping(uint256 => uint256)) public usersRewards;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event TicketsPurchase(\n        address indexed buyer,\n        uint256 indexed lotteryId,\n        uint256 totalAmount\n    );\n    event TicketsRedeem(\n        address indexed redeemer,\n        uint256 indexed lotteryId,\n        uint256 totalAmount\n    );\n    event LotteryOpen(\n        uint256 indexed lotteryId,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 totalRewards\n    );\n    event LotteryNumberDrawn(\n        uint256 indexed lotteryId,\n        uint256 finalNumber,\n        uint256 pendingRewards\n    );\n\n    event ReceiveRewards(\n        address indexed claimer,\n        uint256 amount,\n        uint256 indexed lotteryId\n    );\n\n    event LotteryClose(uint256 indexed lotteryId, uint256 timestamp);\n\n    event LotteryFundInjection(\n        uint256 indexed lotteryId,\n        uint256 injectedAmount\n    );\n    event RandomNumberGeneratorChanged(\n        address oldGenerator,\n        address newGenerator\n    );\n    event OperatorAddressChanged(address oldOperator, address newOperator);\n    event AdminTokenRecovery(address indexed token, uint256 amount);\n\n    event UpdateBalance(\n        uint256 lotteryId,\n        uint256 oldBalance,\n        uint256 newBalance\n    );\n\n    /**\n     * @notice Constructor function\n     * @dev RandomNumberGenerator must be deployed prior to this contract\n     * @param _DEGTokenAddress Address of the DEG token (for buying tickets)\n     * @param _USDTokenAddress Address of the USD token (for prize distribution)\n     * @param _randomGeneratorAddress Address of the RandomGenerator contract used to work with ChainLink VRF\n     */\n    constructor(\n        address _DEGTokenAddress,\n        address _USDTokenAddress,\n        address _randomGeneratorAddress\n    ) Ownable(msg.sender) {\n        DEGToken = IERC20(_DEGTokenAddress);\n        USDToken = IERC20(_USDTokenAddress);\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Not contract address\n     */\n    modifier notContract() {\n        require(!_isContract(msg.sender), \"Contract not allowed\");\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\n        _;\n    }\n\n    /**\n     * @notice Only the operator or owner\n     */\n    modifier onlyOperator() {\n        require(\n            msg.sender == operatorAddress || msg.sender == owner(),\n            \"Not operator or owner\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function getCurrentRoundWeight() public view returns (uint256) {\n        return ((currentLotteryId + 24) * 1000000) / (currentLotteryId + 12);\n    }\n\n    /**\n     * @notice Get pool tickets info\n     * @dev May be a huge number, avoid reading this frequently\n     * @param _startIndex Start number\n     * @param _stopIndex Stop number\n     * @param _position Which level to check (0, 1, 2, 3), use 0 to check the 4-digit number\n     */\n    function getPoolTicketsInfo(\n        uint256 _startIndex,\n        uint256 _stopIndex,\n        uint256 _position\n    )\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        uint256 length = _stopIndex - _startIndex + 1;\n\n        uint256[] memory ticketsNumber = new uint256[](length);\n        uint256[] memory ticketsAmount = new uint256[](length);\n        uint256[] memory ticketsWeight = new uint256[](length);\n\n        for (uint256 i = _startIndex; i <= _stopIndex; i++) {\n            uint256 encodedNumber = _encodeNumber(i, _position);\n\n            ticketsNumber[i - _startIndex] = i;\n            ticketsAmount[i - _startIndex] = poolTickets.ticketsAmount[\n                encodedNumber\n            ];\n            ticketsWeight[i - _startIndex] = poolTickets.ticketsWeight[\n                encodedNumber\n            ];\n        }\n        return (ticketsNumber, ticketsAmount, ticketsWeight);\n    }\n\n    /**\n     * @notice Get user tickets info\n     */\n    function getUserTicketsInfo(\n        address user,\n        uint256 _startIndex,\n        uint256 _stopIndex,\n        uint256 position\n    )\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        uint256 length = _stopIndex - _startIndex + 1;\n\n        uint256[] memory ticketsNumber = new uint256[](length);\n        uint256[] memory ticketsAmount = new uint256[](length);\n        uint256[] memory ticketsWeight = new uint256[](length);\n\n        for (uint256 i = _startIndex; i <= _stopIndex; i++) {\n            uint256 encodedNumber = _encodeNumber(i, position);\n            ticketsNumber[i - _startIndex] = i;\n            ticketsAmount[i - _startIndex] = usersTickets[user].ticketsAmount[\n                encodedNumber\n            ];\n            ticketsWeight[i - _startIndex] = usersTickets[user].ticketsWeight[\n                encodedNumber\n            ];\n        }\n        return (ticketsNumber, ticketsAmount, ticketsWeight);\n    }\n\n    /**\n     * @notice Get lottery stage info\n     */\n    function getLotteriesStageInfo(uint256 _lotteryId)\n        external\n        view\n        returns (\n            uint256[] memory stageProportion,\n            uint256[] memory stageReward,\n            uint256[] memory stageAmount,\n            uint256[] memory stageWeight\n        )\n    {\n        stageProportion = new uint256[](4);\n        stageReward = new uint256[](4);\n        stageAmount = new uint256[](4);\n        stageWeight = new uint256[](4);\n\n        for (uint256 i = 0; i < 4; i++) {\n            stageProportion[i] = lotteries[_lotteryId].stageProportion[i];\n            stageReward[i] = lotteries[_lotteryId].stageReward[i];\n            stageAmount[i] = lotteries[_lotteryId].stageAmount[i];\n            stageWeight[i] = lotteries[_lotteryId].stageWeight[i];\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set operator address\n     * @dev Only callable by the owner\n     * @param _operatorAddress address of the operator\n     */\n    function setOperatorAddress(address _operatorAddress) external onlyOwner {\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\n\n        emit OperatorAddressChanged(operatorAddress, _operatorAddress);\n        operatorAddress = _operatorAddress;\n    }\n\n    /**\n     * @notice Set Random Number Generator contract address\n     * @dev Only callable by the owner\n     * @param _randomNumberGenerator Address of the Random Number Generator contract\n     */\n    function setRandomNumberGenerator(address _randomNumberGenerator)\n        external\n        onlyOwner\n    {\n        require(\n            _randomNumberGenerator != address(0),\n            \"Can not be zero address\"\n        );\n        emit RandomNumberGeneratorChanged(\n            address(randomGenerator),\n            _randomNumberGenerator\n        );\n\n        randomGenerator = IRandomNumberGenerator(_randomNumberGenerator);\n    }\n\n    /**\n     * @notice Change the end time of current round (only if it was set a wrong number)\n     * @dev Normally this function is not needed\n     * @param _endTime New end time\n     */\n    function setEndTime(uint256 _endTime) external onlyOwner {\n        uint256 currentId = currentLotteryId;\n        require(\n            lotteries[currentId].status == Status.Open,\n            \"Only change endtime when Lottery open\"\n        );\n\n        lotteries[currentId].endTime = _endTime;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start the lottery\n     * @dev Callable only by operator\n     * @param _endTime EndTime of the lottery (UNIX timestamp in s)\n     * @param _stageProportion Breakdown of rewards per bracket\n     * @dev Stage proportion must sum to 10,000(100 <=> 1)\n     */\n    function startLottery(\n        uint256 _endTime,\n        uint256[4] calldata _stageProportion\n    ) external onlyOperator {\n        require(\n            (currentLotteryId == 0) ||\n                (lotteries[currentLotteryId].status == Status.Claimable),\n            \"Not time to start lottery\"\n        );\n\n        require(\n            (_stageProportion[0] +\n                _stageProportion[1] +\n                _stageProportion[2] +\n                _stageProportion[3]) <= 10000,\n            \"Total rewards of each bracket should <= 10000\"\n        );\n\n        updateBalance();\n\n        // gas saving\n        uint256 id = ++currentLotteryId;\n\n        // Do not init those have default values at first\n        LotteryInfo storage newLottery = lotteries[id];\n        newLottery.status = Status.Open;\n        newLottery.startTime = block.timestamp;\n        newLottery.endTime = _endTime;\n        newLottery.stageProportion = _stageProportion;\n        newLottery.totalRewards = rewardsToNextLottery;\n\n        // First emit the event\n        emit LotteryOpen(id, block.timestamp, _endTime, rewardsToNextLottery);\n\n        // Clear rewards to next lottery\n        rewardsToNextLottery = 0;\n    }\n\n    /**\n     * @notice Close a lottery\n     * @dev Callable by any address and need to meet the endtime condition\n     * @dev Normally it's automatically called by our contract\n     */\n    function closeLottery() external nonReentrant {\n        updateBalance();\n\n        // gas saving\n        uint256 currentId = currentLotteryId;\n\n        require(\n            lotteries[currentId].status == Status.Open,\n            \"Current lottery is not open\"\n        );\n\n        require(\n            block.timestamp >= lotteries[currentId].endTime,\n            \"Not time to close lottery\"\n        );\n\n        lotteries[currentId].endTime = block.timestamp;\n\n        // Request a random number from the generator\n        // With VRF, the response may need some time to be generated\n        randomGenerator.getRandomNumber();\n\n        // Update the lottery status\n        lotteries[currentId].status = Status.Close;\n\n        emit LotteryClose(currentId, block.timestamp);\n    }\n\n    /**\n     * @notice Buy tickets for the current lottery round\n     * @dev Can not be called by a smart contract\n     * @param _ticketNumbers array of ticket numbers between 0 and 9999\n     * @param _ticketAmounts array of ticket amount\n     */\n    function buyTickets(\n        uint256[] calldata _ticketNumbers,\n        uint256[] calldata _ticketAmounts\n    ) external notContract nonReentrant {\n        require(_ticketNumbers.length != 0, \"No tickets are being bought\");\n        require(\n            _ticketNumbers.length == _ticketAmounts.length,\n            \"Different lengths\"\n        );\n\n        // gas saving\n        uint256 currentId = currentLotteryId;\n\n        require(\n            lotteries[currentId].status == Status.Open,\n            \"Current lottery is not open\"\n        );\n\n        if (checkPoint[msg.sender] == 0) {\n            checkPoint[msg.sender] = currentId;\n        }\n\n        if (checkPoint[msg.sender] < currentId) {\n            receiveRewards(currentId - 1);\n        }\n\n        // Get the weight of current round (round is a global content)\n        uint256 roundWeight = getCurrentRoundWeight();\n\n        // Total amount of tickets will be bought\n        uint256 totalAmount;\n\n        for (uint256 i = 0; i < _ticketNumbers.length; i++) {\n            _buyTicket(\n                poolTickets,\n                _ticketNumbers[i],\n                _ticketAmounts[i],\n                roundWeight * _ticketAmounts[i]\n            );\n            _buyTicket(\n                usersTickets[msg.sender],\n                _ticketNumbers[i],\n                _ticketAmounts[i],\n                roundWeight * _ticketAmounts[i]\n            );\n            totalAmount += _ticketAmounts[i];\n        }\n\n        // Transfer degis\n        DEGToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            totalAmount * TICKET_PRICE\n        );\n\n        emit TicketsPurchase(msg.sender, currentId, totalAmount);\n    }\n\n    /**\n     * @notice Redeem tickets for all lottery\n     * @param _ticketNumbers Array of ticket numbers\n     * @dev Callable by users\n     */\n    function redeemTickets(uint256[] calldata _ticketNumbers)\n        external\n        notContract\n        nonReentrant\n    {\n        require(_ticketNumbers.length != 0, \"No tickets are being redeem\");\n\n        uint256 currentId = currentLotteryId;\n\n        require(\n            lotteries[currentId].status == Status.Open,\n            \"Sorry, current lottery is not open\"\n        );\n\n        if (checkPoint[msg.sender] < currentId) {\n            receiveRewards(currentId - 1);\n        }\n\n        uint256 totalAmount;\n        for (uint256 i; i < _ticketNumbers.length; i++) {\n            uint256 encodedNumber = _encodeNumber(_ticketNumbers[i], 3);\n\n            uint256 ticketAmount = usersTickets[msg.sender].ticketsAmount[\n                encodedNumber\n            ];\n            uint256 ticketWeight = usersTickets[msg.sender].ticketsWeight[\n                encodedNumber\n            ];\n            _redeemTicket(\n                poolTickets,\n                _ticketNumbers[i],\n                ticketAmount,\n                ticketWeight\n            );\n            _redeemTicket(\n                usersTickets[msg.sender],\n                _ticketNumbers[i],\n                ticketAmount,\n                ticketWeight\n            );\n            totalAmount += ticketAmount;\n        }\n\n        require(totalAmount != 0, \"No tickets are being redeemed\");\n\n        DEGToken.safeTransfer(msg.sender, totalAmount * TICKET_PRICE);\n\n        emit TicketsRedeem(msg.sender, currentId, totalAmount);\n    }\n\n    function updateBalance() public {\n        uint256 curBalance = USDToken.balanceOf(address(this));\n        uint256 preBalance = rewardBalance;\n\n        uint256 currentId = currentLotteryId;\n\n        Status currentStatus = lotteries[currentId].status;\n\n        if (currentStatus == Status.Open) {\n            lotteries[currentId].totalRewards =\n                lotteries[currentId].totalRewards +\n                curBalance -\n                preBalance;\n        } else {\n            rewardsToNextLottery =\n                rewardsToNextLottery +\n                curBalance -\n                preBalance;\n        }\n\n        rewardBalance = curBalance;\n\n        emit UpdateBalance(currentId, preBalance, curBalance);\n    }\n\n    /**\n     * @notice Draw the final number, calculate reward in DEG for each group,\n     *         and make this lottery claimable (need to wait for the random generator)\n     * @dev Callable by any address\n     */\n    function drawLottery() external nonReentrant {\n        uint256 currentId = currentLotteryId;\n        require(\n            lotteries[currentId].status == Status.Close,\n            \"this lottery has not closed, you should first close it\"\n        );\n        require(\n            currentId == randomGenerator.latestLotteryId(),\n            \"the final number has not been drawn\"\n        );\n\n        updateBalance();\n\n        // Get the final lucky numbers from randomGenerator\n        uint256 finalNumber = randomGenerator.randomResult();\n\n        uint256 lastAmount;\n        uint256 lastWeight;\n\n        LotteryInfo storage currentLottery = lotteries[currentId];\n\n        uint256 tempPendingRewards;\n\n        for (uint256 j = 0; j < 4; j++) {\n            uint256 i = 3 - j;\n\n            uint256 encodedNumber = _encodeNumber(finalNumber, i);\n\n            currentLottery.stageAmount[i] =\n                poolTickets.ticketsAmount[encodedNumber] -\n                lastAmount;\n            lastAmount = poolTickets.ticketsAmount[encodedNumber];\n\n            currentLottery.stageWeight[i] =\n                poolTickets.ticketsWeight[encodedNumber] -\n                lastWeight;\n            lastWeight = poolTickets.ticketsWeight[encodedNumber];\n\n            if (currentLottery.stageAmount[i] == 0)\n                currentLottery.stageReward[i] = 0;\n            else\n                currentLottery.stageReward[i] =\n                    (currentLottery.stageProportion[i] *\n                        currentLottery.totalRewards) /\n                    10000;\n\n            tempPendingRewards += currentLottery.stageReward[i];\n        }\n        currentLottery.pendingRewards += tempPendingRewards;\n\n        rewardsToNextLottery =\n            currentLottery.totalRewards -\n            currentLottery.pendingRewards;\n\n        require(\n            allPendingRewards + currentLottery.totalRewards <=\n                USDToken.balanceOf(address(this)),\n            \"Wrong USD amount\"\n        );\n\n        // Update internal statuses for this lottery round\n        currentLottery.finalNumber = finalNumber;\n        currentLottery.status = Status.Claimable;\n\n        // Update all pending rewards\n        allPendingRewards += currentLottery.pendingRewards;\n\n        emit LotteryNumberDrawn(\n            currentLotteryId,\n            finalNumber, // final result for this round\n            lotteries[currentLotteryId].pendingRewards\n        );\n    }\n\n    /**\n     * @notice Receive award from a lottery\n     * @param _lotteryId lottery id\n     * @param user user address\n     */\n    function pendingReward(uint256 _lotteryId, address user)\n        public\n        view\n        returns (uint256 reward)\n    {\n        uint256 lastWeight;\n        uint256 finalNumber = lotteries[_lotteryId].finalNumber;\n\n        for (uint256 j; j < 4; j++) {\n            uint256 i = 3 - j;\n\n            uint256 encodedNumber = _encodeNumber(finalNumber, i);\n\n            uint256 weight = usersTickets[user].ticketsWeight[encodedNumber] -\n                lastWeight;\n\n            lastWeight += weight;\n\n            if (lotteries[_lotteryId].stageWeight[i] != 0) {\n                reward +=\n                    (lotteries[_lotteryId].stageReward[i] * weight) /\n                    lotteries[_lotteryId].stageWeight[i];\n            }\n        }\n    }\n\n    /**\n     * @notice Receive all awards from lottery before lottery id\n     * @param _lotteryId lottery id\n     * @dev Callable by users only, not contract!\n     */\n    function receiveRewards(uint256 _lotteryId) public notContract {\n        require(\n            lotteries[_lotteryId].status == Status.Claimable,\n            \"This round not claimable\"\n        );\n\n        require(\n            checkPoint[msg.sender] <= _lotteryId,\n            \"All rewards have been received\"\n        );\n\n        uint256 reward;\n\n        for (\n            uint256 round = checkPoint[msg.sender];\n            round <= _lotteryId;\n            round++\n        ) {\n            uint256 roundReward = pendingReward(round, msg.sender);\n            reward += roundReward;\n\n            lotteries[round].pendingRewards -= roundReward;\n\n            usersRewards[msg.sender][round] = roundReward;\n            usersTotalRewards[msg.sender] += roundReward;\n        }\n        checkPoint[msg.sender] = _lotteryId + 1;\n\n        allPendingRewards -= reward;\n\n        // Transfer the prize to winner\n        if (reward != 0) {\n            USDToken.safeTransfer(msg.sender, reward);\n        }\n        emit ReceiveRewards(msg.sender, reward, _lotteryId);\n    }\n\n    /**\n     * @notice Recover wrong tokens sent to the contract\n     * @dev    Only callable by the owner\n     * @dev    All tokens except DEG and USD are wrong tokens\n     * @param _tokenAddress the address of the token to withdraw\n     * @param _tokenAmount token amount to withdraw\n     */\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(_tokenAddress != address(DEGToken), \"Cannot recover DEG token\");\n\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\n\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update the status to finish buying a ticket\n     * @param tickets Tickets to update\n     * @param _ticketNumber Original number of the ticket\n     * @param _ticketAmount Amount of this number are being bought\n     * @param _ticketWeight Weight of this ticket, depends on round\n     */\n    function _buyTicket(\n        Tickets storage tickets,\n        uint256 _ticketNumber,\n        uint256 _ticketAmount,\n        uint256 _ticketWeight\n    ) internal {\n        for (uint256 i; i < 4; i++) {\n            uint256 encodedNumber = _encodeNumber(_ticketNumber, i);\n            tickets.ticketsWeight[encodedNumber] += _ticketWeight;\n            tickets.ticketsAmount[encodedNumber] += _ticketAmount;\n        }\n    }\n\n    /**\n     * @notice Update the status to finish redeeming a ticket\n     * @param tickets Tickets to update\n     * @param _ticketNumber Original number of the ticket\n     * @param _ticketAmount Amount of this number are being redeemed\n     * @param _ticketWeight Weight of this ticket, depends on round\n     */\n    function _redeemTicket(\n        Tickets storage tickets,\n        uint256 _ticketNumber,\n        uint256 _ticketAmount,\n        uint256 _ticketWeight\n    ) internal {\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 encodedNumber = _encodeNumber(_ticketNumber, i);\n            tickets.ticketsWeight[encodedNumber] -= _ticketWeight;\n            tickets.ticketsAmount[encodedNumber] -= _ticketAmount;\n        }\n    }\n\n    /**\n     * @notice Get the encoded number form\n     * @param _number The original number\n     * @param _position The number's position/level (0, 1, 2, 3)\n     */\n    function _encodeNumber(uint256 _number, uint256 _position)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_number % (10**(_position + 1))) + _position * 10000;\n    }\n\n    /**\n     * @notice Check if an address is a contract\n     */\n    function _isContract(address _addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return size > 0;\n    }\n\n    function _viewUserTicketAmount(address user, uint256 encodedNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        return usersTickets[user].ticketsAmount[encodedNumber];\n    }\n\n    function _viewUserTicketWeight(address user, uint256 encodedNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        return usersTickets[user].ticketsWeight[encodedNumber];\n    }\n\n    function viewUserAllTicketsInfo(address user, uint256 maxAmount)\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256\n        )\n    {\n        uint256[] memory ticketsNumber = new uint256[](maxAmount);\n        uint256[] memory ticketsAmount = new uint256[](maxAmount);\n        uint256[] memory ticketsWeight = new uint256[](maxAmount);\n\n        uint256 amount;\n        uint256 number;\n        uint256 i0;\n        uint256 i1;\n        uint256 i2;\n        uint256 i3;\n\n        for (i0; i0 <= 9; i0++) {\n            number = i0;\n            if (_viewUserTicketAmount(user, _encodeNumber(number, 0)) == 0)\n                continue;\n            for (i1 = 0; i1 <= 9; i1++) {\n                number = i0 + i1 * 10;\n                if (_viewUserTicketAmount(user, _encodeNumber(number, 1)) == 0)\n                    continue;\n                for (i2 = 0; i2 <= 9; i2++) {\n                    number = i0 + i1 * 10 + i2 * 100;\n                    if (\n                        _viewUserTicketAmount(user, _encodeNumber(number, 2)) ==\n                        0\n                    ) continue;\n                    for (i3 = 0; i3 <= 9; i3++) {\n                        number = i0 + i1 * 10 + i2 * 100 + i3 * 1000;\n                        if (\n                            _viewUserTicketAmount(\n                                user,\n                                _encodeNumber(number, 3)\n                            ) == 0\n                        ) continue;\n                        ticketsNumber[amount] = number;\n                        ticketsAmount[amount] = _viewUserTicketAmount(\n                            user,\n                            _encodeNumber(number, 3)\n                        );\n                        ticketsWeight[amount] = _viewUserTicketWeight(\n                            user,\n                            _encodeNumber(number, 3)\n                        );\n                        amount++;\n                        if (amount >= maxAmount)\n                            return (\n                                ticketsNumber,\n                                ticketsAmount,\n                                ticketsWeight,\n                                amount\n                            );\n                    }\n                }\n            }\n        }\n        return (ticketsNumber, ticketsAmount, ticketsWeight, amount);\n    }\n\n    function viewUserRewardsInfo(\n        address user,\n        uint256 _startRound,\n        uint256 _endRound\n    )\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        require(\n            _startRound <= _endRound,\n            \"End lottery smaller than start lottery\"\n        );\n        require(_endRound <= currentLotteryId, \"End lottery round not open\");\n\n        require(\n            lotteries[_endRound].status == Status.Claimable,\n            \"this round of lottery are not ready for claiming\"\n        );\n\n        uint256[] memory lotteryIds = new uint256[](\n            _endRound - _startRound + 1\n        );\n        uint256[] memory userRewards = new uint256[](\n            _endRound - _startRound + 1\n        );\n        uint256[] memory userDrawed = new uint256[](\n            _endRound - _startRound + 1\n        );\n        uint256 userStartLotteryId = checkPoint[user];\n        for (uint256 i = _startRound; i <= _endRound; i++) {\n            lotteryIds[i - _startRound] = i;\n            if (i < userStartLotteryId) {\n                userDrawed[i - _startRound] = 1;\n                userRewards[i - _startRound] = usersRewards[user][i];\n            } else {\n                userDrawed[i - _startRound] = 0;\n                userRewards[i - _startRound] = pendingReward(i, user);\n            }\n        }\n        return (lotteryIds, userRewards, userDrawed);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(\n            _ADMIN_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)\n        );\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation()\n        external\n        ifAdmin\n        returns (address implementation_)\n    {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        ifAdmin\n    {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(\n            msg.sender != _getAdmin(),\n            \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\"\n        );\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.10;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"5c60da1b\"\n        );\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"f851a440\"\n        );\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(\n        TransparentUpgradeableProxy proxy,\n        address newAdmin\n    ) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation)\n        public\n        virtual\n        onlyOwner\n    {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/miserable-flight/interfaces/IFDPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ninterface IFDPolicyToken is IERC721Enumerable {\n    function mintPolicyToken(address _receiver) external;\n\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n\n    function getTokenURI(uint256 _tokenId)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/miserable-flight/PolicyFlow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\nimport \"../proxy/OwnableUpgradeable.sol\";\nimport \"../tokens/interfaces/IBuyerToken.sol\";\nimport \"./interfaces/ISigManager.sol\";\nimport \"./interfaces/IFDPolicyToken.sol\";\nimport \"./interfaces/IFlightOracle.sol\";\nimport \"./interfaces/IInsurancePool.sol\";\nimport \"./interfaces/IPolicyStruct.sol\";\nimport \"./abstracts/PolicyParameters.sol\";\nimport \"../libraries/StringsUtils.sol\";\nimport \"../libraries/StablecoinDecimal.sol\";\n\ncontract PolicyFlow is IPolicyStruct, PolicyParameters, OwnableUpgradeable {\n    using StringsUtils for uint256;\n    using StablecoinDecimal for uint256;\n\n    // Other contracts\n    IBuyerToken public buyerToken;\n    ISigManager public sigManager;\n    IFDPolicyToken public policyToken;\n    IFlightOracle public flightOracle;\n    IInsurancePool public insurancePool;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    string public FLIGHT_STATUS_URL = \"https://degis.io:3207/flight_status?\";\n\n    uint256 public totalPolicies;\n\n    uint256 public fee;\n\n    mapping(uint256 => PolicyInfo) public policyList;\n\n    mapping(address => uint256[]) userPolicyList;\n\n    mapping(bytes32 => uint256) requestList;\n\n    mapping(uint256 => uint256) delayResultList;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event FeeChanged(uint256 newFee);\n    event MaxPayoffChanged(uint256 newMaxPayoff);\n    event MinTimeBeforeDepartureChanged(uint256 newMinTime);\n    event FlightOracleChanged(address newOracle);\n    event OracleUrlChanged(string newUrl);\n    event DelayThresholdChanged(uint256 thresholdMin, uint256 thresholdMax);\n\n    event NewPolicyApplication(uint256 policyId, address indexed user);\n    event NewClaimRequest(\n        uint256 policyId,\n        string flightNumber,\n        bytes32 requestId\n    );\n    event PolicySold(uint256 policyId, address indexed user);\n    event PolicyDeclined(uint256 policyId, address indexed user);\n    event PolicyClaimed(uint256 policyId, address indexed user);\n    event PolicyExpired(uint256 policyId, address indexed user);\n    event FulfilledOracleRequest(uint256 policyId, bytes32 requestId);\n    event PolicyOwnerTransfer(uint256 indexed tokenId, address newOwner);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Initializer ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Initializer of the PolicyFlow contract\n     * @dev Upgradeable contracts do not have a constrcutor\n     * @param _insurancePool The InsurancePool contract address\n     * @param _policyToken The PolicyToken contract address\n     * @param _sigManager The SigManager contract address\n     * @param _buyerToken The BuyerToken contract address\n     */\n    function initialize(\n        address _insurancePool,\n        address _policyToken,\n        address _sigManager,\n        address _buyerToken\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        __PolicyFlow_init(\n            _insurancePool,\n            _policyToken,\n            _sigManager,\n            _buyerToken\n        );\n    }\n\n    function __PolicyFlow_init(\n        address _insurancePool,\n        address _policyToken,\n        address _sigManager,\n        address _buyerToken\n    ) internal onlyInitializing {\n        insurancePool = IInsurancePool(_insurancePool);\n        policyToken = IFDPolicyToken(_policyToken);\n        sigManager = ISigManager(_sigManager);\n        buyerToken = IBuyerToken(_buyerToken);\n\n        // Set the oracle fee\n        fee = 0.1 * 10**18;\n    }\n\n    // ----------------------------------------------------------------------------------- //\n    // ********************************* View Functions ********************************** //\n    // ----------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Show a user's policies (all)\n     * @dev Should only be checked for frontend\n     * @param _user User's address\n     * @return userPolicies User's all policy details\n     */\n    function viewUserPolicy(address _user)\n        external\n        view\n        returns (PolicyInfo[] memory)\n    {\n        uint256 userPolicyAmount = userPolicyList[_user].length;\n        require(userPolicyAmount > 0, \"No policy for this user\");\n\n        PolicyInfo[] memory result = new PolicyInfo[](userPolicyAmount);\n\n        for (uint256 i = 0; i < userPolicyAmount; i++) {\n            uint256 policyId = userPolicyList[_user][i];\n\n            result[i] = policyList[policyId];\n        }\n        return result;\n    }\n\n    /**\n     * @notice Get the policyInfo from its count/order\n     * @param _policyId Total count/order of the policy = NFT tokenId\n     * @return policy A struct of information about this policy\n     */\n    // TODO: If still need this function\n    function getPolicyInfoById(uint256 _policyId)\n        public\n        view\n        returns (PolicyInfo memory policy)\n    {\n        policy = policyList[_policyId];\n    }\n\n    /**\n     * @notice Get the policy buyer by policyId\n     * @param _policyId Unique policy Id (uint256)\n     * @return buyerAddress The buyer of this policy\n     */\n    // TODO: If still need this function\n    function findPolicyBuyerById(uint256 _policyId)\n        public\n        view\n        returns (address buyerAddress)\n    {\n        buyerAddress = policyList[_policyId].buyerAddress;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Change the oracle fee\n     * @param _fee New oracle fee\n     */\n    function setFee(uint256 _fee) external onlyOwner {\n        fee = _fee;\n        emit FeeChanged(_fee);\n    }\n\n    /**\n     * @notice Change the max payoff\n     * @param _newMaxPayoff New maxpayoff amount\n     */\n    function setMaxPayoff(uint256 _newMaxPayoff) external onlyOwner {\n        MAX_PAYOFF = _newMaxPayoff;\n        emit MaxPayoffChanged(_newMaxPayoff);\n    }\n\n    /**\n     * @notice How long before departure when users can not buy new policies\n     * @param _newMinTime New time set\n     */\n    function setMinTimeBeforeDeparture(uint256 _newMinTime) external onlyOwner {\n        MIN_TIME_BEFORE_DEPARTURE = _newMinTime;\n        emit MinTimeBeforeDepartureChanged(_newMinTime);\n    }\n\n    /**\n     * @notice Change the oracle address\n     * @param _oracleAddress New oracle address\n     */\n    function setFlightOracle(address _oracleAddress) external onlyOwner {\n        flightOracle = IFlightOracle(_oracleAddress);\n        emit FlightOracleChanged(_oracleAddress);\n    }\n\n    /**\n     * @notice Set a new url\n     */\n    function setURL(string memory _url) external onlyOwner {\n        FLIGHT_STATUS_URL = _url;\n        emit OracleUrlChanged(_url);\n    }\n\n    /**\n     * @notice Set the new delay threshold used for calculating payoff\n     * @param _thresholdMin New minimum threshold\n     * @param _thresholdMax New maximum threshold\n     */\n    function setDelayThreshold(uint256 _thresholdMin, uint256 _thresholdMax)\n        external\n        onlyOwner\n    {\n        DELAY_THRESHOLD_MIN = _thresholdMin;\n        DELAY_THRESHOLD_MAX = _thresholdMax;\n        emit DelayThresholdChanged(_thresholdMin, _thresholdMax);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Buy a new flight delay policy\n     * @dev The transaction should have the signature from the backend server\n     * @dev Premium is in stablecoin, so it is 6 decimals\n     * @param _productId ID of the purchased product (0: flightdelay; 1,2,3...: others)\n     * @param _flightNumber Flight number in string (e.g. \"AQ1299\")\n     * @param _premium Premium of this policy (decimals: 6)\n     * @param _departureTimestamp Departure date of this flight (unix timestamp in s, not ms!)\n     * @param _landingDate Landing date of this flight (uinx timestamp in s, not ms!)\n     * @param _deadline Deadline for this purchase request\n     * @param signature Use web3.eth.sign(hash(data), account) to generate the signature\n     */\n    function newApplication(\n        uint256 _productId,\n        string memory _flightNumber,\n        uint256 _premium,\n        uint256 _departureTimestamp,\n        uint256 _landingDate,\n        uint256 _deadline,\n        bytes calldata signature\n    ) public returns (uint256 _policyId) {\n        uint256 currentTimestamp = block.timestamp;\n        require(\n            currentTimestamp <= _deadline,\n            \"Expired deadline, please resubmit a transaction\"\n        );\n\n        require(\n            _productId == PRODUCT_ID,\n            \"You are calling the wrong product contract\"\n        );\n\n        require(\n            _departureTimestamp >= currentTimestamp + MIN_TIME_BEFORE_DEPARTURE,\n            \"It's too close to the departure time, you cannot buy this policy\"\n        );\n\n        // Should be signed by operators\n        _checkSignature(\n            signature,\n            _flightNumber,\n            _departureTimestamp,\n            _landingDate,\n            _msgSender(),\n            _premium,\n            _deadline\n        );\n\n        // Generate the policy\n        // Use ++totalPolicies to keep the policyId the same as ERC721 tokenId\n        // Policy Id starts from 1\n        uint256 currentPolicyId = ++totalPolicies;\n\n        policyList[currentPolicyId] = PolicyInfo(\n            PRODUCT_ID,\n            _msgSender(),\n            currentPolicyId,\n            _flightNumber,\n            _premium,\n            MAX_PAYOFF,\n            currentTimestamp,\n            _departureTimestamp,\n            _landingDate,\n            PolicyStatus.INI,\n            false,\n            404\n        );\n\n        // Check the policy with the insurance pool status\n        // May be accepted or rejected, if accepted then update the status of insurancePool\n        _policyCheck(_premium, MAX_PAYOFF, msg.sender, currentPolicyId);\n\n        // Give buyer tokens depending on the usd value they spent\n        buyerToken.mintBuyerToken(msg.sender, _premium.toNormal());\n\n        // Store the policy's total order with userAddress\n        userPolicyList[msg.sender].push(totalPolicies);\n\n        emit NewPolicyApplication(currentPolicyId, msg.sender);\n\n        return currentPolicyId;\n    }\n\n    /**\n     * @notice Make a claim request\n     * @dev Anyone can make a new claim\n     * @param _policyId The total order/id of the policy\n     * @param _flightNumber The flight number\n     * @param _timestamp The flight departure timestamp\n     * @param _path Which data in json needs to get\n     * @param _forceUpdate Owner can force to update\n     */\n    function newClaimRequest(\n        uint256 _policyId,\n        string memory _flightNumber,\n        string memory _timestamp,\n        string memory _path,\n        bool _forceUpdate\n    ) public {\n        PolicyInfo memory policy = policyList[_policyId];\n\n        // Can not get the result before landing date\n        // Landing date may not be true, may be a fixed interval (4hours)\n        require(\n            block.timestamp >= policy.landingTimestamp,\n            \"Can only claim a policy after its expected landing timestamp\"\n        );\n\n        // Check if the policy has been settled\n        require(\n            (!policy.alreadySettled) ||\n                (_forceUpdate && (_msgSender() == owner())),\n            \"Already settled\"\n        );\n\n        // Check if the flight number is correct\n        require(\n            keccak256(abi.encodePacked(_flightNumber)) ==\n                keccak256(abi.encodePacked(policy.flightNumber)),\n            \"Wrong flight number provided\"\n        );\n\n        // Check if the departure date is correct\n        require(\n            keccak256(abi.encodePacked(_timestamp)) ==\n                keccak256(\n                    abi.encodePacked(policy.departureTimestamp.uintToString())\n                ),\n            \"Wrong departure timestamp provided\"\n        );\n\n        // Construct the url for oracle\n        string memory _url = string(\n            abi.encodePacked(\n                FLIGHT_STATUS_URL,\n                \"flight_no=\",\n                _flightNumber,\n                \"&timestamp=\",\n                _timestamp\n            )\n        );\n\n        // Start a new oracle request\n        bytes32 requestId = flightOracle.newOracleRequest(fee, _url, _path, 1);\n\n        // Record this request\n        requestList[requestId] = _policyId;\n        policyList[_policyId].alreadySettled = true;\n\n        emit NewClaimRequest(_policyId, _flightNumber, requestId);\n    }\n\n    /**\n     * @notice Update information when a policy token's ownership has been transferred\n     * @dev This function is called by the ERC721 contract of PolicyToken\n     * @param _tokenId Token Id of the policy token\n     * @param _oldOwner The initial owner\n     * @param _newOwner The new owner\n     */\n    function policyOwnerTransfer(\n        uint256 _tokenId,\n        address _oldOwner,\n        address _newOwner\n    ) external {\n        // Check the call is from policy token contract\n        require(\n            _msgSender() == address(policyToken),\n            \"only called from the flight delay policy token contract\"\n        );\n\n        // Check the previous owner record\n        uint256 policyId = _tokenId;\n        require(\n            _oldOwner == policyList[policyId].buyerAddress,\n            \"The previous owner is wrong\"\n        );\n\n        // Update the new buyer address\n        policyList[policyId].buyerAddress = _newOwner;\n        emit PolicyOwnerTransfer(_tokenId, _newOwner);\n    }\n\n    // ----------------------------------------------------------------------------------- //\n    // ********************************* Oracle Functions ******************************** //\n    // ----------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Do the final settlement, called by FlightOracle contract\n     * @param _requestId Chainlink request id\n     * @param _result Delay result (minutes) given by oracle\n     */\n    function finalSettlement(bytes32 _requestId, uint256 _result) public {\n        // Check if the call is from flight oracle\n        require(\n            msg.sender == address(flightOracle),\n            \"this function should be called by FlightOracle contract\"\n        );\n\n        uint256 policyId = requestList[_requestId];\n\n        PolicyInfo storage policy = policyList[policyId];\n        policy.delayResult = _result;\n\n        uint256 premium = policy.premium;\n        address buyerAddress = policy.buyerAddress;\n\n        require(\n            _result <= DELAY_THRESHOLD_MAX || _result == 400,\n            \"Abnormal oracle result, result should be [0 - 240] or 400\"\n        );\n\n        if (_result == 0) {\n            // 0: on time\n            _policyExpired(premium, MAX_PAYOFF, buyerAddress, policyId);\n        } else if (_result <= DELAY_THRESHOLD_MAX) {\n            uint256 real_payoff = calcPayoff(_result);\n            _policyClaimed(premium, real_payoff, buyerAddress, policyId);\n        } else if (_result == 400) {\n            // 400: cancelled\n            _policyClaimed(premium, MAX_PAYOFF, buyerAddress, policyId);\n        }\n\n        emit FulfilledOracleRequest(policyId, _requestId);\n    }\n\n    // ----------------------------------------------------------------------------------- //\n    // ******************************** Internal Functions ******************************* //\n    // ----------------------------------------------------------------------------------- //\n\n    /**\n     * @notice check the policy and then determine whether we can afford it\n     * @param _payoff the payoff of the policy sold\n     * @param _user user's address\n     * @param _policyId the unique policy ID\n     */\n    function _policyCheck(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user,\n        uint256 _policyId\n    ) internal {\n        // Whether there are enough capacity in the pool\n        bool _isAccepted = insurancePool.checkCapacity(_payoff);\n\n        if (_isAccepted) {\n            insurancePool.updateWhenBuy(_premium, _payoff, _user);\n            policyList[_policyId].status = PolicyStatus.SOLD;\n            emit PolicySold(_policyId, _user);\n\n            policyToken.mintPolicyToken(_user);\n        } else {\n            emit PolicyDeclined(_policyId, _user);\n            revert(\"not sufficient capacity in the insurance pool\");\n        }\n    }\n\n    /**\n     * @notice update the policy when it is expired\n     * @param _premium the premium of the policy sold\n     * @param _payoff the payoff of the policy sold\n     * @param _user user's address\n     * @param _policyId the unique policy ID\n     */\n    function _policyExpired(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user,\n        uint256 _policyId\n    ) internal {\n        insurancePool.updateWhenExpire(_premium, _payoff);\n        policyList[_policyId].status = PolicyStatus.EXPIRED;\n        emit PolicyExpired(_policyId, _user);\n    }\n\n    /**\n     * @notice Update the policy when it is claimed\n     * @param _premium Premium of the policy sold\n     * @param _payoff Payoff of the policy sold\n     * @param _user User's address\n     * @param _policyId The unique policy ID\n     */\n    function _policyClaimed(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user,\n        uint256 _policyId\n    ) internal {\n        insurancePool.payClaim(_premium, MAX_PAYOFF, _payoff, _user);\n        policyList[_policyId].status = PolicyStatus.CLAIMED;\n        emit PolicyClaimed(_policyId, _user);\n    }\n\n    /**\n     * @notice The payoff formula\n     * @param _delay Delay in minutes\n     * @return the final payoff volume\n     */\n    function calcPayoff(uint256 _delay) internal view returns (uint256) {\n        uint256 payoff = 0;\n\n        // payoff model 1 - linear\n        if (_delay <= DELAY_THRESHOLD_MIN) {\n            payoff = 0;\n        } else if (\n            _delay > DELAY_THRESHOLD_MIN && _delay <= DELAY_THRESHOLD_MAX\n        ) {\n            payoff = (_delay * _delay) / 480;\n        } else if (_delay > DELAY_THRESHOLD_MAX) {\n            payoff = MAX_PAYOFF;\n        }\n\n        payoff = payoff * 1e6;\n        return payoff;\n    }\n\n    /**\n     * @notice Check whether the signature is valid\n     * @param signature 65 byte array: [[v (1)], [r (32)], [s (32)]]\n     * @param _flightNumber Flight number\n     * @param _address userAddress\n     * @param _premium Premium of the policy\n     * @param _deadline Deadline of the application\n     */\n    function _checkSignature(\n        bytes calldata signature,\n        string memory _flightNumber,\n        uint256 _departureTimestamp,\n        uint256 _landingDate,\n        address _address,\n        uint256 _premium,\n        uint256 _deadline\n    ) internal view {\n        sigManager.checkSignature(\n            signature,\n            _flightNumber,\n            _departureTimestamp,\n            _landingDate,\n            _address,\n            _premium,\n            _deadline\n        );\n    }\n}\n"
    },
    "contracts/proxy/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init(address _initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(_initialOwner);\n    }\n\n    function __Ownable_init_unchained(address _initialOwner) internal onlyInitializing {\n        _transferOwnership( _initialOwner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/interfaces/IBuyerToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBuyerToken is IERC20 {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Functions ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintBuyerToken(address _account, uint256 _amount) external;\n\n    /**\n     * @notice Burn buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnBuyerToken(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/miserable-flight/interfaces/ISigManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface ISigManager {\n    event SignerAdded(address indexed _newSigner);\n    event SignerRemoved(address indexed _oldSigner);\n\n    function addSigner(address) external;\n\n    function removeSigner(address) external;\n\n    function isValidSigner(address) external view returns (bool);\n\n    function checkSignature(\n        bytes calldata signature,\n        string memory _flightNumber,\n        uint256 _departureTimestamp,\n        uint256 _landingDate,\n        address _address,\n        uint256 _premium,\n        uint256 _deadline\n    ) external view;\n}\n"
    },
    "contracts/miserable-flight/interfaces/IFlightOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IFlightOracle {\n    function newOracleRequest(\n        uint256 _payment,\n        string memory _url,\n        string memory _path,\n        int256 times\n    ) external returns (bytes32);\n\n    // Set a new url\n    function setURL(string memory _url) external;\n\n    // Set the oracle address\n    function setOracleAddress(address _newOracle) external;\n\n    // Set a new job id\n    function setJobId(bytes32 _newJobId) external;\n\n    // Set a new policy flow\n    function setPolicyFlow(address _policyFlow) external;\n\n    function getChainlinkTokenAddress() external view returns (address);\n}\n"
    },
    "contracts/miserable-flight/interfaces/IInsurancePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IInsurancePool {\n    // view functions\n\n    function getUserBalance(address) external view returns (uint256);\n\n    function getPoolUnlocked() external view returns (uint256);\n\n    function getUnlockedFor(address _user) external view returns (uint256);\n\n    function getLockedFor(address _user) external view returns (uint256);\n\n    function checkCapacity(uint256 _payoff) external view returns (bool);\n\n    // set functions\n\n    function setPurchaseIncentive(uint256 _newIncentive) external;\n\n    function setFrozenTime(uint256 _newFrozenTime) external;\n\n    function setPolicyFlow(address _policyFlowAddress) external;\n\n    function setIncomeDistribution(uint256[3] memory _newDistribution) external;\n\n    function setCollateralFactor(uint256 _factor) external;\n\n    function transferOwnership(address _newOwner) external;\n\n    // main functions\n\n    function stake(address _user, uint256 _amount) external;\n\n    function unstake(uint256 _amount) external;\n\n    function unstakeMax() external;\n\n    function updateWhenBuy(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user\n    ) external;\n\n    function updateWhenExpire(uint256 _premium, uint256 _payoff) external;\n\n    function payClaim(\n        uint256 _premium,\n        uint256 _payoff,\n        uint256 _realPayoff,\n        address _user\n    ) external;\n\n    function revertUnstakeRequest(address _user) external;\n\n    function revertAllUnstakeRequest(address _user) external;\n}\n"
    },
    "contracts/miserable-flight/abstracts/PolicyParameters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nabstract contract PolicyParameters {\n    // Product parameter\n    uint256 public constant PRODUCT_ID = 0;\n\n    // Parameters about the claim curve\n    uint256 public MAX_PAYOFF = 180 * 10**6;\n    uint256 public DELAY_THRESHOLD_MIN = 30;\n    uint256 public DELAY_THRESHOLD_MAX = 240;\n\n    // Minimum time before departure for applying\n    uint256 public MIN_TIME_BEFORE_DEPARTURE = 24 hours;\n}\n"
    },
    "contracts/libraries/StablecoinDecimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary StablecoinDecimal {\n    function toNormal(uint256 _value) internal pure returns (uint256) {\n        uint256 decimal_difference = 1e12;\n        return _value / decimal_difference;\n    }\n\n    function toStablecoin(uint256 _value) internal pure returns (uint256) {\n        uint256 decimal_difference = 1e12;\n        return _value * decimal_difference;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/naughty-price/PolicyCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {StringsUtils} from \"../libraries/StringsUtils.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Decimals} from \"../utils/interfaces/IERC20Decimals.sol\";\nimport {IPriceGetter} from \"./interfaces/IPriceGetter.sol\";\nimport {INaughtyFactory} from \"./interfaces/INaughtyFactory.sol\";\nimport {INPPolicyToken} from \"./interfaces/INPPolicyToken.sol\";\n\n/**\n * @title  PolicyCore\n * @notice Core logic of Naughty Price Product\n *         Preset:\n *              (Done in the naughtyFactory contract)\n *              1. Deploy policyToken contract\n *              2. Deploy policyToken-Stablecoin pool contract\n *         User Interaction:\n *              1. Deposit Stablecoin and mint PolicyTokens\n *              2. Redeem their Stablecoin and burn the PolicyTokens (before settlement)\n *              3. Claim for payout with PolicyTokens (after settlement)\n *         PolicyTokens are minted with the ratio 1:1 to Stablecoin\n *         The PolicyTokens are traded in the pool with CFMM (xy=k)\n *         When the event happens, a PolicyToken can be burned for claiming 1 Stablecoin.\n *         When the event does not happen, the PolicyToken depositors can\n *         redeem their 1 deposited Stablecoin\n *\n * @dev    Most of the functions to be called from outside will use the name of policyToken\n *         rather than the address (easy to read).\n *         Other variables or functions still use address to index.\n *         The rule of policyToken naming is:\n *              Original Token Name(with decimals) + Strike Price + Lower or Higher + Date\n *         E.g.  AVAX_30.0_L_2101, BTC_30000.0_L_2102, ETH_8000.0_H_2109\n *         (the original name need to be the same as in the chainlink oracle)\n *         There are three decimals for a policy token:\n *              1. Name decimals: Only for generating the name of policyToken\n *              2. Token decimals: The decimals of the policyToken\n *                 (should be the same as the paired stablecoin)\n *              3. Price decimals: Always 18. The oracle result will be transferred for settlement\n */\n\ncontract PolicyCore is OwnableUpgradeable {\n    using StringsUtils for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Factory contract, responsible for deploying new contracts\n    INaughtyFactory public factory;\n\n    // Oracle contract, responsible for getting the final price\n    IPriceGetter public priceGetter;\n\n    // Lottery address\n    address public lottery;\n\n    // Income sharing contract address\n    address public incomeSharing;\n\n    // Naughty Router contract address\n    address public naughtyRouter;\n\n    // Contract for initial liquidity matching\n    address public ILMContract;\n\n    // Income to lottery ratio (max 10)\n    uint256 public toLotteryPart;\n\n    struct PolicyTokenInfo {\n        address policyTokenAddress;\n        bool isCall;\n        uint256 nameDecimals; // decimals of the name generation\n        uint256 tokenDecimals; // decimals of the policy token\n        uint256 strikePrice;\n        uint256 deadline;\n        uint256 settleTimestamp;\n    }\n    // Policy token name => Policy token information\n    mapping(string => PolicyTokenInfo) public policyTokenInfoMapping;\n\n    // Policy token address => Policy token name\n    mapping(address => string) public policyTokenAddressToName;\n\n    // Policy token name list\n    string[] public allPolicyTokens;\n\n    // Stablecoin address => Supported or not\n    mapping(address => bool) public supportedStablecoin;\n\n    // Policy token address => Stablecoin address\n    mapping(address => address) public whichStablecoin;\n\n    // PolicyToken => Strike Token (e.g. AVAX30L202101 address => AVAX address)\n    mapping(address => string) policyTokenToOriginal;\n\n    // User Address => Token Address => User Quota Amount\n    mapping(address => mapping(address => uint256)) userQuota;\n\n    // Policy token address => All the depositors for this round\n    // (store all the depositors in an array)\n    mapping(address => address[]) public allDepositors;\n\n    struct SettlementInfo {\n        uint256 price;\n        bool isHappened;\n        bool alreadySettled;\n        uint256 currentDistributionIndex;\n    }\n    // Policy token address => Settlement result information\n    mapping(address => SettlementInfo) public settleResult;\n\n    mapping(address => uint256) public pendingIncomeToLottery;\n    mapping(address => uint256) public pendingIncomeToSharing;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Events ******************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event LotteryChanged(address oldLotteryAddress, address newLotteryAddress);\n    event IncomeSharingChanged(\n        address oldIncomeSharing,\n        address newIncomeSharing\n    );\n    event NaughtyRouterChanged(address oldRouter, address newRouter);\n    event ILMChanged(address oldILM, address newILM);\n    event IncomeToLotteryChanged(uint256 oldToLottery, uint256 newToLottery);\n    event PolicyTokenDeployed(\n        string tokenName,\n        address tokenAddress,\n        uint256 tokenDecimals,\n        uint256 deadline,\n        uint256 settleTimestamp\n    );\n    event PoolDeployed(\n        address poolAddress,\n        address policyTokenAddress,\n        address stablecoin\n    );\n    event PoolDeployedWithInitialLiquidity(\n        address poolAddress,\n        address policyTokenAddress,\n        address stablecoin,\n        uint256 initLiquidityA,\n        uint256 initLiquidityB\n    );\n    event Deposit(\n        address userAddress,\n        string policyTokenName,\n        address stablecoin,\n        uint256 amount\n    );\n    event DelegateDeposit(\n        address payerAddress,\n        address userAddress,\n        string policyTokenName,\n        address stablecoin,\n        uint256 amount\n    );\n    event Redeem(\n        address userAddress,\n        string policyTokenName,\n        address stablecoin,\n        uint256 amount\n    );\n    event RedeemAfterSettlement(\n        address userAddress,\n        string policyTokenName,\n        address stablecoin,\n        uint256 amount\n    );\n    event FinalResultSettled(\n        string _policyTokenName,\n        uint256 price,\n        bool isHappened\n    );\n    event NewStablecoinAdded(address _newStablecoin);\n    event PolicyTokensSettledForUsers(\n        string policyTokenName,\n        address stablecoin,\n        uint256 startIndex,\n        uint256 stopIndex\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor, for some addresses\n     * @param _usdc USDC.e is the first stablecoin supported in the pool\n     * @param _factory Address of naughty factory\n     * @param _priceGetter Address of the oracle contract\n     */\n    function initialize(\n        address _usdc,\n        address _factory,\n        address _priceGetter\n    ) public initializer {\n        __Ownable_init();\n\n        // Add the first stablecoin supported\n        supportedStablecoin[_usdc] = true;\n\n        // Initialize the interfaces\n        factory = INaughtyFactory(_factory);\n        priceGetter = IPriceGetter(_priceGetter);\n\n        // 20% to lottery, 80% to income sharing\n        toLotteryPart = 2;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if this stablecoin is supported\n     * @param _stablecoin Stablecoin address\n     */\n    modifier validStablecoin(address _stablecoin) {\n        require(\n            supportedStablecoin[_stablecoin] == true,\n            \"Do not support this stablecoin currently\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Check whether the policy token is paired with this stablecoin\n     * @param _policyTokenName Policy token name\n     * @param _stablecoin Stablecoin address\n     */\n    modifier validPolicyTokenWithStablecoin(\n        string memory _policyTokenName,\n        address _stablecoin\n    ) {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n        require(\n            whichStablecoin[policyTokenAddress] == _stablecoin,\n            \"Invalid policytoken with stablecoin\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Check if the policy token has been deployed, used when deploying pools\n     * @param _policyTokenName Name of the policy token inside the pair\n     */\n    modifier deployedPolicy(string memory _policyTokenName) {\n        require(\n            policyTokenInfoMapping[_policyTokenName].policyTokenAddress !=\n                address(0),\n            \"This policy token has not been deployed, please deploy it first\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Deposit/Redeem/Swap only before deadline\n     * @dev Each pool will also have this deadline\n     *      That needs to be set inside naughtyFactory\n     * @param _policyTokenName Name of the policy token\n     */\n    modifier beforeDeadline(string memory _policyTokenName) {\n        uint256 deadline = policyTokenInfoMapping[_policyTokenName].deadline;\n        require(\n            block.timestamp <= deadline,\n            \"Can not deposit/redeem, has passed the deadline\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Can only settle the result after the \"_settleTimestamp\"\n     * @param _policyTokenName Name of the policy token\n     */\n    modifier afterSettlement(string memory _policyTokenName) {\n        uint256 settleTimestamp = policyTokenInfoMapping[_policyTokenName]\n            .settleTimestamp;\n        require(\n            block.timestamp >= settleTimestamp,\n            \"Can not settle/claim, have not reached settleTimestamp\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Avoid multiple settlements\n     * @param _policyTokenName Name of the policy token\n     */\n    modifier notAlreadySettled(string memory _policyTokenName) {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n        require(\n            settleResult[policyTokenAddress].alreadySettled == false,\n            \"This policy has already been settled\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Find the token address by its name\n     * @param _policyTokenName Name of the policy token (e.g. \"AVAX_30_L_2103\")\n     * @return policyTokenAddress Address of the policy token\n     */\n    function findAddressbyName(string memory _policyTokenName)\n        public\n        view\n        returns (address policyTokenAddress)\n    {\n        policyTokenAddress = policyTokenInfoMapping[_policyTokenName]\n            .policyTokenAddress;\n\n        require(policyTokenAddress != address(0), \"Policy token not found\");\n    }\n\n    /**\n     * @notice Find the token name by its address\n     * @param _policyTokenAddress Address of the policy token\n     * @return policyTokenName Name of the policy token\n     */\n    function findNamebyAddress(address _policyTokenAddress)\n        public\n        view\n        returns (string memory policyTokenName)\n    {\n        policyTokenName = policyTokenAddressToName[_policyTokenAddress];\n\n        require(bytes(policyTokenName).length > 0, \"Policy name not found\");\n    }\n\n    /**\n     * @notice Find the token information by its name\n     * @param _policyTokenName Name of the policy token (e.g. \"AVAX30L202103\")\n     * @return policyTokenInfo PolicyToken detail information\n     */\n    function getPolicyTokenInfo(string memory _policyTokenName)\n        public\n        view\n        returns (PolicyTokenInfo memory)\n    {\n        return policyTokenInfoMapping[_policyTokenName];\n    }\n\n    /**\n     * @notice Get a user's quota for a certain policy token\n     * @param _user Address of the user to be checked\n     * @param _policyTokenAddress Address of the policy token\n     * @return _quota User's quota result\n     */\n    function getUserQuota(address _user, address _policyTokenAddress)\n        external\n        view\n        returns (uint256 _quota)\n    {\n        _quota = userQuota[_user][_policyTokenAddress];\n    }\n\n    /**\n     * @notice Get the information about all the tokens\n     * @dev Include all active&expired tokens\n     * @return tokensInfo Token information list\n     */\n    function getAllTokens() external view returns (PolicyTokenInfo[] memory) {\n        uint256 length = allPolicyTokens.length;\n        PolicyTokenInfo[] memory tokensInfo = new PolicyTokenInfo[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            tokensInfo[i] = policyTokenInfoMapping[allPolicyTokens[i]];\n        }\n\n        return tokensInfo;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new supported stablecoin\n     * @param _newStablecoin Address of the new stablecoin\n     */\n    function addStablecoin(address _newStablecoin) external onlyOwner {\n        supportedStablecoin[_newStablecoin] = true;\n        emit NewStablecoinAdded(_newStablecoin);\n    }\n\n    /**\n     * @notice Change the address of lottery\n     * @param _lotteryAddress Address of the new lottery\n     */\n    function setLottery(address _lotteryAddress) external onlyOwner {\n        emit LotteryChanged(lottery, _lotteryAddress);\n        lottery = _lotteryAddress;\n    }\n\n    /**\n     * @notice Change the address of emergency pool\n     * @param _incomeSharing Address of the new incomeSharing\n     */\n    function setIncomeSharing(address _incomeSharing) external onlyOwner {\n        emit IncomeSharingChanged(incomeSharing, _incomeSharing);\n        incomeSharing = _incomeSharing;\n    }\n\n    /**\n     * @notice Change the address of naughty router\n     * @param _router Address of the new naughty router\n     */\n    function setNaughtyRouter(address _router) external onlyOwner {\n        emit NaughtyRouterChanged(naughtyRouter, _router);\n        naughtyRouter = _router;\n    }\n\n    /**\n     * @notice Change the address of ILM\n     * @param _ILM Address of the new ILM\n     */\n    function setILMContract(address _ILM) external onlyOwner {\n        emit ILMChanged(ILMContract, _ILM);\n        ILMContract = _ILM;\n    }\n\n    /**\n     * @notice Change the income part to lottery\n     * @dev The remaining part will be distributed to incomeSharing\n     * @param _toLottery Proportion to lottery\n     */\n    function setIncomeToLottery(uint256 _toLottery) external onlyOwner {\n        require(_toLottery <= 10, \"Max 10\");\n        emit IncomeToLotteryChanged(toLotteryPart, _toLottery);\n        toLotteryPart = _toLottery;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy a new policy token and return the token address\n     * @dev Only the owner can deploy new policy token\n     *      The name form is like \"AVAX_50_L_2203\" and is built inside the contract.\n     * @param _tokenName Name of the original token (e.g. AVAX, BTC, ETH...)\n     * @param _stablecoin Address of the stablecoin (Just for check decimals here)\n     * @param _isCall The policy is for higher or lower than the strike price (call / put)\n     * @param _nameDecimals Decimals of this token's name (0~18)\n     * @param _tokenDecimals Decimals of this token's value (0~18) (same as paired stablecoin)\n     * @param _strikePrice Strike price of the policy (have already been transferred with 1e18)\n     * @param _round Round of the token (e.g. 2203 -> expired at 22 March)\n     * @param _deadline Deadline of this policy token (deposit / redeem / swap)\n     * @param _settleTimestamp Can settle after this timestamp (for oracle)\n     */\n    function deployPolicyToken(\n        string memory _tokenName,\n        address _stablecoin,\n        bool _isCall,\n        uint256 _nameDecimals,\n        uint256 _tokenDecimals,\n        uint256 _strikePrice,\n        string memory _round,\n        uint256 _deadline,\n        uint256 _settleTimestamp\n    ) external onlyOwner {\n        require(\n            _nameDecimals <= 18 && _tokenDecimals <= 18,\n            \"Too many decimals\"\n        );\n        require(\n            IERC20Decimals(_stablecoin).decimals() == _tokenDecimals,\n            \"Decimals not paired\"\n        );\n\n        require(_deadline > block.timestamp, \"Wrong deadline\");\n        require(_settleTimestamp >= _deadline, \"Wrong settleTimestamp\");\n\n        // Generate the policy token name\n        string memory policyTokenName = _generateName(\n            _tokenName,\n            _nameDecimals,\n            _strikePrice,\n            _isCall,\n            _round\n        );\n        // Deploy a new policy token by the factory contract\n        address policyTokenAddress = factory.deployPolicyToken(\n            policyTokenName,\n            _tokenDecimals\n        );\n\n        // Store the policyToken information in the mapping\n        policyTokenInfoMapping[policyTokenName] = PolicyTokenInfo(\n            policyTokenAddress,\n            _isCall,\n            _nameDecimals,\n            _tokenDecimals,\n            _strikePrice,\n            _deadline,\n            _settleTimestamp\n        );\n\n        // Keep the record from policy token to original token\n        policyTokenToOriginal[policyTokenAddress] = _tokenName;\n\n        // Record the address to name mapping\n        policyTokenAddressToName[policyTokenAddress] = policyTokenName;\n\n        // Push the policytokenName into the list\n        allPolicyTokens.push(policyTokenName);\n\n        emit PolicyTokenDeployed(\n            policyTokenName,\n            policyTokenAddress,\n            _tokenDecimals,\n            _deadline,\n            _settleTimestamp\n        );\n    }\n\n    /**\n     * @notice Deploy a new pair (pool)\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the stable coin\n     * @param _poolDeadline Swapping deadline of the pool (normally the same as the token's deadline)\n     * @param _feeRate Fee rate given to LP holders\n     */\n    function deployPool(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _poolDeadline,\n        uint256 _feeRate\n    )\n        external\n        validStablecoin(_stablecoin)\n        deployedPolicy(_policyTokenName)\n        returns (address)\n    {\n        require(\n            msg.sender == owner() || msg.sender == ILMContract,\n            \"Only owner or ILM\"\n        );\n\n        require(_poolDeadline > block.timestamp, \"Wrong deadline\");\n        require(\n            _poolDeadline == policyTokenInfoMapping[_policyTokenName].deadline,\n            \"Policy token and pool deadline not the same\"\n        );\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        address poolAddress = _deployPool(\n            policyTokenAddress,\n            _stablecoin,\n            _poolDeadline,\n            _feeRate\n        );\n\n        emit PoolDeployed(poolAddress, policyTokenAddress, _stablecoin);\n\n        return poolAddress;\n    }\n\n    /**\n     * @notice Deposit stablecoins and get policy tokens\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the stable coin\n     * @param _amount Amount of stablecoin\n     */\n    function deposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    )\n        public\n        beforeDeadline(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        require(_amount > 0, \"Zero Amount\");\n        _deposit(_policyTokenName, _stablecoin, _amount, msg.sender);\n    }\n\n    /**\n     * @notice Delegate deposit (deposit and mint for other addresses)\n     * @dev Only called by the router contract\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the sable coin\n     * @param _amount Amount of stablecoin\n     * @param _user Address to receive the policy tokens\n     */\n    function delegateDeposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    )\n        external\n        beforeDeadline(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        require(\n            msg.sender == naughtyRouter,\n            \"Only the router contract can delegate\"\n        );\n        require(_amount > 0, \"Zero Amount\");\n\n        _deposit(_policyTokenName, _stablecoin, _amount, _user);\n\n        emit DelegateDeposit(\n            msg.sender,\n            _user,\n            _policyTokenName,\n            _stablecoin,\n            _amount\n        );\n    }\n\n    /**\n     * @notice Burn policy tokens and redeem stablecoins\n     * @dev Redeem happens before the deadline and is different from claim/settle\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the stablecoin\n     * @param _amount Amount to redeem\n     */\n    function redeem(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    )\n        public\n        beforeDeadline(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Check if the user has enough quota (quota is only for those who mint policy tokens)\n        require(\n            userQuota[msg.sender][policyTokenAddress] >= _amount,\n            \"User's quota not sufficient\"\n        );\n\n        // Update quota\n        userQuota[msg.sender][policyTokenAddress] -= _amount;\n\n        // Charge 1% Fee when redeem / claim\n        uint256 amountWithFee = _chargeFee(_stablecoin, _amount);\n\n        // Transfer back the stablecoin\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\n\n        // Burn the policy tokens\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\n        policyToken.burn(msg.sender, _amount);\n\n        emit Redeem(msg.sender, _policyTokenName, _stablecoin, _amount);\n    }\n\n    /**\n     * @notice Redeem policy tokens and get stablecoins by the user himeself\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the stablecoin\n     */\n    function redeemAfterSettlement(\n        string memory _policyTokenName,\n        address _stablecoin\n    )\n        public\n        afterSettlement(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Copy to memory (will not change the result)\n        SettlementInfo memory result = settleResult[policyTokenAddress];\n\n        // Must have got the final price\n        require(\n            result.price != 0 && result.alreadySettled,\n            \"Have not got the oracle result\"\n        );\n\n        // The event must be \"not happend\"\n        require(\n            result.isHappened == false,\n            \"Only call this function when the event does not happen\"\n        );\n\n        uint256 quota = userQuota[msg.sender][policyTokenAddress];\n        // User must have quota because this is for depositors when event not happens\n        require(\n            quota > 0,\n            \"No quota, you did not deposit and mint policy tokens before\"\n        );\n\n        // Charge 1% Fee when redeem / claim\n        uint256 amountWithFee = _chargeFee(_stablecoin, quota);\n\n        // Send back stablecoins directly\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\n\n        // Delete the userQuota storage\n        delete userQuota[msg.sender][policyTokenAddress];\n\n        emit RedeemAfterSettlement(\n            msg.sender,\n            _policyTokenName,\n            _stablecoin,\n            amountWithFee\n        );\n    }\n\n    /**\n     * @notice Claim a payoff based on policy tokens\n     * @dev It is done after result settlement and only if the result is true\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the stable coin\n     * @param _amount Amount of stablecoin\n     */\n    function claim(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    )\n        public\n        afterSettlement(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Copy to memory (will not change the result)\n        SettlementInfo memory result = settleResult[policyTokenAddress];\n\n        // Check if we have already settle the final price\n        require(\n            result.price != 0 && result.alreadySettled,\n            \"Have not got the oracle result\"\n        );\n\n        // Check if the event happens\n        require(\n            result.isHappened,\n            \"The result does not happen, you can not claim\"\n        );\n\n        // Charge 1% fee\n        uint256 amountWithFee = _chargeFee(_stablecoin, _amount);\n\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\n\n        // Users must have enough policy tokens to claim\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\n\n        // Burn the policy tokens\n        policyToken.burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Get the final price from the PriceGetter contract\n     * @param _policyTokenName Name of the policy token\n     */\n    function settleFinalResult(string memory _policyTokenName)\n        public\n        afterSettlement(_policyTokenName)\n        notAlreadySettled(_policyTokenName)\n    {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        SettlementInfo storage result = settleResult[policyTokenAddress];\n\n        // Get the strike token name\n        string memory originalTokenName = policyTokenToOriginal[\n            policyTokenAddress\n        ];\n\n        // Get the final price from oracle\n        uint256 price = priceGetter.getLatestPrice(originalTokenName);\n\n        // Record the price\n        result.alreadySettled = true;\n        result.price = price;\n\n        PolicyTokenInfo memory policyTokenInfo = policyTokenInfoMapping[\n            _policyTokenName\n        ];\n\n        // Get the final result\n        bool situationT1 = (price >= policyTokenInfo.strikePrice) &&\n            policyTokenInfo.isCall;\n        bool situationT2 = (price <= policyTokenInfo.strikePrice) &&\n            !policyTokenInfo.isCall;\n\n        bool isHappened = (situationT1 || situationT2) ? true : false;\n\n        // Record the result\n        result.isHappened = isHappened;\n\n        emit FinalResultSettled(_policyTokenName, price, isHappened);\n    }\n\n    /**\n     * @notice Settle the policies for the users when insurance events do not happen\n     *         Funds are automatically distributed back to the depositors\n     * @dev    Take care of the gas cost and can use the _startIndex and _stopIndex to control the size\n     * @param _policyTokenName Name of policy token\n     * @param _stablecoin Address of stablecoin\n     * @param _startIndex Settlement start index\n     * @param _stopIndex Settlement stop index\n     */\n    function settleAllPolicyTokens(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _startIndex,\n        uint256 _stopIndex\n    ) public onlyOwner {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Copy to memory (will not change the result)\n        SettlementInfo memory result = settleResult[policyTokenAddress];\n\n        // Must have got the final price\n        require(\n            result.price != 0 && result.alreadySettled == true,\n            \"Have not got the oracle result\"\n        );\n\n        // The event must be \"not happend\"\n        require(\n            result.isHappened == false,\n            \"Only call this function when the event does not happen\"\n        );\n\n        // Store the amount to collect to lottery and emergency pool\n        uint256 amountToCollect = 0;\n\n        // Length of all depositors for this policy token\n        uint256 length = allDepositors[policyTokenAddress].length;\n\n        require(\n            result.currentDistributionIndex <= length,\n            \"Have distributed all\"\n        );\n\n        // Settle the policies in [_startIndex, _stopIndex)\n        if (_startIndex == 0 && _stopIndex == 0) {\n            amountToCollect += _settlePolicy(\n                policyTokenAddress,\n                _stablecoin,\n                0,\n                length\n            );\n\n            // Update the distribution index for this policy token\n            settleResult[policyTokenAddress].currentDistributionIndex = length;\n\n            emit PolicyTokensSettledForUsers(\n                _policyTokenName,\n                _stablecoin,\n                0,\n                length\n            );\n        } else {\n            require(\n                result.currentDistributionIndex == _startIndex,\n                \"You need to start from the last distribution point\"\n            );\n            require(_stopIndex < length, \"Invalid stop index\");\n\n            amountToCollect += _settlePolicy(\n                policyTokenAddress,\n                _stablecoin,\n                _startIndex,\n                _stopIndex\n            );\n\n            // Update the distribution index for this policy token\n            settleResult[policyTokenAddress]\n                .currentDistributionIndex = _stopIndex;\n\n            emit PolicyTokensSettledForUsers(\n                _policyTokenName,\n                _stablecoin,\n                _startIndex,\n                _stopIndex\n            );\n        }\n    }\n\n    /**\n     * @notice Collect the income\n     * @dev Can be done by anyone, only when there is some income to be distributed\n     * @param _stablecoin Address of stablecoin\n     */\n    function collectIncome(address _stablecoin) public {\n        require(\n            lottery != address(0) && incomeSharing != address(0),\n            \"Please set the lottery & incomeSharing address\"\n        );\n\n        uint256 amountToLottery = pendingIncomeToLottery[_stablecoin];\n        uint256 amountToSharing = pendingIncomeToSharing[_stablecoin];\n        require(\n            amountToLottery > 0 || amountToSharing > 0,\n            \"No pending income\"\n        );\n\n        IERC20(_stablecoin).safeTransfer(lottery, amountToLottery);\n        IERC20(_stablecoin).safeTransfer(incomeSharing, amountToSharing);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Finish deploying a pool\n     * @param _policyTokenAddress Address of the policy token\n     * @param _stablecoin Address of the stable coin\n     * @param _poolDeadline Swapping deadline of the pool (normally the same as the token's deadline)\n     * @param _feeRate Fee rate given to LP holders\n     * @return poolAddress Address of the pool\n     */\n    function _deployPool(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _poolDeadline,\n        uint256 _feeRate\n    ) internal returns (address) {\n        // Deploy a new pool (policyToken <=> stablecoin)\n        address poolAddress = factory.deployPool(\n            _policyTokenAddress,\n            _stablecoin,\n            _poolDeadline,\n            _feeRate\n        );\n\n        // Record the mapping\n        whichStablecoin[_policyTokenAddress] = _stablecoin;\n\n        return poolAddress;\n    }\n\n    /**\n     * @notice Finish Deposit\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the sable coin\n     * @param _amount Amount of stablecoin\n     * @param _user Address to receive the policy tokens\n     */\n    function _deposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    ) internal {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // If this is the first deposit, store the user address\n        if (userQuota[_user][policyTokenAddress] == 0) {\n            allDepositors[policyTokenAddress].push(_user);\n        }\n\n        // Update the user quota\n        userQuota[_user][policyTokenAddress] += _amount;\n\n        // Transfer stablecoins to this contract\n        IERC20(_stablecoin).safeTransferFrom(_user, address(this), _amount);\n\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\n\n        // Mint new policy tokens\n        policyToken.mint(_user, _amount);\n\n        emit Deposit(_user, _policyTokenName, _stablecoin, _amount);\n    }\n\n    /**\n     * @notice Settle the policy when the event does not happen\n     * @param _policyTokenAddress Address of policy token\n     * @param _stablecoin Address of stable coin\n     * @param _start Start index\n     * @param _stop Stop index\n     */\n    function _settlePolicy(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _start,\n        uint256 _stop\n    ) internal returns (uint256 amountRemaining) {\n        for (uint256 i = _start; i < _stop; i++) {\n            address user = allDepositors[_policyTokenAddress][i];\n            uint256 amount = userQuota[user][_policyTokenAddress];\n            // Charge fee\n            uint256 amountWithFee = _chargeFee(_stablecoin, amount);\n\n            if (amountWithFee > 0) {\n                IERC20(_stablecoin).safeTransfer(user, amountWithFee);\n                delete userQuota[user][_policyTokenAddress];\n\n                // Accumulate the remaining part that will be collected later\n                amountRemaining += amount - amountWithFee;\n            } else continue;\n        }\n    }\n\n    /**\n     * @notice Charge fee when redeem / claim\n     * @param _stablecoin Stablecoin address\n     * @param _amount Amount to redeem / claim\n     * @return amountWithFee Amount with fee\n     */\n    function _chargeFee(address _stablecoin, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        uint256 amountWithFee = (_amount * 990) / 1000;\n        uint256 amountToCollect = _amount - amountWithFee;\n\n        uint256 amountToLottery = (amountToCollect * toLotteryPart) / 10;\n\n        pendingIncomeToLottery[_stablecoin] += amountToLottery;\n        pendingIncomeToSharing[_stablecoin] +=\n            amountToCollect -\n            amountToLottery;\n\n        return amountWithFee;\n    }\n\n    /**\n     * @notice Generate the policy token name\n     * @param _tokenName Name of the stike token (BTC, ETH, AVAX...)\n     * @param _decimals Decimals of the name generation (0,1=>1, 2=>2)\n     * @param _strikePrice Strike price of the policy (18 decimals)\n     * @param _isCall The policy's payoff is triggered when higher(true) or lower(false)\n     * @param _round Round of the policy, named by <month><day> (e.g. 0320, 1215)\n     */\n    function _generateName(\n        string memory _tokenName,\n        uint256 _decimals,\n        uint256 _strikePrice,\n        bool _isCall,\n        string memory _round\n    ) public pure returns (string memory) {\n        // The direction is \"H\"(Call) or \"L\"(Put)\n        string memory direction = _isCall ? \"H\" : \"L\";\n\n        // Integer part of the strike price (12e18 => 12)\n        uint256 intPart = _strikePrice / 1e18;\n        require(intPart > 0, \"Invalid int part\");\n\n        // Decimal part of the strike price (1234e16 => 34)\n        // Can not start with 0 (e.g. 1204e16 => 0 this is incorrect, will revert in next step)\n        uint256 decimalPart = _frac(_strikePrice) / (10**(18 - _decimals));\n        if (_decimals >= 2)\n            require(decimalPart > 10**(_decimals - 1), \"Invalid decimal part\");\n\n        // Combine the string\n        string memory name = string(\n            abi.encodePacked(\n                _tokenName,\n                \"_\",\n                intPart.uintToString(),\n                \".\",\n                decimalPart.uintToString(),\n                \"_\",\n                direction,\n                \"_\",\n                _round\n            )\n        );\n        return name;\n    }\n\n    function _frac(uint256 x) internal pure returns (uint256 result) {\n        uint256 SCALE = 1e18;\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/utils/interfaces/IERC20Decimals.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.10;\n\ninterface IERC20Decimals {\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/naughty-price/interfaces/IPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IPriceGetter {\n    function getPriceFeedAddress(string memory _tokenName)\n        external\n        view\n        returns (address);\n\n    function setPriceFeed(string memory _tokenName, address _feedAddress)\n        external;\n\n    function getLatestPrice(string memory _tokenName)\n        external\n        returns (uint256 _price);\n}\n"
    },
    "contracts/naughty-price/interfaces/INaughtyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface INaughtyFactory {\n    function getPairAddress(address _tokenAddress1, address _tokenAddress2)\n        external\n        view\n        returns (address);\n\n    function deployPolicyToken(\n        string memory _policyTokenName,\n        uint256 _decimals\n    ) external returns (address);\n\n    function deployPool(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external returns (address);\n\n    function incomeMaker() external view returns (address);\n\n    function incomeMakerProportion() external view returns (uint256);\n}\n"
    },
    "contracts/naughty-price/interfaces/INPPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface INPPolicyToken is IERC20 {\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/utils/interfaces/IERC20PermitWithMultipleMinters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\ninterface IERC20PermitWithMultipleMinters is IERC20, IERC20Permit {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Functions ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    /**\n     * @notice Add a new minter into the minterList\n     * @param _newMinter Address of the new minter\n     */\n    function addMinter(address _newMinter) external;\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldMinter Address of the minter to be removed\n     */\n    function removeMinter(address _oldMinter) external;\n\n    /**\n     * @notice Add a new burner into the burnerList\n     * @param _newBurner Address of the new burner\n     */\n    function addBurner(address _newBurner) external;\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldBurner Address of the minter to be removed\n     */\n    function removeBurner(address _oldBurner) external;\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/naughty-price/NaughtyPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport {Math} from \"../libraries/Math.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"../utils/ReentrancyGuard.sol\";\nimport {INaughtyFactory} from \"./interfaces/INaughtyFactory.sol\";\n\n\n/**\n * @title  Naughty Pair\n * @notice This is the contract for the naughtyPrice swapping pair.\n *         Every time a new naughtyPrice product is online you need to deploy this contract.\n *         The contract will be initialized with two tokens and a deadline.\n *         Token0 will be policy tokens and token1 will be stablecoins.\n *         The swaps are only availale before the deadline.\n */\ncontract NaughtyPair is ERC20(\"Naughty Pool LP\", \"NLP\"), ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Minimum liquidity locked\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n\n    // naughtyFactory contract address\n    address public factory;\n\n    // Token addresses in the pool\n    address public token0; // Insurance Token\n    address public token1; // USDT\n\n    uint112 private reserve0; // Amount of Insurance Token\n    uint112 private reserve1; // Amount of USDT\n\n    // Used for modifiers\n    bool public unlocked = true;\n\n    // Every pool will have a deadline\n    uint256 public deadline;\n\n    // Fee Rate, given to LP holders (0 ~ 1000)\n    uint256 public feeRate;\n\n    // reserve0 * reserve1\n    uint256 public kLast;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event ReserveUpdated(uint256 reserve0, uint256 reserve1);\n    event Swap(\n        address indexed sender,\n        uint256 amountAIn,\n        uint256 amountBIn,\n        uint256 amountAOut,\n        uint256 amountBOut,\n        address indexed to\n    );\n\n    event Mint(address indexed sender, uint256 amountA, uint256 amountB);\n    event Burn(\n        address indexed sender,\n        uint256 amountA,\n        uint256 amountB,\n        address indexed to\n    );\n\n    constructor() {\n        factory = msg.sender; // deployed by factory contract\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Can not swap after the deadline\n     * @dev Each pool will have a deadline and it was set when deployed\n     *      Does not apply to income maker contract\n     */\n    modifier beforeDeadline() {\n        if (msg.sender != INaughtyFactory(factory).incomeMaker()) {\n            require(block.timestamp <= deadline, \"Can not swap after deadline\");\n        }\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Init Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Initialize the contract status after the deployment by factory\n     * @param _token0 Token0 address (policy token address)\n     * @param _token1 Token1 address (stablecoin address)\n     * @param _deadline Deadline for this pool\n     * @param _feeRate Fee rate to LP holders (1000 <=> 100%)\n     */\n    function initialize(\n        address _token0,\n        address _token1,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external {\n        require(\n            msg.sender == factory,\n            \"can only be initialized by the factory contract\"\n        );\n        require(_feeRate <= 1000, \"feeRate over 1.0\");\n\n        token0 = _token0;\n        token1 = _token1;\n\n        // deadline for the whole pool after which no swap will be allowed\n        deadline = _deadline;\n\n        feeRate = _feeRate;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get reserve0 (Policy token) and reserve1 (stablecoin).\n     * @dev This function always put policy token at the first place!\n     * @return _reserve0 Reserve of token0\n     * @return _reserve1 Reserve of token1\n     */\n    function getReserves()\n        public\n        view\n        returns (uint112 _reserve0, uint112 _reserve1)\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint LP Token to liquidity providers\n     *         Called when adding liquidity.\n     * @param to The user address\n     * @return liquidity The LP token amount\n     */\n    function mint(address to)\n        external\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n\n        uint256 balance0 = IERC20(token0).balanceOf(address(this)); // policy token balance after deposit\n        uint256 balance1 = IERC20(token1).balanceOf(address(this)); // stablecoin balance after deposit\n\n        uint256 amount0 = balance0 - _reserve0; // just deposit\n        uint256 amount1 = balance1 - _reserve1;\n\n        // Distribute part of the fee to income maker\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n\n        uint256 _totalSupply = totalSupply(); // gas savings\n        if (_totalSupply == 0) {\n            // No liquidity = First add liquidity\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n            // Keep minimum liquidity to this contract\n            _mint(factory, MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = min(\n                (amount0 * _totalSupply) / _reserve0,\n                (amount1 * _totalSupply) / _reserve1\n            );\n        }\n\n        require(liquidity > 0, \"insufficient liquidity minted\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1);\n\n        if (feeOn) kLast = reserve0 * reserve1;\n\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    /**\n     * @notice Burn LP tokens give back the original tokens\n     * @param _to User address\n     * @return amount0 Amount of token0 to be sent back\n     * @return amount1 Amount of token1 to be sent back\n     */\n    function burn(address _to)\n        external\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        // gas savings\n        (uint112 _reserve0, uint112 _reserve1) = getReserves();\n        address _token0 = token0;\n        address _token1 = token1;\n\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this)); // policy token balance\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this)); // stablecoin balance\n\n        uint256 liquidity = balanceOf(address(this));\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n\n        uint256 _totalSupply = totalSupply(); // gas savings\n\n        // How many tokens to be sent back\n        amount0 = (liquidity * balance0) / _totalSupply;\n        amount1 = (liquidity * balance1) / _totalSupply;\n\n        require(amount0 > 0 && amount1 > 0, \"Insufficient liquidity burned\");\n\n        // Currently all the liquidity in the pool was just sent by the user, so burn all\n        _burn(address(this), liquidity);\n\n        // Transfer tokens out and update the balance\n        IERC20(_token0).safeTransfer(_to, amount0);\n        IERC20(_token1).safeTransfer(_to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1);\n\n        if (feeOn) kLast = reserve0 * reserve1;\n\n        emit Burn(msg.sender, amount0, amount1, _to);\n    }\n\n    /**\n     * @notice Finish the swap process\n     * @param _amount0Out Amount of token0 to be given out (may be 0)\n     * @param _amount1Out Amount of token1 to be given out (may be 0)\n     * @param _to Address to receive the swap result\n     */\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to\n    ) external beforeDeadline nonReentrant {\n        require(\n            _amount0Out > 0 || _amount1Out > 0,\n            \"Output amount need to be > 0\"\n        );\n\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n        require(\n            _amount0Out < _reserve0 && _amount1Out < _reserve1,\n            \"Not enough liquidity\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(_to != _token0 && _to != _token1, \"INVALID_TO\");\n\n            if (_amount0Out > 0) IERC20(_token0).safeTransfer(_to, _amount0Out);\n            if (_amount1Out > 0) IERC20(_token1).safeTransfer(_to, _amount1Out);\n\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - _amount0Out\n            ? balance0 - (_reserve0 - _amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - _amount1Out\n            ? balance1 - (_reserve1 - _amount1Out)\n            : 0;\n\n        require(amount0In > 0 || amount1In > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\n        {\n            uint256 balance0Adjusted = balance0 * 1000 - amount0In * feeRate;\n            uint256 balance1Adjusted = balance1 * 1000 - amount1In * feeRate;\n\n            require(\n                balance0Adjusted * balance1Adjusted >=\n                    _reserve0 * _reserve1 * (1000**2),\n                \"The remaining x*y is less than K\"\n            );\n        }\n\n        _update(balance0, balance1);\n\n        emit Swap(\n            msg.sender,\n            amount0In,\n            amount1In,\n            _amount0Out,\n            _amount1Out,\n            _to\n        );\n    }\n\n    /**\n     * @notice Syncrinize the status of this pool\n     */\n    function sync() external nonReentrant {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this))\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ********************************** Internal Functions ********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update the reserves of the pool\n     * @param balance0 Balance of token0\n     * @param balance1 Balance of token1\n     */\n    function _update(uint256 balance0, uint256 balance1) private {\n        uint112 MAX_NUM = type(uint112).max;\n        require(balance0 <= MAX_NUM && balance1 <= MAX_NUM, \"Uint112 OVERFLOW\");\n\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n\n        emit ReserveUpdated(reserve0, reserve1);\n    }\n\n    /**\n     * @notice Get the smaller one of two numbers\n     * @param x The first number\n     * @param y The second number\n     * @return z The smaller one\n     */\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    function _mintFee(uint112 _reserve0, uint112 _reserve1)\n        private\n        returns (bool feeOn)\n    {\n        address incomeMaker = INaughtyFactory(factory).incomeMaker();\n\n        // If incomeMaker is not zero address, fee is on\n        feeOn = incomeMaker != address(0);\n\n        uint256 _k = kLast;\n\n        if (feeOn) {\n            if (_k != 0) {\n                uint256 rootK = Math.sqrt(_reserve0 * _reserve1);\n                uint256 rootKLast = Math.sqrt(_k);\n\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply() * (rootK - rootKLast);\n\n                    // (1 / φ) - 1\n                    // Proportion got from factory is based on 100\n                    uint256 incomeMakerProportion = INaughtyFactory(factory)\n                        .incomeMakerProportion();\n                    uint256 denominator = rootK *\n                        (100 / incomeMakerProportion - 1) +\n                        rootKLast;\n\n                    uint256 liquidity = numerator / denominator;\n\n                    // Mint the liquidity to income maker contract\n                    if (liquidity > 0) _mint(incomeMaker, liquidity);\n                }\n            }\n        } else if (_k != 0) {\n            kLast = 0;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary Math {\n    uint256 internal constant WAD = 10**18;\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return ((x * y) + (WAD / 2)) / WAD;\n    }\n}\n"
    },
    "contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/naughty-price/NaughtyRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IBuyerToken} from \"../tokens/interfaces/IBuyerToken.sol\";\nimport {INaughtyPair} from \"./interfaces/INaughtyPair.sol\";\nimport {INaughtyFactory} from \"./interfaces/INaughtyFactory.sol\";\nimport {IPolicyCore} from \"./interfaces/IPolicyCore.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Decimals} from \"../utils/interfaces/IERC20Decimals.sol\";\n\n/**\n * @title  NaughtyRouter\n * @notice Router for the pool, you can add/remove liquidity or swap A for B.\n *         Swapping fee rate is 2% and all of them are given to LP.\n *         Very similar logic with Uniswap V2.\n *\n */\ncontract NaughtyRouter is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for INaughtyPair;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Some other contracts\n    address public factory;\n    address public policyCore;\n    address public buyerToken;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PolicyCoreChanged(address oldPolicyCore, address newPolicyCore);\n\n    event BuyerTokenChanged(address oldBuyerToken, address newBuyerToken);\n\n    event LiquidityAdded(\n        address indexed pairAddress,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n\n    event LiquidityRemoved(\n        address indexed pairAddress,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _factory, address _buyerToken)\n        public\n        initializer\n    {\n        __Ownable_init();\n\n        factory = _factory;\n        buyerToken = _buyerToken;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Transactions are available only before the deadline\n     * @param _deadLine Deadline of the pool\n     */\n    modifier beforeDeadline(uint256 _deadLine) {\n        if (msg.sender != INaughtyFactory(factory).incomeMaker()) {\n            require(block.timestamp < _deadLine, \"expired transaction\");\n        }\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set the address of policyCore\n     * @param _coreAddress Address of new policyCore\n     */\n    function setPolicyCore(address _coreAddress) external onlyOwner {\n        emit PolicyCoreChanged(policyCore, _coreAddress);\n        policyCore = _coreAddress;\n    }\n\n    /**\n     * @notice Set the address of buyer token\n     * @param _buyerToken Address of new buyer token\n     */\n    function setBuyerToken(address _buyerToken) external onlyOwner {\n        emit BuyerTokenChanged(buyerToken, _buyerToken);\n        buyerToken = _buyerToken;\n    }\n\n    /**\n     * @notice Set the address of factory\n     * @param _naughtyFactory Address of new naughty factory\n     */\n    function setNaughtyFactory(address _naughtyFactory) external onlyOwner {\n        emit BuyerTokenChanged(factory, _naughtyFactory);\n        factory = _naughtyFactory;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Helper Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add liquidity but only provide stablecoins\n     * @dev Only difference with addLiquidity is that mintPolicyTokenForUser\n     * @param _tokenA Address of policyToken\n     * @param _tokenB Address of stablecoin\n     * @param _amountADesired Amount of policyToken desired\n     * @param _amountBDesired Amount of stablecoin desired\n     * @param _amountAMin Minimum amount of policy token\n     * @param _amountBMin Minimum amount of stablecoin\n     * @param _to Address that receive the lp token, normally the user himself\n     * @param _deadline Transaction will revert after this deadline\n     */\n    function addLiquidityWithUSD(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        beforeDeadline(_deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        require(_checkStablecoin(_tokenB), \"Token B should be stablecoin\");\n\n        // Mint _amountADesired policy tokens for users\n        _mintPolicyTokensForUser(\n            _tokenA,\n            _tokenB,\n            _amountADesired,\n            _msgSender()\n        );\n\n        // Add liquidity\n        {\n            (amountA, amountB, liquidity) = addLiquidity(\n                _tokenA,\n                _tokenB,\n                _amountADesired,\n                _amountBDesired,\n                _amountAMin,\n                _amountBMin,\n                _to,\n                _deadline\n            );\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add liquidity function\n     * @param _tokenA Address of policyToken\n     * @param _tokenB Address of stablecoin\n     * @param _amountADesired Amount of policyToken desired\n     * @param _amountBDesired Amount of stablecoin desired\n     * @param _amountAMin Minimum amoutn of policy token\n     * @param _amountBMin Minimum amount of stablecoin\n     * @param _to Address that receive the lp token, normally the user himself\n     * @param _deadline Transaction will revert after this deadline\n     * @return amountA Amount of tokenA to be input\n     * @return amountB Amount of tokenB to be input\n     * @return liquidity LP token to be mint\n     */\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        beforeDeadline(_deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        {\n            (amountA, amountB) = _addLiquidity(\n                _tokenA,\n                _tokenB,\n                _amountADesired,\n                _amountBDesired,\n                _amountAMin,\n                _amountBMin\n            );\n        }\n\n        address pair = INaughtyFactory(factory).getPairAddress(\n            _tokenA,\n            _tokenB\n        );\n\n        _transferHelper(_tokenA, _msgSender(), pair, amountA);\n        _transferHelper(_tokenB, _msgSender(), pair, amountB);\n\n        liquidity = INaughtyPair(pair).mint(_to);\n\n        emit LiquidityAdded(pair, amountA, amountB, liquidity);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool\n     * @param _tokenA Address of policy token\n     * @param _tokenB Address of stablecoin\n     * @param _liquidity The lptoken amount to be removed\n     * @param _amountAMin Minimum amount of tokenA given out\n     * @param _amountBMin Minimum amount of tokenB given out\n     * @param _to User address\n     * @param _deadline Deadline of this transaction\n     * @return amountA Amount of token0 given out\n     * @return amountB Amount of token1 given out\n     */\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        beforeDeadline(_deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        address pair = INaughtyFactory(factory).getPairAddress(\n            _tokenA,\n            _tokenB\n        );\n\n        INaughtyPair(pair).safeTransferFrom(_msgSender(), pair, _liquidity); // send liquidity to pair\n\n        // Amount0: insurance token\n        (amountA, amountB) = INaughtyPair(pair).burn(_to);\n\n        require(amountA >= _amountAMin, \"Insufficient insurance token amount\");\n        require(amountB >= _amountBMin, \"Insufficient USDT token\");\n\n        emit LiquidityRemoved(pair, amountA, amountB, _liquidity);\n    }\n\n    /**\n     * @notice Amount out is fixed\n     * @param _amountInMax Maximum token input\n     * @param _amountOut Fixed token output\n     * @param _tokenIn Address of input token\n     * @param _tokenOut Address of output token\n     * @param _to User address\n     * @param _deadline Deadline for this specific swap\n     * @return amountIn Amounts to be really put in\n     */\n    function swapTokensforExactTokens(\n        uint256 _amountInMax,\n        uint256 _amountOut,\n        address _tokenIn,\n        address _tokenOut,\n        address _to,\n        uint256 _deadline\n    ) external beforeDeadline(_deadline) returns (uint256 amountIn) {\n        address pair = INaughtyFactory(factory).getPairAddress(\n            _tokenIn,\n            _tokenOut\n        );\n        require(\n            block.timestamp <= INaughtyPair(pair).deadline(),\n            \"This pool has been frozen for swapping\"\n        );\n\n        bool isBuying = _checkStablecoin(_tokenIn);\n\n        uint256 feeRate = INaughtyPair(pair).feeRate();\n\n        // Get how many tokens should be put in (the order depends on isBuying)\n        amountIn = _getAmountIn(\n            isBuying,\n            _amountOut,\n            _tokenIn,\n            _tokenOut,\n            feeRate\n        );\n\n        require(amountIn <= _amountInMax, \"excessive input amount\");\n\n        _transferHelper(_tokenIn, _msgSender(), pair, amountIn);\n\n        _swap(pair, _tokenIn, amountIn, _amountOut, isBuying, _to);\n    }\n\n    /**\n     * @notice Amount in is fixed\n     * @param _amountIn Fixed token input\n     * @param _amountOutMin Minimum token output\n     * @param _tokenIn Address of input token\n     * @param _tokenOut Address of output token\n     * @param _to User address\n     * @param _deadline Deadline for this specific swap\n     * @return amountOut Amounts to be really given out\n     */\n    function swapExactTokensforTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _tokenIn,\n        address _tokenOut,\n        address _to,\n        uint256 _deadline\n    ) external beforeDeadline(_deadline) returns (uint256 amountOut) {\n        address pair = INaughtyFactory(factory).getPairAddress(\n            _tokenIn,\n            _tokenOut\n        );\n        require(\n            block.timestamp <= INaughtyPair(pair).deadline(),\n            \"This pool has been frozen for swapping\"\n        );\n\n        // Check if the tokenIn is stablecoin\n        bool isBuying = _checkStablecoin(_tokenIn);\n\n        uint256 feeRate = INaughtyPair(pair).feeRate();\n\n        // Get how many tokens should be given out (the order depends on isBuying)\n        amountOut = _getAmountOut(\n            isBuying,\n            _amountIn,\n            _tokenIn,\n            _tokenOut,\n            feeRate\n        );\n        require(amountOut >= _amountOutMin, \"excessive output amount\");\n\n        _transferHelper(_tokenIn, _msgSender(), pair, _amountIn);\n\n        _swap(pair, _tokenIn, _amountIn, amountOut, isBuying, _to);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Internal function to finish adding liquidity\n     * @param _tokenA Address of tokenA\n     * @param _tokenB Address of tokenB\n     * @param _amountADesired Amount of tokenA to be added\n     * @param _amountBDesired Amount of tokenB to be added\n     * @param _amountAMin Minimum amount of tokenA\n     * @param _amountBMin Minimum amount of tokenB\n     * @return amountA Real amount of tokenA\n     * @return amountB Real amount of tokenB\n     */\n    function _addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) private view returns (uint256 amountA, uint256 amountB) {\n        require(_checkStablecoin(_tokenB), \"Please put stablecoin as tokenB\");\n\n        (uint256 reserveA, uint256 reserveB) = _getReserves(_tokenA, _tokenB);\n\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (_amountADesired, _amountBDesired);\n        } else {\n            uint256 amountBOptimal = _quote(\n                _amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= _amountBDesired) {\n                require(amountBOptimal >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (_amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = _quote(\n                    _amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                require(amountAOptimal <= _amountADesired, \"nonono\");\n                require(amountAOptimal >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, _amountBDesired);\n            }\n        }\n    }\n\n    /**\n     * @notice Finish the erc20 transfer operation\n     * @param _token ERC20 token address\n     * @param _from Address to give out the token\n     * @param _to Pair address to receive the token\n     * @param _amount Transfer amount\n     */\n    function _transferHelper(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        IERC20(_token).safeTransferFrom(_from, _to, _amount);\n    }\n\n    /**\n     * @notice Finish swap process\n     * @param _pair Address of the pair\n     * @param _tokenIn Address of the input token\n     * @param _amountIn Amount of tokens put in\n     * @param _amountOut Amount of tokens get out\n     * @param _isBuying Whether this is a purchase or a sell\n     * @param _to Address of the user\n     */\n    function _swap(\n        address _pair,\n        address _tokenIn,\n        uint256 _amountIn,\n        uint256 _amountOut,\n        bool _isBuying,\n        address _to\n    ) internal {\n        // Only give buyer tokens when this is a purchase\n        if (_isBuying) {\n            // Check the decimals\n            uint256 decimals = IERC20Decimals(_tokenIn).decimals();\n            uint256 buyerTokenAmount = _amountIn * 10**(18 - decimals);\n            IBuyerToken(buyerToken).mintBuyerToken(\n                _msgSender(),\n                buyerTokenAmount\n            );\n        }\n\n        // If the user is buying policies => amount1Out = 0\n        // One of these two variables will be 0\n        uint256 amountAOut = _isBuying ? _amountOut : 0;\n        uint256 amountBOut = _isBuying ? 0 : _amountOut;\n\n        INaughtyPair(_pair).swap(amountAOut, amountBOut, _to);\n    }\n\n    /**\n     * @notice Used when users only provide stablecoins and want to mint & add liquidity in one step\n     * @dev Need have approval before (done by the user himself)\n     * @param _policyTokenAddress Address of the policy token\n     * @param _stablecoin Address of the stablecoin\n     * @param _amount Amount to be used for minting policy tokens\n     * @param _user The user's address\n     */\n    function _mintPolicyTokensForUser(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    ) internal {\n        // Find the policy token name\n        string memory policyTokenName = IPolicyCore(policyCore)\n            .findNamebyAddress(_policyTokenAddress);\n\n        IPolicyCore(policyCore).delegateDeposit(\n            policyTokenName,\n            _stablecoin,\n            _amount,\n            _user\n        );\n    }\n\n    function _checkStablecoin(address _tokenAddress)\n        internal\n        view\n        returns (bool)\n    {\n        return IPolicyCore(policyCore).supportedStablecoin(_tokenAddress);\n    }\n\n    /**\n     * @notice Fetche the reserves for a pair\n     * @dev You need to sort the token order by yourself!\n     *      No matter your input order, the return value will always start with policy token reserve.\n     */\n    function _getReserves(address tokenA, address tokenB)\n        internal\n        view\n        returns (uint112 reserveA, uint112 reserveB)\n    {\n        address pairAddress = INaughtyFactory(factory).getPairAddress(\n            tokenA,\n            tokenB\n        );\n\n        // (Policy token reserve, stablecoin reserve)\n        (reserveA, reserveB) = INaughtyPair(pairAddress).getReserves();\n    }\n\n    /**\n     * @notice Used when swap exact tokens for tokens (in is fixed)\n     * @param isBuying Whether the user is buying policy tokens\n     * @param _amountIn Amount of tokens put in\n     * @param _tokenIn Address of the input token\n     * @param _tokenOut Address of the output token\n     */\n    function _getAmountOut(\n        bool isBuying,\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _feeRate\n    ) internal view returns (uint256 amountOut) {\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\n            _tokenIn,\n            _tokenOut\n        );\n\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\n        // Get the right order\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\n            ? (reserveB, reserveA)\n            : (reserveA, reserveB);\n\n        require(_amountIn > 0, \"insufficient input amount\");\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient liquidity\");\n\n        uint256 amountInWithFee = _amountIn * (1000 - _feeRate);\n        uint256 numerator = amountInWithFee * (reserveOut);\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n\n        amountOut = numerator / denominator;\n    }\n\n    /**\n     * @notice Used when swap tokens for exact tokens (out is fixed)\n     * @param isBuying Whether the user is buying policy tokens\n     * @param _amountOut Amount of tokens given out\n     * @param _tokenIn Address of the input token\n     * @param _tokenOut Address of the output token\n     */\n    function _getAmountIn(\n        bool isBuying,\n        uint256 _amountOut,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _feeRate\n    ) internal view returns (uint256 amountIn) {\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\n            _tokenIn,\n            _tokenOut\n        );\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\n        // Get the right order\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\n            ? (reserveB, reserveA)\n            : (reserveA, reserveB);\n\n        require(_amountOut > 0, \"insufficient output amount\");\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient liquidity\");\n\n        uint256 numerator = reserveIn * (_amountOut) * 1000;\n        uint256 denominator = (reserveOut - _amountOut) * (1000 - _feeRate);\n\n        amountIn = numerator / denominator + 1;\n    }\n\n    /**\n     * @notice Given some amount of an asset and pair reserves\n     *         returns an equivalent amount of the other asset\n     * @dev Used when add or remove liquidity\n     * @param _amountA Amount of tokenA ( can be policytoken or stablecoin)\n     * @param _reserveA Reserve of tokenA\n     * @param _reserveB Reserve of tokenB\n     */\n    function _quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(_amountA > 0, \"insufficient amount\");\n        require(_reserveA > 0 && _reserveB > 0, \"insufficient liquidity\");\n\n        amountB = (_amountA * _reserveB) / _reserveA;\n    }\n}\n"
    },
    "contracts/naughty-price/interfaces/INaughtyPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface INaughtyPair is IERC20 {\n    function initialize(\n        address _token0,\n        address _token1,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external;\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function feeRate() external view returns (uint256);\n\n    function deadline() external view returns (uint256);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 _reserve0, uint112 _reserve1);\n\n    function swap(\n        uint256,\n        uint256,\n        address\n    ) external;\n\n    function burn(address) external returns (uint256, uint256);\n\n    function mint(address) external returns (uint256);\n\n    function sync() external;\n}\n"
    },
    "contracts/naughty-price/interfaces/IPolicyCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IPolicyCore {\n    struct PolicyTokenInfo {\n        address policyTokenAddress;\n        bool isCall;\n        uint256 nameDecimals; // decimals of the name generation\n        uint256 tokenDecimals; // decimals of the policy token\n        uint256 strikePrice;\n        uint256 deadline;\n        uint256 settleTimestamp;\n    }\n\n    /**\n     * @notice Find the address by its name\n     */\n    function findAddressbyName(string memory _policyTokenName)\n        external\n        view\n        returns (address _policyTokenAddress);\n\n    /**\n     * @notice Find the name by address\n     */\n    function findNamebyAddress(address _policyTokenAddress)\n        external\n        view\n        returns (string memory);\n\n    /**\n     * @notice Check whether the stablecoin is supported\n     */\n    function supportedStablecoin(address _coinAddress)\n        external\n        view\n        returns (bool);\n\n    function delegateDeposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    ) external;\n\n    function deployPool(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _poolDeadline,\n        uint256 _feeRate\n    ) external returns (address);\n\n    function getPolicyTokenInfo(string memory _policyTokenName)\n        external\n        view\n        returns (PolicyTokenInfo memory);\n}\n"
    },
    "contracts/ILM/NaughtyPriceILM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Decimals} from \"../utils/interfaces/IERC20Decimals.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IPolicyCore} from \"../naughty-price/interfaces/IPolicyCore.sol\";\nimport {INaughtyRouter} from \"../naughty-price/interfaces/INaughtyRouter.sol\";\nimport {INaughtyPair} from \"../naughty-price/interfaces/INaughtyPair.sol\";\nimport {ILMToken as LPToken} from \"./ILMToken.sol\";\n\n/**\n * @title Naughty Price Initial Liquidity Matching\n * @notice Naughty Price timeline: 1 -- 14 -- 5\n *         The first day of each round would be the time for liquidity matching\n *         User\n *           - Select the naughty token\n *           - Provide stablecoins into this contract & Select your price choice\n *           - Change the amountA and amountB of this pair\n *         When reach deadline\n *           - Final price of ILM = Initial price of naughty price pair = amountA/amountB\n */\ncontract NaughtyPriceILM is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Scale when calculating fee\n    uint256 public constant SCALE = 1e12;\n\n    // Degis entrance fee = 1 / 100 deposit amount\n    uint256 public constant FEE_DENOMINATOR = 100;\n\n    // Minimum deposit amount\n    uint256 public constant MINIMUM_AMOUNT = 1e6;\n\n    // Uint256 maximum value\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Degis token address\n    address public degis;\n\n    // PolicyCore, Router and EmergencyPool contract address\n    address public policyCore;\n    address public naughtyRouter;\n    address public emergencyPool;\n\n    struct UserInfo {\n        uint256 amountA;\n        uint256 amountB;\n        uint256 degisDebt;\n    }\n    // user address => policy token address => user info\n    mapping(address => mapping(address => UserInfo)) public users;\n\n    enum Status {\n        BeforeStart,\n        Active,\n        Finished,\n        Stopped\n    }\n\n    struct PairInfo {\n        Status status; // 0: before start 1: active 2: finished 3: stopped\n        address lptoken; // lptoken address\n        uint256 ILMDeadline; // deadline for initial liquidity matching\n        address stablecoin; // stablecoin address\n        uint256 amountA; // Amount of policy tokens\n        uint256 amountB; // Amount of stablecoins\n        address naughtyPairAddress; // Naughty pair address deployed when finished ILM\n        // degis paid as fee\n        uint256 degisAmount;\n        uint256 accDegisPerShare;\n    }\n    // Policy Token Address => Pair Info\n    mapping(address => PairInfo) public pairs;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Deposit(\n        address indexed policyToken,\n        address indexed stablecoin,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event Withdraw(\n        address indexed policyToken,\n        address indexed stablecoin,\n        address indexed user,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event EmergencyWithdraw(address owner, uint256 amount);\n    event ILMFinish(\n        address policyToken,\n        address stablecoin,\n        address poolAddress,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event ILMStart(\n        address policyToken,\n        address stablecoin,\n        uint256 deadline,\n        address lptokenAddress\n    );\n    event Harvest(address user, uint256 reward);\n    event Claim(address user, uint256 amountA, uint256 amountB);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error ILM__WrongILMDeadline();\n    error ILM__ZeroAddress();\n    error ILM__RoundOver();\n    error ILM__PairNotActive();\n    error ILM__RoundNotOver();\n    error ILM__ZeroAmount();\n    error ILM__NotActiveILM();\n    error ILM__StablecoinNotPaired();\n    error ILM__StablecoinNotSupport();\n    error ILM__NoDeposit();\n    error ILM__NotEnoughDeposit();\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Initialze function for proxy\n     * @dev Called only when deploying proxy contract\n     * @param _degis Degis token address\n     * @param _policyCore PolicyCore contract address\n     * @param _router NaughtyRouter contract address\n     * @param _emergencyPool EmergencyPool contract address\n     */\n    function initialize(\n        address _degis,\n        address _policyCore,\n        address _router,\n        address _emergencyPool\n    ) public initializer {\n        if (_policyCore == address(0) || _router == address(0))\n            revert ILM__ZeroAddress();\n\n        __Ownable_init();\n\n        degis = _degis;\n        policyCore = _policyCore;\n        naughtyRouter = _router;\n\n        emergencyPool = _emergencyPool;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check whether a pair is active\n     * @param _policyToken Policy token address\n     */\n    modifier activePair(address _policyToken) {\n        if (pairs[_policyToken].status != Status.Active)\n            revert ILM__PairNotActive();\n        _;\n    }\n\n    /**\n     * @notice Check whether is during ILM\n     * @param _policyToken Policy token address\n     */\n    modifier duringILM(address _policyToken) {\n        if (block.timestamp > pairs[_policyToken].ILMDeadline)\n            revert ILM__RoundOver();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the current price\n     * @dev Price has a scale of 1e12\n     * @param _policyToken Policy token address\n     * @return price Price of the token pair\n     */\n    function getPrice(address _policyToken) external view returns (uint256) {\n        uint256 amountA = pairs[_policyToken].amountA;\n        uint256 amountB = pairs[_policyToken].amountB;\n        return (amountA * SCALE) / amountB;\n    }\n\n    /**\n     * @notice Get the total amount of a pair\n     * @param _policyToken Policy token address\n     * @return totalAmount Total amount of a pair\n     */\n    function getPairTotalAmount(address _policyToken)\n        external\n        view\n        returns (uint256 totalAmount)\n    {\n        totalAmount = pairs[_policyToken].amountA + pairs[_policyToken].amountB;\n    }\n\n    /**\n     * @notice Get the amount of user's deposit\n     * @param _user User address\n     * @param _policyToken Policy token address\n     */\n    function getUserDeposit(address _user, address _policyToken)\n        external\n        view\n        returns (uint256 amountA, uint256 amountB)\n    {\n        amountA = users[_user][_policyToken].amountA;\n        amountB = users[_user][_policyToken].amountB;\n    }\n\n    /**\n     * @notice Emergency stop ILM\n     * @param _policyToken Policy token address to be stopped\n     */\n    function emergencyStop(address _policyToken) external onlyOwner {\n        pairs[_policyToken].status = Status.Stopped;\n    }\n\n    /**\n     * @notice Emergency restart ILM\n     * @param _policyToken Policy token address to be restarted\n     */\n    function emergencyRestart(address _policyToken) external onlyOwner {\n        pairs[_policyToken].status = Status.Active;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start a new ILM round\n     * @dev A new lp token will be deployed when starting a new ILM round\n     *      It will have a special farming reward pool\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     * @param _ILMDeadline Deadline of ILM period\n     */\n    function startILM(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _ILMDeadline\n    ) external onlyOwner {\n        // Get policy token name & Check if this policy token exists\n        // The check is inside policy core contract\n        string memory policyTokenName = IPolicyCore(policyCore)\n            .findNamebyAddress(_policyToken);\n\n        // Check if the stablecoin is supported\n        bool isSupported = IPolicyCore(policyCore).supportedStablecoin(\n            _stablecoin\n        );\n        if (!isSupported) revert ILM__StablecoinNotSupport();\n\n        // The deadline for ILM can not be later than the policy token deadline\n        uint256 policyTokenDeadline = (\n            IPolicyCore(policyCore).getPolicyTokenInfo(policyTokenName)\n        ).deadline;\n        if (_ILMDeadline >= policyTokenDeadline) revert ILM__WrongILMDeadline();\n\n        PairInfo storage pair = pairs[_policyToken];\n        // Update the status\n        pair.status = Status.Active;\n        pair.stablecoin = _stablecoin;\n        pair.ILMDeadline = _ILMDeadline;\n\n        // Deploy a new ERC20 LP Token\n        string memory LPTokenName = string(\n            abi.encodePacked(\"ILM-\", policyTokenName)\n        );\n        address lpTokenAddress = _deployLPToken(LPTokenName);\n\n        // Record the lptoken address\n        pair.lptoken = lpTokenAddress;\n\n        // Pre-approve the stablecoin for later deposit\n        IERC20(_policyToken).approve(naughtyRouter, MAX_UINT256);\n\n        emit ILMStart(_policyToken, _stablecoin, _ILMDeadline, lpTokenAddress);\n    }\n\n    /**\n     * @notice Approve stablecoins for naughty price contracts\n     * @param _stablecoin Stablecoin address\n     */\n    function approveStablecoin(address _stablecoin) external {\n        IERC20(_stablecoin).approve(naughtyRouter, MAX_UINT256);\n        IERC20(_stablecoin).approve(policyCore, MAX_UINT256);\n    }\n\n    /**\n     * @notice Finish a round of ILM\n     * @dev The swap pool for the protection token will be deployed with inital liquidity\\\n     *      The amount of initial liquidity will be the total amount of the pair\n     *      Can be called by any address\n     * @param _policyToken Policy token address\n     * @param _deadlineForSwap Pool deadline\n     * @param _feeRate Fee rate of the swap pool\n     */\n    function finishILM(\n        address _policyToken,\n        uint256 _deadlineForSwap,\n        uint256 _feeRate\n    ) external activePair(_policyToken) {\n        PairInfo memory pair = pairs[_policyToken];\n\n        // Pair status is 1 and passed deadline => can finish ILM\n        if (block.timestamp <= pair.ILMDeadline) revert ILM__RoundNotOver();\n        if (pair.amountA + pair.amountB == 0) revert ILM__NoDeposit();\n\n        // Update the status of this pair\n        pairs[_policyToken].status = Status.Finished;\n\n        // Get policy token name\n        string memory policyTokenName = IPolicyCore(policyCore)\n            .findNamebyAddress(_policyToken);\n\n        // Deploy a new pool and return the pool address\n        address poolAddress = IPolicyCore(policyCore).deployPool(\n            policyTokenName,\n            pair.stablecoin,\n            _deadlineForSwap,\n            _feeRate // maximum = 1000 = 100%\n        );\n        pairs[_policyToken].naughtyPairAddress = poolAddress;\n\n        // Approval prepration for withdraw liquidity\n        INaughtyPair(poolAddress).approve(naughtyRouter, MAX_UINT256);\n\n        // Add initial liquidity to the pool\n        // Zero slippage\n        INaughtyRouter(naughtyRouter).addLiquidityWithUSD(\n            _policyToken,\n            pair.stablecoin,\n            pair.amountA,\n            pair.amountB,\n            pair.amountA,\n            pair.amountB,\n            address(this),\n            block.timestamp + 60\n        );\n\n        emit ILMFinish(\n            _policyToken,\n            pair.stablecoin,\n            poolAddress,\n            pair.amountA,\n            pair.amountB\n        );\n    }\n\n    /**\n     * @notice Deposit stablecoin and choose the price\n     * @dev Deposit only check the pair status not the deadline\n     *      There may be a zero ILM and we still need to deposit some asset to make it start\n     *      Anyone wants to enter ILM need to pay some DEG as entrance fee\n     *      The ratio is 100:1(usd:deg) and your fee is distributed to the users prior to you\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     * @param _amountA Amount of policy token (virtual)\n     * @param _amountB Amount of stablecoin (virtual)\n     */\n    function deposit(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _amountA,\n        uint256 _amountB\n    ) external activePair(_policyToken) {\n        if (_amountA + _amountB < MINIMUM_AMOUNT) revert ILM__ZeroAmount();\n        if (_stablecoin != pairs[_policyToken].stablecoin)\n            revert ILM__StablecoinNotPaired();\n\n        uint256 amountToDeposit = _amountA + _amountB;\n\n        // Every 100usd pay 1 degis\n        uint256 decimalDiff = 18 - IERC20Decimals(_stablecoin).decimals();\n        uint256 degisToPay = (amountToDeposit * 10**decimalDiff) /\n            FEE_DENOMINATOR;\n\n        // Update the info about deg entrance fee when deposit\n        _updateWhenDeposit(\n            _policyToken,\n            amountToDeposit,\n            degisToPay,\n            decimalDiff\n        );\n\n        PairInfo storage pair = pairs[_policyToken];\n        UserInfo storage user = users[msg.sender][_policyToken];\n\n        // Update deg record and transfer degis token\n        pair.degisAmount += degisToPay;\n        IERC20(degis).safeTransferFrom(msg.sender, address(this), degisToPay);\n\n        // Update the status\n        pair.amountA += _amountA;\n        pair.amountB += _amountB;\n        user.amountA += _amountA;\n        user.amountB += _amountB;\n\n        // Transfer tokens\n        IERC20(_stablecoin).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountToDeposit\n        );\n\n        // Distribute the lptoken\n        address lpToken = pairs[_policyToken].lptoken;\n        LPToken(lpToken).mint(msg.sender, amountToDeposit);\n\n        emit Deposit(_policyToken, _stablecoin, _amountA, _amountB);\n    }\n\n    /**\n     * @notice Withdraw stablecoins\n     * @dev Only checks the status not the deadline\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     * @param _amountA Amount of policy token (virtual)\n     * @param _amountB Amount of stablecoin (virtual)\n     */\n    function withdraw(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _amountA,\n        uint256 _amountB\n    ) public activePair(_policyToken) {\n        UserInfo memory currentUserInfo = users[msg.sender][_policyToken];\n\n        // Check if the user has enough tokens to withdraw\n        if (currentUserInfo.amountA + currentUserInfo.amountB == 0)\n            revert ILM__NoDeposit();\n        if (\n            _amountA > currentUserInfo.amountA ||\n            _amountB > currentUserInfo.amountB\n        ) revert ILM__NotEnoughDeposit();\n\n        PairInfo storage pair = pairs[_policyToken];\n        UserInfo storage user = users[msg.sender][_policyToken];\n\n        // Update status when withdraw\n        uint256 degisToWithdraw = (pair.accDegisPerShare *\n            (currentUserInfo.amountA + currentUserInfo.amountB)) /\n            SCALE -\n            currentUserInfo.degisDebt;\n\n        if (degisToWithdraw > 0) {\n            // Degis will be withdrawed to emergency pool, not the user\n            uint256 reward = _safeTokenTransfer(\n                degis,\n                emergencyPool,\n                degisToWithdraw\n            );\n            emit Harvest(emergencyPool, reward);\n        }\n\n        // Update the user's amount and pool's amount\n        pair.amountA -= _amountA;\n        pair.amountB -= _amountB;\n        user.amountA -= _amountA;\n        user.amountB -= _amountB;\n\n        uint256 amountToWithdraw = _amountA + _amountB;\n\n        // Withdraw stablecoins to the user\n        _safeTokenTransfer(_stablecoin, msg.sender, amountToWithdraw);\n\n        // Burn the lptokens\n        LPToken(pair.lptoken).burn(msg.sender, amountToWithdraw);\n\n        // Update the user debt\n        user.degisDebt =\n            ((user.amountA + user.amountB) * pair.accDegisPerShare) /\n            SCALE;\n\n        emit Withdraw(\n            _policyToken,\n            _stablecoin,\n            msg.sender,\n            _amountA,\n            _amountB\n        );\n    }\n\n    /**\n     * @notice Withdraw all stablecoins of a certain policy token\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     */\n    function withdrawAll(address _policyToken, address _stablecoin) external {\n        uint256 amounAMax = users[msg.sender][_policyToken].amountA;\n        uint256 amounBMax = users[msg.sender][_policyToken].amountB;\n\n        withdraw(_policyToken, _stablecoin, amounAMax, amounBMax);\n    }\n\n    /**\n     * @notice Claim liquidity back\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     * @param _amountAMin Minimum amount of policy token (slippage)\n     * @param _amountBMin Minimum amount of stablecoin (slippage)\n     */\n    function claim(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) external {\n        UserInfo memory user = users[msg.sender][_policyToken];\n\n        if (user.amountA + user.amountB == 0) revert ILM__NotEnoughDeposit();\n\n        address naughtyPair = pairs[_policyToken].naughtyPairAddress;\n        address lptoken = pairs[_policyToken].lptoken;\n\n        // Total liquidity owned by the pool\n        uint256 totalLiquidity = INaughtyPair(naughtyPair).balanceOf(\n            address(this)\n        );\n\n        // User's liquidity amount\n        uint256 userLiquidity = (LPToken(lptoken).balanceOf(msg.sender) *\n            totalLiquidity) / LPToken(lptoken).totalSupply();\n\n        _updateWhenClaim(_policyToken);\n\n        // Remove liquidity\n        (uint256 amountA, uint256 amountB) = INaughtyRouter(naughtyRouter)\n            .removeLiquidity(\n                _policyToken,\n                _stablecoin,\n                userLiquidity,\n                _amountAMin,\n                _amountBMin,\n                msg.sender,\n                block.timestamp + 60\n            );\n\n        delete users[msg.sender][_policyToken];\n\n        // Burn the user's lp tokens\n        LPToken(lptoken).burn(\n            msg.sender,\n            LPToken(lptoken).balanceOf(msg.sender)\n        );\n\n        emit Claim(msg.sender, amountA, amountB);\n    }\n\n    /**\n     * @notice Emergency withdraw a certain token\n     * @param _token Token address\n     * @param _amount Token amount\n     */\n    function emergencyWithdraw(address _token, uint256 _amount) external {\n        IERC20(_token).safeTransfer(owner(), _amount);\n\n        emit EmergencyWithdraw(owner(), _amount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy the new lp token for a round\n     * @param _name Name of the lp token\n     * @return lpTokenAddress Address of the lp token\n     */\n    function _deployLPToken(string memory _name) internal returns (address) {\n        address lpTokenAddress = address(\n            new LPToken(address(this), _name, _name)\n        );\n        return lpTokenAddress;\n    }\n\n    /**\n     * @notice Safely transfer tokens\n     * @param _token Token address\n     * @param _receiver Receiver address\n     * @param _amount Amount of tokens\n     * @return realAmount Real amount that is transferred\n     */\n    function _safeTokenTransfer(\n        address _token,\n        address _receiver,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        if (_amount > balance) {\n            IERC20(_token).safeTransfer(_receiver, balance);\n            return balance;\n        } else {\n            IERC20(_token).safeTransfer(_receiver, _amount);\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice Update debt & fee distribution\n     * @param _policyToken Policy token address\n     * @param _usdAmount Amount of stablecoins input\n     * @param _degAmount Amount of degis input\n     */\n    function _updateWhenDeposit(\n        address _policyToken,\n        uint256 _usdAmount,\n        uint256 _degAmount,\n        uint256 _decimalDiff\n    ) internal {\n        PairInfo storage pair = pairs[_policyToken];\n\n        // If this is the first user, accDegisPerShare = 1e16\n        // No debt\n        if (pair.degisAmount == 0) {\n            pair.accDegisPerShare =\n                (SCALE * 10**_decimalDiff) /\n                FEE_DENOMINATOR;\n            return;\n        }\n\n        UserInfo storage user = users[msg.sender][_policyToken];\n\n        // Update accDegisPerShare first\n        pair.accDegisPerShare +=\n            (_degAmount * SCALE) /\n            (pair.amountA + pair.amountB);\n\n        uint256 currentUserDeposit = user.amountA + user.amountB;\n        // If user has deposited before, distribute the deg reward first\n        // Pending reward is calculated with the new degisPerShare value\n        if (currentUserDeposit > 0) {\n            uint256 pendingReward = (currentUserDeposit *\n                pair.accDegisPerShare) /\n                SCALE -\n                user.degisDebt;\n\n            uint256 reward = _safeTokenTransfer(\n                degis,\n                msg.sender,\n                pendingReward\n            );\n            emit Harvest(msg.sender, reward);\n        }\n\n        // Update user debt\n        user.degisDebt =\n            (pair.accDegisPerShare * (currentUserDeposit + _usdAmount)) /\n            SCALE;\n    }\n\n    /**\n     * @notice Update degis reward when claim\n     * @param _policyToken Policy token address\n     */\n    function _updateWhenClaim(address _policyToken) internal {\n        PairInfo storage pair = pairs[_policyToken];\n\n        UserInfo storage user = users[msg.sender][_policyToken];\n\n        uint256 pendingReward = ((user.amountA + user.amountB) *\n            pair.accDegisPerShare) /\n            SCALE -\n            user.degisDebt;\n\n        uint256 reward = _safeTokenTransfer(degis, msg.sender, pendingReward);\n        emit Harvest(msg.sender, reward);\n    }\n}\n"
    },
    "contracts/naughty-price/interfaces/INaughtyRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\ninterface INaughtyRouter {\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityWithUSD(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function swapExactTokensforTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _tokenIn,\n        address _tokenOut,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/ILM/ILMToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ILMToken is ERC20 {\n    address public ILMContract;\n\n    constructor(\n        address _ILM,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        ILMContract = _ILM;\n    }\n\n    modifier onlyILM() {\n        require(msg.sender == ILMContract, \"Only ILM\");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) public onlyILM {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _to, uint256 _amount) public onlyILM {\n        _burn(_to, _amount);\n    }\n}\n"
    },
    "contracts/naughty-price/NaughtyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\nimport \"./NPPolicyToken.sol\";\nimport \"./NaughtyPair.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {INaughtyPair} from \"./interfaces/INaughtyPair.sol\";\nimport {IPolicyCore} from \"./interfaces/IPolicyCore.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title Naughty Factory\n * @dev Factory contract to deploy new pools periodically\n *      Each pool(product) will have a unique naughtyId\n *      Each pool will have its pool token\n *      PolicyToken - Stablecoin\n *      Token 0 may change but Token 1 is always stablecoin.\n */\n\ncontract NaughtyFactory is OwnableUpgradeable {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // INIT_CODE_HASH for NaughtyPair, may be used in frontend\n    bytes32 public constant PAIR_INIT_CODE_HASH =\n        keccak256(abi.encodePacked(type(NaughtyPair).creationCode));\n\n    // PolicyToken Address => StableCoin Address => Pool Address\n    mapping(address => mapping(address => address)) getPair;\n\n    // Store all the pairs' addresses\n    address[] public allPairs;\n\n    // Store all policy tokens' addresses\n    address[] public allTokens;\n\n    // Next pool id to be deployed\n    uint256 public _nextId;\n\n    // Address of policyCore\n    address public policyCore;\n\n    // Address of income maker, part of the transaction fee will be distributed to this address\n    address public incomeMaker;\n\n    // Swap fee proportion to income maker\n    uint256 public incomeMakerProportion;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PolicyCoreAddressChanged(\n        address oldPolicyCore,\n        address newPolicyCore\n    );\n    event IncomeMakerProportionChanged(\n        uint256 oldProportion,\n        uint256 newProportion\n    );\n    event IncomeMakerAddressChanged(\n        address oldIncomeMaker,\n        address newIncomeMaker\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize() public initializer {\n        __Ownable_init();\n        // 40% of swap fee is distributed to income maker contract\n        // Can be set later\n        incomeMakerProportion = 40;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Modifiers ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only called by policyCore contract\n     */\n    modifier onlyPolicyCore() {\n        require(msg.sender == policyCore, \"Only called by policyCore contract\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the all tokens that have been deployed\n     * @return tokens All tokens\n     */\n    function getAllTokens() external view returns (address[] memory) {\n        return allTokens;\n    }\n\n    /**\n     * @notice Get the INIT_CODE_HASH for policy tokens with parameters\n     * @dev For test/task convinience, pre-compute the address\n     *      Ethers.js:\n     *      Address = ethers.utils.getCreate2Address(factory address, salt, INIT_CODE_HASH)\n     *      salt = keccak256(abi.encodePacked(_policyTokenName))\n     * @param _tokenName Name of the policy token to be deployed\n     * @param _decimals Token decimals of this policy token\n     */\n    function getInitCodeHashForPolicyToken(\n        string memory _tokenName,\n        uint256 _decimals\n    ) public view returns (bytes32) {\n        bytes memory bytecode = _getPolicyTokenBytecode(_tokenName, _decimals);\n        return keccak256(bytecode);\n    }\n\n    /**\n     * @notice Get the pair address deployed by the factory\n     *         PolicyToken address first, and then stablecoin address\n     *         The order of the tokens will be sorted inside the function\n     * @param _tokenAddress1 Address of token1\n     * @param _tokenAddress2 Address of toekn2\n     * @return Pool address of the two tokens\n     */\n    function getPairAddress(address _tokenAddress1, address _tokenAddress2)\n        public\n        view\n        returns (address)\n    {\n        // Policy token address at the first place\n        (address token0, address token1) = IPolicyCore(policyCore)\n            .supportedStablecoin(_tokenAddress2)\n            ? (_tokenAddress1, _tokenAddress2)\n            : (_tokenAddress2, _tokenAddress1);\n\n        address _pairAddress = getPair[token0][token1];\n\n        return _pairAddress;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Set Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Remember to call this function to set the policyCore address\n     * @dev    Only callable by the owner\n     *         < PolicyCore should be the minter of policyToken >\n     *         < This process is done inside constructor >\n     * @param _policyCore Address of policyCore contract\n     */\n    function setPolicyCoreAddress(address _policyCore) external onlyOwner {\n        emit PolicyCoreAddressChanged(policyCore, _policyCore);\n        policyCore = _policyCore;\n    }\n\n    /**\n     * @notice Set income maker proportion\n     * @dev    Only callable by the owner\n     * @param _proportion New proportion to income maker contract\n     */\n    function setIncomeMakerProportion(uint256 _proportion) external onlyOwner {\n        emit IncomeMakerProportionChanged(incomeMakerProportion, _proportion);\n        incomeMakerProportion = _proportion;\n    }\n\n    /**\n     * @notice Set income maker address\n     * @dev Only callable by the owner\n     * @param _incomeMaker New income maker address\n     */\n    function setIncomeMakerAddress(address _incomeMaker) external onlyOwner {\n        emit IncomeMakerAddressChanged(incomeMaker, _incomeMaker);\n        incomeMaker = _incomeMaker;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice For each round we need to first create the policytoken(ERC20)\n     * @param _policyTokenName Name of the policyToken\n     * @param _decimals Decimals of the policyToken\n     * @return tokenAddress PolicyToken address\n     */\n    function deployPolicyToken(\n        string memory _policyTokenName,\n        uint256 _decimals\n    ) external onlyPolicyCore returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(_policyTokenName));\n\n        bytes memory bytecode = _getPolicyTokenBytecode(\n            _policyTokenName,\n            _decimals\n        );\n\n        address _policTokenAddress = _deploy(bytecode, salt);\n\n        allTokens.push(_policTokenAddress);\n\n        _nextId++;\n\n        return _policTokenAddress;\n    }\n\n    /**\n     * @notice After deploy the policytoken and get the address,\n     *         we deploy the policyToken - stablecoin pool contract\n     * @param _policyTokenAddress Address of policy token\n     * @param _stablecoin Address of the stable coin\n     * @param _deadline Deadline of the pool\n     * @param _feeRate Fee rate given to LP holders\n     * @return poolAddress Address of the pool\n     */\n    function deployPool(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) public onlyPolicyCore returns (address) {\n        bytes memory bytecode = type(NaughtyPair).creationCode;\n\n        bytes32 salt = keccak256(\n            abi.encodePacked(_policyTokenAddress, _stablecoin)\n        );\n\n        address _poolAddress = _deploy(bytecode, salt);\n\n        INaughtyPair(_poolAddress).initialize(\n            _policyTokenAddress,\n            _stablecoin,\n            _deadline,\n            _feeRate\n        );\n\n        getPair[_policyTokenAddress][_stablecoin] = _poolAddress;\n\n        allPairs.push(_poolAddress);\n\n        return _poolAddress;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy function with create2\n     * @param code Byte code of the contract (creation code)\n     * @param salt Salt for the deployment\n     * @return addr The deployed contract address\n     */\n    function _deploy(bytes memory code, bytes32 salt)\n        internal\n        returns (address addr)\n    {\n        assembly {\n            addr := create2(0, add(code, 0x20), mload(code), salt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Get the policyToken bytecode (with constructor parameters)\n     * @param _tokenName Name of policyToken\n     * @param _decimals Decimals of policyToken\n     */\n    function _getPolicyTokenBytecode(\n        string memory _tokenName,\n        uint256 _decimals\n    ) internal view returns (bytes memory) {\n        bytes memory bytecode = type(NPPolicyToken).creationCode;\n\n        // Encodepacked the parameters\n        // The minter is set to be the policyCore address\n        return\n            abi.encodePacked(\n                bytecode,\n                abi.encode(_tokenName, _tokenName, policyCore, _decimals)\n            );\n    }\n}\n"
    },
    "contracts/naughty-price/NPPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title  Policy Token for Naughty Price\n * @notice This is the contract for token price policy token.\n *         It is a ERC20 token with an owner and a minter.\n *         The owner should be the deployer at first.\n *         The minter should be the policyCore contract.\n * @dev    It is different from the flight delay token.\n *         That is an ERC721 NFT and this is an ERC20 token.\n */\ncontract NPPolicyToken is ERC20 {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    address public minter;\n\n    uint256 private tokenDecimals;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Mint(address account, uint256 amount);\n    event Burn(address account, uint256 amount);\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _minter,\n        uint256 _decimals\n    ) ERC20(_name, _symbol) {\n        minter = _minter;\n        tokenDecimals = _decimals;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Modifiers **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only the minter can mint\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"only minter can call this function\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint some policy tokens\n     * @param _account Address to receive the tokens\n     * @param _amount Amount to be minted\n     */\n    function mint(address _account, uint256 _amount) public onlyMinter {\n        _mint(_account, _amount);\n        emit Mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn some policy tokens\n     * @param _account Address to burn tokens\n     * @param _amount Amount to be burned\n     */\n    function burn(address _account, uint256 _amount) public onlyMinter {\n        _burn(_account, _amount);\n        emit Burn(_account, _amount);\n    }\n\n    /**\n     * @notice Get the decimals of this token\n     * @dev It should be the same as its paired stablecoin\n     */\n    function decimals() public view override returns (uint8) {\n        return uint8(tokenDecimals);\n    }\n}\n"
    },
    "contracts/tokens/Shield.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {IVeDEG} from \"../governance/interfaces/IVeDEG.sol\";\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title Shield Token (Derived Stablecoin on Degis)\n */\ncontract Shield is ERC20Upgradeable, OwnableUpgradeable {\n    IVeDEG veDEG;\n    mapping(address => bool) supportedStablecoin;\n    mapping(address => uint256) depositRatio;\n\n    function initialize() public initializer {\n        __ERC20_init(\"Shield Token\", \"SHD\");\n        __Ownable_init();\n    }\n\n    function addSupportedStablecoin(address _stablecoin, uint256 _ratio)\n        external\n        onlyOwner\n    {\n        require(_ratio >= 100, \"Deposit ratio must be greater than 100\");\n        supportedStablecoin[_stablecoin] = true;\n        depositRatio[_stablecoin] = _ratio;\n    }\n\n    function _getDiscount() internal {}\n\n    function _swap() internal {}\n\n    function deposit(address _stablecoin, uint256 _amount) external {}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/governance/interfaces/IVeDEG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./IVeERC20.sol\";\n\n/**\n * @dev Interface of the VePtp\n */\ninterface IVeDEG is IVeERC20 {\n    function isUser(address _addr) external view returns (bool);\n\n    function deposit(uint256 _amount) external;\n\n    function claim() external;\n\n    function withdraw(uint256 _amount) external;\n\n    function getStakedPtp(address _addr) external view returns (uint256);\n\n    function getVotes(address _account) external view returns (uint256);\n\n    function lockVeDEG(address _to, uint256 _amount) external;\n\n    function unlockVeDEG(address _to, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/governance/interfaces/IVeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IVeERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/income/IncomeSharingVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IVeDEG} from \"../governance/interfaces/IVeDEG.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title Degis Income Sharing Contract\n * @notice This contract will receive part of the income from Degis products\n *         And the income will be shared by DEG holders (in the form of veDEG)\n *\n *         It is designed to be an ever-lasting reward\n *\n *         At first the reward is USDC.e and later may be transferred to Shield\n *         To enter the income sharing vault, you need to lock some veDEG\n *             - When your veDEG is locked, it can not be withdrawed\n *\n *         The reward is distributed per second like a farming pool\n *         The income will come from (to be updated)\n *             - IncomeMaker: Collect swap fee in naughty price pool\n *             - PolicyCore: Collect deposit/redeem fee in policy core\n */\ncontract IncomeSharingVault is\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 public constant SCALE = 1e30;\n\n    uint256 public roundTime;\n\n    IVeDEG public veDEG;\n\n    struct PoolInfo {\n        bool available;\n        address rewardToken;\n        uint256 totalAmount;\n        uint256 rewardPerSecond;\n        uint256 accRewardPerShare;\n        uint256 lastRewardTimestamp;\n    }\n    // Pool Id\n    // 1: USDC.e as reward\n    // 2: Shield as reward\n    mapping(uint256 => PoolInfo) public pools;\n\n    struct UserInfo {\n        uint256 totalAmount;\n        uint256 rewardDebt;\n    }\n    mapping(uint256 => mapping(address => UserInfo)) public users;\n\n    uint256 public nextPool;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event RoundTimeChanged(uint256 oldRoundTime, uint256 newRoundTime);\n    event NewRewardPoolStart(uint256 poolId, address rewardToken);\n    event RewardSpeedSet(uint256 poolId, uint256 rewardPerSecond);\n    event PoolUpdated(uint256 poolId, uint256 accRewardPerSecond);\n    event Harvest(address user, uint256 poolId, uint256 amount);\n    event Deposit(address user, uint256 poolId, uint256 amount);\n    event Withdraw(address user, uint256 poolId, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Errors start with DIS(Degis Income Sharing)\n    error DIS__PoolNotAvailable();\n    error DIS__ZeroAmount();\n    error DIS__NotEnoughVeDEG();\n    error DIS__WrongSpeed();\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _veDEG) public initializer {\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        veDEG = IVeDEG(_veDEG);\n\n        nextPool = 1;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Pending reward\n     * @param _poolId Pool Id\n     * @param _user User address\n     * @return pendingReward Amount of pending reward\n     */\n    function pendingReward(uint256 _poolId, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo memory pool = pools[_poolId];\n\n        if (\n            pool.lastRewardTimestamp == 0 ||\n            block.timestamp < pool.lastRewardTimestamp\n        ) return 0;\n\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n\n        if (pool.totalAmount == 0) return 0;\n        else {\n            UserInfo memory user = users[_poolId][_user];\n\n            uint256 timePassed = block.timestamp - pool.lastRewardTimestamp;\n            uint256 reward = timePassed * pool.rewardPerSecond;\n\n            console.log(\"reward\", reward);\n\n            // Remainging reward inside the pool\n            uint256 remainingReward = IERC20(pool.rewardToken).balanceOf(\n                address(this)\n            );\n\n            console.log(\"remaining reward\", remainingReward);\n\n            uint256 finalReward = reward > remainingReward\n                ? remainingReward\n                : reward;\n\n            accRewardPerShare += (finalReward * SCALE) / pool.totalAmount;\n\n            uint256 pending = (user.totalAmount * accRewardPerShare) /\n                SCALE -\n                user.rewardDebt;\n\n            return pending;\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set round time\n     * @dev Round time is only used for checking reward speed\n     * @param _roundTime Round time in seconds\n     */\n    function setRoundTime(uint256 _roundTime) external onlyOwner {\n        emit RoundTimeChanged(roundTime, _roundTime);\n        roundTime = _roundTime;\n    }\n\n    /**\n     * @notice Start a new income sharing pool\n     * @dev Normally there will be two pools\n     *          - USDC.e as reward (1)\n     *          - Shield as reward (2)\n     * @param _rewardToken Reward token address\n     */\n    function startPool(address _rewardToken) external onlyOwner {\n        PoolInfo storage pool = pools[nextPool++];\n\n        pool.available = true;\n        pool.rewardToken = _rewardToken;\n\n        emit NewRewardPoolStart(nextPool - 1, _rewardToken);\n    }\n\n    /**\n     * @notice Set reward speed for a pool\n     * @param _poolId Pool id\n     * @param _rewardPerSecond Reward speed\n     */\n    function setRewardSpeed(uint256 _poolId, uint256 _rewardPerSecond)\n        external\n    {\n        updatePool(_poolId);\n\n        PoolInfo memory pool = pools[_poolId];\n\n        // Ensure there is enough reward for this round\n        if (\n            roundTime * _rewardPerSecond >\n            IERC20(pool.rewardToken).balanceOf(address(this))\n        ) revert DIS__WrongSpeed();\n\n        pools[_poolId].rewardPerSecond = _rewardPerSecond;\n\n        emit RewardSpeedSet(_poolId, _rewardPerSecond);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deposit\n     * @param _poolId Pool Id\n     * @param _amount Amount of tokens to deposit\n     */\n    function deposit(uint256 _poolId, uint256 _amount) external nonReentrant {\n        if (!pools[_poolId].available) revert DIS__PoolNotAvailable();\n        if (_amount == 0) revert DIS__ZeroAmount();\n        if (veDEG.balanceOf(msg.sender) < _amount) revert DIS__NotEnoughVeDEG();\n\n        updatePool(_poolId);\n\n        // Lock some veDEG to participate\n        veDEG.lockVeDEG(msg.sender, _amount);\n\n        PoolInfo storage pool = pools[_poolId];\n        UserInfo storage user = users[_poolId][msg.sender];\n\n        if (user.totalAmount > 0) {\n            uint256 pending = (pool.accRewardPerShare * user.totalAmount) /\n                SCALE -\n                user.rewardDebt;\n\n            uint256 reward = _safeRewardTransfer(\n                pool.rewardToken,\n                msg.sender,\n                pending\n            );\n            emit Harvest(msg.sender, _poolId, reward);\n        }\n\n        // Update pool amount\n        pool.totalAmount += _amount;\n\n        // Update user amount\n        user.totalAmount += _amount;\n\n        user.rewardDebt = (pool.accRewardPerShare * user.totalAmount) / SCALE;\n\n        emit Deposit(msg.sender, _poolId, _amount);\n    }\n\n    /**\n     * @notice Withdraw all veDEG\n     * @param _poolId Pool Id\n     */\n    function withdrawAll(uint256 _poolId) external {\n        withdraw(_poolId, users[_poolId][msg.sender].totalAmount);\n    }\n\n    /**\n     * @notice Withdraw the reward from the pool\n     * @param _poolId Pool Id\n     * @param _amount Amount to withdraw\n     */\n    function withdraw(uint256 _poolId, uint256 _amount) public nonReentrant {\n        if (_amount == 0) revert DIS__ZeroAmount();\n\n        PoolInfo storage pool = pools[_poolId];\n        UserInfo storage user = users[_poolId][msg.sender];\n\n        if (user.totalAmount < _amount) revert DIS__NotEnoughVeDEG();\n\n        updatePool(_poolId);\n\n        uint256 pending = (pool.accRewardPerShare * user.totalAmount) /\n            SCALE -\n            user.rewardDebt;\n\n        uint256 reward = _safeRewardTransfer(\n            pool.rewardToken,\n            msg.sender,\n            pending\n        );\n        emit Harvest(msg.sender, _poolId, reward);\n\n        // Update user info\n        pool.totalAmount -= _amount;\n\n        user.totalAmount -= _amount;\n        user.rewardDebt = (user.totalAmount * pool.accRewardPerShare) / SCALE;\n\n        // Unlock veDEG\n        veDEG.unlockVeDEG(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _poolId, _amount);\n    }\n\n    /**\n     * @notice Harvest income reward\n     * @param _poolId Pool Id\n     * @param _to Reward receiver address\n     */\n    function harvest(uint256 _poolId, address _to)\n        public\n        nonReentrant\n        whenNotPaused\n    {\n        updatePool(_poolId);\n\n        PoolInfo memory pool = pools[_poolId];\n        UserInfo storage user = users[_poolId][msg.sender];\n\n        // pending reward\n        uint256 pending = (user.totalAmount * pool.accRewardPerShare) /\n            SCALE -\n            user.rewardDebt;\n\n        user.rewardDebt = (user.totalAmount * pool.accRewardPerShare) / SCALE;\n\n        uint256 reward = _safeRewardTransfer(pool.rewardToken, _to, pending);\n\n        emit Harvest(msg.sender, _poolId, reward);\n    }\n\n    /**\n     * @notice Update pool\n     * @param _poolId Pool id\n     */\n    function updatePool(uint256 _poolId) public {\n        PoolInfo storage pool = pools[_poolId];\n\n        if (block.timestamp <= pool.lastRewardTimestamp) return;\n\n        uint256 totalAmount = pool.totalAmount;\n        uint256 rewardPerSecond = pool.rewardPerSecond;\n\n        if (totalAmount == 0 || rewardPerSecond == 0) {\n            pool.lastRewardTimestamp = block.timestamp;\n            return;\n        }\n\n        // Time passed in seconds and total rewards\n        uint256 timePassed = block.timestamp - pool.lastRewardTimestamp;\n        uint256 reward = timePassed * rewardPerSecond;\n\n        // Remainging reward inside the pool\n        uint256 remainingReward = IERC20(pool.rewardToken).balanceOf(\n            address(this)\n        ) ;\n\n        // Can not exceed the max balance of the pool\n        uint256 finalReward = reward > remainingReward\n            ? remainingReward\n            : reward;\n\n        pool.accRewardPerShare += (finalReward * SCALE) / totalAmount;\n\n        pool.lastRewardTimestamp = block.timestamp;\n\n        emit PoolUpdated(_poolId, pool.accRewardPerShare);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Finish the reward token transfer\n     * @dev Safe means not transfer exceeds the balance of contract\n     *      Manually change the reward speed\n     * @param _to Address to transfer\n     * @param _amount Amount to transfer\n     * @return realAmount Real amount transferred\n     */\n    function _safeRewardTransfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        if (_amount > balance) {\n            IERC20(_token).safeTransfer(_to, balance);\n            return balance;\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n            return _amount;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/governance/VoteEscrowedDegis.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {VeERC20Upgradeable} from \"./VeERC20Upgradeable.sol\";\nimport {Math} from \"../libraries/Math.sol\";\n\nimport {IFarmingPool} from \"../farming/interfaces/IFarmingPool.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title Vote Escrowed Degis\n * @notice The staking contract for DEG -> veDEG\n *         veDEG:\n *            - Boosting the farming reward\n *            - Governance\n *            - Participate in Initial Liquidity Matching (naughty price)\n *            - etc.\n *         If you stake degis, you generate veDEG at the current `generationRate` until you reach `maxCap`\n *         If you unstake any amount of degis, you will lose all of your veDEG tokens\n *\n *         There is also an option that you lock your DEG for the max time\n *         and get the maximum veDEG balance immediately.\n *         !! Attention !!\n *         If you stake DEG for the max time for more than once, the lockUntil timestamp will\n *         be updated to the latest one.\n */\ncontract VoteEscrowedDegis is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    VeERC20Upgradeable\n{\n    using SafeERC20 for IERC20;\n\n    struct UserInfo {\n        // degis staked by user\n        uint256 amount;\n        // time of last veDEG claim or first deposit if user has not claimed yet\n        uint256 lastRelease;\n        // Amount locked for max time\n        uint256 amountLocked;\n        // Lock until timestamp\n        uint256 lockUntil;\n    }\n\n    // User info\n    mapping(address => UserInfo) public users;\n\n    // Degis token\n    // IERC20 public constant degis =\n    //     IERC20(0x9f285507Ea5B4F33822CA7aBb5EC8953ce37A645);\n    IERC20 public degis;\n\n    // Farming pool\n    IFarmingPool public farmingPool;\n\n    // Max veDEG to staked degis ratio\n    // Max veDEG amount = maxCap * degis staked\n    uint256 public maxCapRatio;\n\n    // Rate of veDEG generated per second, per degis staked\n    uint256 public generationRate;\n\n    // Calculation scale\n    uint256 public constant SCALE = 1e18;\n\n    // Whitelist contract checker\n    // Contract addresses are by default unable to stake degis, they must be whitelisted\n    mapping(address => bool) whitelist;\n\n    // Locked amount\n    mapping(address => uint256) public locked;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event GenerationRateChanged(uint256 oldRate, uint256 newRate);\n    event MaxCapRatioChanged(uint256 oldMaxCapRatio, uint256 newMaxCapRatio);\n    event WhiteListAdded(address newWhiteList);\n    event WhiteListRemoved(address oldWhiteList);\n\n    event Deposit(address indexed user, uint256 amount);\n    event DepositMaxTime(\n        address indexed user,\n        uint256 amount,\n        uint256 lockUntil\n    );\n    event Withdraw(address indexed user, uint256 amount);\n\n    event Claimed(address indexed user, uint256 amount);\n\n    event BurnVeDEG(\n        address indexed caller,\n        address indexed user,\n        uint256 amount\n    );\n\n    event LockVeDEG(\n        address indexed caller,\n        address indexed user,\n        uint256 amount\n    );\n\n    event UnlockVeDEG(\n        address indexed caller,\n        address indexed user,\n        uint256 amount\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error VED__NotWhiteListed();\n    error VED__StillLocked();\n    error VED__ZeroAddress();\n    error VED__ZeroAmount();\n    error VED__NotEnoughBalance();\n\n    error VED__TimeNotPassed();\n    error VED__OverLocked();\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _degis, address _farmingPool)\n        public\n        initializer\n    {\n        if (_degis == address(0) || _farmingPool == address(0))\n            revert VED__ZeroAddress();\n\n        // Initialize veDEG\n        __ERC20_init(\"Vote Escrowed Degis\", \"veDEG\");\n        __Ownable_init();\n        __ReentrancyGuard_init_unchained();\n        __Pausable_init_unchained();\n\n        // Set generationRate (veDEG per sec per degis staked)\n        generationRate = 10**18;\n\n        // Set maxCap ratio\n        maxCapRatio = 100;\n\n        // Set degis\n        degis = IERC20(_degis);\n\n        // Set farming pool\n        farmingPool = IFarmingPool(_farmingPool);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier notContract(address _addr) {\n        if (_addr != tx.origin) {\n            if (!whitelist[_addr]) revert VED__NotWhiteListed();\n        }\n        _;\n    }\n\n    modifier noLocked(address _user) {\n        if (locked[_user] > 0) revert VED__StillLocked();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Calculate the amount of veDEG that can be claimed by user\n     * @param _user User address\n     */\n    function claimable(address _user) public view returns (uint256) {\n        if (_user == address(0)) revert VED__ZeroAddress();\n\n        UserInfo memory user = users[_user];\n\n        // Seconds passed since last claim\n        uint256 timePassed = block.timestamp - user.lastRelease;\n\n        // calculate pending amount\n        uint256 pending = Math.wmul(user.amount, timePassed * generationRate);\n\n        // get user's veDEG balance\n        uint256 userVeDEGBalance = balanceOf(_user) -\n            user.amountLocked *\n            maxCapRatio;\n\n        // user veDEG balance cannot go above user.amount * maxCap\n        uint256 veDEGCap = user.amount * maxCapRatio;\n\n        // first, check that user hasn't reached the max limit yet\n        if (userVeDEGBalance < veDEGCap) {\n            // then, check if pending amount will make user balance overpass maximum amount\n            if (userVeDEGBalance + pending > veDEGCap) {\n                return veDEGCap - userVeDEGBalance;\n            } else {\n                return pending;\n            }\n        }\n        return 0;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Add a new whitelist address\n     * @param _account Address to add\n     */\n    function addWhitelist(address _account) external onlyOwner {\n        whitelist[_account] = true;\n        emit WhiteListAdded(_account);\n    }\n\n    /**\n     * @notice Remove a new whitelist address\n     * @param _account Address to remove\n     */\n    function removeWhitelist(address _account) external onlyOwner {\n        whitelist[_account] = false;\n        emit WhiteListRemoved(_account);\n    }\n\n    /**\n     * @notice Set maxCap ratio\n     * @param _maxCapRatio the new max ratio\n     */\n    function setMaxCapRatio(uint256 _maxCapRatio) external onlyOwner {\n        if (_maxCapRatio == 0) revert VED__ZeroAmount();\n        emit MaxCapRatioChanged(maxCapRatio, _maxCapRatio);\n        maxCapRatio = _maxCapRatio;\n    }\n\n    /**\n     * @notice Set generationRate\n     * @param _generationRate New generation rate\n     */\n    function setGenerationRate(uint256 _generationRate) external onlyOwner {\n        if (_generationRate == 0) revert VED__ZeroAmount();\n        emit GenerationRateChanged(generationRate, _generationRate);\n        generationRate = _generationRate;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Depisit degis for veDEG\n     * @dev Only EOA or whitelisted contract address\n     * @param _amount Amount to deposit\n     */\n    function deposit(uint256 _amount)\n        external\n        nonReentrant\n        whenNotPaused\n        notContract(msg.sender)\n    {\n        if (_amount == 0) revert VED__ZeroAmount();\n\n        if (users[msg.sender].amount > 0) {\n            // If the user has amount deposited, claim veDEG\n            _claim(msg.sender);\n\n            // Update the amount\n            users[msg.sender].amount += _amount;\n        } else {\n            // add new user to mapping\n            users[msg.sender].lastRelease = block.timestamp;\n            users[msg.sender].amount = _amount;\n        }\n\n        // Request degis from user\n        degis.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Deposit for the max time\n     * @dev Release the max amount one time\n     */\n    function depositMaxTime(uint256 _amount)\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        if (_amount == 0) revert VED__ZeroAmount();\n\n        uint256 currentMaxTime = (maxCapRatio * SCALE) / generationRate;\n        uint256 lockUntil = block.timestamp + currentMaxTime * 2;\n\n        users[msg.sender].amountLocked += _amount;\n        users[msg.sender].lockUntil = lockUntil;\n\n        // Request degis from user\n        degis.safeTransferFrom(msg.sender, address(this), _amount);\n\n        _mint(msg.sender, maxCapRatio * _amount);\n\n        emit DepositMaxTime(msg.sender, _amount, lockUntil);\n    }\n\n    /**\n     * @notice Claims accumulated veDEG for flex deposit\n     */\n    function claim() public nonReentrant whenNotPaused {\n        if (users[msg.sender].amount == 0) revert VED__ZeroAmount();\n\n        _claim(msg.sender);\n    }\n\n    /**\n     * @notice Withdraw degis token\n     * @dev User will lose all veDEG once he withdrawed\n     * @param _amount Amount to withdraw\n     */\n    function withdraw(uint256 _amount)\n        external\n        nonReentrant\n        whenNotPaused\n        noLocked(msg.sender)\n    {\n        if (_amount == 0) revert VED__ZeroAmount();\n        if (users[msg.sender].amount < _amount) revert VED__NotEnoughBalance();\n\n        // reset last Release timestamp\n        users[msg.sender].lastRelease = block.timestamp;\n\n        // update his balance before burning or sending back degis\n        users[msg.sender].amount -= _amount;\n\n        // get user veDEG balance that must be burned\n        // those locked amount will not be calculated\n        uint256 userVeDEGBalance = balanceOf(msg.sender) -\n            users[msg.sender].amountLocked *\n            maxCapRatio;\n\n        _burn(msg.sender, userVeDEGBalance);\n\n        // send back the staked degis\n        degis.safeTransfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw all the locked veDEG\n     */\n    function withdrawLocked()\n        external\n        nonReentrant\n        whenNotPaused\n        noLocked(msg.sender)\n    {\n        UserInfo memory user = users[msg.sender];\n        \n        if (user.amountLocked == 0) revert VED__ZeroAmount();\n        if (block.timestamp < user.lockUntil) revert VED__TimeNotPassed();\n\n        _burn(msg.sender, user.amountLocked * maxCapRatio);\n\n        // update his balance before burning or sending back degis\n        users[msg.sender].amountLocked = 0;\n        users[msg.sender].lockUntil = 0;\n\n        // send back the staked degis\n        degis.safeTransfer(msg.sender, user.amountLocked);\n    }\n\n    /**\n     * @notice Lock veDEG token\n     * @dev Only whitelisted contract\n     *      Income sharing contract will lock veDEG as entrance\n     * @param _to User address\n     * @param _amount Amount to lock\n     */\n    function lockVeDEG(address _to, uint256 _amount) external {\n        // Only whitelisted contract can lock veDEG\n        if (!whitelist[msg.sender]) revert VED__NotWhiteListed();\n\n        if (locked[_to] + _amount > balanceOf(_to)) revert VED__OverLocked();\n\n        _lock(_to, _amount);\n        emit LockVeDEG(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice Unlock veDEG token\n     * @param _to User address\n     * @param _amount Amount to unlock\n     */\n    function unlockVeDEG(address _to, uint256 _amount) external {\n        // Only whitelisted contract can unlock veDEG\n        if (!whitelist[msg.sender]) revert VED__NotWhiteListed();\n\n        if (locked[_to] < _amount) revert VED__OverLocked();\n\n        _unlock(_to, _amount);\n        emit UnlockVeDEG(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice Burn veDEG\n     * @dev Only whitelisted contract\n     *      For future use, some contracts may need veDEG for entrance\n     * @param _to Address to burn\n     * @param _amount Amount to burn\n     */\n    function burnVeDEG(address _to, uint256 _amount) public {\n        // Only whitelisted contract can burn veDEG\n        if (!whitelist[msg.sender]) revert VED__NotWhiteListed();\n\n        _burn(_to, _amount);\n        emit BurnVeDEG(msg.sender, _to, _amount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Finish claiming veDEG\n     * @param _user User address\n     */\n    function _claim(address _user) internal {\n        uint256 amount = claimable(_user);\n\n        // update last release time\n        users[_user].lastRelease = block.timestamp;\n\n        if (amount > 0) {\n            emit Claimed(_user, amount);\n            _mint(_user, amount);\n        }\n    }\n\n    /**\n     * @notice Update the bonus in farming pool\n     * @dev Every time when token is transferred (balance change)\n     * @param _user User address\n     * @param _newBalance New veDEG balance\n     */\n    function _afterTokenOperation(address _user, uint256 _newBalance)\n        internal\n        override\n    {\n        farmingPool.updateBonus(_user, _newBalance);\n    }\n\n    /**\n     * @notice Lock veDEG token\n     * @param _to User address\n     * @param _amount Amount to lock\n     */\n    function _lock(address _to, uint256 _amount) internal {\n        locked[_to] += _amount;\n    }\n\n    /**\n     * @notice Unlock veDEG token\n     * @param _to User address\n     * @param _amount Amount to unlock\n     */\n    function _unlock(address _to, uint256 _amount) internal {\n        if (locked[_to] < _amount) revert VED__NotEnoughBalance();\n        locked[_to] -= _amount;\n    }\n}\n"
    },
    "contracts/governance/VeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IVeERC20.sol\";\n\n/// @title VeERC20Upgradeable\n/// @notice Modified version of ERC20Upgradeable where transfers and allowances are disabled.\n/// @dev only minting and burning are allowed. The hook _afterTokenOperation is called after Minting and Burning.\ncontract VeERC20Upgradeable is Initializable, ContextUpgradeable, IVeERC20 {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Emitted when `value` tokens are burned and minted\n     */\n    event Burn(address indexed account, uint256 value);\n    event Mint(address indexed beneficiary, uint256 value);\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Mint(account, amount);\n\n        _afterTokenOperation(account, _balances[account]);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Burn(account, amount);\n\n        _afterTokenOperation(account, _balances[account]);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any minting and burning.\n     * @param account the account being affected\n     * @param newBalance newBalance after operation\n     */\n    function _afterTokenOperation(address account, uint256 newBalance)\n        internal\n        virtual\n    {}\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/farming/interfaces/IFarmingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IFarmingPool {\n    function pendingDegis(uint256 _poolId, address _user)\n        external\n        returns (uint256);\n\n    function setStartBlock(uint256 _startBlock) external;\n\n    function add(\n        address _lpToken,\n        uint256 _poolId,\n        bool _withUpdate\n    ) external;\n\n    function setDegisReward(\n        uint256 _poolId,\n        uint256 _basicDegisPerBlock,\n        uint256 _bonusDegisPerBlock,\n        bool _withUpdate\n    ) external;\n\n    function stake(uint256 _poolId, uint256 _amount) external;\n\n    function withdraw(uint256 _poolId, uint256 _amount) external;\n\n    function updatePool(uint256 _poolId) external;\n\n    function massUpdatePools() external;\n\n    function harvest(uint256 _poolId, address _to) external;\n\n    function updateBonus(address _user, uint256 _newBalance) external;\n}\n"
    },
    "contracts/farming/FarmingPoolUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IDegisToken} from \"../tokens/interfaces/IDegisToken.sol\";\nimport {Math} from \"../libraries/Math.sol\";\nimport {IVeDEG} from \"../governance/interfaces/IVeDEG.sol\";\n\n/**\n * @title  Farming Pool\n * @notice This contract is for LPToken mining on Degis\n * @dev    The pool id starts from 1 rather than 0\n *         The degis reward is calculated by timestamp rather than block number\n *\n *         VeDEG will boost the farming speed by having a extra reward type\n *         The extra reward is shared by those staking lptokens with veDEG balances\n *         Every time the veDEG balance change, the reward will be updated\n *\n *         The basic reward depends on the liquidity inside the pool\n *         Update with a piecewise function\n *         liquidity amount:   |---------------|------------------|----------------\n *                             0           threshold 1        threshold 2\n *          reward speed:            speed1          speed2             speed3\n *\n *         The speed update will be updated one tx after the last tx that triggers the threshold\n *         The reward update will be another one tx later\n */\ncontract FarmingPoolUpgradeable is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IDegisToken;\n    using Math for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    string public constant name = \"Degis LP Farming Pool\";\n\n    // The reward token is degis\n    IDegisToken public degis;\n\n    // The bonus reward depends on veDEG\n    IVeDEG public veDEG;\n\n    // SCALE/Precision used for calculating rewards\n    uint256 public constant SCALE = 1e12;\n\n    // PoolId starts from 1\n    uint256 public _nextPoolId;\n\n    // Farming starts from a certain block timestamp\n    // To keep the same with naughty price pools, we change from block numbers to timestamps\n    uint256 public startTimestamp;\n\n    struct PoolInfo {\n        address lpToken; // LPToken address\n        uint256 basicDegisPerSecond; // Basic Reward speed\n        uint256 bonusDegisPerSecond; // Bonus reward speed\n        uint256 lastRewardTimestamp; // Last reward timestamp\n        uint256 accDegisPerShare; // Accumulated degis per share (for those without veDEG boosting)\n        uint256 accDegisPerBonusShare; // Accumulated degis per bonus share (for those with veDEG boosting)\n        uint256 totalBonus; // Total bonus factors\n    }\n    PoolInfo[] public poolList;\n\n    // lptoken address => poolId\n    mapping(address => uint256) public poolMapping;\n\n    // poolId => alreadyFarming\n    mapping(uint256 => bool) public isFarming;\n\n    struct UserInfo {\n        uint256 rewardDebt; // degis reward debt\n        uint256 stakingBalance; // the amount of a user's staking in the pool\n        uint256 bonus; // user bonus point (by veDEG balance)\n    }\n    // poolId => userAddress => userInfo\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    // Extra claimable balance when updating bonus from veDEG\n    mapping(uint256 => mapping(address => uint256)) public extraClaimable;\n\n    // Reward speed change with liquidity inside contract\n    mapping(uint256 => uint256[]) public thresholdBasic;\n    mapping(uint256 => uint256[]) public piecewiseBasic;\n    uint256 public currentRewardLevel;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event StartTimestampChanged(uint256 startTimestamp);\n    event Stake(address staker, uint256 poolId, uint256 amount);\n    event Withdraw(address staker, uint256 poolId, uint256 amount);\n    event Harvest(\n        address staker,\n        address rewardReceiver,\n        uint256 poolId,\n        uint256 pendingReward\n    );\n    event NewPoolAdded(\n        address lpToken,\n        uint256 basicDegisPerSecond,\n        uint256 bonusDegisPerSecond\n    );\n    event FarmingPoolStarted(uint256 poolId, uint256 timestamp);\n    event FarmingPoolStopped(uint256 poolId, uint256 timestamp);\n    event DegisRewardChanged(\n        uint256 poolId,\n        uint256 basicDegisPerSecond,\n        uint256 bonusDegisPerSecond\n    );\n    event PoolUpdated(\n        uint256 poolId,\n        uint256 accDegisPerShare,\n        uint256 accDegisPerBonusShare\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _degis) public initializer {\n        require(_degis != address(0), \"Zero address\");\n\n        __Ownable_init();\n        __ReentrancyGuard_init_unchained();\n        __Pausable_init_unchained();\n\n        degis = IDegisToken(_degis);\n\n        // Start from 1\n        _nextPoolId = 1;\n\n        poolList.push(\n            PoolInfo({\n                lpToken: address(0),\n                basicDegisPerSecond: 0,\n                bonusDegisPerSecond: 0,\n                lastRewardTimestamp: 0,\n                accDegisPerShare: 0,\n                accDegisPerBonusShare: 0,\n                totalBonus: 0\n            })\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice The address can not be zero\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    /**\n     * @notice The pool is still in farming\n     */\n    modifier stillFarming(uint256 _poolId) {\n        require(isFarming[_poolId], \"Pool is not farming\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** View Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check the amount of pending degis reward\n     * @param _poolId PoolId of this farming pool\n     * @param _user User address\n     * @return pendingDegisAmount Amount of pending degis\n     */\n    function pendingDegis(uint256 _poolId, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo memory poolInfo = poolList[_poolId];\n\n        if (\n            poolInfo.lastRewardTimestamp == 0 ||\n            block.timestamp < poolInfo.lastRewardTimestamp ||\n            block.timestamp < startTimestamp\n        ) return 0;\n\n        UserInfo memory user = userInfo[_poolId][_user];\n\n        // Total lp token balance\n        uint256 lp_balance = IERC20(poolInfo.lpToken).balanceOf(address(this));\n\n        // Accumulated shares to be calculated\n        uint256 accDegisPerShare = poolInfo.accDegisPerShare;\n        uint256 accDegisPerBonusShare = poolInfo.accDegisPerBonusShare;\n\n        if (lp_balance == 0) return 0;\n        else {\n            // If the pool is still farming, update the info\n            if (isFarming[_poolId]) {\n                // Deigs amount given to this pool\n                uint256 timePassed = block.timestamp -\n                    poolInfo.lastRewardTimestamp;\n                uint256 basicReward = poolInfo.basicDegisPerSecond * timePassed;\n                // Update accDegisPerShare\n                // LPToken may have different decimals\n                accDegisPerShare += (basicReward * SCALE) / lp_balance;\n\n                // If there is any bonus reward\n                if (poolInfo.totalBonus > 0) {\n                    uint256 bonusReward = poolInfo.bonusDegisPerSecond *\n                        timePassed;\n                    accDegisPerBonusShare +=\n                        (bonusReward * SCALE) /\n                        poolInfo.totalBonus;\n                }\n            }\n\n            // If the pool has stopped, not update the info\n            uint256 pending = (user.stakingBalance *\n                accDegisPerShare +\n                user.bonus *\n                accDegisPerBonusShare) /\n                SCALE +\n                extraClaimable[_poolId][_user] -\n                user.rewardDebt;\n\n            return pending;\n        }\n    }\n\n    /**\n     * @notice Get the total pool list\n     * @return pooList Total pool list\n     */\n    function getPoolList() external view returns (PoolInfo[] memory) {\n        return poolList;\n    }\n\n    /**\n     * @notice Get a user's balance\n     * @param _poolId Id of the pool\n     * @param _user User address\n     * @return balance User's balance (lpToken)\n     */\n    function getUserBalance(uint256 _poolId, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        return userInfo[_poolId][_user].stakingBalance;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Set Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setVeDEG(address _veDEG) external onlyOwner {\n        veDEG = IVeDEG(_veDEG);\n    }\n\n    /**\n     * @notice Set the start block timestamp\n     * @param _startTimestamp New start block timestamp\n     */\n    function setStartTimestamp(uint256 _startTimestamp)\n        external\n        onlyOwner\n        whenNotPaused\n    {\n        // Can only be set before any pool is added\n        require(\n            _nextPoolId == 1,\n            \"Can not set start timestamp after adding a pool\"\n        );\n\n        startTimestamp = _startTimestamp;\n        emit StartTimestampChanged(_startTimestamp);\n    }\n\n    /**\n     * @notice Set piecewise reward and threshold\n     * @param _poolId Id of the pool\n     * @param _threshold Piecewise threshold\n     * @param _reward Piecewise reward\n     */\n    function setPiecewise(\n        uint256 _poolId,\n        uint256[] calldata _threshold,\n        uint256[] calldata _reward\n    ) external onlyOwner {\n        thresholdBasic[_poolId] = _threshold;\n        piecewiseBasic[_poolId] = _reward;\n\n        // If reward for mimimum level is > 0, update isFarming\n        if (_reward[0] > 0) isFarming[_poolId] = true;\n        else isFarming[_poolId] = false;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new lp into the pool\n     * @dev Can only be called by the owner\n     *      The reward speed can be 0 and set later by setDegisReward function\n     * @param _lpToken LP token address\n     * @param _basicDegisPerSecond Basic reward speed(per second) for this new pool\n     * @param _bonusDegisPerSecond Bonus reward speed(per second) for this new pool\n     * @param _withUpdate Whether update all pools' status\n     */\n    function add(\n        address _lpToken,\n        uint256 _basicDegisPerSecond,\n        uint256 _bonusDegisPerSecond,\n        bool _withUpdate\n    ) public notZeroAddress(_lpToken) onlyOwner whenNotPaused {\n        // Check if already exists, if the poolId is 0, that means not in the pool\n        require(!_alreadyInPool(_lpToken), \"Already in the pool\");\n\n        if (_bonusDegisPerSecond > 0)\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\n\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n\n        uint256 lastRewardTimestamp = block.timestamp > startTimestamp\n            ? block.timestamp\n            : startTimestamp;\n\n        // Push this new pool into the list\n        poolList.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                basicDegisPerSecond: _basicDegisPerSecond,\n                bonusDegisPerSecond: _bonusDegisPerSecond,\n                lastRewardTimestamp: lastRewardTimestamp,\n                accDegisPerShare: 0,\n                accDegisPerBonusShare: 0,\n                totalBonus: 0\n            })\n        );\n\n        // Store the poolId and set the farming status to true\n        if (_basicDegisPerSecond > 0) isFarming[_nextPoolId] = true;\n\n        poolMapping[_lpToken] = _nextPoolId++;\n\n        emit NewPoolAdded(_lpToken, _basicDegisPerSecond, _bonusDegisPerSecond);\n    }\n\n    /**\n     * @notice Update the degisPerSecond for a specific pool (set to 0 to stop farming)\n     * @param _poolId Id of the farming pool\n     * @param _basicDegisPerSecond New basic reward amount per second\n     * @param _bonusDegisPerSecond New bonus reward amount per second\n     * @param _withUpdate Whether update all pools\n     */\n    function setDegisReward(\n        uint256 _poolId,\n        uint256 _basicDegisPerSecond,\n        uint256 _bonusDegisPerSecond,\n        bool _withUpdate\n    ) public onlyOwner whenNotPaused {\n        // Ensure there already exists this pool\n        require(poolList[_poolId].lastRewardTimestamp != 0, \"Pool not exists\");\n\n        if (_bonusDegisPerSecond > 0)\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\n\n        if (_withUpdate) massUpdatePools();\n        else updatePool(_poolId);\n\n        // Not farming now + reward > 0 => Restart\n        if (isFarming[_poolId] == false && _basicDegisPerSecond > 0) {\n            isFarming[_poolId] = true;\n            emit FarmingPoolStarted(_poolId, block.timestamp);\n        }\n\n        if (_basicDegisPerSecond == 0) {\n            isFarming[_poolId] = false;\n            emit FarmingPoolStopped(_poolId, block.timestamp);\n        } else {\n            poolList[_poolId].basicDegisPerSecond = _basicDegisPerSecond;\n            poolList[_poolId].bonusDegisPerSecond = _bonusDegisPerSecond;\n            emit DegisRewardChanged(\n                _poolId,\n                _basicDegisPerSecond,\n                _bonusDegisPerSecond\n            );\n        }\n    }\n\n    /**\n     * @notice Stake LP token into the farming pool\n     * @dev Can only stake to the pools that are still farming\n     * @param _poolId Id of the farming pool\n     * @param _amount Staking amount\n     */\n    function stake(uint256 _poolId, uint256 _amount)\n        public\n        nonReentrant\n        whenNotPaused\n        stillFarming(_poolId)\n    {\n        require(_amount > 0, \"Can not stake zero\");\n\n        PoolInfo storage pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][msg.sender];\n\n        // Must update first\n        updatePool(_poolId);\n\n        // First distribute the reward if exists\n        if (user.stakingBalance > 0) {\n            uint256 pending = (user.stakingBalance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n                SCALE +\n                extraClaimable[_poolId][msg.sender] -\n                user.rewardDebt;\n\n            // Clear the extra record (has been distributed)\n            extraClaimable[_poolId][msg.sender] = 0;\n\n            // Real reward amount by safe transfer\n            uint256 reward = _safeDegisTransfer(msg.sender, pending);\n            emit Harvest(msg.sender, msg.sender, _poolId, reward);\n        }\n\n        // Actual deposit amount\n        uint256 actualAmount = _safeLPTransfer(\n            false,\n            pool.lpToken,\n            msg.sender,\n            _amount\n        );\n\n        user.stakingBalance += actualAmount;\n\n        if (address(veDEG) != address(0)) {\n            // Update the user's bonus if veDEG boosting is on\n            uint256 oldBonus = user.bonus;\n            user.bonus = (user.stakingBalance * veDEG.balanceOf(msg.sender))\n                .sqrt();\n            // Update the pool's total bonus\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\n        }\n\n        user.rewardDebt =\n            (user.stakingBalance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n            SCALE;\n\n        emit Stake(msg.sender, _poolId, actualAmount);\n    }\n\n    /**\n     * @notice Withdraw lptoken from the pool\n     * @param _poolId Id of the farming pool\n     * @param _amount Amount of lp tokens to withdraw\n     */\n    function withdraw(uint256 _poolId, uint256 _amount)\n        public\n        nonReentrant\n        whenNotPaused\n    {\n        require(_amount > 0, \"Zero amount\");\n\n        PoolInfo storage pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][msg.sender];\n\n        require(user.stakingBalance >= _amount, \"Not enough stakingBalance\");\n\n        // Update if the pool is still farming\n        // Users can withdraw even after the pool stopped\n        if (isFarming[_poolId]) updatePool(_poolId);\n        else {\n            pool.lastRewardTimestamp = block.timestamp;\n        }\n\n        uint256 pending = (user.stakingBalance *\n            pool.accDegisPerShare +\n            user.bonus *\n            pool.accDegisPerBonusShare) /\n            SCALE +\n            extraClaimable[_poolId][msg.sender] -\n            user.rewardDebt;\n\n        // Clear the extra record (has been distributed)\n        extraClaimable[_poolId][msg.sender] = 0;\n\n        // Real reward amount by safe transfer\n        uint256 reward = _safeDegisTransfer(msg.sender, pending);\n        emit Harvest(msg.sender, msg.sender, _poolId, reward);\n\n        uint256 actualAmount = _safeLPTransfer(\n            true,\n            pool.lpToken,\n            msg.sender,\n            _amount\n        );\n\n        user.stakingBalance -= actualAmount;\n\n        // Update the user's bonus when veDEG boosting is on\n        if (address(veDEG) != address(0)) {\n            uint256 oldBonus = user.bonus;\n            user.bonus = (user.stakingBalance * veDEG.balanceOf(msg.sender))\n                .sqrt();\n            // Update the pool's total bonus\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\n        }\n\n        user.rewardDebt =\n            (user.stakingBalance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n            SCALE;\n\n        emit Withdraw(msg.sender, _poolId, actualAmount);\n    }\n\n    /**\n     * @notice Harvest the degis reward and can be sent to another address\n     * @param _poolId Id of the farming pool\n     * @param _to Receiver of degis rewards\n     */\n    function harvest(uint256 _poolId, address _to)\n        public\n        nonReentrant\n        whenNotPaused\n    {\n        // Only update the pool when it is still in farming\n        if (isFarming[_poolId]) updatePool(_poolId);\n        else {\n            poolList[_poolId].lastRewardTimestamp = block.timestamp;\n        }\n\n        PoolInfo memory pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][msg.sender];\n\n        uint256 pendingReward = (user.stakingBalance *\n            pool.accDegisPerShare +\n            user.bonus *\n            pool.accDegisPerBonusShare) /\n            SCALE +\n            extraClaimable[_poolId][msg.sender] -\n            user.rewardDebt;\n\n        extraClaimable[_poolId][msg.sender] = 0;\n\n        require(pendingReward > 0, \"No pending reward\");\n\n        // Update the reward debt\n        user.rewardDebt =\n            (user.stakingBalance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n            SCALE;\n\n        // Transfer the reward\n        uint256 reward = _safeDegisTransfer(_to, pendingReward);\n\n        emit Harvest(msg.sender, _to, _poolId, reward);\n    }\n\n    /**\n     * @notice Update the pool's reward status\n     * @param _poolId Id of the farming pool\n     */\n    function updatePool(uint256 _poolId) public {\n        PoolInfo storage pool = poolList[_poolId];\n        if (block.timestamp <= pool.lastRewardTimestamp) {\n            return;\n        }\n\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n\n        // No LP deposited, then just update the lastRewardTimestamp\n        if (lpSupply == 0) {\n            pool.lastRewardTimestamp = block.timestamp;\n            return;\n        }\n\n        uint256 timePassed = block.timestamp - pool.lastRewardTimestamp;\n\n        uint256 basicReward = timePassed * pool.basicDegisPerSecond;\n        uint256 bonusReward = timePassed * pool.bonusDegisPerSecond;\n\n        pool.accDegisPerShare += (basicReward * SCALE) / lpSupply;\n\n        if (pool.totalBonus == 0) {\n            pool.accDegisPerBonusShare = 0;\n        } else {\n            pool.accDegisPerBonusShare +=\n                (bonusReward * SCALE) /\n                pool.totalBonus;\n        }\n\n        // Don't forget to set the farming pool as minter\n        degis.mintDegis(address(this), basicReward + bonusReward);\n\n        pool.lastRewardTimestamp = block.timestamp;\n\n        // Update the new reward speed\n        // Only if the threshold are already set\n        if (thresholdBasic[_poolId].length > 0) {\n            uint256 currentLiquidity = thresholdBasic[_poolId][\n                currentRewardLevel\n            ];\n            if (\n                currentRewardLevel < thresholdBasic[_poolId].length - 1 &&\n                lpSupply >= thresholdBasic[_poolId][currentRewardLevel + 1]\n            ) {\n                _updateRewardSpeed(_poolId);\n            } else if (lpSupply < currentLiquidity) {\n                _updateRewardSpeed(_poolId);\n            }\n        }\n\n        emit PoolUpdated(\n            _poolId,\n            pool.accDegisPerShare,\n            pool.accDegisPerBonusShare\n        );\n    }\n\n    /**\n     * @notice Update all farming pools (except for those stopped ones)\n     * @dev Can be called by anyone\n     *      Only update those active pools\n     */\n    function massUpdatePools() public {\n        uint256 length = poolList.length;\n        for (uint256 poolId = 1; poolId < length; ++poolId) {\n            if (isFarming[poolId] == false) {\n                poolList[poolId].lastRewardTimestamp = block.timestamp;\n                continue;\n            } else updatePool(poolId);\n        }\n    }\n\n    /**\n     * @notice Update a user's bonus\n     * @dev When veDEG has balance change\n     *      Only called by veDEG contract\n     * @param _user User address\n     * @param _newVeDEGBalance New veDEG balance\n     */\n    function updateBonus(address _user, uint256 _newVeDEGBalance) external {\n        require(msg.sender == address(veDEG), \"Only veDEG contract\");\n\n        // loop over each pool : beware gas cost!\n        uint256 length = poolList.length;\n\n        for (uint256 poolId; poolId < length; ++poolId) {\n            // Skip if the pool is not farming\n            if (!isFarming[poolId]) continue;\n\n            UserInfo storage user = userInfo[poolId][_user];\n            // Skip if user doesn't have any deposit in the pool\n            if (user.stakingBalance == 0) continue;\n\n            PoolInfo storage pool = poolList[poolId];\n\n            // first, update pool\n            updatePool(poolId);\n\n            // Update the extra claimable amount\n            uint256 pending = (user.stakingBalance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n                SCALE -\n                user.rewardDebt;\n            extraClaimable[poolId][_user] += pending;\n\n            // get oldFactor\n            uint256 oldFactor = user.bonus; // get old factor\n            // calculate newFactor\n            uint256 newFactor = (_newVeDEGBalance * user.stakingBalance).sqrt();\n            // update user factor\n            user.bonus = newFactor;\n            // update reward debt, take into account newFactor\n            user.rewardDebt =\n                (user.stakingBalance *\n                    pool.accDegisPerShare +\n                    newFactor *\n                    pool.accDegisPerBonusShare) /\n                SCALE;\n\n            // Update the pool's total bonus\n            pool.totalBonus = pool.totalBonus + newFactor - oldFactor;\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ********************************** Internal Functions ********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if a lptoken has been added into the pool before\n     * @dev This can also be written as a modifier\n     * @param _lpToken LP token address\n     * @return _isInPool Wether this lp is already in pool\n     */\n    function _alreadyInPool(address _lpToken)\n        internal\n        view\n        returns (bool _isInPool)\n    {\n        uint256 poolId = poolMapping[_lpToken];\n\n        _isInPool = (poolId != 0) ? true : false;\n    }\n\n    /**\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\n     * @param _to User's address\n     * @param _amount Amount to transfer\n     */\n    function _safeDegisTransfer(address _to, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        uint256 poolDegisBalance = degis.balanceOf(address(this));\n        require(poolDegisBalance > 0, \"No Degis token in the pool\");\n\n        if (_amount > poolDegisBalance) {\n            degis.safeTransfer(_to, poolDegisBalance);\n            return (poolDegisBalance);\n        } else {\n            degis.safeTransfer(_to, _amount);\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice Finish the transfer of LP Token\n     * @dev The lp token may have loss during transfer\n     * @param _out Whether the lp token is out\n     * @param _lpToken LP token address\n     * @param _user User address\n     * @param _amount Amount of lp tokens\n     */\n    function _safeLPTransfer(\n        bool _out,\n        address _lpToken,\n        address _user,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 poolBalanceBefore = IERC20(_lpToken).balanceOf(address(this));\n\n        if (_out) IERC20(_lpToken).safeTransfer(_user, _amount);\n        else IERC20(_lpToken).safeTransferFrom(_user, address(this), _amount);\n\n        uint256 poolBalanceAfter = IERC20(_lpToken).balanceOf(address(this));\n\n        return\n            _out\n                ? poolBalanceBefore - poolBalanceAfter\n                : poolBalanceAfter - poolBalanceBefore;\n    }\n\n    /**\n     * @notice Update the reward speed\n     * @param _poolId Pool ID\n     */\n    function _updateRewardSpeed(uint256 _poolId) internal {\n        uint256 currentBasicBalance = IERC20(poolList[_poolId].lpToken)\n            .balanceOf(address(this));\n\n        uint256 basicRewardSpeed;\n\n        for (uint256 i = thresholdBasic[_poolId].length - 1; i >= 0; --i) {\n            if (currentBasicBalance >= thresholdBasic[_poolId][i]) {\n                basicRewardSpeed = piecewiseBasic[_poolId][i];\n                // record current reward level\n                currentRewardLevel = i;\n                break;\n            } else continue;\n        }\n\n        poolList[_poolId].basicDegisPerSecond = basicRewardSpeed;\n    }\n}\n"
    },
    "contracts/farming/PurchaseIncentiveVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\npragma solidity ^0.8.10;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../tokens/interfaces/IDegisToken.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"hardhat/console.sol\";\n/**\n * @title  Purchase Incentive Vault\n * @notice This is the purchase incentive vault for staking buyer tokens\n *         Users first stake their buyer tokens and wait for distribution\n *         About every 24 hours, the reward will be calculated to users' account\n *         After disrtribution, reward will be updated\n *              but it still need to be manually claimed.\n *\n *         Buyer tokens can only be used once\n *         You can withdraw your buyer token within the same round (current round)\n *         They can not be withdrawed if the round was settled\n */\ncontract PurchaseIncentiveVault is\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    string public constant name = \"Degis Purchase Incentive Vault\";\n\n    // Buyer Token & Degis Token SCALE = 1e18\n    uint256 public constant SCALE = 1e18;\n\n    // Other contracts\n    IERC20 buyerToken;\n    IDegisToken degis;\n\n    // Current round number\n    uint256 public currentRound;\n\n    // Degis reward per round\n    uint256 public degisPerRound;\n\n    // The interval will only limit the distribution (not the staking)\n    uint256 public distributionInterval;\n\n    // Last distribution block\n    uint256 public lastDistribution;\n\n    // Max round for one claim\n    // When upgrade this parameter, redeploy the contract\n    uint256 public constant MAX_ROUND = 50;\n\n    struct RoundInfo {\n        uint256 shares;\n        address[] users;\n        bool hasDistributed;\n        uint256 degisPerShare;\n    }\n    mapping(uint256 => RoundInfo) public rounds;\n\n    struct UserInfo {\n        uint256 lastRewardRoundIndex;\n        uint256[] pendingRounds;\n    }\n    mapping(address => UserInfo) public users;\n\n    // User address => Round number => User shares\n    mapping(address => mapping(uint256 => uint256)) public userSharesInRound;\n\n    uint256[] threshold;\n    uint256[] piecewise;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event DegisRewardChanged(\n        uint256 oldRewardPerRound,\n        uint256 newRewardPerRound\n    );\n    event DistributionIntervalChanged(uint256 oldInterval, uint256 newInterval);\n    event Stake(\n        address userAddress,\n        uint256 currentRound,\n        uint256 actualAmount\n    );\n    event Redeem(address userAddress, uint256 currentRound, uint256 amount);\n    event RewardClaimed(address userAddress, uint256 userReward);\n    event RoundSettled(uint256 currentRound, uint256 blockNumber);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error PIV__NotPassedInterval();\n    error PIV__ZeroAmount();\n    error PIV__NotEnoughBuyerTokens();\n    error PIV__AlreadyDistributed();\n    error PIV__NoPendingRound();\n    error PIV__ClaimedAll();\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _buyerToken, address _degisToken)\n        public\n        initializer\n    {\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        // Initialize two tokens\n        buyerToken = IERC20(_buyerToken);\n        degis = IDegisToken(_degisToken);\n\n        // Initialize the last distribution time\n        lastDistribution = block.timestamp;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if admins can distribute now\n     * @dev Should pass the distribution interval\n     */\n    modifier hasPassedInterval() {\n        if (block.timestamp - lastDistribution <= distributionInterval)\n            revert PIV__NotPassedInterval();\n\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the amount of users in _round, used for distribution\n     * @param _round Round number to check\n     * @return totalUsers Total amount of users in _round\n     */\n    function getTotalUsersInRound(uint256 _round)\n        external\n        view\n        returns (uint256)\n    {\n        return rounds[_round].users.length;\n    }\n\n    /**\n     * @notice Get the user addresses in _round\n     * @param _round Round number to check\n     * @return users All user addresses in this round\n     */\n    function getUsersInRound(uint256 _round)\n        external\n        view\n        returns (address[] memory)\n    {\n        return rounds[_round].users;\n    }\n\n    /**\n     * @notice Get user's pending rounds\n     * @param _user User address to check\n     * @return pendingRounds User's pending rounds\n     */\n    function getUserPendingRounds(address _user)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return users[_user].pendingRounds;\n    }\n\n    /**\n     * @notice Get your shares in the current round\n     * @param _user Address of the user\n     * @param _round Round number\n     * @return userShares User's shares in the current round\n     */\n    function getUserShares(address _user, uint256 _round)\n        external\n        view\n        returns (uint256)\n    {\n        return userSharesInRound[_user][_round];\n    }\n\n    /**\n     * @notice Get a user's pending reward\n     * @param _user User address\n     * @return userPendingReward User's pending reward\n     */\n    function pendingReward(address _user)\n        external\n        view\n        returns (uint256 userPendingReward)\n    {\n        UserInfo memory user = users[_user];\n\n        // Total rounds that need to be distributed\n        uint256 length = user.pendingRounds.length - user.lastRewardRoundIndex;\n\n        // Start from last reward round index\n        uint256 startIndex = user.lastRewardRoundIndex;\n\n        for (uint256 i = startIndex; i < startIndex + length; i++) {\n            uint256 round = user.pendingRounds[i];\n\n            userPendingReward +=\n                (rounds[round].degisPerShare *\n                    userSharesInRound[_user][round]) /\n                SCALE;\n        }\n    }\n\n    /**\n     * @notice Get degis reward per round\n     * @dev Depends on the total shares in this round\n     * @return rewardPerRound Degis reward per round\n     */\n    function getRewardPerRound() public view returns (uint256 rewardPerRound) {\n        uint256 buyerBalance = rounds[currentRound].shares;\n\n        uint256[] memory thresholdM = threshold;\n\n        // If no piecewise is set, use the default degisPerRound\n        if (thresholdM.length == 0) rewardPerRound = degisPerRound;\n        else {\n            for (uint256 i = thresholdM.length - 1; i >= 0; ) {\n                if (buyerBalance >= thresholdM[i]) {\n                    rewardPerRound = piecewise[i];\n                    break;\n                }\n                unchecked {\n                    --i;\n                }\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function pause() external onlyOwner {\n        super._pause();\n    }\n\n    function unpause() external onlyOwner {\n        super._unpause();\n    }\n\n    /**\n     * @notice Set degis distribution per round\n     * @param _degisPerRound Degis distribution per round\n     */\n    function setDegisPerRound(uint256 _degisPerRound) external onlyOwner {\n        emit DegisRewardChanged(degisPerRound, _degisPerRound);\n        degisPerRound = _degisPerRound;\n    }\n\n    /**\n     * @notice Set a new distribution interval\n     * @param _newInterval The new interval\n     */\n    function setDistributionInterval(uint256 _newInterval) external onlyOwner {\n        emit DistributionIntervalChanged(distributionInterval, _newInterval);\n        distributionInterval = _newInterval;\n    }\n\n    /**\n     * @notice Set the threshold and piecewise reward\n     * @param _threshold The threshold\n     * @param _reward The piecewise reward\n     */\n    function setPiecewise(\n        uint256[] calldata _threshold,\n        uint256[] calldata _reward\n    ) external onlyOwner {\n        threshold = _threshold;\n        piecewise = _reward;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Stake buyer tokens into this contract\n     * @param _amount Amount of buyer tokens to stake\n     */\n    function stake(uint256 _amount) external nonReentrant whenNotPaused {\n        if (_amount == 0) revert PIV__ZeroAmount();\n\n        // Save gas\n        uint256 round = currentRound;\n\n        // User info of msg.sender\n        UserInfo storage user = users[msg.sender];\n\n        // If the user has not staked in this round, record this new user to the users array\n        if (userSharesInRound[msg.sender][round] == 0) {\n            rounds[round].users.push(msg.sender);\n        }\n\n        userSharesInRound[msg.sender][round] += _amount;\n\n        uint256 length = user.pendingRounds.length;\n        // Only add the round if it's not in the array\n        // Condition 1: length == 0 => no pending rounds => add this round\n        // Condition 2: length != 0 && last pending round is not the current round => add this round\n        if (\n            length == 0 ||\n            (length != 0 && user.pendingRounds[length - 1] != round)\n        ) user.pendingRounds.push(round);\n\n        // Update the total shares\n        rounds[round].shares += _amount;\n\n        // Finish the token transfer (need approval)\n        buyerToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Stake(msg.sender, round, _amount);\n    }\n\n    /**\n     * @notice Redeem buyer token from the vault\n     * @param _amount Amount to redeem\n     */\n    function redeem(uint256 _amount) external nonReentrant whenNotPaused {\n        if (_amount == 0) revert PIV__ZeroAmount();\n\n        uint256 round = currentRound;\n\n        uint256 userBalance = userSharesInRound[msg.sender][round];\n        if (userBalance < _amount) revert PIV__NotEnoughBuyerTokens();\n\n        userSharesInRound[msg.sender][round] -= _amount;\n\n        // If redeem all buyer tokens, remove this round from the user's pending rounds\n        if (userSharesInRound[msg.sender][round] == 0) {\n            users[msg.sender].pendingRounds.pop();\n        }\n\n        rounds[round].shares -= _amount;\n\n        // Finish the buyer token transfer\n        buyerToken.safeTransfer(msg.sender, _amount);\n\n        emit Redeem(msg.sender, round, _amount);\n    }\n\n    /**\n     * @notice Setttle the current round\n     * @dev Callable by any address, must pass the distribution interval\n     */\n    function settleCurrentRound() external hasPassedInterval whenNotPaused {\n        RoundInfo storage info = rounds[currentRound];\n        if (info.hasDistributed) revert PIV__AlreadyDistributed();\n\n        uint256 totalShares = info.shares;\n        uint256 totalReward = getRewardPerRound();\n\n        // If no one staked, no reward\n        if (totalShares == 0) info.degisPerShare = 0;\n        else info.degisPerShare = (totalReward * SCALE) / totalShares;\n\n        info.hasDistributed = true;\n\n        emit RoundSettled(currentRound, block.timestamp);\n\n        // Update current round, ++ save little gas\n        ++currentRound;\n\n        // Update last distribution time\n        lastDistribution = block.timestamp;\n    }\n\n    /**\n     * @notice User can claim his own reward\n     */\n    function claim() external nonReentrant whenNotPaused {\n        UserInfo memory user = users[msg.sender];\n\n        if (user.pendingRounds.length == 0) revert PIV__NoPendingRound();\n\n        uint256 roundsToClaim = user.pendingRounds.length -\n            user.lastRewardRoundIndex;\n\n        if (roundsToClaim == 0) revert PIV__ClaimedAll();\n\n        if (user.pendingRounds[user.pendingRounds.length - 1] == currentRound) {\n            roundsToClaim -= 1;\n        }\n\n        uint256 startIndex = user.lastRewardRoundIndex;\n\n        // MAX_ROUND to claim each time\n        if (roundsToClaim > MAX_ROUND) {\n            roundsToClaim = MAX_ROUND;\n            users[msg.sender].lastRewardRoundIndex += MAX_ROUND;\n        } else users[msg.sender].lastRewardRoundIndex += roundsToClaim;\n\n        uint256 userPendingReward;\n        \n\n        for (uint256 i = startIndex; i < startIndex + roundsToClaim;) {\n            uint256 round = user.pendingRounds[i];\n\n            userPendingReward +=\n                (rounds[round].degisPerShare *\n                    userSharesInRound[msg.sender][round]) /\n                SCALE;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Mint reward to user\n        degis.mintDegis(msg.sender, userPendingReward);\n    }\n}\n"
    },
    "contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(\n            _initializing ? _isConstructor() : !_initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/farming/FarmingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {OwnableWithoutContext} from \"../utils/OwnableWithoutContext.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IDegisToken} from \"../tokens/interfaces/IDegisToken.sol\";\nimport {Math} from \"../libraries/Math.sol\";\nimport {IVeDEG} from \"../governance/interfaces/IVeDEG.sol\";\n\n/**\n * @title  Farming Pool\n * @notice This contract is for LPToken mining on Degis\n * @dev    The pool id starts from 1 rather than 0\n *         The degis reward is calculated by timestamp rather than block number\n *\n *         VeDEG will boost the farming speed by having a extra reward type\n *         The extra reward is shared by those staking lptokens with veDEG balances\n *         Every time the veDEG balance change, the reward will be updated\n */\ncontract FarmingPool is OwnableWithoutContext, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IDegisToken;\n    using Math for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    string public constant name = \"Degis LP Farming Pool\";\n\n    // The reward token is degis\n    IDegisToken public degis;\n\n    // The bonus reward depends on veDEG\n    IVeDEG public veDEG;\n\n    // SCALE/Precision used for calculating rewards\n    uint256 public constant SCALE = 1e12;\n\n    // PoolId starts from 1\n    uint256 public _nextPoolId;\n\n    // Farming starts from a certain block timestamp\n    // To keep the same with naughty price pools, we change from block numbers to timestamps\n    uint256 public startTimestamp;\n\n    struct PoolInfo {\n        address lpToken; // LPToken address\n        uint256 basicDegisPerSecond; // Basic Reward speed\n        uint256 bonusDegisPerSecond; // Bonus reward speed\n        uint256 lastRewardTimestamp; // Last reward timestamp\n        uint256 accDegisPerShare; // Accumulated degis per share (for those without veDEG boosting)\n        uint256 accDegisPerBonusShare; // Accumulated degis per bonus share (for those with veDEG boosting)\n        uint256 totalBonus; // Total bonus factors\n    }\n    PoolInfo[] public poolList;\n\n    // lptoken address => poolId\n    mapping(address => uint256) public poolMapping;\n\n    // poolId => alreadyFarming\n    mapping(uint256 => bool) public isFarming;\n\n    struct UserInfo {\n        uint256 rewardDebt; // degis reward debt\n        uint256 stakingBalance; // the amount of a user's staking in the pool\n        uint256 bonus; // user bonus point (by veDEG balance)\n    }\n    // poolId => userAddress => userInfo\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event StartTimestampChanged(uint256 startTimestamp);\n    event Stake(address staker, uint256 poolId, uint256 amount);\n    event Withdraw(address staker, uint256 poolId, uint256 amount);\n    event Harvest(\n        address staker,\n        address rewardReceiver,\n        uint256 poolId,\n        uint256 pendingReward\n    );\n    event NewPoolAdded(\n        address lpToken,\n        uint256 basicDegisPerSecond,\n        uint256 bonusDegisPerSecond\n    );\n    event FarmingPoolStarted(uint256 poolId, uint256 timestamp);\n    event FarmingPoolStopped(uint256 poolId, uint256 timestamp);\n    event DegisRewardChanged(\n        uint256 poolId,\n        uint256 basicDegisPerSecond,\n        uint256 bonusDegisPerSecond\n    );\n    event PoolUpdated(\n        uint256 poolId,\n        uint256 accDegisPerShare,\n        uint256 accDegisPerBonusShare\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(address _degis) OwnableWithoutContext(msg.sender) {\n        degis = IDegisToken(_degis);\n\n        // Start from 1\n        _nextPoolId = 1;\n\n        poolList.push(\n            PoolInfo({\n                lpToken: address(0),\n                basicDegisPerSecond: 0,\n                bonusDegisPerSecond: 0,\n                lastRewardTimestamp: 0,\n                accDegisPerShare: 0,\n                accDegisPerBonusShare: 0,\n                totalBonus: 0\n            })\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice The address can not be zero\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    /**\n     * @notice The pool is still in farming\n     */\n    modifier stillFarming(uint256 _poolId) {\n        require(isFarming[_poolId], \"Pool is not farming\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** View Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check the amount of pending degis reward\n     * @param _poolId PoolId of this farming pool\n     * @param _user User address\n     * @return pendingDegisAmount Amount of pending degis\n     */\n    function pendingDegis(uint256 _poolId, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo memory poolInfo = poolList[_poolId];\n\n        if (\n            poolInfo.lastRewardTimestamp == 0 ||\n            block.timestamp < poolInfo.lastRewardTimestamp ||\n            block.timestamp < startTimestamp\n        ) return 0;\n\n        UserInfo memory user = userInfo[_poolId][_user];\n\n        // Total lp token balance\n        uint256 lp_balance = IERC20(poolInfo.lpToken).balanceOf(address(this));\n\n        // Accumulated shares to be calculated\n        uint256 accDegisPerShare = poolInfo.accDegisPerShare;\n        uint256 accDegisPerBonusShare = poolInfo.accDegisPerBonusShare;\n\n        if (lp_balance == 0) return 0;\n        else {\n            // If the pool is still farming, update the info\n            if (isFarming[_poolId]) {\n                // Deigs amount given to this pool\n                uint256 timePassed = block.timestamp -\n                    poolInfo.lastRewardTimestamp;\n                uint256 basicReward = poolInfo.basicDegisPerSecond * timePassed;\n                // Update accDegisPerShare\n                // LPToken may have different decimals\n                accDegisPerShare += (basicReward * SCALE) / lp_balance;\n\n                // If there is any bonus reward\n                if (poolInfo.totalBonus > 0) {\n                    uint256 bonusReward = poolInfo.bonusDegisPerSecond *\n                        timePassed;\n                    accDegisPerBonusShare +=\n                        (bonusReward * SCALE) /\n                        poolInfo.totalBonus;\n                }\n            }\n\n            // If the pool has stopped, not update the info\n            uint256 pending = (user.stakingBalance *\n                accDegisPerShare +\n                user.bonus *\n                accDegisPerBonusShare) /\n                SCALE -\n                user.rewardDebt;\n\n            return pending;\n        }\n    }\n\n    /**\n     * @notice Get the total pool list\n     * @return pooList Total pool list\n     */\n    function getPoolList() external view returns (PoolInfo[] memory) {\n        return poolList;\n    }\n\n    /**\n     * @notice Get a user's balance\n     * @param _poolId Id of the pool\n     * @param _user User address\n     * @return balance User's balance (lpToken)\n     */\n    function getUserBalance(uint256 _poolId, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        return userInfo[_poolId][_user].stakingBalance;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Set Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setVeDEG(address _veDEG) external onlyOwner {\n        veDEG = IVeDEG(_veDEG);\n    }\n\n    /**\n     * @notice Set the start block timestamp\n     * @param _startTimestamp New start block timestamp\n     */\n    function setStartTimestamp(uint256 _startTimestamp)\n        external\n        onlyOwner\n        whenNotPaused\n    {\n        // Can only be set before any pool is added\n        require(\n            _nextPoolId == 1,\n            \"Can not set start timestamp after adding a pool\"\n        );\n\n        startTimestamp = _startTimestamp;\n        emit StartTimestampChanged(_startTimestamp);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new lp into the pool\n     * @dev Can only be called by the owner\n     *      The reward speed can be 0 and set later by setDegisReward function\n     * @param _lpToken LP token address\n     * @param _basicDegisPerSecond Basic reward speed(per second) for this new pool\n     * @param _bonusDegisPerSecond Bonus reward speed(per second) for this new pool\n     * @param _withUpdate Whether update all pools' status\n     */\n    function add(\n        address _lpToken,\n        uint256 _basicDegisPerSecond,\n        uint256 _bonusDegisPerSecond,\n        bool _withUpdate\n    ) public notZeroAddress(_lpToken) onlyOwner whenNotPaused {\n        // Check if already exists, if the poolId is 0, that means not in the pool\n        require(!_alreadyInPool(_lpToken), \"Already in the pool\");\n\n        if (_bonusDegisPerSecond > 0)\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\n\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n\n        uint256 lastRewardTimestamp = block.timestamp > startTimestamp\n            ? block.timestamp\n            : startTimestamp;\n\n        // Push this new pool into the list\n        poolList.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                basicDegisPerSecond: _basicDegisPerSecond,\n                bonusDegisPerSecond: _bonusDegisPerSecond,\n                lastRewardTimestamp: lastRewardTimestamp,\n                accDegisPerShare: 0,\n                accDegisPerBonusShare: 0,\n                totalBonus: 0\n            })\n        );\n\n        // Store the poolId and set the farming status to true\n        if (_basicDegisPerSecond > 0) isFarming[_nextPoolId] = true;\n\n        poolMapping[_lpToken] = _nextPoolId++;\n\n        emit NewPoolAdded(_lpToken, _basicDegisPerSecond, _bonusDegisPerSecond);\n    }\n\n    /**\n     * @notice Update the degisPerSecond for a specific pool (set to 0 to stop farming)\n     * @param _poolId Id of the farming pool\n     * @param _basicDegisPerSecond New basic reward amount per second\n     * @param _bonusDegisPerSecond New bonus reward amount per second\n     * @param _withUpdate Whether update all pools\n     */\n    function setDegisReward(\n        uint256 _poolId,\n        uint256 _basicDegisPerSecond,\n        uint256 _bonusDegisPerSecond,\n        bool _withUpdate\n    ) public onlyOwner whenNotPaused {\n        // Ensure there already exists this pool\n        require(poolList[_poolId].lastRewardTimestamp != 0, \"Pool not exists\");\n\n        if (_bonusDegisPerSecond > 0)\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\n\n        if (_withUpdate) massUpdatePools();\n        else updatePool(_poolId);\n\n        // Not farming now + reward > 0 => Restart\n        if (isFarming[_poolId] == false && _basicDegisPerSecond > 0) {\n            isFarming[_poolId] = true;\n            emit FarmingPoolStarted(_poolId, block.timestamp);\n        }\n\n        if (_basicDegisPerSecond == 0) {\n            isFarming[_poolId] = false;\n            emit FarmingPoolStopped(_poolId, block.timestamp);\n        } else {\n            poolList[_poolId].basicDegisPerSecond = _basicDegisPerSecond;\n            poolList[_poolId].bonusDegisPerSecond = _bonusDegisPerSecond;\n            emit DegisRewardChanged(\n                _poolId,\n                _basicDegisPerSecond,\n                _bonusDegisPerSecond\n            );\n        }\n    }\n\n    /**\n     * @notice Stake LP token into the farming pool\n     * @dev Can only stake to the pools that are still farming\n     * @param _poolId Id of the farming pool\n     * @param _amount Staking amount\n     */\n    function stake(uint256 _poolId, uint256 _amount)\n        public\n        nonReentrant\n        whenNotPaused\n        stillFarming(_poolId)\n    {\n        require(_amount > 0, \"Can not stake zero\");\n\n        PoolInfo storage pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][msg.sender];\n\n        // Must update first\n        updatePool(_poolId);\n\n        // First distribute the reward if exists\n        if (user.stakingBalance > 0) {\n            uint256 pending = (user.stakingBalance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n                SCALE -\n                user.rewardDebt;\n\n            // Real reward amount\n            uint256 reward = _safeDegisTransfer(msg.sender, pending);\n            emit Harvest(msg.sender, msg.sender, _poolId, reward);\n        }\n\n        // Actual deposit amount\n        uint256 actualAmount = _safeLPTransfer(\n            false,\n            pool.lpToken,\n            msg.sender,\n            _amount\n        );\n\n        user.stakingBalance += actualAmount;\n\n        if (address(veDEG) != address(0)) {\n            // Update the user's bonus if veDEG boosting is on\n            uint256 oldBonus = user.bonus;\n            user.bonus = (user.stakingBalance * veDEG.balanceOf(msg.sender))\n                .sqrt();\n            // Update the pool's total bonus\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\n        }\n\n        user.rewardDebt =\n            (user.stakingBalance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n            SCALE;\n\n        emit Stake(msg.sender, _poolId, actualAmount);\n    }\n\n    /**\n     * @notice Withdraw lptoken from the pool\n     * @param _poolId Id of the farming pool\n     * @param _amount Amount of lp tokens to withdraw\n     */\n    function withdraw(uint256 _poolId, uint256 _amount)\n        public\n        nonReentrant\n        whenNotPaused\n    {\n        require(_amount > 0, \"Zero amount\");\n\n        PoolInfo storage pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][msg.sender];\n\n        require(user.stakingBalance >= _amount, \"Not enough stakingBalance\");\n\n        // Update if the pool is still farming\n        // Users can withdraw even after the pool stopped\n        if (isFarming[_poolId]) updatePool(_poolId);\n\n        uint256 pending = (user.stakingBalance *\n            pool.accDegisPerShare +\n            user.bonus *\n            pool.accDegisPerBonusShare) /\n            SCALE -\n            user.rewardDebt;\n\n        uint256 reward = _safeDegisTransfer(msg.sender, pending);\n        emit Harvest(msg.sender, msg.sender, _poolId, reward);\n\n        uint256 actualAmount = _safeLPTransfer(\n            true,\n            pool.lpToken,\n            msg.sender,\n            _amount\n        );\n\n        user.stakingBalance -= actualAmount;\n\n        // Update the user's bonus when veDEG boosting is on\n        if (address(veDEG) != address(0)) {\n            uint256 oldBonus = user.bonus;\n            user.bonus = (user.stakingBalance * veDEG.balanceOf(msg.sender))\n                .sqrt();\n            // Update the pool's total bonus\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\n        }\n\n        user.rewardDebt =\n            (user.stakingBalance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n            SCALE;\n\n        emit Withdraw(msg.sender, _poolId, actualAmount);\n    }\n\n    /**\n     * @notice Harvest the degis reward and can be sent to another address\n     * @param _poolId Id of the farming pool\n     * @param _to Receiver of degis rewards\n     */\n    function harvest(uint256 _poolId, address _to)\n        public\n        nonReentrant\n        whenNotPaused\n    {\n        // Only update the pool when it is still in farming\n        if (isFarming[_poolId]) updatePool(_poolId);\n\n        PoolInfo memory pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][msg.sender];\n\n        uint256 pendingReward = (user.stakingBalance *\n            pool.accDegisPerShare +\n            user.bonus *\n            pool.accDegisPerBonusShare) /\n            SCALE -\n            user.rewardDebt;\n\n        require(pendingReward > 0, \"No pending reward\");\n\n        // Update the reward debt\n        user.rewardDebt =\n            (user.stakingBalance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n            SCALE;\n\n        // Transfer the reward\n        uint256 reward = _safeDegisTransfer(_to, pendingReward);\n\n        emit Harvest(msg.sender, _to, _poolId, reward);\n    }\n\n    /**\n     * @notice Update the pool's reward status\n     * @param _poolId Id of the farming pool\n     */\n    function updatePool(uint256 _poolId) public {\n        PoolInfo storage pool = poolList[_poolId];\n        if (block.timestamp <= pool.lastRewardTimestamp) {\n            return;\n        }\n\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n\n        // No LP deposited, then just update the lastRewardTimestamp\n        if (lpSupply == 0) {\n            pool.lastRewardTimestamp = block.timestamp;\n            return;\n        }\n\n        uint256 timePassed = block.timestamp - pool.lastRewardTimestamp;\n\n        uint256 basicReward = timePassed * pool.basicDegisPerSecond;\n        uint256 bonusReward = timePassed * pool.bonusDegisPerSecond;\n\n        pool.accDegisPerShare += (basicReward * SCALE) / lpSupply;\n\n        if (pool.totalBonus == 0) {\n            pool.accDegisPerBonusShare = 0;\n        } else {\n            pool.accDegisPerBonusShare +=\n                (bonusReward * SCALE) /\n                pool.totalBonus;\n        }\n\n        // Don't forget to set the farming pool as minter\n        degis.mintDegis(address(this), basicReward + bonusReward);\n\n        pool.lastRewardTimestamp = block.timestamp;\n\n        emit PoolUpdated(\n            _poolId,\n            pool.accDegisPerShare,\n            pool.accDegisPerBonusShare\n        );\n    }\n\n    /**\n     * @notice Update all farming pools (except for those stopped ones)\n     * @dev Can be called by anyone\n     *      Only update those active pools\n     */\n    function massUpdatePools() public {\n        uint256 length = poolList.length;\n        for (uint256 poolId; poolId < length; poolId++) {\n            if (isFarming[poolId] == false) continue;\n            else updatePool(poolId);\n        }\n    }\n\n    /**\n     * @notice Update a user's bonus\n     * @dev When veDEG has balance change\n     *      Only called by veDEG contract\n     * @param _user User address\n     * @param _newVeDEGBalance New veDEG balance\n     */\n    function updateBonus(address _user, uint256 _newVeDEGBalance) external {\n        require(msg.sender == address(veDEG), \"Only veDEG contract\");\n\n        // loop over each pool : beware gas cost!\n        uint256 length = poolList.length;\n\n        for (uint256 poolId; poolId < length; ++poolId) {\n            // Skip if the pool is not farming\n            if (!isFarming[poolId]) continue;\n\n            UserInfo storage user = userInfo[poolId][_user];\n            // Skip if user doesn't have any deposit in the pool\n            if (user.stakingBalance == 0) continue;\n\n            PoolInfo storage pool = poolList[poolId];\n\n            // first, update pool\n            updatePool(poolId);\n\n            // get oldFactor\n            uint256 oldFactor = user.bonus; // get old factor\n            // calculate newFactor\n            uint256 newFactor = (_newVeDEGBalance * user.stakingBalance).sqrt();\n            // update user factor\n            user.bonus = newFactor;\n            // update reward debt, take into account newFactor\n            user.rewardDebt =\n                (user.stakingBalance *\n                    pool.accDegisPerShare +\n                    newFactor *\n                    pool.accDegisPerBonusShare) /\n                SCALE;\n\n            // Update the pool's total bonus\n            pool.totalBonus = pool.totalBonus + newFactor - oldFactor;\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ********************************** Internal Functions ********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if a lptoken has been added into the pool before\n     * @dev This can also be written as a modifier\n     * @param _lpToken LP token address\n     * @return _isInPool Wether this lp is already in pool\n     */\n    function _alreadyInPool(address _lpToken)\n        internal\n        view\n        returns (bool _isInPool)\n    {\n        uint256 poolId = poolMapping[_lpToken];\n\n        _isInPool = (poolId != 0) ? true : false;\n    }\n\n    /**\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\n     * @param _to User's address\n     * @param _amount Amount to transfer\n     */\n    function _safeDegisTransfer(address _to, uint256 _amount)\n        internal\n        returns (uint256)\n    {\n        uint256 poolDegisBalance = degis.balanceOf(address(this));\n        require(poolDegisBalance > 0, \"No Degis token in the pool\");\n\n        if (_amount > poolDegisBalance) {\n            degis.safeTransfer(_to, poolDegisBalance);\n            return (poolDegisBalance);\n        } else {\n            degis.safeTransfer(_to, _amount);\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice Finish the transfer of LP Token\n     * @dev The lp token may have loss during transfer\n     * @param _out Whether the lp token is out\n     * @param _lpToken LP token address\n     * @param _user User address\n     * @param _amount Amount of lp tokens\n     */\n    function _safeLPTransfer(\n        bool _out,\n        address _lpToken,\n        address _user,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 poolBalanceBefore = IERC20(_lpToken).balanceOf(address(this));\n\n        if (_out) IERC20(_lpToken).safeTransfer(_user, _amount);\n        else IERC20(_lpToken).safeTransferFrom(_user, address(this), _amount);\n\n        uint256 poolBalanceAfter = IERC20(_lpToken).balanceOf(address(this));\n\n        return\n            _out\n                ? poolBalanceBefore - poolBalanceAfter\n                : poolBalanceAfter - poolBalanceBefore;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/income/IncomeMaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-Later\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../naughty-price/interfaces/INaughtyRouter.sol\";\nimport \"../naughty-price/interfaces/INaughtyFactory.sol\";\nimport \"../naughty-price/interfaces/INaughtyPair.sol\";\n\n/**\n * @title Degis Maker Contract\n * @dev This contract will receive the transaction fee from swap pool\n *      Then it will transfer\n */\ncontract IncomeMaker is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 public constant UINT256_MAX = type(uint256).max;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    INaughtyRouter public router;\n\n    INaughtyFactory public factory;\n\n    address public incomeSharingVault;\n\n    uint256 public PRICE_SCALE = 1e6;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event IncomeToUSD(\n        address policyTokenAddress,\n        address stablecoin,\n        uint256 amountOut\n    );\n    event ConvertIncome(\n        address caller,\n        address policyTokenAddress,\n        address stablecoin,\n        uint256 policyTokenAmount, // Amount of policy token by burning lp tokens\n        uint256 stablecoinAmount, // Amount of stablecoin by burning lp tokens\n        uint256 stablecoinBackAmount // Amount of stablecoin by swapping policy tokens\n    );\n    event EmergencyWithdraw(address token, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Initialize function\n     * @param _router Address of the naughty router\n     * @param _factory Address of the naughty factory\n     * @param _vault Address of the income sharing vault\n     */\n    function initialize(\n        address _router,\n        address _factory,\n        address _vault\n    ) public initializer {\n        __Ownable_init();\n\n        router = INaughtyRouter(_router);\n        factory = INaughtyFactory(_factory);\n\n        incomeSharingVault = _vault;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Convert the income to stablecoin and transfer to the incomeSharingVault\n     * @param _policyToken Address of the policy token\n     * @param _stablecoin Address of the stablecoi\n     */\n    function convertIncome(address _policyToken, address _stablecoin) external {\n        // Get the pair\n        INaughtyPair pair = INaughtyPair(\n            factory.getPairAddress(_policyToken, _stablecoin)\n        );\n        require(address(pair) != address(0), \"Pair not exist\");\n\n        // Transfer lp token to the pool and get two tokens\n        IERC20(address(pair)).safeTransfer(\n            address(pair),\n            pair.balanceOf(address(this))\n        );\n\n        // Directly call the pair to burn lp tokens\n        (uint256 amount0, uint256 amount1) = pair.burn(address(this));\n\n        // Finish swap\n        uint256 amountOut = _swap(\n            _policyToken,\n            _stablecoin,\n            amount0,\n            address(this)\n        );\n\n        // Transfer all stablecoins to income sharing vault\n        IERC20(_stablecoin).safeTransfer(\n            incomeSharingVault,\n            IERC20(_stablecoin).balanceOf(address(this))\n        );\n\n        emit ConvertIncome(\n            msg.sender,\n            _policyToken,\n            _stablecoin,\n            amount0,\n            amount1,\n            amountOut\n        );\n    }\n\n    /**\n     * @notice Emergency withdraw by the owner\n     * @param _token Address of the token\n     * @param _amount Amount of the token\n     */\n    function emergencyWithdraw(address _token, uint256 _amount)\n        external\n        onlyOwner\n    {\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        emit EmergencyWithdraw(_token, _amount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Swap policy tokens to stablecoins\n     * @param _policyToken Address of policy token\n     * @param _stablecoin Address of stablecoin\n     * @param _amount Amount of policy token\n     * @param _to Address of the receiver\n     */\n    function _swap(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _amount,\n        address _to\n    ) internal returns (uint256 amountOut) {\n        // Get the pair\n        INaughtyPair pair = INaughtyPair(\n            factory.getPairAddress(_policyToken, _stablecoin)\n        );\n        require(address(pair) != address(0), \"Pair not exist\");\n\n        (uint256 reserve0, uint256 reserve1) = pair.getReserves();\n\n        uint256 feeRate = pair.feeRate();\n\n        // Calculate amountIn - fee\n        uint256 amountInWithFee = _amount * (1000 - feeRate);\n\n        // Calculate amountOut\n        amountOut =\n            (amountInWithFee * reserve1) /\n            (reserve0 * 1000 + amountInWithFee);\n\n        // Transfer policy token and swap\n        IERC20(_policyToken).safeTransfer(address(pair), _amount);\n        pair.swap(0, amountOut, _to);\n    }\n}\n"
    },
    "contracts/ILM/ILMFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {NaughtyPriceILM} from \"./NaughtyPriceILM.sol\";\n\ncontract ILMFactory {\n\n    \n}"
    },
    "contracts/mocks/MockUSD.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @notice This is the MockUSD used in testnet\n *         Maximum mint amount is 500k for each user.\n *         Maximum mint amount for every single tx is 100k.\n */\ncontract MockUSD is ERC20 {\n    uint256 public constant INITIAL_SUPPLY = 100000 * 1e6;\n\n    constructor() ERC20(\"MOCKUSD\", \"USDC\") {\n        // When first deployed, give the owner some coins\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\n\n    // Everyone can mint, have fun for test\n    function mint(address _account, uint256 _amount) public {\n        _mint(_account, _amount);\n    }\n\n    // 6 decimals to mock stablecoins\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @notice MockERC20 for test\n * @dev MockUSD has 6 decimals, this contract is 18 decimals\n */\ncontract MockERC20 is ERC20 {\n    constructor() ERC20(\"MockERC20\", \"ERC20\") {}\n\n    // Everyone can mint, have fun for test\n    function mint(address _account, uint256 _amount) public {\n        _mint(_account, _amount);\n    }\n}\n"
    },
    "contracts/governance/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) private {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n}\n"
    },
    "contracts/miserable-flight/SigManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @title  Signature Manager\n * @notice Signature is used when submitting new applications.\n *         The premium should be decided by the pricing model and be signed by a private key.\n *         Other submissions will not be accepted.\n *         Please keep the signer key safe.\n */\ncontract SigManager is Ownable {\n    using ECDSA for bytes32;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Variables *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    mapping(address => bool) public isValidSigner;\n\n    bytes32 public _SUBMIT_APPLICATION_TYPEHASH;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event SignerAdded(address _newSigner);\n    event SignerRemoved(address _oldSigner);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() Ownable(msg.sender) {\n        _SUBMIT_APPLICATION_TYPEHASH = keccak256(\n            \"5G is great, physical lab is difficult to find\"\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @dev This modifier uses assert which means this error should never happens\n     */\n    modifier validAddress(address _address) {\n        assert(_address != address(0));\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a signer into valid signer list\n     * @param _newSigner The new signer address\n     */\n    function addSigner(address _newSigner)\n        external\n        validAddress(_newSigner)\n        onlyOwner\n    {\n        require(!isValidSigner[_newSigner], \"Already a signer\");\n\n        isValidSigner[_newSigner] = true;\n\n        emit SignerAdded(_newSigner);\n    }\n\n    /**\n     * @notice Remove a signer from the valid signer list\n     * @param _oldSigner The old signer address to be removed\n     */\n    function removeSigner(address _oldSigner)\n        external\n        validAddress(_oldSigner)\n        onlyOwner\n    {\n        require(isValidSigner[_oldSigner], \"Not a signer\");\n\n        isValidSigner[_oldSigner] = false;\n\n        emit SignerRemoved(_oldSigner);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check signature when buying a new policy (avoid arbitrary premium amount)\n     * @param signature 65 bytes array: [[v (1)], [r (32)], [s (32)]]\n     * @param _flightNumber Flight number\n     * @param _departureTimestamp Flight departure timestamp\n     * @param _landingDate Flight landing date\n     * @param _user User address\n     * @param _premium Policy premium\n     * @param _deadline Deadline of a this signature\n     */\n    function checkSignature(\n        bytes calldata signature,\n        string memory _flightNumber,\n        uint256 _departureTimestamp,\n        uint256 _landingDate,\n        address _user,\n        uint256 _premium,\n        uint256 _deadline\n    ) external view {\n        bytes32 hashedFlightNumber = keccak256(bytes(_flightNumber));\n\n        bytes32 hashData = keccak256(\n            abi.encodePacked(\n                _SUBMIT_APPLICATION_TYPEHASH,\n                hashedFlightNumber,\n                _departureTimestamp,\n                _landingDate,\n                _user,\n                _premium,\n                _deadline\n            )\n        );\n        address signer = hashData.toEthSignedMessageHash().recover(signature);\n\n        require(isValidSigner[signer], \"Only submitted by authorized signers\");\n    }\n}\n"
    },
    "contracts/miserable-flight/FDPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"../utils/OwnableWithoutContext.sol\";\nimport \"../libraries/StringsUtils.sol\";\nimport \"./interfaces/IPolicyFlow.sol\";\nimport \"./interfaces/IPolicyStruct.sol\";\n\n/**\n * @title  Policy Token for flight delay\n * @notice ERC721 policy token\n *         Can get a long string form of the tokenURI\n *         When the ownership is transferred, it will update the status in policyFlow\n */\ncontract FDPolicyToken is\n    ERC721Enumerable,\n    IPolicyStruct,\n    OwnableWithoutContext\n{\n    using StringsUtils for uint256;\n    using StringsUtils for address;\n\n    // PolicyFlow contract interface\n    IPolicyFlow public policyFlow;\n\n    uint256 public _nextId;\n\n    struct PolicyTokenURIParam {\n        string flightNumber;\n        address owner;\n        uint256 premium;\n        uint256 payoff;\n        uint256 purchaseTimestamp;\n        uint256 departureTimestamp;\n        uint256 landingTimestamp;\n        uint256 status;\n    }\n\n    event PolicyFlowUpdated(address newPolicyFlow);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor()\n        ERC721(\"Degis FlightDelay PolicyToken\", \"DEGIS_FD_PT\")\n        OwnableWithoutContext(msg.sender)\n    {\n        _nextId = 1;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the tokenURI of a policy\n     * @param _tokenId Token Id of the policy token\n     * @return The tokenURI in string form\n     */\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override(ERC721)\n        returns (string memory)\n    {\n        require(_tokenId < _nextId, \"TokenId is too large!\");\n        return _getTokenURI(_tokenId);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Set Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n       @notice Update the policyFlow address if it has been updated\n       @param _policyFlow New policyFlow contract address\n     */\n    function updatePolicyFlow(address _policyFlow) external onlyOwner {\n        policyFlow = IPolicyFlow(_policyFlow);\n        emit PolicyFlowUpdated(_policyFlow);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint a new policy token to an address\n     * @param _to The receiver address\n     */\n    function mintPolicyToken(address _to) public {\n        require(\n            _msgSender() == address(policyFlow),\n            \"Only the policyflow contract can mint fd policy token\"\n        );\n        uint256 tokenId = _nextId++;\n        _safeMint(_to, tokenId);\n    }\n\n    /**\n     * @notice Transfer the owner of a policy token and update the information in policyFlow\n     * @dev Need approval and is prepared for secondary market\n     * @dev If you just transfer the policy token, you will not transfer the right for claiming payoff\n     * @param _from The original owner of the policy\n     * @param _to The new owner of the policy\n     * @param _tokenId Token id of the policy\n     */\n    function transferOwner(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public {\n        safeTransferFrom(_from, _to, _tokenId);\n        policyFlow.policyOwnerTransfer(_tokenId, _from, _to);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the tokenURI, the metadata is from policyFlow contract\n     * @param _tokenId Token Id of the policy token\n     */\n    function _getTokenURI(uint256 _tokenId)\n        internal\n        view\n        returns (string memory)\n    {\n        PolicyInfo memory info = policyFlow.getPolicyInfoById(_tokenId);\n\n        return\n            _constructTokenURI(\n                PolicyTokenURIParam(\n                    info.flightNumber,\n                    info.buyerAddress,\n                    info.premium,\n                    info.payoff,\n                    info.purchaseTimestamp,\n                    info.departureTimestamp,\n                    info.landingTimestamp,\n                    uint256(info.status)\n                )\n            );\n    }\n\n    /**\n     * @notice Construct the metadata of a specific policy token\n     * @param _params The parameters of the policy token\n     */\n    function _constructTokenURI(PolicyTokenURIParam memory _params)\n        internal\n        pure\n        returns (string memory)\n    {\n        string[9] memory parts;\n\n        parts[0] = \"ProductId: 0, \";\n        parts[1] = string(\n            abi.encodePacked(\"FlightNumber: \", _params.flightNumber, \", \")\n        );\n        parts[2] = string(\n            abi.encodePacked(\n                \"BuyerAddress: \",\n                (_params.owner).addressToString(),\n                \", \"\n            )\n        );\n\n        parts[3] = string(\n            abi.encodePacked(\n                \"Premium: \",\n                (_params.premium / 1e18).uintToString(),\n                \", \"\n            )\n        );\n\n        parts[4] = string(\n            abi.encodePacked(\n                \"Payoff: \",\n                (_params.payoff / 1e18).uintToString(),\n                \", \"\n            )\n        );\n\n        parts[5] = string(\n            abi.encodePacked(\n                \"PurchaseTimestamp: \",\n                _params.purchaseTimestamp.uintToString(),\n                \", \"\n            )\n        );\n\n        parts[6] = string(\n            abi.encodePacked(\n                \"DepartureTimestamp:\",\n                _params.departureTimestamp.uintToString(),\n                \", \"\n            )\n        );\n\n        parts[7] = string(\n            abi.encodePacked(\n                \"LandingTimestamp: \",\n                (_params.landingTimestamp).uintToString(),\n                \", \"\n            )\n        );\n\n        parts[8] = string(\n            abi.encodePacked(\n                \"PolicyStatus: \",\n                _params.status.uintToString(),\n                \".\"\n            )\n        );\n\n        string memory output = string(\n            abi.encodePacked(\n                parts[0],\n                parts[1],\n                parts[2],\n                parts[3],\n                parts[4],\n                parts[5],\n                parts[6],\n                parts[7],\n                parts[8]\n            )\n        );\n        return output;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/miserable-flight/FlightOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"./interfaces/IPolicyFlow.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @title  Flight Oracle\n * @notice This is the flight oracle contract.\n *         Called by policyFlow contract and send the request to chainlink node.\n *         After receiving the result, call the policyFlow contract to do the settlement.\n * @dev    Remember to set the url, oracleAddress and jobId\n *         If there are multiple oracle providers in the future, this contract may need to be updated.\n */\ncontract FlightOracle is ChainlinkClient, Ownable {\n    using Chainlink for Chainlink.Request;\n\n    IPolicyFlow public policyFlow;\n\n    address public oracleAddress;\n    bytes32 public jobId;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event OracleAddressChanged(address newOracle);\n    event JobIdChanged(bytes32 newJobId);\n    event PolicyFlowChanged(address newPolicyFlow);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Need the address of LINK token on specific network\n     */\n    constructor(address _policyFlow, address _link) Ownable(msg.sender) {\n        policyFlow = IPolicyFlow(_policyFlow);\n\n        setChainlinkToken(_link);\n\n        oracleAddress = 0x7D9398979267a6E050FbFDFff953Fc612A5aD4C9;\n        jobId = \"bcc0a699531940479bc93cf9fa5afb3f\";\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Only the policyFlow can call some functions\n    modifier onlyPolicyFlow() {\n        require(\n            msg.sender == address(policyFlow),\n            \"Only the policyflow can call this function\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Returns the address of the LINK token\n     * @dev This is the public implementation for chainlinkTokenAddress, which is\n     *      an internal method of the ChainlinkClient contract\n     */\n    function getChainlinkTokenAddress() external view returns (address) {\n        return chainlinkTokenAddress();\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set the oracle address\n     */\n    function setOracleAddress(address _newOracle) external onlyOwner {\n        oracleAddress = _newOracle;\n        emit OracleAddressChanged(_newOracle);\n    }\n\n    /**\n     * @notice Set a new job id\n     */\n    function setJobId(bytes32 _newJobId) external onlyOwner {\n        jobId = _newJobId;\n        emit JobIdChanged(_newJobId);\n    }\n\n    /**\n     * @notice Change the policy flow contract address\n     */\n    function setPolicyFlow(address _policyFlow) external onlyOwner {\n        policyFlow = IPolicyFlow(_policyFlow);\n        emit PolicyFlowChanged(_policyFlow);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Creates a request to the specified Oracle contract address\n     * @dev This function ignores the stored Oracle contract address and\n     *      will instead send the request to the address specified\n     * @param _payment Payment to the oracle\n     * @param _url The URL to fetch data from\n     * @param _path The dot-delimited path to parse of the response\n     * @param _times The number to multiply the result by\n     */\n    function newOracleRequest(\n        uint256 _payment,\n        string memory _url,\n        string memory _path,\n        int256 _times\n    ) public onlyPolicyFlow returns (bytes32) {\n        require(\n            oracleAddress != address(0) && jobId != 0,\n            \"Set the oracle address & jobId\"\n        );\n\n        // Enough LINK token for payment\n        require(\n            LinkTokenInterface(chainlinkTokenAddress()).balanceOf(\n                address(this)\n            ) >= _payment,\n            \"Insufficient LINK balance\"\n        );\n\n        Chainlink.Request memory req = buildChainlinkRequest(\n            jobId,\n            address(this),\n            this.fulfill.selector\n        );\n        req.add(\"url\", _url);\n        req.add(\"path\", _path);\n        req.addInt(\"times\", _times);\n        return sendChainlinkRequestTo(oracleAddress, req, _payment);\n    }\n\n    /**\n     * @notice The fulfill method from requests created by this contract\n     * @dev The recordChainlinkFulfillment protects this function from being called\n     *      by anyone other than the oracle address that the request was sent to\n     * @param _requestId The ID that was generated for the request\n     * @param _data The answer provided by the oracle\n     */\n    function fulfill(bytes32 _requestId, uint256 _data)\n        public\n        recordChainlinkFulfillment(_requestId)\n    {\n        policyFlow.finalSettlement(_requestId, _data);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "contracts/libraries/StringsUtilsTester.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./StringsUtils.sol\";\n\ncontract StringsUtilsTester {\n    function byToString(bytes32 _bytes) public pure returns (string memory) {\n        return StringsUtils.byToString(_bytes);\n    }\n\n    function addressToString(address _addr)\n        public\n        pure\n        returns (string memory)\n    {\n        return StringsUtils.addressToString(_addr);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function uintToString(uint256 value) public pure returns (string memory) {\n        return StringsUtils.uintToString(value);\n    }\n\n    function uintToHexString(uint256 value)\n        public\n        pure\n        returns (string memory)\n    {\n        return StringsUtils.uintToHexString(value);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function uintToHexString(uint256 value, uint256 length)\n        public\n        pure\n        returns (string memory)\n    {\n        return StringsUtils.uintToHexString(value, length);\n    }\n}\n"
    },
    "contracts/chainlinkMock/VRFMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"../lucky-box/interfaces/IDegisLottery.sol\";\nimport \"../libraries/StringsUtils.sol\";\n\ncontract VRFMock is Ownable {\n    using StringsUtils for uint256;\n\n    IDegisLottery public DegisLottery;\n\n    uint256 public randomResult;\n\n    uint256 public latestLotteryId;\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Set the address for the DegisLottery\n     * @param _degisLottery address of the PancakeSwap lottery\n     */\n    function setLotteryAddress(address _degisLottery) external onlyOwner {\n        DegisLottery = IDegisLottery(_degisLottery);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Request randomness from Chainlink VRF\n     */\n    function getRandomNumber() external {\n        require(_msgSender() == address(DegisLottery), \"Only DegisLottery\");\n\n        // TODO: This part is only for test on Fuji Testnet because there is no VRF currently\n        string memory randInput = string(\n            abi.encodePacked((block.timestamp).uintToString(), address(this))\n        );\n        randomResult = _rand(randInput) % 10000;\n\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\n    }\n\n    function _rand(string memory input) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(input)));\n    }\n}\n"
    },
    "contracts/chainlinkMock/PriceFeedMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"../libraries/StringsUtils.sol\";\n\ncontract PriceFeedMock is Ownable {\n    using StringsUtils for uint256;\n\n    struct PriceFeedInfo {\n        address priceFeedAddress;\n        uint256 decimals;\n    }\n    // Use token name (string) as the mapping key\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\n\n    uint256 public roundId;\n\n    uint256 public result;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event PriceFeedChanged(\n        string tokenName,\n        address feedAddress,\n        uint256 decimals\n    );\n\n    event LatestPriceGet(uint256 roundID, uint256 price);\n\n    constructor() Ownable(msg.sender) {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @dev For test, you can set the result you want\n     */\n    function setResult(uint256 _result) public {\n        result = _result;\n    }\n\n    /**\n     * @notice Get latest price of a token\n     * @param _tokenName Address of the token\n     * @return price The latest price\n     */\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\n        uint256 price = result;\n\n        // require(price > 0, \"Only accept price that > 0\");\n        if (price < 0) price = 0;\n\n        emit LatestPriceGet(roundId, price);\n\n        roundId += 1;\n\n        uint256 finalPrice = uint256(price);\n\n        return finalPrice;\n    }\n}\n"
    },
    "contracts/EmergencyPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./utils/Ownable.sol\";\n\n/**\n * @title  Emergency Pool\n * @notice Emergency pool in degis will keep a reserve vault for emergency usage.\n *         The asset comes from part of the product's income (currently 10%).\n *         Users can also stake funds into this contract manually.\n *         The owner has the right to withdraw funds from emergency pool and it would be passed to community governance.\n */\ncontract EmergencyPool is Ownable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    string public name = \"Degis Emergency Pool\";\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Deposit(\n        address indexed tokenAddress,\n        address indexed userAddress,\n        uint256 amount\n    );\n    event Withdraw(\n        address indexed tokenAddress,\n        address indexed userAddress,\n        uint256 amount\n    );\n    event UseFund(\n        address indexed tokenAddress,\n        address indexed userAddress,\n        uint256 amount\n    );\n\n    constructor() Ownable(msg.sender) {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Manually stake into the pool\n     * @param _tokenAddress Address of the ERC20 token\n     * @param _amount The amount that the user want to stake\n     */\n    function deposit(address _tokenAddress, uint256 _amount) external {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        IERC20(_tokenAddress).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _amount\n        );\n\n        emit Deposit(_tokenAddress, _msgSender(), _amount);\n    }\n\n    /**\n     * @notice Withdraw the asset when emergency (only by the owner)\n     * @dev The ownership need to be transferred to another contract in the future\n     * @param _tokenAddress Address of the ERC20 token\n     * @param _amount The amount that the user want to unstake\n     */\n    function emergencyWithdraw(address _tokenAddress, uint256 _amount)\n        external\n        onlyOwner\n    {\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\n        require(_amount <= balance, \"Insufficient funds\");\n\n        IERC20(_tokenAddress).safeTransfer(owner(), _amount);\n        emit Withdraw(_tokenAddress, owner(), _amount);\n    }\n\n    /**\n     * @notice Use emergency pool fund\n     * @param _tokenAddress Address of the ERC20 token\n     * @param _receiver Address of the receiver\n     * @param _amount The amount to use    \n     */\n    function useFund(\n        address _tokenAddress,\n        address _receiver,\n        uint256 _amount\n    ) external onlyOwner {\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\n        require(_amount <= balance, \"Insufficient funds\");\n\n        IERC20(_tokenAddress).safeTransfer(_receiver, _amount);\n        emit UseFund(_tokenAddress, _receiver, _amount);\n    }\n}\n"
    },
    "contracts/libraries/SafePRBMathTester.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./SafePRBMath.sol\";\n\ncontract SafePRBMathTester {\n    function avg(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.avg(x, y);\n    }\n\n    function ceil(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.ceil(x);\n    }\n\n    function div(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.div(x, y);\n    }\n\n    function e() public pure returns (uint256 result) {\n        return SafePRBMath.e();\n    }\n\n    function exp(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.exp(x);\n    }\n\n    function exp2(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.exp2(x);\n    }\n\n    function floor(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.floor(x);\n    }\n\n    function frac(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.frac(x);\n    }\n\n    function fromUint(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.fromUint(x);\n    }\n\n    function gm(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.gm(x, y);\n    }\n\n    function inv(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.inv(x);\n    }\n\n    function ln(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.ln(x);\n    }\n\n    function log10(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.log10(x);\n    }\n\n    function log2(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.log2(x);\n    }\n\n    function mul(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.mul(x, y);\n    }\n\n    function pi() public pure returns (uint256 result) {\n        return SafePRBMath.pi();\n    }\n\n    function pow(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.pow(x, y);\n    }\n\n    function powu(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.powu(x, y);\n    }\n\n    function scale() public pure returns (uint256 result) {\n        return SafePRBMath.scale();\n    }\n\n    function sqrt(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.sqrt(x);\n    }\n\n    function toUint(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.toUint(x);\n    }\n}\n"
    },
    "contracts/tokens/BuyerToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../utils/ERC20PermitWithMultipleMinters.sol\";\n\n/**\n * @title  Buyer Token\n * @notice Buyer tokens are distributed to buyers corresponding to the usd value they spend.\n *         Users can deposit their buyer tokens into PurchaseIncentiveVault.\n *         Periodical reward will be given to the participants in PurchaseIncentiveVault.\n *         When distributing purchase incentive reward, the buyer tokens will be burned.\n * @dev    Need to set the correct minters and burners when reploying this contract.\n */\ncontract BuyerToken is ERC20PermitWithMultipleMinters {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Constructor *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() ERC20PermitWithMultipleMinters(\"DegisBuyerToken\", \"DBT\") {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintBuyerToken(address _account, uint256 _amount) external {\n        mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnBuyerToken(address _account, uint256 _amount) external {\n        burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/naughty-price/PriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {Ownable} from \"../utils/Ownable.sol\";\n\n/**\n * @title  Price Getter\n * @notice This is the contract for getting price feed from chainlink.\n *         The contract will keep a record from tokenName => priceFeed Address.\n *         Got the sponsorship and collaboration with Chainlink.\n * @dev    The price from chainlink priceFeed has different decimals, be careful.\n */\ncontract PriceGetter is Ownable {\n    struct PriceFeedInfo {\n        address priceFeedAddress;\n        uint256 decimals;\n    }\n    // Use token name (string) as the mapping key\n    // Should set the correct orginal token name\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event PriceFeedChanged(\n        string tokenName,\n        address feedAddress,\n        uint256 decimals\n    );\n\n    event LatestPriceGet(\n        uint80 roundID,\n        int256 price,\n        uint256 startedAt,\n        uint256 timeStamp,\n        uint80 answeredInRound\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor function, initialize some price feed\n     */\n    constructor() Ownable(msg.sender) {\n        // Avalanche data feed addresses and decimals\n        priceFeedInfo[\"AVAX\"] = PriceFeedInfo(\n            0x0A77230d17318075983913bC2145DB16C7366156,\n            8\n        );\n\n        priceFeedInfo[\"ETH\"] = PriceFeedInfo(\n            0x976B3D034E162d8bD72D6b9C989d545b839003b0,\n            8\n        );\n\n        priceFeedInfo[\"BTC\"] = PriceFeedInfo(\n            0x2779D32d5166BAaa2B2b658333bA7e6Ec0C65743,\n            8\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Modifiers ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Can not give zero address\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set a price feed oracle address for a token\n     * @param _tokenName Address of the token\n     * @param _feedAddress Price feed oracle address\n     * @param _decimals Decimals of this price feed service\n     */\n    function setPriceFeed(\n        string memory _tokenName,\n        address _feedAddress,\n        uint256 _decimals\n    ) public onlyOwner notZeroAddress(_feedAddress) {\n        require(_decimals <= 18, \"Too many decimals\");\n        priceFeedInfo[_tokenName] = PriceFeedInfo(_feedAddress, _decimals);\n\n        emit PriceFeedChanged(_tokenName, _feedAddress, _decimals);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get latest price of a token\n     * @param _tokenName Address of the token\n     * @return price The latest price\n     */\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\n        PriceFeedInfo memory priceFeed = priceFeedInfo[_tokenName];\n\n        (\n            uint80 roundID,\n            int256 price,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(priceFeed.priceFeedAddress).latestRoundData();\n\n        // require(price > 0, \"Only accept price that > 0\");\n        if (price < 0) price = 0;\n\n        emit LatestPriceGet(\n            roundID,\n            price,\n            startedAt,\n            timeStamp,\n            answeredInRound\n        );\n        // Transfer the result decimals\n        uint256 finalPrice = uint256(price) * (10**(18 - priceFeed.decimals));\n\n        return finalPrice;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}