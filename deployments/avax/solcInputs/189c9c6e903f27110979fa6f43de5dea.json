{
  "language": "Solidity",
  "sources": {
    "contracts/chainlinkMock/FlightOracleMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../miserable-flight/interfaces/IPolicyFlow.sol\";\r\nimport \"../utils/Ownable.sol\";\r\n\r\n/**\r\n * @title  Flight Oracle Mock\r\n * @notice Mock oracle contract for test.\r\n */\r\ncontract FlightOracleMock is Ownable {\r\n    IPolicyFlow public policyFlow;\r\n\r\n    uint256 public delayResult; // For test\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event PolicyFlowChanged(address newPolicyFlow);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Need the address of LINK token on specific network\r\n     */\r\n    constructor(address _policyFlow) Ownable(msg.sender) {\r\n        policyFlow = IPolicyFlow(_policyFlow);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Only the policyFlow can call some functions\r\n    modifier onlyPolicyFlow() {\r\n        require(\r\n            msg.sender == address(policyFlow),\r\n            \"Only the policyflow can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Change the policy flow contract address\r\n     */\r\n    function setPolicyFlow(address _policyFlow) external onlyOwner {\r\n        policyFlow = IPolicyFlow(_policyFlow);\r\n        emit PolicyFlowChanged(_policyFlow);\r\n    }\r\n\r\n    function setResult(uint256 _delayResult) external {\r\n        delayResult = _delayResult;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Creates a request to the specified Oracle contract address\r\n     * @dev This function ignores the stored Oracle contract address and\r\n     *      will instead send the request to the address specified\r\n     * @param _payment Payment to the oracle\r\n     * @param _url The URL to fetch data from\r\n     * @param _path The dot-delimited path to parse of the response\r\n     * @param _times The number to multiply the result by\r\n     */\r\n    function newOracleRequest(\r\n        uint256 _payment,\r\n        string memory _url,\r\n        string memory _path,\r\n        int256 _times\r\n    ) public view onlyPolicyFlow returns (bytes32 requestId) {\r\n        requestId = keccak256(abi.encodePacked(_payment, _url, _path, _times));\r\n\r\n        // fulfill(test_hash, delayResult);\r\n        return requestId;\r\n    }\r\n\r\n    /**\r\n     * @notice The fulfill method from requests created by this contract\r\n     * @dev The recordChainlinkFulfillment protects this function from being called\r\n     *      by anyone other than the oracle address that the request was sent to\r\n     * @param _requestId The ID that was generated for the request\r\n     */\r\n    function fulfill(bytes32 _requestId) public {\r\n        policyFlow.finalSettlement(_requestId, delayResult);\r\n    }\r\n}\r\n"
    },
    "contracts/miserable-flight/interfaces/IPolicyFlow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./IPolicyStruct.sol\";\r\n\r\n/**\r\n * @title  IPolicyFlow\r\n * @notice This is the interface of PolicyFlow contract.\r\n *         Contains some type definations, event list and function declarations.\r\n */\r\ninterface IPolicyFlow is IPolicyStruct {\r\n    /// @notice Function declarations\r\n\r\n    /// @notice Apply for a new policy\r\n    function newApplication(\r\n        uint256 _productId,\r\n        string memory _flightNumber,\r\n        uint256 _premium,\r\n        uint256 _departureTimestamp,\r\n        uint256 _landingTimestamp,\r\n        uint256 _deadline,\r\n        bytes calldata signature\r\n    ) external returns (uint256 policyId);\r\n\r\n    /// @notice Start a new claim request\r\n    function newClaimRequest(\r\n        uint256 _policyId,\r\n        string memory _flightNumber,\r\n        string memory _timestamp,\r\n        string memory _path,\r\n        bool _forceUpdate\r\n    ) external;\r\n\r\n    /// @notice View a user's policy info\r\n    function viewUserPolicy(address)\r\n        external\r\n        view\r\n        returns (PolicyInfo[] memory);\r\n\r\n    /// @notice Get the policy info by its policyId\r\n    function getPolicyInfoById(uint256)\r\n        external\r\n        view\r\n        returns (PolicyInfo memory);\r\n\r\n    /// @notice Update when the policy token is transferred to another owner\r\n    function policyOwnerTransfer(\r\n        uint256,\r\n        address,\r\n        address\r\n    ) external;\r\n\r\n    /// @notice Do the final settlement when receiving the oracle result\r\n    function finalSettlement(bytes32 _requestId, uint256 _result) external;\r\n}\r\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev The owner can be set during deployment, not default to be msg.sender\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor(address _initialOwner) {\r\n        _transferOwnership(_initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Leaves the contract without owner. It will not be possible to call\r\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * @dev    Renouncing ownership will leave the contract without an owner,\r\n     *         thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\r\n     * @dev    Can only be called by the current owner.\r\n     * @param  newOwner Address of the new owner\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\r\n     * @dev    Internal function without access restriction.\r\n     * @param  newOwner Address of the new owner\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"
    },
    "contracts/miserable-flight/interfaces/IPolicyStruct.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface IPolicyStruct {\r\n    enum PolicyStatus {\r\n        INI,\r\n        SOLD,\r\n        EXPIRED,\r\n        CLAIMED\r\n    }\r\n\r\n    struct PolicyInfo {\r\n        uint256 productId;\r\n        address buyerAddress;\r\n        uint256 policyId;\r\n        string flightNumber;\r\n        uint256 premium;\r\n        uint256 payoff;\r\n        uint256 purchaseTimestamp;\r\n        uint256 departureTimestamp;\r\n        uint256 landingTimestamp;\r\n        PolicyStatus status;\r\n        bool alreadySettled;\r\n        uint256 delayResult;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n"
    },
    "contracts/staking/StakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport {Ownable} from \"../utils/Ownable.sol\";\r\nimport {IPool} from \"./interfaces/IPool.sol\";\r\nimport {BasePool, CoreStakingPool} from \"./CoreStakingPool.sol\";\r\nimport {IDegisToken} from \"../tokens/interfaces/IDegisToken.sol\";\r\n\r\ncontract StakingPoolFactory is Ownable {\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Pool data info\r\n    struct PoolData {\r\n        address poolToken; // pool token address (Degis / Degis LP Token)\r\n        address poolAddress; // pool address (deployed by factory)\r\n        uint256 startTimestamp; // pool start timestamp\r\n        uint256 degisPerSecond; // reward speed\r\n    }\r\n\r\n    address public degisToken;\r\n\r\n    // Pool token address  => pool address\r\n    mapping(address => address) public pools;\r\n\r\n    // Pool address -> whether exists\r\n    mapping(address => bool) public poolExists;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event PoolRegistered(\r\n        address indexed by,\r\n        address indexed poolToken,\r\n        address indexed poolAddress,\r\n        uint256 degisPerSecond\r\n    );\r\n\r\n    event DegisPerSecondChanged(address pool, uint256 degisPerSecond);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    constructor(address _degisToken) Ownable(msg.sender) {\r\n        degisToken = _degisToken;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get the pool address from pool token address\r\n     * @param _poolToken Pool token address\r\n     */\r\n    function getPoolAddress(address _poolToken)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return pools[_poolToken];\r\n    }\r\n\r\n    /**\r\n     * @notice Get pool data from pool token address\r\n     * @param _poolToken Pool token address\r\n     * @return poolData Pool data struct\r\n     */\r\n    function getPoolData(address _poolToken)\r\n        public\r\n        view\r\n        returns (PoolData memory)\r\n    {\r\n        // get the pool address from the mapping\r\n        address poolAddr = pools[_poolToken];\r\n\r\n        // throw if there is no pool registered for the token specified\r\n        require(poolAddr != address(0), \"pool not found\");\r\n\r\n        // read pool information from the pool smart contract\r\n        // via the pool interface (IPool)\r\n        address poolToken = IPool(poolAddr).poolToken();\r\n        uint256 startTimestamp = IPool(poolAddr).startTimestamp();\r\n        uint256 degisPerSecond = IPool(poolAddr).degisPerSecond();\r\n\r\n        // create the in-memory structure and return it\r\n        return\r\n            PoolData({\r\n                poolToken: poolToken,\r\n                poolAddress: poolAddr,\r\n                startTimestamp: startTimestamp,\r\n                degisPerSecond: degisPerSecond\r\n            });\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Set degis per second for a pool\r\n     * @param _pool Address of the staking pool\r\n     * @param _degisPerSecond Degis reward per second\r\n     */\r\n    function setDegisPerSecond(address _pool, uint256 _degisPerSecond)\r\n        external\r\n        onlyOwner\r\n    {\r\n        BasePool(_pool).setDegisPerSecond(_degisPerSecond);\r\n\r\n        emit DegisPerSecondChanged(_pool, _degisPerSecond);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Creates a staking pool and registers it within the factory\r\n     * @dev Only called by the owner\r\n     * @param _poolToken Pool token address\r\n     * @param _startTimestamp Start timestamp for reward\r\n     * @param _degisPerSecond Reward speed\r\n     */\r\n    function createPool(\r\n        address _poolToken,\r\n        uint256 _startTimestamp,\r\n        uint256 _degisPerSecond\r\n    ) external onlyOwner {\r\n        // create/deploy new core pool instance\r\n        IPool pool = new CoreStakingPool(\r\n            degisToken,\r\n            _poolToken,\r\n            address(this),\r\n            _startTimestamp,\r\n            _degisPerSecond\r\n        );\r\n\r\n        // register it within a factory\r\n        _registerPool(address(pool));\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Register a deployed pool instance within the factory\r\n     * @param _poolAddr Address of the already deployed pool instance\r\n     */\r\n    function _registerPool(address _poolAddr) internal {\r\n        // Read pool information from the pool smart contract\r\n        // via the pool interface (IPool)\r\n        address poolToken = IPool(_poolAddr).poolToken();\r\n        uint256 degisPerSecond = IPool(_poolAddr).degisPerSecond();\r\n\r\n        // Ensure that the pool is not already registered within the factory\r\n        require(\r\n            pools[poolToken] == address(0),\r\n            \"This pool is already registered\"\r\n        );\r\n\r\n        // Record\r\n        pools[poolToken] = _poolAddr;\r\n        poolExists[_poolAddr] = true;\r\n\r\n        emit PoolRegistered(\r\n            msg.sender,\r\n            poolToken,\r\n            _poolAddr,\r\n            degisPerSecond\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Mint degis tokens as reward\r\n     * @dev With this function, we only need to add factory contract into minterList\r\n     * @param _to The address to mint tokens to\r\n     * @param _amount Amount of degis tokens to mint\r\n     */\r\n    function mintReward(address _to, uint256 _amount) external {\r\n        // Verify that sender is a pool registered withing the factory\r\n        require(poolExists[msg.sender], \"Only called from pool\");\r\n\r\n        // Mint degis tokens as required\r\n        IDegisToken(degisToken).mintDegis(_to, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/staking/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @title Illuvium Pool\r\n *\r\n * @notice An abstraction representing a pool, see IlluviumPoolBase for details\r\n *\r\n * @author Pedro Bergamini, reviewed by Basil Gorin\r\n */\r\ninterface IPool {\r\n    /**\r\n     * @dev Deposit is a key data structure used in staking,\r\n     *      it represents a unit of stake with its amount, weight and term (time interval)\r\n     */\r\n    struct Deposit {\r\n        // @dev token amount staked\r\n        uint256 tokenAmount;\r\n        // @dev stake weight\r\n        uint256 weight;\r\n        // @dev locking period - from\r\n        uint256 lockedFrom;\r\n        // @dev locking period - until\r\n        uint256 lockedUntil;\r\n    }\r\n\r\n    // for the rest of the functions see Soldoc in IlluviumPoolBase\r\n\r\n    function degisToken() external view returns (address);\r\n\r\n    function poolToken() external view returns (address);\r\n\r\n    function startTimestamp() external view returns (uint256);\r\n\r\n    function degisPerSecond() external view returns (uint256);\r\n\r\n    function totalWeight() external view returns (uint256);\r\n\r\n    function accDegisPerWeight() external view returns (uint256);\r\n\r\n    function pendingReward(address _user) external view returns (uint256);\r\n\r\n    function setDegisPerSecond(uint256 _degisPerSecond) external;\r\n}\r\n"
    },
    "contracts/staking/CoreStakingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport {Ownable} from \"../utils/Ownable.sol\";\r\nimport {BasePool} from \"./abstracts/BasePool.sol\";\r\n\r\ncontract CoreStakingPool is Ownable, BasePool {\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    constructor(\r\n        address _degisToken,\r\n        address _poolToken,\r\n        address _factory,\r\n        uint256 _startTimestamp,\r\n        uint256 _degisPerSecond\r\n    )\r\n        Ownable(msg.sender)\r\n        BasePool(\r\n            _degisToken,\r\n            _poolToken,\r\n            _factory,\r\n            _startTimestamp,\r\n            _degisPerSecond\r\n        )\r\n    {}\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Stake function, will call the stake in BasePool\r\n     * @param _user User address\r\n     * @param _amount Amount to stake\r\n     * @param _lockUntil Lock until timestamp (0 means flexible staking)\r\n     */\r\n    function _stake(\r\n        address _user,\r\n        uint256 _amount,\r\n        uint256 _lockUntil\r\n    ) internal override {\r\n        super._stake(_user, _amount, _lockUntil);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstake function, will check some conditions and call the unstake in BasePool\r\n     * @param _user User address\r\n     * @param _depositId Deposit id\r\n     * @param _amount Amount to unstake\r\n     */\r\n    function _unstake(\r\n        address _user,\r\n        uint256 _depositId,\r\n        uint256 _amount\r\n    ) internal override {\r\n        UserInfo storage user = users[_msgSender()];\r\n        Deposit memory stakeDeposit = user.deposits[_depositId];\r\n        require(\r\n            stakeDeposit.lockedFrom == 0 ||\r\n                block.timestamp >= stakeDeposit.lockedUntil,\r\n            \"Deposit not yet unlocked\"\r\n        );\r\n\r\n        super._unstake(_user, _depositId, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/tokens/interfaces/IDegisToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IDegisToken is IERC20, IERC20Permit {\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Functions ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n    function CAP() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Mint degis tokens\r\n     * @param  _account Receiver's address\r\n     * @param  _amount Amount to be minted\r\n     */\r\n    function mintDegis(address _account, uint256 _amount) external;\r\n\r\n    /**\r\n     * @notice Burn degis tokens\r\n     * @param  _account Receiver's address\r\n     * @param  _amount Amount to be burned\r\n     */\r\n    function burnDegis(address _account, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/staking/abstracts/BasePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../interfaces/IPool.sol\";\r\nimport \"../interfaces/IStakingPoolFactory.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nabstract contract BasePool is IPool, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    struct UserInfo {\r\n        uint256 tokenAmount;\r\n        uint256 totalWeight;\r\n        uint256 rewardDebt;\r\n        // An array of holder's deposits\r\n        Deposit[] deposits;\r\n    }\r\n    mapping(address => UserInfo) public users;\r\n\r\n    // Token address staked in this pool\r\n    address public poolToken;\r\n\r\n    // Reward token: degis\r\n    address public degisToken;\r\n\r\n    // Reward start timestamp\r\n    uint256 public startTimestamp;\r\n\r\n    // Degis reward speed\r\n    uint256 public degisPerSecond;\r\n\r\n    // Last check point\r\n    uint256 public lastRewardTimestamp;\r\n\r\n    // Accumulated degis per weight till now\r\n    uint256 public accDegisPerWeight;\r\n\r\n    // Total weight in the pool\r\n    uint256 public totalWeight;\r\n\r\n    // Factory contract address\r\n    address public factory;\r\n\r\n    // Fees are paid to the previous stakers\r\n    uint256 public constant fee = 2;\r\n\r\n    // Weight multiplier constants\r\n    uint256 internal constant WEIGHT_MULTIPLIER = 1e6;\r\n\r\n    uint256 internal constant YEAR_STAKE_WEIGHT_MULTIPLIER =\r\n        2 * WEIGHT_MULTIPLIER;\r\n\r\n    uint256 internal constant REWARD_PER_WEIGHT_MULTIPLIER = 1e12;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event Stake(address user, uint256 amount, uint256 lockUntil);\r\n\r\n    event Unstake(address user, uint256 amount);\r\n\r\n    event Harvest(address user, uint256 amount);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Constructor\r\n     */\r\n    constructor(\r\n        address _degisToken,\r\n        address _poolToken,\r\n        address _factory,\r\n        uint256 _startTimestamp,\r\n        uint256 _degisPerSecond\r\n    ) {\r\n        degisToken = _degisToken;\r\n        poolToken = _poolToken;\r\n        factory = _factory;\r\n\r\n        degisPerSecond = _degisPerSecond;\r\n\r\n        startTimestamp = _startTimestamp;\r\n\r\n        lastRewardTimestamp = block.timestamp > _startTimestamp\r\n            ? block.timestamp\r\n            : _startTimestamp;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Only the factory can call some functions\r\n     */\r\n    modifier onlyFactory() {\r\n        require(msg.sender == factory, \"Only factory\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get a user's deposit info\r\n     * @param _user User address\r\n     * @return deposits[] User's deposit info\r\n     */\r\n    function getUserDeposits(address _user)\r\n        external\r\n        view\r\n        returns (Deposit[] memory)\r\n    {\r\n        return users[_user].deposits;\r\n    }\r\n\r\n    /**\r\n     * @notice Get pending rewards\r\n     * @param _user User address\r\n     * @return pendingReward User's pending rewards\r\n     */\r\n    function pendingReward(address _user) external view returns (uint256) {\r\n        if (\r\n            block.timestamp < lastRewardTimestamp ||\r\n            block.timestamp < startTimestamp ||\r\n            totalWeight == 0\r\n        ) return 0;\r\n\r\n        uint256 blocks = block.timestamp - lastRewardTimestamp;\r\n        uint256 degisReward = blocks * degisPerSecond;\r\n\r\n        // recalculated value for `yieldRewardsPerWeight`\r\n        uint256 newDegisPerWeight = rewardToWeight(degisReward, totalWeight) +\r\n            accDegisPerWeight;\r\n\r\n        // based on the rewards per weight value, calculate pending rewards;\r\n        UserInfo memory user = users[_user];\r\n\r\n        uint256 pending = weightToReward(user.totalWeight, newDegisPerWeight) -\r\n            user.rewardDebt;\r\n\r\n        return pending;\r\n    }\r\n\r\n    function rewardToWeight(uint256 reward, uint256 rewardPerWeight)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (reward * REWARD_PER_WEIGHT_MULTIPLIER) / rewardPerWeight;\r\n    }\r\n\r\n    function weightToReward(uint256 weight, uint256 rewardPerWeight)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (weight * rewardPerWeight) / REWARD_PER_WEIGHT_MULTIPLIER;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n    function setDegisPerSecond(uint256 _degisPerSecond) external onlyFactory {\r\n        degisPerSecond = _degisPerSecond;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Stake tokens\r\n     * @param _amount Amount of tokens to stake\r\n     * @param _lockUntil Lock until timestamp\r\n     */\r\n    function stake(uint256 _amount, uint256 _lockUntil) external {\r\n        _stake(msg.sender, _amount, _lockUntil);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstake tokens\r\n     * @param _depositId Deposit id to be unstaked\r\n     * @param _amount Amount of tokens to unstake\r\n     */\r\n    function unstake(uint256 _depositId, uint256 _amount) external {\r\n        _unstake(msg.sender, _depositId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Harvest your staking rewards\r\n     */\r\n    function harvest() external {\r\n        // First update the pool\r\n        updatePool();\r\n\r\n        UserInfo storage user = users[msg.sender];\r\n\r\n        // calculate pending yield rewards, this value will be returned\r\n        uint256 pending = _pendingReward(msg.sender);\r\n\r\n        if (pending == 0) return;\r\n\r\n        _safeDegisTransfer(msg.sender, pending);\r\n\r\n        user.rewardDebt = weightToReward(user.totalWeight, accDegisPerWeight);\r\n\r\n        emit Harvest(msg.sender, pending);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the pool without fee\r\n     */\r\n    function updatePool() public {\r\n        _updatePoolWithFee(0);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Update pool status with fee (if any)\r\n     * @param _fee Fee to be distributed\r\n     */\r\n    function _updatePoolWithFee(uint256 _fee) internal {\r\n        if (block.timestamp <= lastRewardTimestamp) return;\r\n\r\n        uint256 balance = IERC20(poolToken).balanceOf(address(this));\r\n\r\n        if (balance == 0) {\r\n            lastRewardTimestamp = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        uint256 timePassed = block.timestamp - lastRewardTimestamp;\r\n\r\n        // There is _fee when staking\r\n        uint256 degisReward = timePassed * degisPerSecond + _fee;\r\n\r\n        // Mint reward to this staking pool\r\n        IStakingPoolFactory(factory).mintReward(address(this), degisReward);\r\n\r\n        accDegisPerWeight += rewardToWeight(degisReward, totalWeight);\r\n\r\n        lastRewardTimestamp = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Finish stake process\r\n     * @param _user User address\r\n     * @param _amount Amount of tokens to stake\r\n     * @param _lockUntil Lock until timestamp\r\n     */\r\n    function _stake(\r\n        address _user,\r\n        uint256 _amount,\r\n        uint256 _lockUntil\r\n    ) internal virtual nonReentrant {\r\n        require(block.timestamp > startTimestamp, \"Pool not started yet\");\r\n        require(_amount > 0, \"Zero amount\");\r\n        require(\r\n            _lockUntil == 0 || (_lockUntil > block.timestamp),\r\n            \"Invalid lock interval\"\r\n        );\r\n        if (_lockUntil >= block.timestamp + 365 days)\r\n            _lockUntil = block.timestamp + 365 days;\r\n\r\n        uint256 depositFee;\r\n        if (IERC20(poolToken).balanceOf(address(this)) > 0) {\r\n            // Charge deposit fee and distribute to previous stakers\r\n            depositFee = (_amount * fee) / 100;\r\n            _updatePoolWithFee(depositFee);\r\n        } else updatePool();\r\n\r\n        UserInfo storage user = users[_user];\r\n\r\n        if (user.tokenAmount > 0) {\r\n            _distributeReward(_user);\r\n        }\r\n\r\n        uint256 previousBalance = IERC20(poolToken).balanceOf(address(this));\r\n        transferPoolTokenFrom(msg.sender, address(this), _amount);\r\n        uint256 newBalance = IERC20(poolToken).balanceOf(address(this));\r\n\r\n        // Actual amount is without the fee\r\n        uint256 addedAmount = newBalance - previousBalance - depositFee;\r\n\r\n        uint256 lockFrom = _lockUntil > 0 ? block.timestamp : 0;\r\n        uint256 lockUntil = _lockUntil;\r\n\r\n        uint256 stakeWeight = timeToWeight(lockUntil - lockFrom) * addedAmount;\r\n\r\n        // makes sure stakeWeight is valid\r\n        assert(stakeWeight > 0);\r\n\r\n        // create and save the deposit (append it to deposits array)\r\n        Deposit memory deposit = Deposit({\r\n            tokenAmount: addedAmount,\r\n            weight: stakeWeight,\r\n            lockedFrom: lockFrom,\r\n            lockedUntil: lockUntil\r\n        });\r\n        // deposit ID is an index of the deposit in `deposits` array\r\n        user.deposits.push(deposit);\r\n\r\n        // update user record\r\n        user.tokenAmount += addedAmount;\r\n        user.totalWeight += stakeWeight;\r\n        user.rewardDebt = weightToReward(user.totalWeight, accDegisPerWeight);\r\n\r\n        // update global variable\r\n        totalWeight += stakeWeight;\r\n\r\n        // emit an event\r\n        emit Stake(msg.sender, _amount, _lockUntil);\r\n    }\r\n\r\n    /**\r\n     * @notice Finish unstake process\r\n     * @param _user User address\r\n     * @param _depositId deposit ID to unstake from, zero-indexed\r\n     * @param _amount amount of tokens to unstake\r\n     */\r\n    function _unstake(\r\n        address _user,\r\n        uint256 _depositId,\r\n        uint256 _amount\r\n    ) internal virtual nonReentrant {\r\n        // verify an amount is set\r\n        require(_amount > 0, \"zero amount\");\r\n\r\n        UserInfo storage user = users[_user];\r\n\r\n        Deposit storage stakeDeposit = user.deposits[_depositId];\r\n\r\n        // verify available balance\r\n        // if staker address ot deposit doesn't exist this check will fail as well\r\n        require(stakeDeposit.tokenAmount >= _amount, \"amount exceeds stake\");\r\n\r\n        // update smart contract state\r\n        updatePool();\r\n        // and process current pending rewards if any\r\n        _distributeReward(_user);\r\n\r\n        // recalculate deposit weight\r\n        uint256 previousWeight = stakeDeposit.weight;\r\n\r\n        uint256 newWeight = timeToWeight(\r\n            stakeDeposit.lockedUntil - stakeDeposit.lockedFrom\r\n        ) * (stakeDeposit.tokenAmount - _amount);\r\n\r\n        // update the deposit, or delete it if its depleted\r\n        if (stakeDeposit.tokenAmount - _amount == 0) {\r\n            delete user.deposits[_depositId];\r\n        } else {\r\n            stakeDeposit.tokenAmount -= _amount;\r\n            stakeDeposit.weight = newWeight;\r\n        }\r\n\r\n        // update user record\r\n        user.tokenAmount -= _amount;\r\n        user.totalWeight = user.totalWeight - previousWeight + newWeight;\r\n        user.rewardDebt = weightToReward(user.totalWeight, accDegisPerWeight);\r\n\r\n        // update global variable\r\n        totalWeight -= (previousWeight - newWeight);\r\n\r\n        // otherwise just return tokens back to holder\r\n        transferPoolToken(msg.sender, _amount);\r\n\r\n        // emit an event\r\n        emit Unstake(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Lock time => Lock weight\r\n     * @dev 1 year = 2e6\r\n     *      1 week = 1e6\r\n     *      2 weeks = 1e6 * ( 1 + 1 / 365)\r\n     */\r\n    function timeToWeight(uint256 _length)\r\n        public\r\n        pure\r\n        returns (uint256 _weight)\r\n    {\r\n        _weight =\r\n            ((_length * WEIGHT_MULTIPLIER) / 365 days) +\r\n            WEIGHT_MULTIPLIER;\r\n    }\r\n\r\n    /**\r\n     * @notice Check pending reward after update\r\n     * @param _user User address\r\n     */\r\n    function _pendingReward(address _user)\r\n        internal\r\n        view\r\n        returns (uint256 pending)\r\n    {\r\n        // read user data structure into memory\r\n        UserInfo memory user = users[_user];\r\n\r\n        // and perform the calculation using the values read\r\n        return\r\n            weightToReward(user.totalWeight, accDegisPerWeight) -\r\n            user.rewardDebt;\r\n    }\r\n\r\n    /**\r\n     * @notice Distribute reward to staker\r\n     * @param _user User address\r\n     */\r\n    function _distributeReward(address _user) internal {\r\n        uint256 pending = _pendingReward(_user);\r\n\r\n        if (pending == 0) return;\r\n        else {\r\n            _safeDegisTransfer(_user, pending);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer pool token from pool to user\r\n     */\r\n    function transferPoolToken(address _to, uint256 _value) internal {\r\n        // just delegate call to the target\r\n        IERC20(poolToken).safeTransfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer pool token from user to pool\r\n     * @param _from User address\r\n     * @param _to Pool address\r\n     * @param _value Amount of tokens to transfer\r\n     */\r\n    function transferPoolTokenFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n        IERC20(poolToken).safeTransferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\r\n     * @param _to User's address\r\n     * @param _amount Amount to transfer\r\n     */\r\n    function _safeDegisTransfer(address _to, uint256 _amount) internal {\r\n        uint256 totalDegis = IERC20(degisToken).balanceOf(address(this));\r\n        if (_amount > totalDegis) {\r\n            IERC20(degisToken).safeTransfer(_to, totalDegis);\r\n        } else {\r\n            IERC20(degisToken).safeTransfer(_to, _amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/staking/interfaces/IStakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface IStakingPoolFactory {\r\n    function createPool(\r\n        address _poolToken,\r\n        uint256 _startBlock,\r\n        uint256 _degisPerBlock\r\n    ) external;\r\n\r\n    function mintReward(address _to, uint256 _amount) external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/tokens/DegisToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./interfaces/IDegisToken.sol\";\r\nimport \"../utils/ERC20PermitWithMultipleMinters.sol\";\r\n\r\n/**@title  Degis Token\r\n * @notice DegisToken inherits from ERC20 Permit which contains the basic ERC20 implementation.\r\n *         DegisToken can use the permit function rather than approve + transferFrom.\r\n *\r\n *         DegisToken has an owner, a minterList and a burnerList.\r\n *         When lauched on mainnet, the owner may be removed or tranferred to a multisig.\r\n *         By default, the owner & the first minter will be the one that deploys the contract.\r\n *         The minterList should contain FarmingPool and PurchaseIncentiveVault.\r\n *         The burnerList should contain EmergencyPool.\r\n */\r\ncontract DegisToken is ERC20PermitWithMultipleMinters {\r\n    // Degis has a total supply of 100 million\r\n    uint256 public constant CAP = 1e8 ether;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Constructor *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    constructor() ERC20PermitWithMultipleMinters(\"DegisToken\", \"DEG\") {}\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Modifiers **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Degis token has a hard cap of 100 million\r\n    modifier notExceedCap(uint256 _amount) {\r\n        require(\r\n            totalSupply() + _amount <= CAP,\r\n            \"Exceeds the DEG cap (100 million)\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Main Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Mint degis tokens\r\n     * @param  _account Receiver's address\r\n     * @param  _amount  Amount to be minted\r\n     */\r\n    function mintDegis(address _account, uint256 _amount)\r\n        external\r\n        notExceedCap(_amount)\r\n    {\r\n        mint(_account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn degis tokens\r\n     * @param  _account Receiver's address\r\n     * @param  _amount  Amount to be burned\r\n     */\r\n    function burnDegis(address _account, uint256 _amount) external {\r\n        burn(_account, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/ERC20PermitWithMultipleMinters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\r\nimport \"./OwnableWithoutContext.sol\";\r\n\r\n/**\r\n * @title  ERC20 with Multiple Minters and Burners\r\n * @notice This is contract used for ERC20 tokens that has multiple minters and burners.\r\n * @dev    The minters and burners are some contracts in Degis that need to issue DEG.\r\n *         It has basic implementations for ERC20 and also the owner control.\r\n *         Even if the owner is renounced to zero address, the token can still be minted/burned.\r\n *         DegisToken and BuyerToken are both this kind ERC20 token.\r\n */\r\ncontract ERC20PermitWithMultipleMinters is ERC20Permit, OwnableWithoutContext {\r\n    // List of all minters\r\n    mapping(address => bool) public isMinter;\r\n\r\n    // List of all burners\r\n    mapping(address => bool) public isBurner;\r\n\r\n    event MinterAdded(address newMinter);\r\n    event MinterRemoved(address oldMinter);\r\n\r\n    event BurnerAdded(address newBurner);\r\n    event BurnerRemoved(address oldBurner);\r\n\r\n    event Mint(address indexed account, uint256 amount);\r\n    event Burn(address indexed account, uint256 amount);\r\n\r\n    constructor(string memory name, string memory symbol)\r\n        ERC20(name, symbol)\r\n        ERC20Permit(name)\r\n        OwnableWithoutContext(msg.sender)\r\n    {\r\n        // After the owner is transferred to multisig governance\r\n        // This initial minter should be removed\r\n        isMinter[_msgSender()] = true;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Modifiers ****************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     *@notice Check if the msg.sender is in the minter list\r\n     */\r\n    modifier validMinter(address _sender) {\r\n        require(isMinter[_sender], \"Invalid minter\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the msg.sender is in the burner list\r\n     */\r\n    modifier validBurner(address _sender) {\r\n        require(isBurner[_sender], \"Invalid burner\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Admin Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Add a new minter into the minterList\r\n     * @param _newMinter Address of the new minter\r\n     */\r\n    function addMinter(address _newMinter) external onlyOwner {\r\n        require(!isMinter[_newMinter], \"Already a minter\");\r\n\r\n        isMinter[_newMinter] = true;\r\n\r\n        emit MinterAdded(_newMinter);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a minter from the minterList\r\n     * @param _oldMinter Address of the minter to be removed\r\n     */\r\n    function removeMinter(address _oldMinter) external onlyOwner {\r\n        require(isMinter[_oldMinter], \"Not a minter\");\r\n\r\n        isMinter[_oldMinter] = false;\r\n\r\n        emit MinterRemoved(_oldMinter);\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new burner into the burnerList\r\n     * @param _newBurner Address of the new burner\r\n     */\r\n    function addBurner(address _newBurner) external onlyOwner {\r\n        require(!isBurner[_newBurner], \"Already a burner\");\r\n\r\n        isBurner[_newBurner] = true;\r\n\r\n        emit BurnerAdded(_newBurner);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a minter from the minterList\r\n     * @param _oldBurner Address of the minter to be removed\r\n     */\r\n    function removeBurner(address _oldBurner) external onlyOwner {\r\n        require(isMinter[_oldBurner], \"Not a burner\");\r\n\r\n        isBurner[_oldBurner] = false;\r\n\r\n        emit BurnerRemoved(_oldBurner);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Mint tokens\r\n     * @param _account Receiver's address\r\n     * @param _amount Amount to be minted\r\n     */\r\n    function mint(address _account, uint256 _amount)\r\n        internal\r\n        validMinter(_msgSender())\r\n    {\r\n        _mint(_account, _amount); // ERC20 method with an event\r\n        emit Mint(_account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn tokens\r\n     * @param _account address\r\n     * @param _amount amount to be burned\r\n     */\r\n    function burn(address _account, uint256 _amount)\r\n        internal\r\n        validBurner(_msgSender())\r\n    {\r\n        _burn(_account, _amount);\r\n        emit Burn(_account, _amount);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "contracts/utils/OwnableWithoutContext.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @dev The owner can be set during deployment, not default to be msg.sender\r\n */\r\nabstract contract OwnableWithoutContext {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor(address _initialOwner) {\r\n        _transferOwnership(_initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Leaves the contract without owner. It will not be possible to call\r\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * @dev    Renouncing ownership will leave the contract without an owner,\r\n     *         thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\r\n     * @dev    Can only be called by the current owner.\r\n     * @param  newOwner Address of the new owner\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\r\n     * @dev    Internal function without access restriction.\r\n     * @param  newOwner Address of the new owner\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/miserable-flight/InsurancePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"../libraries/SafePRBMath.sol\";\r\nimport \"../lucky-box/interfaces/IDegisLottery.sol\";\r\nimport \"../utils/OwnableWithoutContext.sol\";\r\nimport \"./abstracts/InsurancePoolStore.sol\";\r\n\r\n/**\r\n * @title  Insurance Pool\r\n * @notice Insurance pool is the reserved risk pool for flight delay product.\r\n *         For simplicity, some state variables are in the InsurancePoolStore contract.\r\n */\r\ncontract InsurancePool is\r\n    ERC20(\"Degis FlightDelay LPToken\", \"DLP\"),\r\n    InsurancePoolStore,\r\n    OwnableWithoutContext,\r\n    ReentrancyGuard\r\n{\r\n    using SafeERC20 for IERC20;\r\n    using SafePRBMath for uint256;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Other Contracts ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    IERC20 public USDToken;\r\n    IDegisLottery public degisLottery;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Constructor function\r\n     * @param _emergencyPool Emergency pool address\r\n     * @param _degisLottery Lottery address\r\n     * @param _usdAddress USDToken address\r\n     */\r\n    constructor(\r\n        address _emergencyPool,\r\n        address _degisLottery,\r\n        address _usdAddress\r\n    ) OwnableWithoutContext(msg.sender) {\r\n        // Initialize some factors\r\n        collateralFactor = 1e18;\r\n        lockedRatio = 1e18;\r\n        LPValue = 1e18;\r\n\r\n        emergencyPool = _emergencyPool;\r\n\r\n        USDToken = IERC20(_usdAddress);\r\n\r\n        degisLottery = IDegisLottery(_degisLottery);\r\n\r\n        // Initial distribution, 0: LP 1: Lottery 2: Emergency\r\n        rewardDistribution[0] = 50;\r\n        rewardDistribution[1] = 40;\r\n        rewardDistribution[2] = 10;\r\n\r\n        frozenTime = 7 days;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Only the policyFlow contract can call some functions\r\n     */\r\n    modifier onlyPolicyFlow() {\r\n        require(\r\n            _msgSender() == policyFlow,\r\n            \"Only the policyFlow contract can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice The address can not be zero\r\n     */\r\n    modifier notZeroAddress(address _address) {\r\n        assert(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice There is a frozen time for unstaking\r\n     */\r\n    modifier afterFrozenTime(address _user) {\r\n        require(\r\n            block.timestamp >= userInfo[_user].depositTime + frozenTime,\r\n            \"Can not withdraw until the fronzen time\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get the real balance: LPValue * LP_Num\r\n     * @dev Used in many places so give it a seperate function\r\n     * @param _user User's address\r\n     * @return _userBalance Real balance of this user\r\n     */\r\n    function getUserBalance(address _user)\r\n        public\r\n        view\r\n        returns (uint256 _userBalance)\r\n    {\r\n        uint256 lp_num = balanceOf(_user);\r\n        _userBalance = lp_num.mul(LPValue);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the balance that one user(LP) can unlock\r\n     * @param _user User's address\r\n     * @return _unlockedAmount Unlocked amount of the user\r\n     */\r\n    function getUnlockedFor(address _user)\r\n        public\r\n        view\r\n        returns (uint256 _unlockedAmount)\r\n    {\r\n        uint256 userBalance = getUserBalance(_user);\r\n        _unlockedAmount = availableCapacity >= userBalance\r\n            ? userBalance\r\n            : availableCapacity;\r\n    }\r\n\r\n    /**\r\n     * @notice Check the conditions when receive new buying request\r\n     * @param _payoff Payoff of the policy to be bought\r\n     * @return Whether there is enough capacity in the pool for this payoff\r\n     */\r\n    function checkCapacity(uint256 _payoff) external view returns (bool) {\r\n        return availableCapacity >= _payoff;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Owner Functions *********************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Set a new frozen time\r\n     * @param _newFrozenTime New frozen time, in timestamp(s)\r\n     */\r\n    function setFrozenTime(uint256 _newFrozenTime) external onlyOwner {\r\n        frozenTime = _newFrozenTime;\r\n        emit FrozenTimeChanged(_newFrozenTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address of policyFlow\r\n     */\r\n    function setPolicyFlow(address _policyFlowAddress)\r\n        public\r\n        onlyOwner\r\n        notZeroAddress(_policyFlowAddress)\r\n    {\r\n        policyFlow = _policyFlowAddress;\r\n        emit PolicyFlowChanged(_policyFlowAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the premium reward distribution\r\n     * @param _newDistribution New distribution [LP, Lottery, Emergency]\r\n     */\r\n    function setRewardDistribution(uint256[3] memory _newDistribution)\r\n        public\r\n        onlyOwner\r\n    {\r\n        uint256 sum = _newDistribution[0] +\r\n            _newDistribution[1] +\r\n            _newDistribution[2];\r\n        require(sum == 100, \"Reward distribution must sum to 100\");\r\n\r\n        for (uint256 i = 0; i < 3; i++) {\r\n            rewardDistribution[i] = _newDistribution[i];\r\n        }\r\n        emit RewardDistributionChanged(\r\n            _newDistribution[0],\r\n            _newDistribution[1],\r\n            _newDistribution[2]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Change the collateral factor\r\n     * @param _factor The new collateral factor\r\n     */\r\n    function setCollateralFactor(uint256 _factor) public onlyOwner {\r\n        require(_factor > 0, \"Collateral Factor should be larger than 0\");\r\n        uint256 oldFactor = collateralFactor;\r\n        collateralFactor = _factor.div(100);\r\n        emit CollateralFactorChanged(oldFactor, _factor);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice LPs stake assets into the pool\r\n     * @param _amount The amount that the user want to stake\r\n     */\r\n    function stake(uint256 _amount) external nonReentrant {\r\n        require(_amount > 0, \"Zero Amount\");\r\n        require(\r\n            IERC20(USDToken).balanceOf(_msgSender()) >= _amount,\r\n            \"Not enough USD\"\r\n        );\r\n\r\n        _updateLPValue();\r\n\r\n        _deposit(_msgSender(), _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstake from the pool (May fail if a claim happens before this operation)\r\n     * @dev Only unstake by yourself\r\n     * @param _amount The amount that the user want to unstake\r\n     */\r\n    function unstake(uint256 _amount)\r\n        external\r\n        afterFrozenTime(_msgSender())\r\n        nonReentrant\r\n    {\r\n        require(totalStakingBalance - lockedBalance > 0, \"All locked\");\r\n\r\n        address _user = _msgSender();\r\n\r\n        _updateLPValue();\r\n\r\n        uint256 userBalance = getUserBalance(_user);\r\n        require(\r\n            _amount <= userBalance && _amount > 0,\r\n            \"Not enough balance to be unlocked or your withdraw amount is 0\"\r\n        );\r\n\r\n        uint256 unlocked = totalStakingBalance - lockedBalance;\r\n        uint256 unstakeAmount = _amount;\r\n\r\n        // Will jump this part when the pool has enough liquidity\r\n        if (_amount > unlocked) unstakeAmount = unlocked; // only withdraw the unlocked value\r\n\r\n        if (unstakeAmount > 0) _withdraw(_user, unstakeAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstake the max amount of a user\r\n     */\r\n    function unstakeMax() external afterFrozenTime(_msgSender()) nonReentrant {\r\n        require(totalStakingBalance - lockedBalance > 0, \"All locked\");\r\n\r\n        address _user = _msgSender();\r\n\r\n        _updateLPValue();\r\n\r\n        uint256 userBalance = getUserBalance(_user);\r\n\r\n        uint256 unlocked = totalStakingBalance - lockedBalance;\r\n        uint256 unstakeAmount = userBalance;\r\n\r\n        // Will jump this part when the pool has enough liquidity\r\n        if (userBalance > unlocked) unstakeAmount = unlocked; // only withdraw the unlocked value\r\n\r\n        _withdraw(_user, unstakeAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the pool variables when buying policies\r\n     * @dev Capacity check is done before calling this function\r\n     * @param _premium Policy's premium\r\n     * @param _payoff Policy's payoff (max payoff)\r\n     * @param _user Address of the buyer\r\n     */\r\n    function updateWhenBuy(\r\n        uint256 _premium,\r\n        uint256 _payoff,\r\n        address _user\r\n    ) external onlyPolicyFlow {\r\n        // Update pool status\r\n        lockedBalance += _payoff;\r\n        activePremiums += _premium;\r\n        availableCapacity -= _payoff;\r\n\r\n        // Update lockedRatio\r\n        _updateLockedRatio();\r\n\r\n        // Remember approval\r\n        USDToken.safeTransferFrom(_user, address(this), _premium);\r\n\r\n        emit NewPolicyBought(_user, _premium, _payoff);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status when a policy expires\r\n     * @param _premium Policy's premium\r\n     * @param _payoff Policy's payoff (max payoff)\r\n     */\r\n    function updateWhenExpire(uint256 _premium, uint256 _payoff)\r\n        external\r\n        onlyPolicyFlow\r\n    {\r\n        // Distribute the premium\r\n        uint256 remainingPremium = _distributePremium(_premium);\r\n\r\n        // Update pool status\r\n        activePremiums -= _premium;\r\n        lockedBalance -= _payoff;\r\n\r\n        availableCapacity += _payoff + remainingPremium;\r\n        totalStakingBalance += remainingPremium;\r\n\r\n        _updateLPValue();\r\n    }\r\n\r\n    /**\r\n     * @notice Pay a claim\r\n     * @param _premium Premium of the policy\r\n     * @param _payoff Max payoff of the policy\r\n     * @param _realPayoff Real payoff of the policy\r\n     * @param _user Address of the policy claimer\r\n     */\r\n    function payClaim(\r\n        uint256 _premium,\r\n        uint256 _payoff,\r\n        uint256 _realPayoff,\r\n        address _user\r\n    ) external onlyPolicyFlow notZeroAddress(_user) {\r\n        // Distribute the premium\r\n        uint256 remainingPremium = _distributePremium(_premium);\r\n\r\n        // Update the pool status\r\n        lockedBalance -= _payoff;\r\n\r\n        totalStakingBalance =\r\n            totalStakingBalance -\r\n            _realPayoff +\r\n            remainingPremium;\r\n\r\n        availableCapacity += (_payoff - _realPayoff + remainingPremium);\r\n\r\n        activePremiums -= _premium;\r\n\r\n        // Pay the claim\r\n        USDToken.safeTransfer(_user, _realPayoff);\r\n\r\n        _updateLPValue();\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ********************************** Internal Functions ********************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Finish the deposit process\r\n     * @dev LPValue will not change during deposit\r\n     * @param _user Address of the user who deposits\r\n     * @param _amount Amount he deposits\r\n     */\r\n    function _deposit(address _user, uint256 _amount) internal {\r\n        uint256 amountWithFactor = _amount.mul(collateralFactor);\r\n\r\n        // Update the pool's status\r\n        totalStakingBalance += _amount;\r\n        availableCapacity += amountWithFactor;\r\n\r\n        _updateLockedRatio();\r\n\r\n        // msg.sender always pays\r\n        USDToken.safeTransferFrom(_user, address(this), _amount);\r\n\r\n        // LP Token number need to be newly minted\r\n        uint256 lp_num = _amount.div(LPValue);\r\n        _mint(_user, lp_num);\r\n\r\n        userInfo[_user].depositTime = block.timestamp;\r\n\r\n        emit Stake(_user, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice _withdraw: finish the withdraw action, only when meeting the conditions\r\n     * @dev LPValue will not change during withdraw\r\n     * @param _user address of the user who withdraws\r\n     * @param _amount the amount he withdraws\r\n     */\r\n    function _withdraw(address _user, uint256 _amount) internal {\r\n        uint256 amountWithFactor = _amount.mul(collateralFactor);\r\n        // Update the pool's status\r\n        totalStakingBalance -= _amount;\r\n        availableCapacity -= amountWithFactor;\r\n\r\n        _updateLockedRatio();\r\n\r\n        USDToken.safeTransfer(_user, _amount);\r\n\r\n        uint256 lp_num = _amount.div(LPValue);\r\n        _burn(_user, lp_num);\r\n\r\n        emit Unstake(_user, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Distribute the premium to lottery and emergency pool\r\n     * @param _premium Premium amount to be distributed\r\n     */\r\n    function _distributePremium(uint256 _premium) internal returns (uint256) {\r\n        uint256 premiumToLottery = _premium.mul(rewardDistribution[1].div(100));\r\n\r\n        uint256 premiumToEmergency = _premium.mul(\r\n            rewardDistribution[2].div(100)\r\n        );\r\n\r\n        // Transfer some reward to emergency pool\r\n        USDToken.safeTransfer(emergencyPool, premiumToEmergency);\r\n\r\n        // Transfer some reward to lottery\r\n        USDToken.safeTransfer(address(degisLottery), premiumToLottery);\r\n\r\n        emit PremiumDistributed(premiumToEmergency, premiumToLottery);\r\n\r\n        return _premium - premiumToEmergency - premiumToLottery;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the value of each lp token\r\n     * @dev Normally it will update when claim or expire\r\n     */\r\n    function _updateLPValue() internal {\r\n        uint256 totalLP = totalSupply();\r\n\r\n        if (totalLP == 0) return;\r\n        else {\r\n            uint256 totalBalance = IERC20(USDToken).balanceOf(address(this));\r\n\r\n            LPValue = (totalBalance - activePremiums).div(totalLP);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update the pool's locked ratio\r\n     */\r\n    function _updateLockedRatio() internal {\r\n        if (lockedBalance == 0) lockedRatio = 0;\r\n        else lockedRatio = lockedBalance.div(totalStakingBalance);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/SafePRBMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"prb-math/contracts/PRBMath.sol\";\r\n\r\n/**\r\n * @notice This prb-math version is 2.4.1\r\n *         https://github.com/hifi-finance/prb-math\r\n */\r\n\r\n/// @title PRBMathUD60x18\r\n/// @author Paul Razvan Berg\r\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\r\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\r\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\r\n/// maximum values permitted by the Solidity type uint256.\r\nlibrary SafePRBMath {\r\n    /// @dev Half the SCALE number.\r\n    uint256 internal constant HALF_SCALE = 5e17;\r\n\r\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\r\n    uint256 internal constant LOG2_E = 1_442695040888963407;\r\n\r\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\r\n    uint256 internal constant MAX_UD60x18 =\r\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\r\n\r\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\r\n    uint256 internal constant MAX_WHOLE_UD60x18 =\r\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\r\n\r\n    /// @dev How many trailing decimals can be represented.\r\n    uint256 internal constant SCALE = 1e18;\r\n\r\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\r\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\r\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        // The operations can never overflow.\r\n        unchecked {\r\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\r\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\r\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\r\n    ///\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\r\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\r\n    function ceil(uint256 x) internal pure returns (uint256 result) {\r\n        if (x > MAX_WHOLE_UD60x18) {\r\n            revert PRBMathUD60x18__CeilOverflow(x);\r\n        }\r\n        assembly {\r\n            // Equivalent to \"x % SCALE\" but faster.\r\n            let remainder := mod(x, SCALE)\r\n\r\n            // Equivalent to \"SCALE - remainder\" but faster.\r\n            let delta := sub(SCALE, remainder)\r\n\r\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\r\n            result := add(x, mul(delta, gt(remainder, 0)))\r\n        }\r\n    }\r\n\r\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\r\n    ///\r\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\r\n    ///\r\n    /// Requirements:\r\n    /// - The denominator cannot be zero.\r\n    ///\r\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = PRBMath.mulDiv(x, SCALE, y);\r\n    }\r\n\r\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\r\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\r\n    function e() internal pure returns (uint256 result) {\r\n        result = 2_718281828459045235;\r\n    }\r\n\r\n    /// @notice Calculates the natural exponent of x.\r\n    ///\r\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    /// - x must be less than 133.084258667509499441.\r\n    ///\r\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp(uint256 x) internal pure returns (uint256 result) {\r\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\r\n        if (x >= 133_084258667509499441) {\r\n            revert PRBMathUD60x18__ExpInputTooBig(x);\r\n        }\r\n\r\n        // Do the fixed-point multiplication inline to save gas.\r\n        unchecked {\r\n            uint256 doubleScaleProduct = x * LOG2_E;\r\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\r\n    ///\r\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be 192 or less.\r\n    /// - The result must fit within MAX_UD60x18.\r\n    ///\r\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp2(uint256 x) internal pure returns (uint256 result) {\r\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\r\n        if (x >= 192e18) {\r\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\r\n        }\r\n\r\n        unchecked {\r\n            // Convert x to the 192.64-bit fixed-point format.\r\n            uint256 x192x64 = (x << 64) / SCALE;\r\n\r\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\r\n            result = PRBMath.exp2(x192x64);\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\r\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\r\n    function floor(uint256 x) internal pure returns (uint256 result) {\r\n        assembly {\r\n            // Equivalent to \"x % SCALE\" but faster.\r\n            let remainder := mod(x, SCALE)\r\n\r\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\r\n            result := sub(x, mul(remainder, gt(remainder, 0)))\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the excess beyond the floor of x.\r\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\r\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\r\n    function frac(uint256 x) internal pure returns (uint256 result) {\r\n        assembly {\r\n            result := mod(x, SCALE)\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\r\n    ///\r\n    /// @param x The basic integer to convert.\r\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\r\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            if (x > MAX_UD60x18 / SCALE) {\r\n                revert PRBMathUD60x18__FromUintOverflow(x);\r\n            }\r\n            result = x * SCALE;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\r\n    ///\r\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        unchecked {\r\n            // Checking for overflow this way is faster than letting Solidity do it.\r\n            uint256 xy = x * y;\r\n            if (xy / x != y) {\r\n                revert PRBMathUD60x18__GmOverflow(x, y);\r\n            }\r\n\r\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\r\n            // during multiplication. See the comments within the \"sqrt\" function.\r\n            result = PRBMath.sqrt(xy);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates 1 / x, rounding toward zero.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x cannot be zero.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\r\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\r\n    function inv(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 1e36 is SCALE * SCALE.\r\n            result = 1e36 / x;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the natural logarithm of x.\r\n    ///\r\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\r\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\r\n    function ln(uint256 x) internal pure returns (uint256 result) {\r\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\r\n        // can return is 196205294292027477728.\r\n        unchecked {\r\n            result = (log2(x) * SCALE) / LOG2_E;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the common logarithm of x.\r\n    ///\r\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\r\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\r\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\r\n    function log10(uint256 x) internal pure returns (uint256 result) {\r\n        if (x < SCALE) {\r\n            revert PRBMathUD60x18__LogInputTooSmall(x);\r\n        }\r\n\r\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\r\n        // in this contract.\r\n        // prettier-ignore\r\n        assembly {\r\n            switch x\r\n            case 1 { result := mul(SCALE, sub(0, 18)) }\r\n            case 10 { result := mul(SCALE, sub(1, 18)) }\r\n            case 100 { result := mul(SCALE, sub(2, 18)) }\r\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\r\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\r\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\r\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\r\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\r\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\r\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\r\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\r\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\r\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\r\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\r\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\r\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\r\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\r\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\r\n            case 1000000000000000000 { result := 0 }\r\n            case 10000000000000000000 { result := SCALE }\r\n            case 100000000000000000000 { result := mul(SCALE, 2) }\r\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\r\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\r\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\r\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\r\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\r\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\r\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\r\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\r\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\r\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\r\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\r\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\r\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\r\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\r\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\r\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\r\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\r\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\r\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\r\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\r\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\r\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\r\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\r\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\r\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\r\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\r\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\r\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\r\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\r\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\r\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\r\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\r\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\r\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\r\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\r\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\r\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\r\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\r\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\r\n            default {\r\n                result := MAX_UD60x18\r\n            }\r\n        }\r\n\r\n        if (result == MAX_UD60x18) {\r\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\r\n            unchecked {\r\n                result = (log2(x) * SCALE) / 3_321928094887362347;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary logarithm of x.\r\n    ///\r\n    /// @dev Based on the iterative approximation algorithm.\r\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\r\n    ///\r\n    /// Caveats:\r\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\r\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\r\n    function log2(uint256 x) internal pure returns (uint256 result) {\r\n        if (x < SCALE) {\r\n            revert PRBMathUD60x18__LogInputTooSmall(x);\r\n        }\r\n        unchecked {\r\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\r\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\r\n\r\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\r\n            // because n is maximum 255 and SCALE is 1e18.\r\n            result = n * SCALE;\r\n\r\n            // This is y = x * 2^(-n).\r\n            uint256 y = x >> n;\r\n\r\n            // If y = 1, the fractional part is zero.\r\n            if (y == SCALE) {\r\n                return result;\r\n            }\r\n\r\n            // Calculate the fractional part via the iterative approximation.\r\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\r\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\r\n                y = (y * y) / SCALE;\r\n\r\n                // Is y^2 > 2 and so in the range [2,4)?\r\n                if (y >= 2 * SCALE) {\r\n                    // Add the 2^(-m) factor to the logarithm.\r\n                    result += delta;\r\n\r\n                    // Corresponds to z/2 on Wikipedia.\r\n                    y >>= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\r\n    /// fixed-point number.\r\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\r\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = PRBMath.mulDivFixedPoint(x, y);\r\n    }\r\n\r\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\r\n    function pi() internal pure returns (uint256 result) {\r\n        result = 3_141592653589793238;\r\n    }\r\n\r\n    /// @notice Raises x to the power of y.\r\n    ///\r\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\r\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            result = y == 0 ? SCALE : uint256(0);\r\n        } else {\r\n            result = exp2(mul(log2(x), y));\r\n        }\r\n    }\r\n\r\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\r\n    /// famous algorithm \"exponentiation by squaring\".\r\n    ///\r\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\r\n    ///\r\n    /// Requirements:\r\n    /// - The result must fit within MAX_UD60x18.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"mul\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The exponent as an uint256.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        // Calculate the first iteration of the loop in advance.\r\n        result = y & 1 > 0 ? x : SCALE;\r\n\r\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\r\n        for (y >>= 1; y > 0; y >>= 1) {\r\n            x = PRBMath.mulDivFixedPoint(x, x);\r\n\r\n            // Equivalent to \"y % 2 == 1\" but faster.\r\n            if (y & 1 > 0) {\r\n                result = PRBMath.mulDivFixedPoint(result, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\r\n    function scale() internal pure returns (uint256 result) {\r\n        result = SCALE;\r\n    }\r\n\r\n    /// @notice Calculates the square root of x, rounding down.\r\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be less than MAX_UD60x18 / SCALE.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\r\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            if (x > MAX_UD60x18 / SCALE) {\r\n                revert PRBMathUD60x18__SqrtOverflow(x);\r\n            }\r\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\r\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\r\n            result = PRBMath.sqrt(x * SCALE);\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\r\n    /// @return result The same number in basic integer form.\r\n    function toUint(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            result = x / SCALE;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/lucky-box/interfaces/IDegisLottery.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface IDegisLottery {\r\n    /**\r\n     * @notice Inject funds\r\n     * @param _amount amount to inject in USD\r\n     * @dev Callable by operator\r\n     */\r\n    function injectFunds(uint256 _amount) external;\r\n\r\n    /**\r\n     * @notice View current lottery id\r\n     */\r\n    function currentLotteryId() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/miserable-flight/abstracts/InsurancePoolStore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nabstract contract InsurancePoolStore {\r\n    address public policyFlow;\r\n    address public emergencyPool;\r\n\r\n    uint256 public frozenTime; // default as 7 days\r\n\r\n    struct UserInfo {\r\n        uint256 depositTime;\r\n        uint256 pendingBalance; // the amount in the unstake queue\r\n    }\r\n    mapping(address => UserInfo) public userInfo;\r\n\r\n    // 1 LP = LPValue(USD)\r\n    uint256 public LPValue;\r\n\r\n    // Total staking balance of the pool\r\n    uint256 public totalStakingBalance;\r\n\r\n    // Locked balance is for potiential payoff\r\n    uint256 public lockedBalance;\r\n\r\n    // locked relation = locked balance / totalStakingBalance\r\n    uint256 public lockedRatio; //  1e18 = 1  1e17 = 0.1  1e19 = 10\r\n    uint256 public collateralFactor; //  1e18 = 1  1e17 = 0.1  1e19 = 10\r\n\r\n    // Available capacity for taking new\r\n    uint256 public availableCapacity;\r\n\r\n    // Premiums have been paid but the policies haven't expired\r\n    uint256 public activePremiums;\r\n\r\n    // [0]: LP, [1]: Lottery, [2]: Emergency\r\n    uint256[3] public rewardDistribution;\r\n\r\n    // events\r\n    event Stake(address indexed userAddress, uint256 amount);\r\n    event Unstake(address indexed userAddress, uint256 amount);\r\n\r\n    event CollateralFactorChanged(uint256 oldFactor, uint256 newFactor);\r\n\r\n    event PolicyFlowChanged(address policyFlowAddress);\r\n\r\n    event NewPolicyBought(\r\n        address indexed userAddress,\r\n        uint256 premium,\r\n        uint256 payout\r\n    );\r\n    event RewardDistributionChanged(\r\n        uint256 toLP,\r\n        uint256 toLottery,\r\n        uint256 toEmergency\r\n    );\r\n\r\n    event FrozenTimeChanged(uint256 _newFrozenTime);\r\n\r\n    event PremiumDistributed(\r\n        uint256 _premiumToEmergency,\r\n        uint256 _premiumToLottery\r\n    );\r\n}\r\n"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the closest power of two that is higher than x.\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "contracts/lucky-box/RandomNumberGeneratorV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\r\nimport \"./interfaces/IDegisLottery.sol\";\r\n\r\ncontract RandomNumberGeneratorV2 is VRFConsumerBaseV2 {\r\n    // Coordinator address based on networks\r\n    // Fuji: 0x2eD832Ba664535e5886b75D64C46EB9a228C2610\r\n    // Mainnet: 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634\r\n    VRFCoordinatorV2Interface public coordinator;\r\n\r\n    // Subscription id, created on chainlink website\r\n    // Fuji: 130\r\n    // Mainnet: 28 (test)\r\n    uint64 public subscriptionId;\r\n\r\n    // Different networks and gas prices have different keyHash\r\n    // Fuji: 300gwei 0x354d2f95da55398f44b7cff77da56283d9c6c829a4bdf1bbcaf2ad6a4d081f61\r\n    // Mainnet: 500gwei 0x89630569c9567e43c4fe7b1633258df9f2531b62f2352fa721cf3162ee4ecb46\r\n    bytes32 public keyHash;\r\n\r\n    // Gas limit for callback\r\n    uint32 public callbackGasLimit = 100000;\r\n\r\n    // Confirmations for each request\r\n    uint16 public requestConfirmations = 3;\r\n\r\n    // Request 1 random number each time\r\n    uint32 public wordsPerTime = 1;\r\n\r\n    // Store the latest result\r\n    uint256 public randomResult;\r\n\r\n    // Store the latest request id\r\n    uint256 public s_requestId;\r\n\r\n    // Owner address\r\n    address public owner;\r\n\r\n    // Latest lottery id\r\n    uint256 public latestLotteryId;\r\n\r\n    address public degisLottery;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event RequestRandomWords(uint256 requestId);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    constructor(\r\n        address _vrfCoordinator,\r\n        bytes32 _keyHash,\r\n        uint64 _subscriptionId\r\n    ) VRFConsumerBaseV2(_vrfCoordinator) {\r\n        // Set coordinator address depends on networks\r\n        coordinator = VRFCoordinatorV2Interface(_vrfCoordinator);\r\n\r\n        // Set keyhash depends on networks and gas price\r\n        keyHash = _keyHash;\r\n\r\n        // Subscription id depends on networks\r\n        subscriptionId = _subscriptionId;\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner || msg.sender == degisLottery,\r\n            \"Only owner or lottery\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function setKeyHash(bytes32 _keyHash) external onlyOwner {\r\n        keyHash = _keyHash;\r\n    }\r\n\r\n    function setSubscriptionId(uint64 _subscriptionId) external onlyOwner {\r\n        subscriptionId = _subscriptionId;\r\n    }\r\n\r\n    function setCoordinator(address _coordinator) external onlyOwner {\r\n        coordinator = VRFCoordinatorV2Interface(_coordinator);\r\n    }\r\n\r\n    function setWordsPerTime(uint32 _wordsPerTime) external onlyOwner {\r\n        wordsPerTime = _wordsPerTime;\r\n    }\r\n\r\n    function setRequestConfirmations(uint16 _requestConfirmations)\r\n        external\r\n        onlyOwner\r\n    {\r\n        requestConfirmations = _requestConfirmations;\r\n    }\r\n\r\n    function setDegisLottery(address _lottery) external onlyOwner {\r\n        degisLottery = _lottery;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function requestRandomWords() external onlyOwner {\r\n        s_requestId = coordinator.requestRandomWords(\r\n            keyHash,\r\n            subscriptionId,\r\n            requestConfirmations,\r\n            callbackGasLimit,\r\n            wordsPerTime\r\n        );\r\n\r\n        emit RequestRandomWords(s_requestId);\r\n    }\r\n\r\n    function fulfillRandomWords(uint256, uint256[] memory _randomWords)\r\n        internal\r\n        override\r\n    {\r\n        randomResult = (_randomWords[0] % 10000) + 10000;\r\n\r\n        // Update latest lottery id\r\n        // Before this update, lottery can not make that round claimable\r\n        latestLotteryId = IDegisLottery(degisLottery).currentLotteryId();\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "contracts/lucky-box/RandomNumberGenerator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../utils/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"../libraries/StringsUtils.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\r\n\r\nimport \"./interfaces/IDegisLottery.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract RandomNumberGenerator is VRFConsumerBase, Ownable {\r\n    using StringsUtils for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IDegisLottery public DegisLottery;\r\n\r\n    bytes32 public keyHash;\r\n    bytes32 public latestRequestId;\r\n    uint256 public randomResult;\r\n    uint256 public fee;\r\n\r\n    uint256 public latestLotteryId;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @dev RandomNumberGenerator must be deployed before the lottery.\r\n     * Once the lottery contract is deployed, setLotteryAddress must be called.\r\n     * https://docs.chain.link/docs/vrf-contracts/\r\n     * @param _vrfCoordinator address of the VRF coordinator\r\n     * @param _linkToken address of the LINK token\r\n     */\r\n    constructor(\r\n        address _vrfCoordinator,\r\n        address _linkToken,\r\n        bytes32 _keyHash\r\n    ) Ownable(msg.sender) VRFConsumerBase(_vrfCoordinator, _linkToken) {\r\n        keyHash = _keyHash;\r\n        fee = 0.1 * 10e18;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Change the fee\r\n     * @param _fee new fee (in LINK)\r\n     */\r\n    function setFee(uint256 _fee) external onlyOwner {\r\n        fee = _fee;\r\n    }\r\n\r\n    /**\r\n     * @notice Change the keyHash\r\n     * @param _keyHash new keyHash\r\n     */\r\n    function setKeyHash(bytes32 _keyHash) external onlyOwner {\r\n        keyHash = _keyHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address for the DegisLottery\r\n     * @param _degisLottery address of the PancakeSwap lottery\r\n     */\r\n    function setLotteryAddress(address _degisLottery) external onlyOwner {\r\n        DegisLottery = IDegisLottery(_degisLottery);\r\n    }\r\n\r\n    /**\r\n     * @notice It allows the admin to withdraw tokens sent to the contract\r\n     * @param _tokenAddress the address of the token to withdraw\r\n     * @param _tokenAmount the number of token amount to withdraw\r\n     * @dev Only callable by owner.\r\n     */\r\n    function withdrawTokens(address _tokenAddress, uint256 _tokenAmount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        IERC20(_tokenAddress).safeTransfer(_msgSender(), _tokenAmount);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Request randomness from Chainlink VRF\r\n     */\r\n    function getRandomNumber() external {\r\n        require(_msgSender() == address(DegisLottery), \"Only DegisLottery\");\r\n\r\n        require(keyHash != bytes32(0), \"Must have valid key hash\");\r\n        // require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK tokens\");\r\n\r\n        //*********************************//\r\n        // TODO: This part is only for test on Fuji Testnet because there is no VRF currently\r\n        string memory randInput = string(\r\n            abi.encodePacked(\r\n                block.timestamp.uintToString(),\r\n                blockhash(block.number - (block.timestamp % 64)),\r\n                address(this)\r\n            )\r\n        );\r\n        randomResult = _rand(randInput) % 10000;\r\n\r\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\r\n        //*********************************//\r\n\r\n        // latestRequestId = requestRandomness(keyHash, fee);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the random number\r\n     * @return randomNumber the random result\r\n     */\r\n    function _rand(string memory input) internal pure returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(input)));\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Callback function used by ChainLink's VRF Coordinator\r\n     */\r\n    // TODO: On Fuji testnet, we use fake random numbers\r\n    function fulfillRandomness(bytes32 requestId, uint256 randomness)\r\n        internal\r\n        override\r\n    {\r\n        require(latestRequestId == requestId, \"Wrong requestId\");\r\n        randomResult = randomness % 10000;\r\n\r\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/StringsUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary StringsUtils {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @notice Bytes to string (not human-readable form)\r\n     * @param _bytes Input bytes\r\n     * @return stringBytes String form of the bytes\r\n     */\r\n    function byToString(bytes32 _bytes) internal pure returns (string memory) {\r\n        return uintToHexString(uint256(_bytes), 32);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer address to string (not change the content)\r\n     * @param _addr Input address\r\n     * @return stringAddress String form of the address\r\n     */\r\n    function addressToString(address _addr)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return uintToHexString(uint256(uint160(_addr)), 20);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function uintToString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function uintToHexString(uint256 value)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return uintToHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function uintToHexString(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\n\n  /**\n   * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash] + 1;\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface internal immutable LINK;\n  address private immutable vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\n    private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  constructor(address _vrfCoordinator, address _link) {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "contracts/tokens/Shield.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title  Shield Token (Derived Stablecoin on Degis)\r\n * @author Eric Lee (ylikp.ust@gmail.com)\r\n * @dev    Users can swap other stablecoins to Shield\r\n *         Shield can be used in NaughtyPrice and future products\r\n *\r\n *         When users want to withdraw, their shield tokens will be burned\r\n *         and USDC will be sent back to them\r\n *\r\n *         Currently, the swap is done inside Platypus & Curve\r\n */\r\ncontract Shield is ERC20Upgradeable, OwnableUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constants **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // PTP USD Pool to be used for swapping stablecoins\r\n    address public PTPPOOL = 0x66357dCaCe80431aee0A7507e2E361B7e2402370;\r\n    address public YUSDCTPOOL = 0x1da20Ac34187b2d9c74F729B85acB225D3341b25;\r\n    address public USDCeUSDCPOOL = 0x3a43A5851A3e3E0e25A3c1089670269786be1577;\r\n    address public aTRICURVEPOOL = 0xB755B949C126C04e0348DD881a5cF55d424742B2;\r\n\r\n    // USDC address\r\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\r\n\r\n    // Other stablecoin addresses\r\n    address public constant USDCe = 0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664;\r\n    address public constant USDT = 0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7;\r\n    address public constant USDTe = 0xc7198437980c041c805A1EDcbA50c1Ce5db95118;\r\n    address public constant DAIe = 0xd586E7F844cEa2F87f50152665BCbc2C279D8d70;\r\n    address public constant YUSD = 0x111111111111ed1D73f860F57b2798b683f2d325;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // stablecoin => whether supported\r\n    mapping(address => bool) public supportedStablecoin;\r\n\r\n    // User info\r\n    mapping(address => uint256) public userBalance;\r\n\r\n    // ------------------------------------------------------------------------- --------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event AddStablecoin(address stablecoin);\r\n    event SetPTPPool(address oldPool, address newPool);\r\n    event Deposit(\r\n        address indexed user,\r\n        address indexed stablecoin,\r\n        uint256 inAmount,\r\n        uint256 outAmount\r\n    );\r\n    event Withdraw(address indexed user, uint256 amount);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function initialize() public initializer {\r\n        __ERC20_init(\"Shield Token\", \"SHD\");\r\n        __Ownable_init();\r\n\r\n        // USDT.e\r\n        supportedStablecoin[USDTe] = true;\r\n        // USDT\r\n        supportedStablecoin[USDT] = true;\r\n        // USDC.e\r\n        supportedStablecoin[USDCe] = true;\r\n        // USDC\r\n        supportedStablecoin[USDC] = true;\r\n        // DAI.e\r\n        supportedStablecoin[DAIe] = true;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Add new supported stablecoin\r\n     *\r\n     * @dev Set a new supported token address\r\n     *      The collateral ratio need to be less than 100\r\n     *      Only callable by the owner\r\n     *\r\n     * @param _stablecoin Stablecoin address\r\n     */\r\n    function addSupportedStablecoin(address _stablecoin) external onlyOwner {\r\n        supportedStablecoin[_stablecoin] = true;\r\n\r\n        emit AddStablecoin(_stablecoin);\r\n    }\r\n\r\n    function setPTPPool(address _ptpPool) external onlyOwner {\r\n        emit SetPTPPool(PTPPOOL, _ptpPool);\r\n        PTPPOOL = _ptpPool;\r\n    }\r\n\r\n    function approveStablecoin(address _token) external {\r\n        IERC20(_token).approve(PTPPOOL, type(uint256).max);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Deposit tokens and mint Shield\r\n     *         If the input is USDC, no swap needed, otherwise, swap to USDC\r\n     *\r\n     * @param _stablecoin Stablecoin address\r\n     * @param _amount     Input stablecoin amount\r\n     * @param _minAmount  Minimum amount output (if need swap)\r\n     */\r\n    function deposit(\r\n        address _stablecoin,\r\n        uint256 _amount,\r\n        uint256 _minAmount\r\n    ) external {\r\n        require(supportedStablecoin[_stablecoin], \"Stablecoin not supported\");\r\n\r\n        // Actual shield amount\r\n        uint256 outAmount;\r\n\r\n        // Transfer stablecoin to this contract\r\n        IERC20(_stablecoin).safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n\r\n        if (_stablecoin != USDC) {\r\n            // Swap stablecoin to USDC and directly goes to this contract\r\n            outAmount = _swap(\r\n                _stablecoin,\r\n                USDC,\r\n                _amount,\r\n                _minAmount,\r\n                address(this),\r\n                block.timestamp + 60\r\n            );\r\n        } else {\r\n            outAmount = _amount;\r\n        }\r\n\r\n        // Record user balance\r\n        userBalance[msg.sender] += outAmount;\r\n\r\n        // Mint shield\r\n        _mint(msg.sender, outAmount);\r\n\r\n        emit Deposit(msg.sender, _stablecoin, _amount, outAmount);\r\n    }\r\n\r\n    function withdraw(\r\n        address _stablecoin,\r\n        uint256 _amount,\r\n        uint256 _minAmount\r\n    ) external {\r\n        require(supportedStablecoin[_stablecoin], \"Stablecoin not supported\");\r\n\r\n        if (_stablecoin == USDC) withdraw(_amount);\r\n        else {\r\n            // Swap USDC to stablecoin and directly\r\n            uint256 actualAmount = _swap(\r\n                USDC,\r\n                _stablecoin,\r\n                _amount,\r\n                _minAmount,\r\n                address(this),\r\n                block.timestamp + 60\r\n            );\r\n\r\n            withdraw(actualAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw stablecoins\r\n     *\r\n     * @param _amount Amount of Shield to be burned\r\n     */\r\n    function withdraw(uint256 _amount) public {\r\n        require(userBalance[msg.sender] >= _amount, \"Insufficient balance\");\r\n        userBalance[msg.sender] -= _amount;\r\n\r\n        // Transfer USDC back\r\n        uint256 realAmount = _safeTokenTransfer(USDC, _amount);\r\n\r\n        // Burn shield token\r\n        _burn(msg.sender, realAmount);\r\n\r\n        // Transfer USDC back\r\n        IERC20(USDC).safeTransfer(msg.sender, _amount);\r\n\r\n        emit Withdraw(msg.sender, realAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all stablecoins\r\n     */\r\n    function withdrawAll() external {\r\n        require(userBalance[msg.sender] > 0, \"Insufficient balance\");\r\n        withdraw(userBalance[msg.sender]);\r\n    }\r\n\r\n    function decimals() public pure override returns (uint8) {\r\n        return 6;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Swap stablecoin to USDC in PTP\r\n     * @param _fromToken   From token address\r\n     * @param _toToken     To token address\r\n     * @param _fromAmount  Amount of from token\r\n     * @param _minToAmount Minimun output amount\r\n     * @param _to          Address that will receive the output token\r\n     * @param _deadline    Deadline for this transaction\r\n     */\r\n    function _swap(\r\n        address _fromToken,\r\n        address _toToken,\r\n        uint256 _fromAmount,\r\n        uint256 _minToAmount,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) internal returns (uint256) {\r\n        bytes memory data = abi.encodeWithSignature(\r\n            \"swap(address,address,uint256,uint256,address,uint256)\",\r\n            _fromToken,\r\n            _toToken,\r\n            _fromAmount,\r\n            _minToAmount,\r\n            _to,\r\n            _deadline\r\n        );\r\n\r\n        (bool success, bytes memory res) = PTPPOOL.call(data);\r\n\r\n        require(success, \"PTP swap failed\");\r\n\r\n        (uint256 actualAmount, ) = abi.decode(res, (uint256, uint256));\r\n\r\n        return actualAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe token transfer\r\n     * @dev Not allowed to transfer more tokens than the current balance\r\n     * @param _token  Token address to be transferred\r\n     * @param _amount Amount of token to be transferred\r\n     * @return realAmount Real amount that has been transferred\r\n     */\r\n    function _safeTokenTransfer(address _token, uint256 _amount)\r\n        internal\r\n        returns (uint256 realAmount)\r\n    {\r\n        uint256 balance = IERC20(_token).balanceOf(address(this));\r\n\r\n        if (balance > _amount) {\r\n            realAmount = _amount;\r\n        } else {\r\n            realAmount = balance;\r\n        }\r\n        IERC20(_token).safeTransfer(msg.sender, realAmount);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/naughty-price/PolicyCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { StringsUtils } from \"../libraries/StringsUtils.sol\";\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport { IERC20Decimals } from \"../utils/interfaces/IERC20Decimals.sol\";\r\nimport { IPriceGetter } from \"./interfaces/IPriceGetter.sol\";\r\nimport { INaughtyFactory } from \"./interfaces/INaughtyFactory.sol\";\r\nimport { INPPolicyToken } from \"./interfaces/INPPolicyToken.sol\";\r\n\r\n/**\r\n * @title  PolicyCore\r\n * @notice Core logic of Naughty Price Product\r\n *         Preset:\r\n *              (Done in the naughtyFactory contract)\r\n *              1. Deploy policyToken contract\r\n *              2. Deploy policyToken-Stablecoin pool contract\r\n *         User Interaction:\r\n *              1. Deposit Stablecoin and mint PolicyTokens\r\n *              2. Redeem their Stablecoin and burn the PolicyTokens (before settlement)\r\n *              3. Claim for payout with PolicyTokens (after settlement)\r\n *         PolicyTokens are minted with the ratio 1:1 to Stablecoin\r\n *         The PolicyTokens are traded in the pool with CFMM (xy=k)\r\n *         When the event happens, a PolicyToken can be burned for claiming 1 Stablecoin.\r\n *         When the event does not happen, the PolicyToken depositors can\r\n *         redeem their 1 deposited Stablecoin\r\n *\r\n * @dev    Most of the functions to be called from outside will use the name of policyToken\r\n *         rather than the address (easy to read).\r\n *         Other variables or functions still use address to index.\r\n *         The rule of policyToken naming is:\r\n *              Original Token Name(with decimals) + Strike Price + Lower or Higher + Date\r\n *         E.g.  AVAX_30.0_L_2101, BTC_30000.0_L_2102, ETH_8000.0_H_2109\r\n *         (the original name need to be the same as in the chainlink oracle)\r\n *         There are three decimals for a policy token:\r\n *              1. Name decimals: Only for generating the name of policyToken\r\n *              2. Token decimals: The decimals of the policyToken\r\n *                 (should be the same as the paired stablecoin)\r\n *              3. Price decimals: Always 18. The oracle result will be transferred for settlement\r\n */\r\n\r\ncontract PolicyCore is OwnableUpgradeable {\r\n    using StringsUtils for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Factory contract, responsible for deploying new contracts\r\n    INaughtyFactory public factory;\r\n\r\n    // Oracle contract, responsible for getting the final price\r\n    IPriceGetter public priceGetter;\r\n\r\n    // Lottery address\r\n    address public lottery;\r\n\r\n    // Income sharing contract address\r\n    address public incomeSharing;\r\n\r\n    // Naughty Router contract address\r\n    address public naughtyRouter;\r\n\r\n    // Contract for initial liquidity matching\r\n    address public ILMContract;\r\n\r\n    // Income to lottery ratio (max 10)\r\n    uint256 public toLotteryPart;\r\n\r\n    struct PolicyTokenInfo {\r\n        address policyTokenAddress;\r\n        bool isCall;\r\n        uint256 nameDecimals; // decimals of the name generation\r\n        uint256 tokenDecimals; // decimals of the policy token\r\n        uint256 strikePrice;\r\n        uint256 deadline;\r\n        uint256 settleTimestamp;\r\n    }\r\n    // Policy token name => Policy token information\r\n    mapping(string => PolicyTokenInfo) public policyTokenInfoMapping;\r\n\r\n    // Policy token address => Policy token name\r\n    mapping(address => string) public policyTokenAddressToName;\r\n\r\n    // Policy token name list\r\n    string[] public allPolicyTokens;\r\n\r\n    // Stablecoin address => Supported or not\r\n    mapping(address => bool) public supportedStablecoin;\r\n\r\n    // Policy token address => Stablecoin address\r\n    mapping(address => address) public whichStablecoin;\r\n\r\n    // PolicyToken => Strike Token (e.g. AVAX30L202101 address => AVAX address)\r\n    mapping(address => string) policyTokenToOriginal;\r\n\r\n    // User Address => Token Address => User Quota Amount\r\n    mapping(address => mapping(address => uint256)) userQuota;\r\n\r\n    // Policy token address => All the depositors for this round\r\n    // (store all the depositors in an array)\r\n    mapping(address => address[]) public allDepositors;\r\n\r\n    struct SettlementInfo {\r\n        uint256 price;\r\n        bool isHappened;\r\n        bool alreadySettled;\r\n        uint256 currentDistributionIndex;\r\n    }\r\n    // Policy token address => Settlement result information\r\n    mapping(address => SettlementInfo) public settleResult;\r\n\r\n    mapping(address => uint256) public pendingIncomeToLottery;\r\n    mapping(address => uint256) public pendingIncomeToSharing;\r\n\r\n    // IDO pool record and ido price getter contract\r\n    mapping(string => bool) public isIDOPool;\r\n    IPriceGetter public idoPriceGetter;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Events ******************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event LotteryChanged(address oldLotteryAddress, address newLotteryAddress);\r\n    event IncomeSharingChanged(\r\n        address oldIncomeSharing,\r\n        address newIncomeSharing\r\n    );\r\n    event NaughtyRouterChanged(address oldRouter, address newRouter);\r\n    event ILMChanged(address oldILM, address newILM);\r\n    event IncomeToLotteryChanged(uint256 oldToLottery, uint256 newToLottery);\r\n    event PolicyTokenDeployed(\r\n        string tokenName,\r\n        address tokenAddress,\r\n        uint256 tokenDecimals,\r\n        uint256 deadline,\r\n        uint256 settleTimestamp\r\n    );\r\n    event PoolDeployed(\r\n        address poolAddress,\r\n        address policyTokenAddress,\r\n        address stablecoin\r\n    );\r\n    event PoolDeployedWithInitialLiquidity(\r\n        address poolAddress,\r\n        address policyTokenAddress,\r\n        address stablecoin,\r\n        uint256 initLiquidityA,\r\n        uint256 initLiquidityB\r\n    );\r\n    event Deposit(\r\n        address indexed userAddress,\r\n        string indexed policyTokenName,\r\n        address indexed stablecoin,\r\n        uint256 amount\r\n    );\r\n    event DelegateDeposit(\r\n        address payerAddress,\r\n        address userAddress,\r\n        string policyTokenName,\r\n        address stablecoin,\r\n        uint256 amount\r\n    );\r\n    event Redeem(\r\n        address indexed userAddress,\r\n        string indexed policyTokenName,\r\n        address indexed stablecoin,\r\n        uint256 amount\r\n    );\r\n    event RedeemAfterSettlement(\r\n        address indexed userAddress,\r\n        string indexed policyTokenName,\r\n        address indexed stablecoin,\r\n        uint256 amount\r\n    );\r\n    event FinalResultSettled(\r\n        string _policyTokenName,\r\n        uint256 price,\r\n        bool isHappened\r\n    );\r\n    event NewStablecoinAdded(address _newStablecoin);\r\n    event PolicyTokensSettledForUsers(\r\n        string policyTokenName,\r\n        address stablecoin,\r\n        uint256 startIndex,\r\n        uint256 stopIndex\r\n    );\r\n    event UpdateUserQuota(\r\n        address user,\r\n        address policyTokenAddress,\r\n        uint256 amount\r\n    );\r\n    event IDOPriceGetterChanged(address oldPriceGetter, address newPriceGetter);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Constructor, for some addresses\r\n     * @param _usdc        USDC.e is the first stablecoin supported in the pool\r\n     * @param _factory     Address of naughty factory\r\n     * @param _priceGetter Address of the oracle contract\r\n     */\r\n    function initialize(\r\n        address _usdc,\r\n        address _factory,\r\n        address _priceGetter\r\n    ) public initializer {\r\n        __Ownable_init();\r\n\r\n        // Add the first stablecoin supported\r\n        supportedStablecoin[_usdc] = true;\r\n\r\n        // Initialize the interfaces\r\n        factory = INaughtyFactory(_factory);\r\n        priceGetter = IPriceGetter(_priceGetter);\r\n\r\n        // 20% to lottery, 80% to income sharing\r\n        toLotteryPart = 2;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Check if this stablecoin is supported\r\n     * @param _stablecoin Stablecoin address\r\n     */\r\n    modifier validStablecoin(address _stablecoin) {\r\n        require(\r\n            supportedStablecoin[_stablecoin] == true,\r\n            \"Do not support this stablecoin currently\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether the policy token is paired with this stablecoin\r\n     * @param _policyTokenName Policy token name\r\n     * @param _stablecoin      Stablecoin address\r\n     */\r\n    modifier validPolicyTokenWithStablecoin(\r\n        string memory _policyTokenName,\r\n        address _stablecoin\r\n    ) {\r\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\r\n        require(\r\n            whichStablecoin[policyTokenAddress] == _stablecoin,\r\n            \"Invalid policytoken with stablecoin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the policy token has been deployed, used when deploying pools\r\n     * @param _policyTokenName Name of the policy token inside the pair\r\n     */\r\n    modifier deployedPolicy(string memory _policyTokenName) {\r\n        require(\r\n            policyTokenInfoMapping[_policyTokenName].policyTokenAddress !=\r\n                address(0),\r\n            \"This policy token has not been deployed, please deploy it first\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit/Redeem/Swap only before deadline\r\n     * @dev Each pool will also have this deadline\r\n     *      That needs to be set inside naughtyFactory\r\n     * @param _policyTokenName Name of the policy token\r\n     */\r\n    modifier beforeDeadline(string memory _policyTokenName) {\r\n        uint256 deadline = policyTokenInfoMapping[_policyTokenName].deadline;\r\n        require(\r\n            block.timestamp <= deadline,\r\n            \"Can not deposit/redeem, has passed the deadline\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Can only settle the result after the \"_settleTimestamp\"\r\n     * @param _policyTokenName Name of the policy token\r\n     */\r\n    modifier afterSettlement(string memory _policyTokenName) {\r\n        uint256 settleTimestamp = policyTokenInfoMapping[_policyTokenName]\r\n            .settleTimestamp;\r\n        require(\r\n            block.timestamp >= settleTimestamp,\r\n            \"Can not settle/claim, have not reached settleTimestamp\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Avoid multiple settlements\r\n     * @param _policyTokenName Name of the policy token\r\n     */\r\n    modifier notAlreadySettled(string memory _policyTokenName) {\r\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\r\n        require(\r\n            settleResult[policyTokenAddress].alreadySettled == false,\r\n            \"This policy has already been settled\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Find the token address by its name\r\n     * @param _policyTokenName Name of the policy token (e.g. \"AVAX_30_L_2103\")\r\n     * @return policyTokenAddress Address of the policy token\r\n     */\r\n    function findAddressbyName(string memory _policyTokenName)\r\n        public\r\n        view\r\n        returns (address policyTokenAddress)\r\n    {\r\n        policyTokenAddress = policyTokenInfoMapping[_policyTokenName]\r\n            .policyTokenAddress;\r\n\r\n        require(policyTokenAddress != address(0), \"Policy token not found\");\r\n    }\r\n\r\n    /**\r\n     * @notice Find the token name by its address\r\n     * @param _policyTokenAddress Address of the policy token\r\n     * @return policyTokenName Name of the policy token\r\n     */\r\n    function findNamebyAddress(address _policyTokenAddress)\r\n        public\r\n        view\r\n        returns (string memory policyTokenName)\r\n    {\r\n        policyTokenName = policyTokenAddressToName[_policyTokenAddress];\r\n\r\n        require(bytes(policyTokenName).length > 0, \"Policy name not found\");\r\n    }\r\n\r\n    /**\r\n     * @notice Find the token information by its name\r\n     * @param _policyTokenName Name of the policy token (e.g. \"AVAX30L202103\")\r\n     * @return policyTokenInfo PolicyToken detail information\r\n     */\r\n    function getPolicyTokenInfo(string memory _policyTokenName)\r\n        public\r\n        view\r\n        returns (PolicyTokenInfo memory)\r\n    {\r\n        return policyTokenInfoMapping[_policyTokenName];\r\n    }\r\n\r\n    /**\r\n     * @notice Get a user's quota for a certain policy token\r\n     * @param _user               Address of the user to be checked\r\n     * @param _policyTokenAddress Address of the policy token\r\n     * @return _quota User's quota result\r\n     */\r\n    function getUserQuota(address _user, address _policyTokenAddress)\r\n        external\r\n        view\r\n        returns (uint256 _quota)\r\n    {\r\n        _quota = userQuota[_user][_policyTokenAddress];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the information about all the tokens\r\n     * @dev Include all active&expired tokens\r\n     * @return tokensInfo Token information list\r\n     */\r\n    function getAllTokens() external view returns (PolicyTokenInfo[] memory) {\r\n        uint256 length = allPolicyTokens.length;\r\n        PolicyTokenInfo[] memory tokensInfo = new PolicyTokenInfo[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tokensInfo[i] = policyTokenInfoMapping[allPolicyTokens[i]];\r\n        }\r\n\r\n        return tokensInfo;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Add a new supported stablecoin\r\n     * @param _newStablecoin Address of the new stablecoin\r\n     */\r\n    function addStablecoin(address _newStablecoin) external onlyOwner {\r\n        supportedStablecoin[_newStablecoin] = true;\r\n        emit NewStablecoinAdded(_newStablecoin);\r\n    }\r\n\r\n    /**\r\n     * @notice Change the address of lottery\r\n     * @param _lotteryAddress Address of the new lottery\r\n     */\r\n    function setLottery(address _lotteryAddress) external onlyOwner {\r\n        emit LotteryChanged(lottery, _lotteryAddress);\r\n        lottery = _lotteryAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Change the address of emergency pool\r\n     * @param _incomeSharing Address of the new incomeSharing\r\n     */\r\n    function setIncomeSharing(address _incomeSharing) external onlyOwner {\r\n        emit IncomeSharingChanged(incomeSharing, _incomeSharing);\r\n        incomeSharing = _incomeSharing;\r\n    }\r\n\r\n    /**\r\n     * @notice Change the address of naughty router\r\n     * @param _router Address of the new naughty router\r\n     */\r\n    function setNaughtyRouter(address _router) external onlyOwner {\r\n        emit NaughtyRouterChanged(naughtyRouter, _router);\r\n        naughtyRouter = _router;\r\n    }\r\n\r\n    /**\r\n     * @notice Change the address of ILM\r\n     * @param _ILM Address of the new ILM\r\n     */\r\n    function setILMContract(address _ILM) external onlyOwner {\r\n        emit ILMChanged(ILMContract, _ILM);\r\n        ILMContract = _ILM;\r\n    }\r\n\r\n    /**\r\n     * @notice Change the income part to lottery\r\n     * @dev The remaining part will be distributed to incomeSharing\r\n     * @param _toLottery Proportion to lottery\r\n     */\r\n    function setIncomeToLottery(uint256 _toLottery) external onlyOwner {\r\n        require(_toLottery <= 10, \"Max 10\");\r\n        emit IncomeToLotteryChanged(toLotteryPart, _toLottery);\r\n        toLotteryPart = _toLottery;\r\n    }\r\n\r\n    /**\r\n     * @notice Set IDO price getter contract\r\n     * @param _idoPriceGetter Address of the new IDO price getter contract\r\n     */\r\n    function setIDOPriceGetter(address _idoPriceGetter) external onlyOwner {\r\n        emit IDOPriceGetterChanged(address(idoPriceGetter), _idoPriceGetter);\r\n        idoPriceGetter = IPriceGetter(_idoPriceGetter);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Deploy a new policy token and return the token address\r\n     * @dev Only the owner can deploy new policy tokens\r\n     *      The name form is like \"AVAX_50_L_2203\" and is built inside the contract\r\n     *      Name decimals and token decimals are different here\r\n     *      The original token name should be the same in Chainlink PriceFeeds\r\n     *      Those tokens that are not listed on Chainlink are not supported\r\n     * @param _tokenName       Name of the original token (e.g. AVAX, BTC, ETH...)\r\n     * @param _stablecoin      Address of the stablecoin (Just for check decimals here)\r\n     * @param _isCall          The policy is for higher or lower than the strike price (call / put)\r\n     * @param _nameDecimals    Decimals of this token's name (0~18)\r\n     * @param _tokenDecimals   Decimals of this token's value (0~18) (same as paired stablecoin)\r\n     * @param _strikePrice     Strike price of the policy (have already been transferred with 1e18)\r\n     * @param _round           Round of the token (e.g. 2203 -> expired at 22 March)\r\n     * @param _deadline        Deadline of this policy token (deposit / redeem / swap)\r\n     * @param _settleTimestamp Can settle after this timestamp (for oracle)\r\n     * @param _isIDOPool       Whether this token is an IDO pool\r\n     */\r\n    function deployPolicyToken(\r\n        string memory _tokenName,\r\n        address _stablecoin,\r\n        bool _isCall,\r\n        uint256 _nameDecimals,\r\n        uint256 _tokenDecimals,\r\n        uint256 _strikePrice,\r\n        string memory _round,\r\n        uint256 _deadline,\r\n        uint256 _settleTimestamp,\r\n        bool _isIDOPool\r\n    ) external onlyOwner {\r\n        require(\r\n            _nameDecimals <= 18 && _tokenDecimals <= 18,\r\n            \"Too many decimals\"\r\n        );\r\n        require(\r\n            IERC20Decimals(_stablecoin).decimals() == _tokenDecimals,\r\n            \"Decimals not paired\"\r\n        );\r\n\r\n        require(_deadline > block.timestamp, \"Wrong deadline\");\r\n        require(_settleTimestamp >= _deadline, \"Wrong settleTimestamp\");\r\n\r\n        // Generate the policy token name\r\n        string memory policyTokenName = _generateName(\r\n            _tokenName,\r\n            _nameDecimals,\r\n            _strikePrice,\r\n            _isCall,\r\n            _round\r\n        );\r\n        // Deploy a new policy token by the factory contract\r\n        address policyTokenAddress = factory.deployPolicyToken(\r\n            policyTokenName,\r\n            _tokenDecimals\r\n        );\r\n\r\n        // Store the policyToken information in the mapping\r\n        policyTokenInfoMapping[policyTokenName] = PolicyTokenInfo(\r\n            policyTokenAddress,\r\n            _isCall,\r\n            _nameDecimals,\r\n            _tokenDecimals,\r\n            _strikePrice,\r\n            _deadline,\r\n            _settleTimestamp\r\n        );\r\n\r\n        // Keep the record from policy token to original token\r\n        policyTokenToOriginal[policyTokenAddress] = _tokenName;\r\n\r\n        // Record the address to name mapping\r\n        policyTokenAddressToName[policyTokenAddress] = policyTokenName;\r\n\r\n        // Push the policytokenName into the list\r\n        allPolicyTokens.push(policyTokenName);\r\n\r\n        emit PolicyTokenDeployed(\r\n            policyTokenName,\r\n            policyTokenAddress,\r\n            _tokenDecimals,\r\n            _deadline,\r\n            _settleTimestamp\r\n        );\r\n\r\n        // Record if it is a IDO pool\r\n        isIDOPool[policyTokenName] = _isIDOPool;\r\n    }\r\n\r\n    /**\r\n     * @notice Deploy a new pair (pool)\r\n     * @param _policyTokenName Name of the policy token\r\n     * @param _stablecoin      Address of the stable coin\r\n     * @param _poolDeadline    Swapping deadline of the pool (normally the same as the token's deadline)\r\n     * @param _feeRate         Fee rate given to LP holders\r\n     */\r\n    function deployPool(\r\n        string memory _policyTokenName,\r\n        address _stablecoin,\r\n        uint256 _poolDeadline,\r\n        uint256 _feeRate\r\n    )\r\n        external\r\n        validStablecoin(_stablecoin)\r\n        deployedPolicy(_policyTokenName)\r\n        returns (address)\r\n    {\r\n        require(\r\n            msg.sender == owner() || msg.sender == ILMContract,\r\n            \"Only owner or ILM\"\r\n        );\r\n\r\n        require(_poolDeadline > block.timestamp, \"Wrong deadline\");\r\n        require(\r\n            _poolDeadline == policyTokenInfoMapping[_policyTokenName].deadline,\r\n            \"Policy token and pool deadline not the same\"\r\n        );\r\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\r\n\r\n        address poolAddress = _deployPool(\r\n            policyTokenAddress,\r\n            _stablecoin,\r\n            _poolDeadline,\r\n            _feeRate\r\n        );\r\n\r\n        emit PoolDeployed(poolAddress, policyTokenAddress, _stablecoin);\r\n\r\n        return poolAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit stablecoins and get policy tokens\r\n     * @param _policyTokenName Name of the policy token\r\n     * @param _stablecoin      Address of the stable coin\r\n     * @param _amount          Amount of stablecoin\r\n     */\r\n    function deposit(\r\n        string memory _policyTokenName,\r\n        address _stablecoin,\r\n        uint256 _amount\r\n    )\r\n        public\r\n        beforeDeadline(_policyTokenName)\r\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\r\n    {\r\n        require(_amount > 0, \"Zero Amount\");\r\n        _deposit(_policyTokenName, _stablecoin, _amount, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate deposit (deposit and mint for other addresses)\r\n     * @dev Only called by the router contract\r\n     * @param _policyTokenName Name of the policy token\r\n     * @param _stablecoin      Address of the sable coin\r\n     * @param _amount          Amount of stablecoin\r\n     * @param _user            Address to receive the policy tokens\r\n     */\r\n    function delegateDeposit(\r\n        string memory _policyTokenName,\r\n        address _stablecoin,\r\n        uint256 _amount,\r\n        address _user\r\n    )\r\n        external\r\n        beforeDeadline(_policyTokenName)\r\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\r\n    {\r\n        require(\r\n            msg.sender == naughtyRouter,\r\n            \"Only the router contract can delegate\"\r\n        );\r\n        require(_amount > 0, \"Zero Amount\");\r\n\r\n        _deposit(_policyTokenName, _stablecoin, _amount, _user);\r\n\r\n        emit DelegateDeposit(\r\n            msg.sender,\r\n            _user,\r\n            _policyTokenName,\r\n            _stablecoin,\r\n            _amount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Burn policy tokens and redeem stablecoins\r\n     * @dev Redeem happens before the deadline and is different from claim/settle\r\n     * @param _policyTokenName Name of the policy token\r\n     * @param _stablecoin      Address of the stablecoin\r\n     * @param _amount          Amount to redeem\r\n     */\r\n    function redeem(\r\n        string memory _policyTokenName,\r\n        address _stablecoin,\r\n        uint256 _amount\r\n    )\r\n        public\r\n        beforeDeadline(_policyTokenName)\r\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\r\n    {\r\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\r\n\r\n        // Check if the user has enough quota (quota is only for those who mint policy tokens)\r\n        require(\r\n            userQuota[msg.sender][policyTokenAddress] >= _amount,\r\n            \"User's quota not sufficient\"\r\n        );\r\n\r\n        // Update quota\r\n        userQuota[msg.sender][policyTokenAddress] -= _amount;\r\n\r\n        // Charge 1% Fee when redeem / claim\r\n        uint256 amountWithFee = _chargeFee(_stablecoin, _amount);\r\n\r\n        // Transfer back the stablecoin\r\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\r\n\r\n        // Burn the policy tokens\r\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\r\n        policyToken.burn(msg.sender, _amount);\r\n\r\n        emit Redeem(msg.sender, _policyTokenName, _stablecoin, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Redeem policy tokens and get stablecoins by the user himeself\r\n     * @param _policyTokenName Name of the policy token\r\n     * @param _stablecoin      Address of the stablecoin\r\n     */\r\n    function redeemAfterSettlement(\r\n        string memory _policyTokenName,\r\n        address _stablecoin\r\n    )\r\n        public\r\n        afterSettlement(_policyTokenName)\r\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\r\n    {\r\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\r\n\r\n        // Copy to memory (will not change the result)\r\n        SettlementInfo memory result = settleResult[policyTokenAddress];\r\n\r\n        // Must have got the final price\r\n        require(\r\n            result.price != 0 && result.alreadySettled,\r\n            \"Have not got the oracle result\"\r\n        );\r\n\r\n        // The event must be \"not happend\"\r\n        require(\r\n            result.isHappened == false,\r\n            \"Only call this function when the event does not happen\"\r\n        );\r\n\r\n        uint256 quota = userQuota[msg.sender][policyTokenAddress];\r\n        // User must have quota because this is for depositors when event not happens\r\n        require(\r\n            quota > 0,\r\n            \"No quota, you did not deposit and mint policy tokens before\"\r\n        );\r\n\r\n        // Charge 1% Fee when redeem / claim\r\n        uint256 amountWithFee = _chargeFee(_stablecoin, quota);\r\n\r\n        // Send back stablecoins directly\r\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\r\n\r\n        // Delete the userQuota storage\r\n        delete userQuota[msg.sender][policyTokenAddress];\r\n\r\n        emit RedeemAfterSettlement(\r\n            msg.sender,\r\n            _policyTokenName,\r\n            _stablecoin,\r\n            amountWithFee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Claim a payoff based on policy tokens\r\n     * @dev It is done after result settlement and only if the result is true\r\n     * @param _policyTokenName Name of the policy token\r\n     * @param _stablecoin      Address of the stable coin\r\n     * @param _amount          Amount of stablecoin\r\n     */\r\n    function claim(\r\n        string memory _policyTokenName,\r\n        address _stablecoin,\r\n        uint256 _amount\r\n    )\r\n        public\r\n        afterSettlement(_policyTokenName)\r\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\r\n    {\r\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\r\n\r\n        // Copy to memory (will not change the result)\r\n        SettlementInfo memory result = settleResult[policyTokenAddress];\r\n\r\n        // Check if we have already settle the final price\r\n        require(\r\n            result.price != 0 && result.alreadySettled,\r\n            \"Have not got the oracle result\"\r\n        );\r\n\r\n        // Check if the event happens\r\n        require(\r\n            result.isHappened,\r\n            \"The result does not happen, you can not claim\"\r\n        );\r\n\r\n        // Charge 1% fee\r\n        uint256 amountWithFee = _chargeFee(_stablecoin, _amount);\r\n\r\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\r\n\r\n        // Users must have enough policy tokens to claim\r\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\r\n\r\n        // Burn the policy tokens\r\n        policyToken.burn(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the final price from the PriceGetter contract\r\n     * @param _policyTokenName Name of the policy token\r\n     */\r\n    function settleFinalResult(string memory _policyTokenName)\r\n        public\r\n        afterSettlement(_policyTokenName)\r\n        notAlreadySettled(_policyTokenName)\r\n    {\r\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\r\n\r\n        SettlementInfo storage result = settleResult[policyTokenAddress];\r\n\r\n        // Get the strike token name\r\n        string memory originalTokenName = policyTokenToOriginal[\r\n            policyTokenAddress\r\n        ];\r\n\r\n        uint256 finalPrice;\r\n        // Get the final price from oracle\r\n        if (isIDOPool[_policyTokenName]) {\r\n            finalPrice = idoPriceGetter.getLatestPrice(_policyTokenName);\r\n        } else {\r\n            finalPrice = priceGetter.getLatestPrice(originalTokenName);\r\n        }\r\n\r\n        // Record the price\r\n        result.alreadySettled = true;\r\n        result.price = finalPrice;\r\n\r\n        PolicyTokenInfo memory policyTokenInfo = policyTokenInfoMapping[\r\n            _policyTokenName\r\n        ];\r\n\r\n        // Get the final result\r\n        bool situationT1 = (finalPrice >= policyTokenInfo.strikePrice) &&\r\n            policyTokenInfo.isCall;\r\n        bool situationT2 = (finalPrice <= policyTokenInfo.strikePrice) &&\r\n            !policyTokenInfo.isCall;\r\n\r\n        bool isHappened = (situationT1 || situationT2) ? true : false;\r\n\r\n        // Record the result\r\n        result.isHappened = isHappened;\r\n\r\n        emit FinalResultSettled(_policyTokenName, finalPrice, isHappened);\r\n    }\r\n\r\n    /**\r\n     * @notice Settle the policies for the users when insurance events do not happen\r\n     *         Funds are automatically distributed back to the depositors\r\n     * @dev    Take care of the gas cost and can use the _startIndex and _stopIndex to control the size\r\n     * @param _policyTokenName Name of policy token\r\n     * @param _stablecoin      Address of stablecoin\r\n     * @param _startIndex      Settlement start index\r\n     * @param _stopIndex       Settlement stop index\r\n     */\r\n    function settleAllPolicyTokens(\r\n        string memory _policyTokenName,\r\n        address _stablecoin,\r\n        uint256 _startIndex,\r\n        uint256 _stopIndex\r\n    ) public onlyOwner {\r\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\r\n\r\n        // Copy to memory (will not change the result)\r\n        SettlementInfo memory result = settleResult[policyTokenAddress];\r\n\r\n        // Must have got the final price\r\n        require(\r\n            result.price != 0 && result.alreadySettled == true,\r\n            \"Have not got the oracle result\"\r\n        );\r\n\r\n        // The event must be \"not happend\"\r\n        require(\r\n            result.isHappened == false,\r\n            \"Only call this function when the event does not happen\"\r\n        );\r\n\r\n        // Store the amount to collect to lottery and emergency pool\r\n        uint256 amountToCollect = 0;\r\n\r\n        // Length of all depositors for this policy token\r\n        uint256 length = allDepositors[policyTokenAddress].length;\r\n\r\n        require(\r\n            result.currentDistributionIndex <= length,\r\n            \"Have distributed all\"\r\n        );\r\n\r\n        // Settle the policies in [_startIndex, _stopIndex)\r\n        if (_startIndex == 0 && _stopIndex == 0) {\r\n            amountToCollect += _settlePolicy(\r\n                policyTokenAddress,\r\n                _stablecoin,\r\n                0,\r\n                length\r\n            );\r\n\r\n            // Update the distribution index for this policy token\r\n            settleResult[policyTokenAddress].currentDistributionIndex = length;\r\n\r\n            emit PolicyTokensSettledForUsers(\r\n                _policyTokenName,\r\n                _stablecoin,\r\n                0,\r\n                length\r\n            );\r\n        } else {\r\n            require(\r\n                result.currentDistributionIndex == _startIndex,\r\n                \"You need to start from the last distribution point\"\r\n            );\r\n            require(_stopIndex < length, \"Invalid stop index\");\r\n\r\n            amountToCollect += _settlePolicy(\r\n                policyTokenAddress,\r\n                _stablecoin,\r\n                _startIndex,\r\n                _stopIndex\r\n            );\r\n\r\n            // Update the distribution index for this policy token\r\n            settleResult[policyTokenAddress]\r\n                .currentDistributionIndex = _stopIndex;\r\n\r\n            emit PolicyTokensSettledForUsers(\r\n                _policyTokenName,\r\n                _stablecoin,\r\n                _startIndex,\r\n                _stopIndex\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Collect the income\r\n     * @dev Can be done by anyone, only when there is some income to be distributed\r\n     * @param _stablecoin Address of stablecoin\r\n     */\r\n    function collectIncome(address _stablecoin) public {\r\n        require(\r\n            lottery != address(0) && incomeSharing != address(0),\r\n            \"Please set the lottery & incomeSharing address\"\r\n        );\r\n\r\n        uint256 amountToLottery = pendingIncomeToLottery[_stablecoin];\r\n        uint256 amountToSharing = pendingIncomeToSharing[_stablecoin];\r\n        require(\r\n            amountToLottery > 0 || amountToSharing > 0,\r\n            \"No pending income\"\r\n        );\r\n\r\n        IERC20(_stablecoin).safeTransfer(lottery, amountToLottery);\r\n        IERC20(_stablecoin).safeTransfer(incomeSharing, amountToSharing);\r\n\r\n        pendingIncomeToLottery[_stablecoin] = 0;\r\n        pendingIncomeToSharing[_stablecoin] = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Update user quota from ILM when claim\r\n     *\r\n     * @dev When you claim your liquidity from ILM, you will get normal quota as you are using policyCore\r\n     * @param _user        User address\r\n     * @param _policyToken PolicyToken address\r\n     * @param _amount      Quota amount\r\n     */\r\n    function updateUserQuota(\r\n        address _user,\r\n        address _policyToken,\r\n        uint256 _amount\r\n    ) external {\r\n        require(msg.sender == ILMContract, \"Only ILM\");\r\n\r\n        userQuota[_user][_policyToken] += _amount;\r\n\r\n        emit UpdateUserQuota(_user, _policyToken, _amount);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Finish deploying a pool\r\n     *\r\n     * @param _policyTokenAddress Address of the policy token\r\n     * @param _stablecoin         Address of the stable coin\r\n     * @param _poolDeadline       Swapping deadline of the pool (normally the same as the token's deadline)\r\n     * @param _feeRate            Fee rate given to LP holders\r\n     *\r\n     * @return poolAddress Address of the pool\r\n     */\r\n    function _deployPool(\r\n        address _policyTokenAddress,\r\n        address _stablecoin,\r\n        uint256 _poolDeadline,\r\n        uint256 _feeRate\r\n    ) internal returns (address) {\r\n        // Deploy a new pool (policyToken <=> stablecoin)\r\n        address poolAddress = factory.deployPool(\r\n            _policyTokenAddress,\r\n            _stablecoin,\r\n            _poolDeadline,\r\n            _feeRate\r\n        );\r\n\r\n        // Record the mapping\r\n        whichStablecoin[_policyTokenAddress] = _stablecoin;\r\n\r\n        return poolAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Finish Deposit\r\n     *\r\n     * @param _policyTokenName Name of the policy token\r\n     * @param _stablecoin Address of the sable coin\r\n     * @param _amount Amount of stablecoin\r\n     * @param _user Address to receive the policy tokens\r\n     */\r\n    function _deposit(\r\n        string memory _policyTokenName,\r\n        address _stablecoin,\r\n        uint256 _amount,\r\n        address _user\r\n    ) internal {\r\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\r\n\r\n        // If this is the first deposit, store the user address\r\n        if (userQuota[_user][policyTokenAddress] == 0) {\r\n            allDepositors[policyTokenAddress].push(_user);\r\n        }\r\n\r\n        // Update the user quota\r\n        userQuota[_user][policyTokenAddress] += _amount;\r\n\r\n        // Transfer stablecoins to this contract\r\n        IERC20(_stablecoin).safeTransferFrom(_user, address(this), _amount);\r\n\r\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\r\n\r\n        // Mint new policy tokens\r\n        policyToken.mint(_user, _amount);\r\n\r\n        emit Deposit(_user, _policyTokenName, _stablecoin, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Settle the policy when the event does not happen\r\n     *\r\n     * @param _policyTokenAddress Address of policy token\r\n     * @param _stablecoin Address of stable coin\r\n     * @param _start Start index\r\n     * @param _stop Stop index\r\n     */\r\n    function _settlePolicy(\r\n        address _policyTokenAddress,\r\n        address _stablecoin,\r\n        uint256 _start,\r\n        uint256 _stop\r\n    ) internal returns (uint256 amountRemaining) {\r\n        for (uint256 i = _start; i < _stop; i++) {\r\n            address user = allDepositors[_policyTokenAddress][i];\r\n            uint256 amount = userQuota[user][_policyTokenAddress];\r\n            // Charge fee\r\n            uint256 amountWithFee = _chargeFee(_stablecoin, amount);\r\n\r\n            if (amountWithFee > 0) {\r\n                IERC20(_stablecoin).safeTransfer(user, amountWithFee);\r\n                delete userQuota[user][_policyTokenAddress];\r\n\r\n                // Accumulate the remaining part that will be collected later\r\n                amountRemaining += amount - amountWithFee;\r\n            } else continue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Charge fee when redeem / claim\r\n     *\r\n     * @param _stablecoin Stablecoin address\r\n     * @param _amount     Amount to redeem / claim\r\n     *\r\n     * @return amountWithFee Amount with fee\r\n     */\r\n    function _chargeFee(address _stablecoin, uint256 _amount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 amountWithFee = (_amount * 990) / 1000;\r\n        uint256 amountToCollect = _amount - amountWithFee;\r\n\r\n        uint256 amountToLottery = (amountToCollect * toLotteryPart) / 10;\r\n\r\n        pendingIncomeToLottery[_stablecoin] += amountToLottery;\r\n        pendingIncomeToSharing[_stablecoin] +=\r\n            amountToCollect -\r\n            amountToLottery;\r\n\r\n        return amountWithFee;\r\n    }\r\n\r\n    /**\r\n     * @notice Generate the policy token name\r\n     *\r\n     * @param _tokenName   Name of the stike token (BTC, ETH, AVAX...)\r\n     * @param _decimals    Decimals of the name generation (0,1=>1, 2=>2)\r\n     * @param _strikePrice Strike price of the policy (18 decimals)\r\n     * @param _isCall      The policy's payoff is triggered when higher(true) or lower(false)\r\n     * @param _round       Round of the policy, named by <month><day> (e.g. 0320, 1215)\r\n     */\r\n    function _generateName(\r\n        string memory _tokenName,\r\n        uint256 _decimals,\r\n        uint256 _strikePrice,\r\n        bool _isCall,\r\n        string memory _round\r\n    ) public pure returns (string memory) {\r\n        // The direction is \"H\"(Call) or \"L\"(Put)\r\n        string memory direction = _isCall ? \"H\" : \"L\";\r\n\r\n        // Integer part of the strike price (12e18 => 12)\r\n        uint256 intPart = _strikePrice / 1e18;\r\n        // require(intPart > 0, \"Invalid int part\");\r\n\r\n        // Decimal part of the strike price (1234e16 => 34)\r\n        // Can not start with 0 (e.g. 1204e16 => 0 this is incorrect, will revert in next step)\r\n        uint256 decimalPart = _frac(_strikePrice) / (10**(18 - _decimals));\r\n        if (_decimals >= 2)\r\n            require(decimalPart > 10**(_decimals - 1), \"Invalid decimal part\");\r\n\r\n        // Combine the string\r\n        string memory name = string(\r\n            abi.encodePacked(\r\n                _tokenName,\r\n                \"_\",\r\n                intPart.uintToString(),\r\n                \".\",\r\n                decimalPart.uintToString(),\r\n                \"_\",\r\n                direction,\r\n                \"_\",\r\n                _round\r\n            )\r\n        );\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the fraction part of a number\r\n     *\r\n     * @dev The scale is fixed as 1e18 (decimal fraction)\r\n     *\r\n     * @param x Number to calculate\r\n     *\r\n     * @return result Fraction result\r\n     */\r\n    function _frac(uint256 x) internal pure returns (uint256 result) {\r\n        uint256 SCALE = 1e18;\r\n        assembly {\r\n            result := mod(x, SCALE)\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/utils/interfaces/IERC20Decimals.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.10;\r\n\r\ninterface IERC20Decimals {\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "contracts/naughty-price/interfaces/IPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface IPriceGetter {\r\n    function getPriceFeedAddress(string memory _tokenName)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function setPriceFeed(string memory _tokenName, address _feedAddress)\r\n        external;\r\n\r\n    function getLatestPrice(string memory _tokenName)\r\n        external\r\n        returns (uint256 _price);\r\n}\r\n"
    },
    "contracts/naughty-price/interfaces/INaughtyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface INaughtyFactory {\r\n    function getPairAddress(address _tokenAddress1, address _tokenAddress2)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function deployPolicyToken(\r\n        string memory _policyTokenName,\r\n        uint256 _decimals\r\n    ) external returns (address);\r\n\r\n    function deployPool(\r\n        address _policyTokenAddress,\r\n        address _stablecoin,\r\n        uint256 _deadline,\r\n        uint256 _feeRate\r\n    ) external returns (address);\r\n\r\n    function incomeMaker() external view returns (address);\r\n\r\n    function incomeMakerProportion() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/naughty-price/interfaces/INPPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface INPPolicyToken is IERC20 {\r\n    function mint(address _account, uint256 _amount) external;\r\n\r\n    function burn(address _account, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/utils/interfaces/IERC20PermitWithMultipleMinters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\r\n\r\ninterface IERC20PermitWithMultipleMinters is IERC20, IERC20Permit {\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Functions ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n    /**\r\n     * @notice Add a new minter into the minterList\r\n     * @param _newMinter Address of the new minter\r\n     */\r\n    function addMinter(address _newMinter) external;\r\n\r\n    /**\r\n     * @notice Remove a minter from the minterList\r\n     * @param _oldMinter Address of the minter to be removed\r\n     */\r\n    function removeMinter(address _oldMinter) external;\r\n\r\n    /**\r\n     * @notice Add a new burner into the burnerList\r\n     * @param _newBurner Address of the new burner\r\n     */\r\n    function addBurner(address _newBurner) external;\r\n\r\n    /**\r\n     * @notice Remove a minter from the minterList\r\n     * @param _oldBurner Address of the minter to be removed\r\n     */\r\n    function removeBurner(address _oldBurner) external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/miserable-flight/interfaces/IFDPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\r\n\r\ninterface IFDPolicyToken is IERC721Enumerable {\r\n    function mintPolicyToken(address _receiver) external;\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n\r\n    function getTokenURI(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (string memory);\r\n}\r\n"
    },
    "contracts/miserable-flight/PolicyFlow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"../tokens/interfaces/IBuyerToken.sol\";\r\nimport \"./interfaces/ISigManager.sol\";\r\nimport \"./interfaces/IFDPolicyToken.sol\";\r\nimport \"./interfaces/IFlightOracle.sol\";\r\nimport \"./interfaces/IInsurancePool.sol\";\r\nimport \"./interfaces/IPolicyStruct.sol\";\r\nimport \"./abstracts/PolicyParameters.sol\";\r\nimport \"../libraries/StringsUtils.sol\";\r\nimport \"../libraries/StablecoinDecimal.sol\";\r\n\r\ncontract PolicyFlow is IPolicyStruct, PolicyParameters, OwnableUpgradeable {\r\n    using StringsUtils for uint256;\r\n    using StablecoinDecimal for uint256;\r\n\r\n    // Other contracts\r\n    IBuyerToken public buyerToken;\r\n    ISigManager public sigManager;\r\n    IFDPolicyToken public policyToken;\r\n    IFlightOracle public flightOracle;\r\n    IInsurancePool public insurancePool;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    string public FLIGHT_STATUS_URL = \"https://degis.io:3207/flight_status?\";\r\n\r\n    uint256 public totalPolicies;\r\n\r\n    uint256 public fee;\r\n\r\n    mapping(uint256 => PolicyInfo) public policyList;\r\n\r\n    mapping(address => uint256[]) userPolicyList;\r\n\r\n    mapping(bytes32 => uint256) requestList;\r\n\r\n    mapping(uint256 => uint256) delayResultList;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n    event FeeChanged(uint256 newFee);\r\n    event MaxPayoffChanged(uint256 newMaxPayoff);\r\n    event MinTimeBeforeDepartureChanged(uint256 newMinTime);\r\n    event FlightOracleChanged(address newOracle);\r\n    event OracleUrlChanged(string newUrl);\r\n    event DelayThresholdChanged(uint256 thresholdMin, uint256 thresholdMax);\r\n\r\n    event NewPolicyApplication(uint256 policyId, address indexed user);\r\n    event NewClaimRequest(\r\n        uint256 policyId,\r\n        string flightNumber,\r\n        bytes32 requestId\r\n    );\r\n    event PolicySold(uint256 policyId, address indexed user);\r\n    event PolicyDeclined(uint256 policyId, address indexed user);\r\n    event PolicyClaimed(uint256 policyId, address indexed user);\r\n    event PolicyExpired(uint256 policyId, address indexed user);\r\n    event FulfilledOracleRequest(uint256 policyId, bytes32 requestId);\r\n    event PolicyOwnerTransfer(uint256 indexed tokenId, address newOwner);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Initializer ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Initializer of the PolicyFlow contract\r\n     * @dev Upgradeable contracts do not have a constrcutor\r\n     * @param _insurancePool The InsurancePool contract address\r\n     * @param _policyToken The PolicyToken contract address\r\n     * @param _sigManager The SigManager contract address\r\n     * @param _buyerToken The BuyerToken contract address\r\n     */\r\n    function initialize(\r\n        address _insurancePool,\r\n        address _policyToken,\r\n        address _sigManager,\r\n        address _buyerToken\r\n    ) public initializer {\r\n        __Ownable_init();\r\n        __PolicyFlow_init(\r\n            _insurancePool,\r\n            _policyToken,\r\n            _sigManager,\r\n            _buyerToken\r\n        );\r\n    }\r\n\r\n    function __PolicyFlow_init(\r\n        address _insurancePool,\r\n        address _policyToken,\r\n        address _sigManager,\r\n        address _buyerToken\r\n    ) internal onlyInitializing {\r\n        insurancePool = IInsurancePool(_insurancePool);\r\n        policyToken = IFDPolicyToken(_policyToken);\r\n        sigManager = ISigManager(_sigManager);\r\n        buyerToken = IBuyerToken(_buyerToken);\r\n\r\n        // Set the oracle fee\r\n        fee = 0.1 * 10**18;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------------- //\r\n    // ********************************* View Functions ********************************** //\r\n    // ----------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Show a user's policies (all)\r\n     * @dev Should only be checked for frontend\r\n     * @param _user User's address\r\n     * @return userPolicies User's all policy details\r\n     */\r\n    function viewUserPolicy(address _user)\r\n        external\r\n        view\r\n        returns (PolicyInfo[] memory)\r\n    {\r\n        uint256 userPolicyAmount = userPolicyList[_user].length;\r\n        require(userPolicyAmount > 0, \"No policy for this user\");\r\n\r\n        PolicyInfo[] memory result = new PolicyInfo[](userPolicyAmount);\r\n\r\n        for (uint256 i = 0; i < userPolicyAmount; i++) {\r\n            uint256 policyId = userPolicyList[_user][i];\r\n\r\n            result[i] = policyList[policyId];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the policyInfo from its count/order\r\n     * @param _policyId Total count/order of the policy = NFT tokenId\r\n     * @return policy A struct of information about this policy\r\n     */\r\n    // TODO: If still need this function\r\n    function getPolicyInfoById(uint256 _policyId)\r\n        public\r\n        view\r\n        returns (PolicyInfo memory policy)\r\n    {\r\n        policy = policyList[_policyId];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the policy buyer by policyId\r\n     * @param _policyId Unique policy Id (uint256)\r\n     * @return buyerAddress The buyer of this policy\r\n     */\r\n    // TODO: If still need this function\r\n    function findPolicyBuyerById(uint256 _policyId)\r\n        public\r\n        view\r\n        returns (address buyerAddress)\r\n    {\r\n        buyerAddress = policyList[_policyId].buyerAddress;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Change the oracle fee\r\n     * @param _fee New oracle fee\r\n     */\r\n    function setFee(uint256 _fee) external onlyOwner {\r\n        fee = _fee;\r\n        emit FeeChanged(_fee);\r\n    }\r\n\r\n    /**\r\n     * @notice Change the max payoff\r\n     * @param _newMaxPayoff New maxpayoff amount\r\n     */\r\n    function setMaxPayoff(uint256 _newMaxPayoff) external onlyOwner {\r\n        MAX_PAYOFF = _newMaxPayoff;\r\n        emit MaxPayoffChanged(_newMaxPayoff);\r\n    }\r\n\r\n    /**\r\n     * @notice How long before departure when users can not buy new policies\r\n     * @param _newMinTime New time set\r\n     */\r\n    function setMinTimeBeforeDeparture(uint256 _newMinTime) external onlyOwner {\r\n        MIN_TIME_BEFORE_DEPARTURE = _newMinTime;\r\n        emit MinTimeBeforeDepartureChanged(_newMinTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Change the oracle address\r\n     * @param _oracleAddress New oracle address\r\n     */\r\n    function setFlightOracle(address _oracleAddress) external onlyOwner {\r\n        flightOracle = IFlightOracle(_oracleAddress);\r\n        emit FlightOracleChanged(_oracleAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set a new url\r\n     */\r\n    function setURL(string memory _url) external onlyOwner {\r\n        FLIGHT_STATUS_URL = _url;\r\n        emit OracleUrlChanged(_url);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the new delay threshold used for calculating payoff\r\n     * @param _thresholdMin New minimum threshold\r\n     * @param _thresholdMax New maximum threshold\r\n     */\r\n    function setDelayThreshold(uint256 _thresholdMin, uint256 _thresholdMax)\r\n        external\r\n        onlyOwner\r\n    {\r\n        DELAY_THRESHOLD_MIN = _thresholdMin;\r\n        DELAY_THRESHOLD_MAX = _thresholdMax;\r\n        emit DelayThresholdChanged(_thresholdMin, _thresholdMax);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Buy a new flight delay policy\r\n     * @dev The transaction should have the signature from the backend server\r\n     * @dev Premium is in stablecoin, so it is 6 decimals\r\n     * @param _productId ID of the purchased product (0: flightdelay; 1,2,3...: others)\r\n     * @param _flightNumber Flight number in string (e.g. \"AQ1299\")\r\n     * @param _premium Premium of this policy (decimals: 6)\r\n     * @param _departureTimestamp Departure date of this flight (unix timestamp in s, not ms!)\r\n     * @param _landingDate Landing date of this flight (uinx timestamp in s, not ms!)\r\n     * @param _deadline Deadline for this purchase request\r\n     * @param signature Use web3.eth.sign(hash(data), account) to generate the signature\r\n     */\r\n    function newApplication(\r\n        uint256 _productId,\r\n        string memory _flightNumber,\r\n        uint256 _premium,\r\n        uint256 _departureTimestamp,\r\n        uint256 _landingDate,\r\n        uint256 _deadline,\r\n        bytes calldata signature\r\n    ) public returns (uint256 _policyId) {\r\n        uint256 currentTimestamp = block.timestamp;\r\n        require(\r\n            currentTimestamp <= _deadline,\r\n            \"Expired deadline, please resubmit a transaction\"\r\n        );\r\n\r\n        require(\r\n            _productId == PRODUCT_ID,\r\n            \"You are calling the wrong product contract\"\r\n        );\r\n\r\n        require(\r\n            _departureTimestamp >= currentTimestamp + MIN_TIME_BEFORE_DEPARTURE,\r\n            \"It's too close to the departure time, you cannot buy this policy\"\r\n        );\r\n\r\n        // Should be signed by operators\r\n        _checkSignature(\r\n            signature,\r\n            _flightNumber,\r\n            _departureTimestamp,\r\n            _landingDate,\r\n            _msgSender(),\r\n            _premium,\r\n            _deadline\r\n        );\r\n\r\n        // Generate the policy\r\n        // Use ++totalPolicies to keep the policyId the same as ERC721 tokenId\r\n        // Policy Id starts from 1\r\n        uint256 currentPolicyId = ++totalPolicies;\r\n\r\n        policyList[currentPolicyId] = PolicyInfo(\r\n            PRODUCT_ID,\r\n            _msgSender(),\r\n            currentPolicyId,\r\n            _flightNumber,\r\n            _premium,\r\n            MAX_PAYOFF,\r\n            currentTimestamp,\r\n            _departureTimestamp,\r\n            _landingDate,\r\n            PolicyStatus.INI,\r\n            false,\r\n            404\r\n        );\r\n\r\n        // Check the policy with the insurance pool status\r\n        // May be accepted or rejected, if accepted then update the status of insurancePool\r\n        _policyCheck(_premium, MAX_PAYOFF, msg.sender, currentPolicyId);\r\n\r\n        // Give buyer tokens depending on the usd value they spent\r\n        buyerToken.mintBuyerToken(msg.sender, _premium.toNormal());\r\n\r\n        // Store the policy's total order with userAddress\r\n        userPolicyList[msg.sender].push(totalPolicies);\r\n\r\n        emit NewPolicyApplication(currentPolicyId, msg.sender);\r\n\r\n        return currentPolicyId;\r\n    }\r\n\r\n    /**\r\n     * @notice Make a claim request\r\n     * @dev Anyone can make a new claim\r\n     * @param _policyId The total order/id of the policy\r\n     * @param _flightNumber The flight number\r\n     * @param _timestamp The flight departure timestamp\r\n     * @param _path Which data in json needs to get\r\n     * @param _forceUpdate Owner can force to update\r\n     */\r\n    function newClaimRequest(\r\n        uint256 _policyId,\r\n        string memory _flightNumber,\r\n        string memory _timestamp,\r\n        string memory _path,\r\n        bool _forceUpdate\r\n    ) public {\r\n        PolicyInfo memory policy = policyList[_policyId];\r\n\r\n        // Can not get the result before landing date\r\n        // Landing date may not be true, may be a fixed interval (4hours)\r\n        require(\r\n            block.timestamp >= policy.landingTimestamp,\r\n            \"Can only claim a policy after its expected landing timestamp\"\r\n        );\r\n\r\n        // Check if the policy has been settled\r\n        require(\r\n            (!policy.alreadySettled) ||\r\n                (_forceUpdate && (_msgSender() == owner())),\r\n            \"Already settled\"\r\n        );\r\n\r\n        // Check if the flight number is correct\r\n        require(\r\n            keccak256(abi.encodePacked(_flightNumber)) ==\r\n                keccak256(abi.encodePacked(policy.flightNumber)),\r\n            \"Wrong flight number provided\"\r\n        );\r\n\r\n        // Check if the departure date is correct\r\n        require(\r\n            keccak256(abi.encodePacked(_timestamp)) ==\r\n                keccak256(\r\n                    abi.encodePacked(policy.departureTimestamp.uintToString())\r\n                ),\r\n            \"Wrong departure timestamp provided\"\r\n        );\r\n\r\n        // Construct the url for oracle\r\n        string memory _url = string(\r\n            abi.encodePacked(\r\n                FLIGHT_STATUS_URL,\r\n                \"flight_no=\",\r\n                _flightNumber,\r\n                \"&timestamp=\",\r\n                _timestamp\r\n            )\r\n        );\r\n\r\n        // Start a new oracle request\r\n        bytes32 requestId = flightOracle.newOracleRequest(fee, _url, _path, 1);\r\n\r\n        // Record this request\r\n        requestList[requestId] = _policyId;\r\n        policyList[_policyId].alreadySettled = true;\r\n\r\n        emit NewClaimRequest(_policyId, _flightNumber, requestId);\r\n    }\r\n\r\n    /**\r\n     * @notice Update information when a policy token's ownership has been transferred\r\n     * @dev This function is called by the ERC721 contract of PolicyToken\r\n     * @param _tokenId Token Id of the policy token\r\n     * @param _oldOwner The initial owner\r\n     * @param _newOwner The new owner\r\n     */\r\n    function policyOwnerTransfer(\r\n        uint256 _tokenId,\r\n        address _oldOwner,\r\n        address _newOwner\r\n    ) external {\r\n        // Check the call is from policy token contract\r\n        require(\r\n            _msgSender() == address(policyToken),\r\n            \"only called from the flight delay policy token contract\"\r\n        );\r\n\r\n        // Check the previous owner record\r\n        uint256 policyId = _tokenId;\r\n        require(\r\n            _oldOwner == policyList[policyId].buyerAddress,\r\n            \"The previous owner is wrong\"\r\n        );\r\n\r\n        // Update the new buyer address\r\n        policyList[policyId].buyerAddress = _newOwner;\r\n        emit PolicyOwnerTransfer(_tokenId, _newOwner);\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------------- //\r\n    // ********************************* Oracle Functions ******************************** //\r\n    // ----------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Do the final settlement, called by FlightOracle contract\r\n     * @param _requestId Chainlink request id\r\n     * @param _result Delay result (minutes) given by oracle\r\n     */\r\n    function finalSettlement(bytes32 _requestId, uint256 _result) public {\r\n        // Check if the call is from flight oracle\r\n        require(\r\n            msg.sender == address(flightOracle),\r\n            \"this function should be called by FlightOracle contract\"\r\n        );\r\n\r\n        uint256 policyId = requestList[_requestId];\r\n\r\n        PolicyInfo storage policy = policyList[policyId];\r\n        policy.delayResult = _result;\r\n\r\n        uint256 premium = policy.premium;\r\n        address buyerAddress = policy.buyerAddress;\r\n\r\n        require(\r\n            _result <= DELAY_THRESHOLD_MAX || _result == 400,\r\n            \"Abnormal oracle result, result should be [0 - 240] or 400\"\r\n        );\r\n\r\n        if (_result == 0) {\r\n            // 0: on time\r\n            _policyExpired(premium, MAX_PAYOFF, buyerAddress, policyId);\r\n        } else if (_result <= DELAY_THRESHOLD_MAX) {\r\n            uint256 real_payoff = calcPayoff(_result);\r\n            _policyClaimed(premium, real_payoff, buyerAddress, policyId);\r\n        } else if (_result == 400) {\r\n            // 400: cancelled\r\n            _policyClaimed(premium, MAX_PAYOFF, buyerAddress, policyId);\r\n        }\r\n\r\n        emit FulfilledOracleRequest(policyId, _requestId);\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------------- //\r\n    // ******************************** Internal Functions ******************************* //\r\n    // ----------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice check the policy and then determine whether we can afford it\r\n     * @param _payoff the payoff of the policy sold\r\n     * @param _user user's address\r\n     * @param _policyId the unique policy ID\r\n     */\r\n    function _policyCheck(\r\n        uint256 _premium,\r\n        uint256 _payoff,\r\n        address _user,\r\n        uint256 _policyId\r\n    ) internal {\r\n        // Whether there are enough capacity in the pool\r\n        bool _isAccepted = insurancePool.checkCapacity(_payoff);\r\n\r\n        if (_isAccepted) {\r\n            insurancePool.updateWhenBuy(_premium, _payoff, _user);\r\n            policyList[_policyId].status = PolicyStatus.SOLD;\r\n            emit PolicySold(_policyId, _user);\r\n\r\n            policyToken.mintPolicyToken(_user);\r\n        } else {\r\n            emit PolicyDeclined(_policyId, _user);\r\n            revert(\"not sufficient capacity in the insurance pool\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice update the policy when it is expired\r\n     * @param _premium the premium of the policy sold\r\n     * @param _payoff the payoff of the policy sold\r\n     * @param _user user's address\r\n     * @param _policyId the unique policy ID\r\n     */\r\n    function _policyExpired(\r\n        uint256 _premium,\r\n        uint256 _payoff,\r\n        address _user,\r\n        uint256 _policyId\r\n    ) internal {\r\n        insurancePool.updateWhenExpire(_premium, _payoff);\r\n        policyList[_policyId].status = PolicyStatus.EXPIRED;\r\n        emit PolicyExpired(_policyId, _user);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the policy when it is claimed\r\n     * @param _premium Premium of the policy sold\r\n     * @param _payoff Payoff of the policy sold\r\n     * @param _user User's address\r\n     * @param _policyId The unique policy ID\r\n     */\r\n    function _policyClaimed(\r\n        uint256 _premium,\r\n        uint256 _payoff,\r\n        address _user,\r\n        uint256 _policyId\r\n    ) internal {\r\n        insurancePool.payClaim(_premium, MAX_PAYOFF, _payoff, _user);\r\n        policyList[_policyId].status = PolicyStatus.CLAIMED;\r\n        emit PolicyClaimed(_policyId, _user);\r\n    }\r\n\r\n    /**\r\n     * @notice The payoff formula\r\n     * @param _delay Delay in minutes\r\n     * @return the final payoff volume\r\n     */\r\n    function calcPayoff(uint256 _delay) internal view returns (uint256) {\r\n        uint256 payoff = 0;\r\n\r\n        // payoff model 1 - linear\r\n        if (_delay <= DELAY_THRESHOLD_MIN) {\r\n            payoff = 0;\r\n        } else if (\r\n            _delay > DELAY_THRESHOLD_MIN && _delay <= DELAY_THRESHOLD_MAX\r\n        ) {\r\n            payoff = (_delay * _delay) / 480;\r\n        } else if (_delay > DELAY_THRESHOLD_MAX) {\r\n            payoff = MAX_PAYOFF;\r\n        }\r\n\r\n        payoff = payoff * 1e6;\r\n        return payoff;\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether the signature is valid\r\n     * @param signature 65 byte array: [[v (1)], [r (32)], [s (32)]]\r\n     * @param _flightNumber Flight number\r\n     * @param _address userAddress\r\n     * @param _premium Premium of the policy\r\n     * @param _deadline Deadline of the application\r\n     */\r\n    function _checkSignature(\r\n        bytes calldata signature,\r\n        string memory _flightNumber,\r\n        uint256 _departureTimestamp,\r\n        uint256 _landingDate,\r\n        address _address,\r\n        uint256 _premium,\r\n        uint256 _deadline\r\n    ) internal view {\r\n        sigManager.checkSignature(\r\n            signature,\r\n            _flightNumber,\r\n            _departureTimestamp,\r\n            _landingDate,\r\n            _address,\r\n            _premium,\r\n            _deadline\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/tokens/interfaces/IBuyerToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IBuyerToken is IERC20 {\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Functions ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Mint buyer tokens\r\n     * @param  _account Receiver's address\r\n     * @param  _amount Amount to be minted\r\n     */\r\n    function mintBuyerToken(address _account, uint256 _amount) external;\r\n\r\n    /**\r\n     * @notice Burn buyer tokens\r\n     * @param  _account Receiver's address\r\n     * @param  _amount Amount to be burned\r\n     */\r\n    function burnBuyerToken(address _account, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/miserable-flight/interfaces/ISigManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface ISigManager {\r\n    event SignerAdded(address indexed _newSigner);\r\n    event SignerRemoved(address indexed _oldSigner);\r\n\r\n    function addSigner(address) external;\r\n\r\n    function removeSigner(address) external;\r\n\r\n    function isValidSigner(address) external view returns (bool);\r\n\r\n    function checkSignature(\r\n        bytes calldata signature,\r\n        string memory _flightNumber,\r\n        uint256 _departureTimestamp,\r\n        uint256 _landingDate,\r\n        address _address,\r\n        uint256 _premium,\r\n        uint256 _deadline\r\n    ) external view;\r\n}\r\n"
    },
    "contracts/miserable-flight/interfaces/IFlightOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface IFlightOracle {\r\n    function newOracleRequest(\r\n        uint256 _payment,\r\n        string memory _url,\r\n        string memory _path,\r\n        int256 times\r\n    ) external returns (bytes32);\r\n\r\n    // Set a new url\r\n    function setURL(string memory _url) external;\r\n\r\n    // Set the oracle address\r\n    function setOracleAddress(address _newOracle) external;\r\n\r\n    // Set a new job id\r\n    function setJobId(bytes32 _newJobId) external;\r\n\r\n    // Set a new policy flow\r\n    function setPolicyFlow(address _policyFlow) external;\r\n\r\n    function getChainlinkTokenAddress() external view returns (address);\r\n}\r\n"
    },
    "contracts/miserable-flight/interfaces/IInsurancePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface IInsurancePool {\r\n    // view functions\r\n\r\n    function getUserBalance(address) external view returns (uint256);\r\n\r\n    function getPoolUnlocked() external view returns (uint256);\r\n\r\n    function getUnlockedFor(address _user) external view returns (uint256);\r\n\r\n    function getLockedFor(address _user) external view returns (uint256);\r\n\r\n    function checkCapacity(uint256 _payoff) external view returns (bool);\r\n\r\n    // set functions\r\n\r\n    function setPurchaseIncentive(uint256 _newIncentive) external;\r\n\r\n    function setFrozenTime(uint256 _newFrozenTime) external;\r\n\r\n    function setPolicyFlow(address _policyFlowAddress) external;\r\n\r\n    function setIncomeDistribution(uint256[3] memory _newDistribution) external;\r\n\r\n    function setCollateralFactor(uint256 _factor) external;\r\n\r\n    function transferOwnership(address _newOwner) external;\r\n\r\n    // main functions\r\n\r\n    function stake(address _user, uint256 _amount) external;\r\n\r\n    function unstake(uint256 _amount) external;\r\n\r\n    function unstakeMax() external;\r\n\r\n    function updateWhenBuy(\r\n        uint256 _premium,\r\n        uint256 _payoff,\r\n        address _user\r\n    ) external;\r\n\r\n    function updateWhenExpire(uint256 _premium, uint256 _payoff) external;\r\n\r\n    function payClaim(\r\n        uint256 _premium,\r\n        uint256 _payoff,\r\n        uint256 _realPayoff,\r\n        address _user\r\n    ) external;\r\n\r\n    function revertUnstakeRequest(address _user) external;\r\n\r\n    function revertAllUnstakeRequest(address _user) external;\r\n}\r\n"
    },
    "contracts/miserable-flight/abstracts/PolicyParameters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nabstract contract PolicyParameters {\r\n    // Product parameter\r\n    uint256 public constant PRODUCT_ID = 0;\r\n\r\n    // Parameters about the claim curve\r\n    uint256 public MAX_PAYOFF = 180 * 10**6;\r\n    uint256 public DELAY_THRESHOLD_MIN = 30;\r\n    uint256 public DELAY_THRESHOLD_MAX = 240;\r\n\r\n    // Minimum time before departure for applying\r\n    uint256 public MIN_TIME_BEFORE_DEPARTURE = 24 hours;\r\n}\r\n"
    },
    "contracts/libraries/StablecoinDecimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\nlibrary StablecoinDecimal {\r\n    function toNormal(uint256 _value) internal pure returns (uint256) {\r\n        uint256 decimal_difference = 1e12;\r\n        return _value / decimal_difference;\r\n    }\r\n\r\n    function toStablecoin(uint256 _value) internal pure returns (uint256) {\r\n        uint256 decimal_difference = 1e12;\r\n        return _value * decimal_difference;\r\n    }\r\n}\r\n"
    },
    "contracts/miserable-flight/FDPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport \"../utils/OwnableWithoutContext.sol\";\r\nimport \"../libraries/StringsUtils.sol\";\r\nimport \"./interfaces/IPolicyFlow.sol\";\r\nimport \"./interfaces/IPolicyStruct.sol\";\r\n\r\n/**\r\n * @title  Policy Token for flight delay\r\n * @notice ERC721 policy token\r\n *         Can get a long string form of the tokenURI\r\n *         When the ownership is transferred, it will update the status in policyFlow\r\n */\r\ncontract FDPolicyToken is\r\n    ERC721Enumerable,\r\n    IPolicyStruct,\r\n    OwnableWithoutContext\r\n{\r\n    using StringsUtils for uint256;\r\n    using StringsUtils for address;\r\n\r\n    // PolicyFlow contract interface\r\n    IPolicyFlow public policyFlow;\r\n\r\n    uint256 public _nextId;\r\n\r\n    struct PolicyTokenURIParam {\r\n        string flightNumber;\r\n        address owner;\r\n        uint256 premium;\r\n        uint256 payoff;\r\n        uint256 purchaseTimestamp;\r\n        uint256 departureTimestamp;\r\n        uint256 landingTimestamp;\r\n        uint256 status;\r\n    }\r\n\r\n    event PolicyFlowUpdated(address newPolicyFlow);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    constructor()\r\n        ERC721(\"Degis FlightDelay PolicyToken\", \"DEGIS_FD_PT\")\r\n        OwnableWithoutContext(msg.sender)\r\n    {\r\n        _nextId = 1;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get the tokenURI of a policy\r\n     * @param _tokenId Token Id of the policy token\r\n     * @return The tokenURI in string form\r\n     */\r\n    function tokenURI(uint256 _tokenId)\r\n        public\r\n        view\r\n        override(ERC721)\r\n        returns (string memory)\r\n    {\r\n        require(_tokenId < _nextId, \"TokenId is too large!\");\r\n        return _getTokenURI(_tokenId);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Set Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n       @notice Update the policyFlow address if it has been updated\r\n       @param _policyFlow New policyFlow contract address\r\n     */\r\n    function updatePolicyFlow(address _policyFlow) external onlyOwner {\r\n        policyFlow = IPolicyFlow(_policyFlow);\r\n        emit PolicyFlowUpdated(_policyFlow);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Main Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Mint a new policy token to an address\r\n     * @param _to The receiver address\r\n     */\r\n    function mintPolicyToken(address _to) public {\r\n        require(\r\n            _msgSender() == address(policyFlow),\r\n            \"Only the policyflow contract can mint fd policy token\"\r\n        );\r\n        uint256 tokenId = _nextId++;\r\n        _safeMint(_to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the owner of a policy token and update the information in policyFlow\r\n     * @dev Need approval and is prepared for secondary market\r\n     * @dev If you just transfer the policy token, you will not transfer the right for claiming payoff\r\n     * @param _from The original owner of the policy\r\n     * @param _to The new owner of the policy\r\n     * @param _tokenId Token id of the policy\r\n     */\r\n    function transferOwner(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) public {\r\n        safeTransferFrom(_from, _to, _tokenId);\r\n        policyFlow.policyOwnerTransfer(_tokenId, _from, _to);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get the tokenURI, the metadata is from policyFlow contract\r\n     * @param _tokenId Token Id of the policy token\r\n     */\r\n    function _getTokenURI(uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n        PolicyInfo memory info = policyFlow.getPolicyInfoById(_tokenId);\r\n\r\n        return\r\n            _constructTokenURI(\r\n                PolicyTokenURIParam(\r\n                    info.flightNumber,\r\n                    info.buyerAddress,\r\n                    info.premium,\r\n                    info.payoff,\r\n                    info.purchaseTimestamp,\r\n                    info.departureTimestamp,\r\n                    info.landingTimestamp,\r\n                    uint256(info.status)\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Construct the metadata of a specific policy token\r\n     * @param _params The parameters of the policy token\r\n     */\r\n    function _constructTokenURI(PolicyTokenURIParam memory _params)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        string[9] memory parts;\r\n\r\n        parts[0] = \"ProductId: 0, \";\r\n        parts[1] = string(\r\n            abi.encodePacked(\"FlightNumber: \", _params.flightNumber, \", \")\r\n        );\r\n        parts[2] = string(\r\n            abi.encodePacked(\r\n                \"BuyerAddress: \",\r\n                (_params.owner).addressToString(),\r\n                \", \"\r\n            )\r\n        );\r\n\r\n        parts[3] = string(\r\n            abi.encodePacked(\r\n                \"Premium: \",\r\n                (_params.premium / 1e18).uintToString(),\r\n                \", \"\r\n            )\r\n        );\r\n\r\n        parts[4] = string(\r\n            abi.encodePacked(\r\n                \"Payoff: \",\r\n                (_params.payoff / 1e18).uintToString(),\r\n                \", \"\r\n            )\r\n        );\r\n\r\n        parts[5] = string(\r\n            abi.encodePacked(\r\n                \"PurchaseTimestamp: \",\r\n                _params.purchaseTimestamp.uintToString(),\r\n                \", \"\r\n            )\r\n        );\r\n\r\n        parts[6] = string(\r\n            abi.encodePacked(\r\n                \"DepartureTimestamp:\",\r\n                _params.departureTimestamp.uintToString(),\r\n                \", \"\r\n            )\r\n        );\r\n\r\n        parts[7] = string(\r\n            abi.encodePacked(\r\n                \"LandingTimestamp: \",\r\n                (_params.landingTimestamp).uintToString(),\r\n                \", \"\r\n            )\r\n        );\r\n\r\n        parts[8] = string(\r\n            abi.encodePacked(\r\n                \"PolicyStatus: \",\r\n                _params.status.uintToString(),\r\n                \".\"\r\n            )\r\n        );\r\n\r\n        string memory output = string(\r\n            abi.encodePacked(\r\n                parts[0],\r\n                parts[1],\r\n                parts[2],\r\n                parts[3],\r\n                parts[4],\r\n                parts[5],\r\n                parts[6],\r\n                parts[7],\r\n                parts[8]\r\n            )\r\n        );\r\n        return output;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/miserable-flight/FlightOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\r\nimport \"./interfaces/IPolicyFlow.sol\";\r\nimport \"../utils/Ownable.sol\";\r\n\r\n/**\r\n * @title  Flight Oracle\r\n * @notice This is the flight oracle contract.\r\n *         Called by policyFlow contract and send the request to chainlink node.\r\n *         After receiving the result, call the policyFlow contract to do the settlement.\r\n * @dev    Remember to set the url, oracleAddress and jobId\r\n *         If there are multiple oracle providers in the future, this contract may need to be updated.\r\n */\r\ncontract FlightOracle is ChainlinkClient, Ownable {\r\n    using Chainlink for Chainlink.Request;\r\n\r\n    IPolicyFlow public policyFlow;\r\n\r\n    address public oracleAddress;\r\n    bytes32 public jobId;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event OracleAddressChanged(address newOracle);\r\n    event JobIdChanged(bytes32 newJobId);\r\n    event PolicyFlowChanged(address newPolicyFlow);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Need the address of LINK token on specific network\r\n     */\r\n    constructor(address _policyFlow, address _link) Ownable(msg.sender) {\r\n        policyFlow = IPolicyFlow(_policyFlow);\r\n\r\n        setChainlinkToken(_link);\r\n\r\n        oracleAddress = 0x7D9398979267a6E050FbFDFff953Fc612A5aD4C9;\r\n        jobId = \"bcc0a699531940479bc93cf9fa5afb3f\";\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Only the policyFlow can call some functions\r\n    modifier onlyPolicyFlow() {\r\n        require(\r\n            msg.sender == address(policyFlow),\r\n            \"Only the policyflow can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Returns the address of the LINK token\r\n     * @dev This is the public implementation for chainlinkTokenAddress, which is\r\n     *      an internal method of the ChainlinkClient contract\r\n     */\r\n    function getChainlinkTokenAddress() external view returns (address) {\r\n        return chainlinkTokenAddress();\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Set the oracle address\r\n     */\r\n    function setOracleAddress(address _newOracle) external onlyOwner {\r\n        oracleAddress = _newOracle;\r\n        emit OracleAddressChanged(_newOracle);\r\n    }\r\n\r\n    /**\r\n     * @notice Set a new job id\r\n     */\r\n    function setJobId(bytes32 _newJobId) external onlyOwner {\r\n        jobId = _newJobId;\r\n        emit JobIdChanged(_newJobId);\r\n    }\r\n\r\n    /**\r\n     * @notice Change the policy flow contract address\r\n     */\r\n    function setPolicyFlow(address _policyFlow) external onlyOwner {\r\n        policyFlow = IPolicyFlow(_policyFlow);\r\n        emit PolicyFlowChanged(_policyFlow);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Creates a request to the specified Oracle contract address\r\n     * @dev This function ignores the stored Oracle contract address and\r\n     *      will instead send the request to the address specified\r\n     * @param _payment Payment to the oracle\r\n     * @param _url The URL to fetch data from\r\n     * @param _path The dot-delimited path to parse of the response\r\n     * @param _times The number to multiply the result by\r\n     */\r\n    function newOracleRequest(\r\n        uint256 _payment,\r\n        string memory _url,\r\n        string memory _path,\r\n        int256 _times\r\n    ) public onlyPolicyFlow returns (bytes32) {\r\n        require(\r\n            oracleAddress != address(0) && jobId != 0,\r\n            \"Set the oracle address & jobId\"\r\n        );\r\n\r\n        // Enough LINK token for payment\r\n        require(\r\n            LinkTokenInterface(chainlinkTokenAddress()).balanceOf(\r\n                address(this)\r\n            ) >= _payment,\r\n            \"Insufficient LINK balance\"\r\n        );\r\n\r\n        Chainlink.Request memory req = buildChainlinkRequest(\r\n            jobId,\r\n            address(this),\r\n            this.fulfill.selector\r\n        );\r\n        req.add(\"url\", _url);\r\n        req.add(\"path\", _path);\r\n        req.addInt(\"times\", _times);\r\n        return sendChainlinkRequestTo(oracleAddress, req, _payment);\r\n    }\r\n\r\n    /**\r\n     * @notice The fulfill method from requests created by this contract\r\n     * @dev The recordChainlinkFulfillment protects this function from being called\r\n     *      by anyone other than the oracle address that the request was sent to\r\n     * @param _requestId The ID that was generated for the request\r\n     * @param _data The answer provided by the oracle\r\n     */\r\n    function fulfill(bytes32 _requestId, uint256 _data)\r\n        public\r\n        recordChainlinkFulfillment(_requestId)\r\n    {\r\n        policyFlow.finalSettlement(_requestId, _data);\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "contracts/libraries/StringsUtilsTester.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./StringsUtils.sol\";\r\n\r\ncontract StringsUtilsTester {\r\n    function byToString(bytes32 _bytes) public pure returns (string memory) {\r\n        return StringsUtils.byToString(_bytes);\r\n    }\r\n\r\n    function addressToString(address _addr)\r\n        public\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return StringsUtils.addressToString(_addr);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function uintToString(uint256 value) public pure returns (string memory) {\r\n        return StringsUtils.uintToString(value);\r\n    }\r\n\r\n    function uintToHexString(uint256 value)\r\n        public\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return StringsUtils.uintToHexString(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function uintToHexString(uint256 value, uint256 length)\r\n        public\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return StringsUtils.uintToHexString(value, length);\r\n    }\r\n}\r\n"
    },
    "contracts/chainlinkMock/VRFMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../utils/Ownable.sol\";\r\nimport \"../lucky-box/interfaces/IDegisLottery.sol\";\r\nimport \"../libraries/StringsUtils.sol\";\r\n\r\ncontract VRFMock is Ownable {\r\n    using StringsUtils for uint256;\r\n\r\n    IDegisLottery public DegisLottery;\r\n\r\n    uint256 public seed;\r\n\r\n    uint256 public randomResult;\r\n\r\n    uint256 public latestLotteryId;\r\n\r\n    constructor() Ownable(msg.sender) {}\r\n\r\n    /**\r\n     * @notice Set the address for the DegisLottery\r\n     * @param _degisLottery address of the PancakeSwap lottery\r\n     */\r\n    function setLotteryAddress(address _degisLottery) external onlyOwner {\r\n        DegisLottery = IDegisLottery(_degisLottery);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Request randomness from Chainlink VRF\r\n     */\r\n    function requestRandomWords() external {\r\n        require(\r\n            _msgSender() == address(DegisLottery) || _msgSender() == owner(),\r\n            \"Only DegisLottery\"\r\n        );\r\n\r\n        randomResult = (_rand(++seed) % 10000) + 10000;\r\n\r\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\r\n    }\r\n\r\n    function _rand(uint256 _input) internal pure returns (uint256) {\r\n        return _input * 12345;\r\n    }\r\n}\r\n"
    },
    "contracts/chainlinkMock/PriceFeedMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../utils/Ownable.sol\";\r\nimport \"../libraries/StringsUtils.sol\";\r\n\r\ncontract PriceFeedMock is Ownable {\r\n    using StringsUtils for uint256;\r\n\r\n    struct PriceFeedInfo {\r\n        address priceFeedAddress;\r\n        uint256 decimals;\r\n    }\r\n    // Use token name (string) as the mapping key\r\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\r\n\r\n    uint256 public roundId;\r\n\r\n    uint256 public result;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n    event PriceFeedChanged(\r\n        string tokenName,\r\n        address feedAddress,\r\n        uint256 decimals\r\n    );\r\n\r\n    event LatestPriceGet(uint256 roundID, uint256 price);\r\n\r\n    constructor() Ownable(msg.sender) {}\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Main Functions *********************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @dev For test, you can set the result you want\r\n     */\r\n    function setResult(uint256 _result) public {\r\n        result = _result;\r\n    }\r\n\r\n    /**\r\n     * @notice Get latest price of a token\r\n     * @param _tokenName Address of the token\r\n     * @return price The latest price\r\n     */\r\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\r\n        uint256 price = result;\r\n\r\n        // require(price > 0, \"Only accept price that > 0\");\r\n        if (price < 0) price = 0;\r\n\r\n        emit LatestPriceGet(roundId, price);\r\n\r\n        roundId += 1;\r\n\r\n        uint256 finalPrice = uint256(price);\r\n\r\n        return finalPrice;\r\n    }\r\n}\r\n"
    },
    "contracts/naughty-price/NaughtyRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\npragma solidity ^0.8.10;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {IBuyerToken} from \"../tokens/interfaces/IBuyerToken.sol\";\r\nimport {INaughtyPair} from \"./interfaces/INaughtyPair.sol\";\r\nimport {INaughtyFactory} from \"./interfaces/INaughtyFactory.sol\";\r\nimport {IPolicyCore} from \"./interfaces/IPolicyCore.sol\";\r\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport {IERC20Decimals} from \"../utils/interfaces/IERC20Decimals.sol\";\r\n\r\n/**\r\n * @title  NaughtyRouter\r\n * @notice Router for the pool, you can add/remove liquidity or swap A for B.\r\n *         Swapping fee rate is 2% and all of them are given to LP.\r\n *         Very similar logic with Uniswap V2.\r\n *\r\n */\r\ncontract NaughtyRouter is OwnableUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for INaughtyPair;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Some other contracts\r\n    address public factory;\r\n    address public policyCore;\r\n    address public buyerToken;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event PolicyCoreChanged(address oldPolicyCore, address newPolicyCore);\r\n\r\n    event BuyerTokenChanged(address oldBuyerToken, address newBuyerToken);\r\n\r\n    event LiquidityAdded(\r\n        address indexed pairAddress,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint256 liquidity\r\n    );\r\n\r\n    event LiquidityRemoved(\r\n        address indexed pairAddress,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        uint256 liquidity\r\n    );\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function initialize(address _factory, address _buyerToken)\r\n        public\r\n        initializer\r\n    {\r\n        __Ownable_init();\r\n\r\n        factory = _factory;\r\n        buyerToken = _buyerToken;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Transactions are available only before the deadline\r\n     * @param _deadLine Deadline of the pool\r\n     */\r\n    modifier beforeDeadline(uint256 _deadLine) {\r\n        if (msg.sender != INaughtyFactory(factory).incomeMaker()) {\r\n            require(block.timestamp < _deadLine, \"expired transaction\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Set the address of policyCore\r\n     * @param _coreAddress Address of new policyCore\r\n     */\r\n    function setPolicyCore(address _coreAddress) external onlyOwner {\r\n        emit PolicyCoreChanged(policyCore, _coreAddress);\r\n        policyCore = _coreAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address of buyer token\r\n     * @param _buyerToken Address of new buyer token\r\n     */\r\n    function setBuyerToken(address _buyerToken) external onlyOwner {\r\n        emit BuyerTokenChanged(buyerToken, _buyerToken);\r\n        buyerToken = _buyerToken;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address of factory\r\n     * @param _naughtyFactory Address of new naughty factory\r\n     */\r\n    function setNaughtyFactory(address _naughtyFactory) external onlyOwner {\r\n        emit BuyerTokenChanged(factory, _naughtyFactory);\r\n        factory = _naughtyFactory;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Helper Functions *********************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Add liquidity but only provide stablecoins\r\n     * @dev Only difference with addLiquidity is that mintPolicyTokenForUser\r\n     * @param _tokenA Address of policyToken\r\n     * @param _tokenB Address of stablecoin\r\n     * @param _amountADesired Amount of policyToken desired\r\n     * @param _amountBDesired Amount of stablecoin desired\r\n     * @param _amountAMin Minimum amount of policy token\r\n     * @param _amountBMin Minimum amount of stablecoin\r\n     * @param _to Address that receive the lp token, normally the user himself\r\n     * @param _deadline Transaction will revert after this deadline\r\n     */\r\n    function addLiquidityWithUSD(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    )\r\n        external\r\n        beforeDeadline(_deadline)\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        require(_checkStablecoin(_tokenB), \"Token B should be stablecoin\");\r\n\r\n        // Mint _amountADesired policy tokens for users\r\n        _mintPolicyTokensForUser(\r\n            _tokenA,\r\n            _tokenB,\r\n            _amountADesired,\r\n            _msgSender()\r\n        );\r\n\r\n        // Add liquidity\r\n        {\r\n            (amountA, amountB, liquidity) = addLiquidity(\r\n                _tokenA,\r\n                _tokenB,\r\n                _amountADesired,\r\n                _amountBDesired,\r\n                _amountAMin,\r\n                _amountBMin,\r\n                _to,\r\n                _deadline\r\n            );\r\n        }\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Add liquidity function\r\n     * @param _tokenA Address of policyToken\r\n     * @param _tokenB Address of stablecoin\r\n     * @param _amountADesired Amount of policyToken desired\r\n     * @param _amountBDesired Amount of stablecoin desired\r\n     * @param _amountAMin Minimum amoutn of policy token\r\n     * @param _amountBMin Minimum amount of stablecoin\r\n     * @param _to Address that receive the lp token, normally the user himself\r\n     * @param _deadline Transaction will revert after this deadline\r\n     * @return amountA Amount of tokenA to be input\r\n     * @return amountB Amount of tokenB to be input\r\n     * @return liquidity LP token to be mint\r\n     */\r\n    function addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    )\r\n        public\r\n        beforeDeadline(_deadline)\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        )\r\n    {\r\n        {\r\n            (amountA, amountB) = _addLiquidity(\r\n                _tokenA,\r\n                _tokenB,\r\n                _amountADesired,\r\n                _amountBDesired,\r\n                _amountAMin,\r\n                _amountBMin\r\n            );\r\n        }\r\n\r\n        address pair = INaughtyFactory(factory).getPairAddress(\r\n            _tokenA,\r\n            _tokenB\r\n        );\r\n\r\n        _transferHelper(_tokenA, _msgSender(), pair, amountA);\r\n        _transferHelper(_tokenB, _msgSender(), pair, amountB);\r\n\r\n        liquidity = INaughtyPair(pair).mint(_to);\r\n\r\n        emit LiquidityAdded(pair, amountA, amountB, liquidity);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool\r\n     * @param _tokenA Address of policy token\r\n     * @param _tokenB Address of stablecoin\r\n     * @param _liquidity The lptoken amount to be removed\r\n     * @param _amountAMin Minimum amount of tokenA given out\r\n     * @param _amountBMin Minimum amount of tokenB given out\r\n     * @param _to User address\r\n     * @param _deadline Deadline of this transaction\r\n     * @return amountA Amount of token0 given out\r\n     * @return amountB Amount of token1 given out\r\n     */\r\n    function removeLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    )\r\n        public\r\n        beforeDeadline(_deadline)\r\n        returns (uint256 amountA, uint256 amountB)\r\n    {\r\n        address pair = INaughtyFactory(factory).getPairAddress(\r\n            _tokenA,\r\n            _tokenB\r\n        );\r\n\r\n        INaughtyPair(pair).safeTransferFrom(_msgSender(), pair, _liquidity); // send liquidity to pair\r\n\r\n        // Amount0: insurance token\r\n        (amountA, amountB) = INaughtyPair(pair).burn(_to);\r\n\r\n        require(amountA >= _amountAMin, \"Insufficient insurance token amount\");\r\n        require(amountB >= _amountBMin, \"Insufficient USDT token\");\r\n\r\n        emit LiquidityRemoved(pair, amountA, amountB, _liquidity);\r\n    }\r\n\r\n    /**\r\n     * @notice Amount out is fixed\r\n     * @param _amountInMax Maximum token input\r\n     * @param _amountOut Fixed token output\r\n     * @param _tokenIn Address of input token\r\n     * @param _tokenOut Address of output token\r\n     * @param _to User address\r\n     * @param _deadline Deadline for this specific swap\r\n     * @return amountIn Amounts to be really put in\r\n     */\r\n    function swapTokensforExactTokens(\r\n        uint256 _amountInMax,\r\n        uint256 _amountOut,\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external beforeDeadline(_deadline) returns (uint256 amountIn) {\r\n        address pair = INaughtyFactory(factory).getPairAddress(\r\n            _tokenIn,\r\n            _tokenOut\r\n        );\r\n        require(\r\n            block.timestamp <= INaughtyPair(pair).deadline(),\r\n            \"This pool has been frozen for swapping\"\r\n        );\r\n\r\n        bool isBuying = _checkStablecoin(_tokenIn);\r\n\r\n        uint256 feeRate = INaughtyPair(pair).feeRate();\r\n\r\n        // Get how many tokens should be put in (the order depends on isBuying)\r\n        amountIn = _getAmountIn(\r\n            isBuying,\r\n            _amountOut,\r\n            _tokenIn,\r\n            _tokenOut,\r\n            feeRate\r\n        );\r\n\r\n        require(amountIn <= _amountInMax, \"excessive input amount\");\r\n\r\n        _transferHelper(_tokenIn, _msgSender(), pair, amountIn);\r\n\r\n        _swap(pair, _tokenIn, amountIn, _amountOut, isBuying, _to);\r\n    }\r\n\r\n    /**\r\n     * @notice Amount in is fixed\r\n     * @param _amountIn Fixed token input\r\n     * @param _amountOutMin Minimum token output\r\n     * @param _tokenIn Address of input token\r\n     * @param _tokenOut Address of output token\r\n     * @param _to User address\r\n     * @param _deadline Deadline for this specific swap\r\n     * @return amountOut Amounts to be really given out\r\n     */\r\n    function swapExactTokensforTokens(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external beforeDeadline(_deadline) returns (uint256 amountOut) {\r\n        address pair = INaughtyFactory(factory).getPairAddress(\r\n            _tokenIn,\r\n            _tokenOut\r\n        );\r\n        require(\r\n            block.timestamp <= INaughtyPair(pair).deadline(),\r\n            \"This pool has been frozen for swapping\"\r\n        );\r\n\r\n        // Check if the tokenIn is stablecoin\r\n        bool isBuying = _checkStablecoin(_tokenIn);\r\n\r\n        uint256 feeRate = INaughtyPair(pair).feeRate();\r\n\r\n        // Get how many tokens should be given out (the order depends on isBuying)\r\n        amountOut = _getAmountOut(\r\n            isBuying,\r\n            _amountIn,\r\n            _tokenIn,\r\n            _tokenOut,\r\n            feeRate\r\n        );\r\n        require(amountOut >= _amountOutMin, \"excessive output amount\");\r\n\r\n        _transferHelper(_tokenIn, _msgSender(), pair, _amountIn);\r\n\r\n        _swap(pair, _tokenIn, _amountIn, amountOut, isBuying, _to);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Internal function to finish adding liquidity\r\n     * @param _tokenA Address of tokenA\r\n     * @param _tokenB Address of tokenB\r\n     * @param _amountADesired Amount of tokenA to be added\r\n     * @param _amountBDesired Amount of tokenB to be added\r\n     * @param _amountAMin Minimum amount of tokenA\r\n     * @param _amountBMin Minimum amount of tokenB\r\n     * @return amountA Real amount of tokenA\r\n     * @return amountB Real amount of tokenB\r\n     */\r\n    function _addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin\r\n    ) private view returns (uint256 amountA, uint256 amountB) {\r\n        require(_checkStablecoin(_tokenB), \"Please put stablecoin as tokenB\");\r\n\r\n        (uint256 reserveA, uint256 reserveB) = _getReserves(_tokenA, _tokenB);\r\n\r\n        if (reserveA == 0 && reserveB == 0) {\r\n            (amountA, amountB) = (_amountADesired, _amountBDesired);\r\n        } else {\r\n            uint256 amountBOptimal = _quote(\r\n                _amountADesired,\r\n                reserveA,\r\n                reserveB\r\n            );\r\n            if (amountBOptimal <= _amountBDesired) {\r\n                require(amountBOptimal >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\r\n                (amountA, amountB) = (_amountADesired, amountBOptimal);\r\n            } else {\r\n                uint256 amountAOptimal = _quote(\r\n                    _amountBDesired,\r\n                    reserveB,\r\n                    reserveA\r\n                );\r\n                require(amountAOptimal <= _amountADesired, \"nonono\");\r\n                require(amountAOptimal >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\r\n                (amountA, amountB) = (amountAOptimal, _amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Finish the erc20 transfer operation\r\n     * @param _token ERC20 token address\r\n     * @param _from Address to give out the token\r\n     * @param _to Pair address to receive the token\r\n     * @param _amount Transfer amount\r\n     */\r\n    function _transferHelper(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal {\r\n        IERC20(_token).safeTransferFrom(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Finish swap process\r\n     * @param _pair Address of the pair\r\n     * @param _tokenIn Address of the input token\r\n     * @param _amountIn Amount of tokens put in\r\n     * @param _amountOut Amount of tokens get out\r\n     * @param _isBuying Whether this is a purchase or a sell\r\n     * @param _to Address of the user\r\n     */\r\n    function _swap(\r\n        address _pair,\r\n        address _tokenIn,\r\n        uint256 _amountIn,\r\n        uint256 _amountOut,\r\n        bool _isBuying,\r\n        address _to\r\n    ) internal {\r\n        // Only give buyer tokens when this is a purchase\r\n        if (_isBuying) {\r\n            // Check the decimals\r\n            uint256 decimals = IERC20Decimals(_tokenIn).decimals();\r\n            uint256 buyerTokenAmount = _amountIn * 10**(18 - decimals);\r\n            IBuyerToken(buyerToken).mintBuyerToken(\r\n                _msgSender(),\r\n                buyerTokenAmount\r\n            );\r\n        }\r\n\r\n        // If the user is buying policies => amount1Out = 0\r\n        // One of these two variables will be 0\r\n        uint256 amountAOut = _isBuying ? _amountOut : 0;\r\n        uint256 amountBOut = _isBuying ? 0 : _amountOut;\r\n\r\n        INaughtyPair(_pair).swap(amountAOut, amountBOut, _to);\r\n    }\r\n\r\n    /**\r\n     * @notice Used when users only provide stablecoins and want to mint & add liquidity in one step\r\n     * @dev Need have approval before (done by the user himself)\r\n     * @param _policyTokenAddress Address of the policy token\r\n     * @param _stablecoin Address of the stablecoin\r\n     * @param _amount Amount to be used for minting policy tokens\r\n     * @param _user The user's address\r\n     */\r\n    function _mintPolicyTokensForUser(\r\n        address _policyTokenAddress,\r\n        address _stablecoin,\r\n        uint256 _amount,\r\n        address _user\r\n    ) internal {\r\n        // Find the policy token name\r\n        string memory policyTokenName = IPolicyCore(policyCore)\r\n            .findNamebyAddress(_policyTokenAddress);\r\n\r\n        IPolicyCore(policyCore).delegateDeposit(\r\n            policyTokenName,\r\n            _stablecoin,\r\n            _amount,\r\n            _user\r\n        );\r\n    }\r\n\r\n    function _checkStablecoin(address _tokenAddress)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return IPolicyCore(policyCore).supportedStablecoin(_tokenAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Fetche the reserves for a pair\r\n     * @dev You need to sort the token order by yourself!\r\n     *      No matter your input order, the return value will always start with policy token reserve.\r\n     */\r\n    function _getReserves(address tokenA, address tokenB)\r\n        internal\r\n        view\r\n        returns (uint112 reserveA, uint112 reserveB)\r\n    {\r\n        address pairAddress = INaughtyFactory(factory).getPairAddress(\r\n            tokenA,\r\n            tokenB\r\n        );\r\n\r\n        // (Policy token reserve, stablecoin reserve)\r\n        (reserveA, reserveB) = INaughtyPair(pairAddress).getReserves();\r\n    }\r\n\r\n    /**\r\n     * @notice Used when swap exact tokens for tokens (in is fixed)\r\n     * @param isBuying Whether the user is buying policy tokens\r\n     * @param _amountIn Amount of tokens put in\r\n     * @param _tokenIn Address of the input token\r\n     * @param _tokenOut Address of the output token\r\n     */\r\n    function _getAmountOut(\r\n        bool isBuying,\r\n        uint256 _amountIn,\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _feeRate\r\n    ) internal view returns (uint256 amountOut) {\r\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\r\n            _tokenIn,\r\n            _tokenOut\r\n        );\r\n\r\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\r\n        // Get the right order\r\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\r\n            ? (reserveB, reserveA)\r\n            : (reserveA, reserveB);\r\n\r\n        require(_amountIn > 0, \"insufficient input amount\");\r\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient liquidity\");\r\n\r\n        uint256 amountInWithFee = _amountIn * (1000 - _feeRate);\r\n        uint256 numerator = amountInWithFee * (reserveOut);\r\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\r\n\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    /**\r\n     * @notice Used when swap tokens for exact tokens (out is fixed)\r\n     * @param isBuying Whether the user is buying policy tokens\r\n     * @param _amountOut Amount of tokens given out\r\n     * @param _tokenIn Address of the input token\r\n     * @param _tokenOut Address of the output token\r\n     */\r\n    function _getAmountIn(\r\n        bool isBuying,\r\n        uint256 _amountOut,\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        uint256 _feeRate\r\n    ) internal view returns (uint256 amountIn) {\r\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\r\n            _tokenIn,\r\n            _tokenOut\r\n        );\r\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\r\n        // Get the right order\r\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\r\n            ? (reserveB, reserveA)\r\n            : (reserveA, reserveB);\r\n\r\n        require(_amountOut > 0, \"insufficient output amount\");\r\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient liquidity\");\r\n\r\n        uint256 numerator = reserveIn * (_amountOut) * 1000;\r\n        uint256 denominator = (reserveOut - _amountOut) * (1000 - _feeRate);\r\n\r\n        amountIn = numerator / denominator + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Given some amount of an asset and pair reserves\r\n     *         returns an equivalent amount of the other asset\r\n     * @dev Used when add or remove liquidity\r\n     * @param _amountA Amount of tokenA ( can be policytoken or stablecoin)\r\n     * @param _reserveA Reserve of tokenA\r\n     * @param _reserveB Reserve of tokenB\r\n     */\r\n    function _quote(\r\n        uint256 _amountA,\r\n        uint256 _reserveA,\r\n        uint256 _reserveB\r\n    ) internal pure returns (uint256 amountB) {\r\n        require(_amountA > 0, \"insufficient amount\");\r\n        require(_reserveA > 0 && _reserveB > 0, \"insufficient liquidity\");\r\n\r\n        amountB = (_amountA * _reserveB) / _reserveA;\r\n    }\r\n}\r\n"
    },
    "contracts/naughty-price/interfaces/INaughtyPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface INaughtyPair is IERC20 {\r\n    function initialize(\r\n        address _token0,\r\n        address _token1,\r\n        uint256 _deadline,\r\n        uint256 _feeRate\r\n    ) external;\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function feeRate() external view returns (uint256);\r\n\r\n    function deadline() external view returns (uint256);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 _reserve0, uint112 _reserve1);\r\n\r\n    function swap(\r\n        uint256,\r\n        uint256,\r\n        address\r\n    ) external;\r\n\r\n    function burn(address) external returns (uint256, uint256);\r\n\r\n    function mint(address) external returns (uint256);\r\n\r\n    function sync() external;\r\n}\r\n"
    },
    "contracts/naughty-price/interfaces/IPolicyCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface IPolicyCore {\r\n    struct PolicyTokenInfo {\r\n        address policyTokenAddress;\r\n        bool isCall;\r\n        uint256 nameDecimals; // decimals of the name generation\r\n        uint256 tokenDecimals; // decimals of the policy token\r\n        uint256 strikePrice;\r\n        uint256 deadline;\r\n        uint256 settleTimestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Find the address by its name\r\n     */\r\n    function findAddressbyName(string memory _policyTokenName)\r\n        external\r\n        view\r\n        returns (address _policyTokenAddress);\r\n\r\n    /**\r\n     * @notice Find the name by address\r\n     */\r\n    function findNamebyAddress(address _policyTokenAddress)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    /**\r\n     * @notice Check whether the stablecoin is supported\r\n     */\r\n    function supportedStablecoin(address _coinAddress)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function delegateDeposit(\r\n        string memory _policyTokenName,\r\n        address _stablecoin,\r\n        uint256 _amount,\r\n        address _user\r\n    ) external;\r\n\r\n    function deployPool(\r\n        string memory _policyTokenName,\r\n        address _stablecoin,\r\n        uint256 _poolDeadline,\r\n        uint256 _feeRate\r\n    ) external returns (address);\r\n\r\n    function getPolicyTokenInfo(string memory _policyTokenName)\r\n        external\r\n        view\r\n        returns (PolicyTokenInfo memory);\r\n\r\n    function updateUserQuota(\r\n        address _user,\r\n        address _policyToken,\r\n        uint256 _amount\r\n    ) external;\r\n}\r\n"
    },
    "contracts/ILM/NaughtyPriceILM.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { IERC20Decimals } from \"../utils/interfaces/IERC20Decimals.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport { IPolicyCore } from \"../naughty-price/interfaces/IPolicyCore.sol\";\r\nimport { INaughtyRouter } from \"../naughty-price/interfaces/INaughtyRouter.sol\";\r\nimport { INaughtyPair } from \"../naughty-price/interfaces/INaughtyPair.sol\";\r\nimport { ILMToken as LPToken } from \"./ILMToken.sol\";\r\n\r\n/**\r\n * @title Naughty Price Initial Liquidity Matching\r\n * @notice Naughty Price timeline: 1 -- 14 -- 5\r\n *         The first day of each round would be the time for liquidity matching\r\n *         User\r\n *           - Select the naughty token\r\n *           - Provide stablecoins into this contract & Select your price choice\r\n *           - Change the amountA and amountB of this pair\r\n *         When reach deadline\r\n *           - Final price of ILM = Initial price of naughty price pair = amountA/amountB\r\n */\r\ncontract NaughtyPriceILM is OwnableUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constants **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Scale when calculating fee\r\n    uint256 public constant SCALE = 1e12;\r\n\r\n    // Degis entrance fee = 1 / 100 deposit amount\r\n    uint256 public constant FEE_DENOMINATOR = 100;\r\n\r\n    // Minimum deposit amount\r\n    uint256 public constant MINIMUM_AMOUNT = 1e6;\r\n\r\n    // Uint256 maximum value\r\n    uint256 public constant MAX_UINT256 = type(uint256).max;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Degis token address\r\n    address public degis;\r\n\r\n    // PolicyCore, Router and EmergencyPool contract address\r\n    address public policyCore;\r\n    address public router;\r\n    address public emergencyPool;\r\n\r\n    struct UserInfo {\r\n        uint256 amountA;\r\n        uint256 amountB;\r\n        uint256 degisDebt;\r\n    }\r\n    // user address => policy token address => user info\r\n    mapping(address => mapping(address => UserInfo)) public users;\r\n\r\n    // Status of an ILM round\r\n    enum Status {\r\n        BeforeStart,\r\n        Active,\r\n        Finished,\r\n        Stopped\r\n    }\r\n\r\n    struct PairInfo {\r\n        Status status; // 0: before start 1: active 2: finished 3: stopped\r\n        address lptoken; // lptoken address\r\n        uint256 ILMDeadline; // deadline for initial liquidity matching\r\n        address stablecoin; // stablecoin address\r\n        uint256 amountA; // Amount of policy tokens\r\n        uint256 amountB; // Amount of stablecoins\r\n        address naughtyPairAddress; // Naughty pair address deployed when finished ILM\r\n        // degis paid as fee\r\n        uint256 degisAmount;\r\n        uint256 accDegisPerShare;\r\n    }\r\n    // Policy Token Address => Pair Info\r\n    mapping(address => PairInfo) public pairs;\r\n\r\n    mapping(address => uint256) public endPrice;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event Deposit(\r\n        address indexed policyToken,\r\n        address indexed stablecoin,\r\n        uint256 amountA,\r\n        uint256 amountB\r\n    );\r\n    event Withdraw(\r\n        address indexed policyToken,\r\n        address indexed stablecoin,\r\n        address indexed user,\r\n        uint256 amountA,\r\n        uint256 amountB\r\n    );\r\n    event EmergencyWithdraw(address owner, uint256 amount);\r\n    event ILMFinish(\r\n        address policyToken,\r\n        address stablecoin,\r\n        address poolAddress,\r\n        uint256 amountA,\r\n        uint256 amountB\r\n    );\r\n    event ILMStart(\r\n        address policyToken,\r\n        address stablecoin,\r\n        uint256 deadline,\r\n        address lptokenAddress\r\n    );\r\n    event Harvest(address user, uint256 reward);\r\n    event Claim(address user, uint256 amountA, uint256 amountB);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Errors ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    error ILM__WrongILMDeadline();\r\n    error ILM__ZeroAddress();\r\n    error ILM__RoundOver();\r\n    error ILM__PairNotActive();\r\n    error ILM__RoundNotOver();\r\n    error ILM__ZeroAmount();\r\n    error ILM__NotActiveILM();\r\n    error ILM__StablecoinNotPaired();\r\n    error ILM__StablecoinNotSupport();\r\n    error ILM__NoDeposit();\r\n    error ILM__NotEnoughDeposit();\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Initialze function for proxy\r\n     * @dev Called only when deploying proxy contract\r\n     * @param _degis Degis token address\r\n     * @param _policyCore PolicyCore contract address\r\n     * @param _router NaughtyRouter contract address\r\n     * @param _emergencyPool EmergencyPool contract address\r\n     */\r\n    function initialize(\r\n        address _degis,\r\n        address _policyCore,\r\n        address _router,\r\n        address _emergencyPool\r\n    ) public initializer {\r\n        if (_policyCore == address(0) || _router == address(0))\r\n            revert ILM__ZeroAddress();\r\n\r\n        __Ownable_init();\r\n\r\n        degis = _degis;\r\n        policyCore = _policyCore;\r\n        router = _router;\r\n\r\n        emergencyPool = _emergencyPool;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Check whether a pair is active\r\n     * @param _policyToken Policy token address\r\n     */\r\n    modifier activePair(address _policyToken) {\r\n        if (pairs[_policyToken].status != Status.Active)\r\n            revert ILM__PairNotActive();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether is during ILM\r\n     * @param _policyToken Policy token address\r\n     */\r\n    modifier duringILM(address _policyToken) {\r\n        if (block.timestamp > pairs[_policyToken].ILMDeadline)\r\n            revert ILM__RoundOver();\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get the current price\r\n     * @dev Price has a scale of 1e12\r\n     * @param _policyToken Policy token address\r\n     * @return price Price of the token pair\r\n     */\r\n    function getPrice(address _policyToken) external view returns (uint256) {\r\n        uint256 amountA = pairs[_policyToken].amountA;\r\n        uint256 amountB = pairs[_policyToken].amountB;\r\n        return (amountB * SCALE) / amountA;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total amount of a pair\r\n     * @param _policyToken Policy token address\r\n     * @return totalAmount Total amount of a pair\r\n     */\r\n    function getPairTotalAmount(address _policyToken)\r\n        external\r\n        view\r\n        returns (uint256 totalAmount)\r\n    {\r\n        totalAmount = pairs[_policyToken].amountA + pairs[_policyToken].amountB;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the amount of user's deposit\r\n     * @param _user User address\r\n     * @param _policyToken Policy token address\r\n     */\r\n    function getUserDeposit(address _user, address _policyToken)\r\n        external\r\n        view\r\n        returns (uint256 amountA, uint256 amountB)\r\n    {\r\n        amountA = users[_user][_policyToken].amountA;\r\n        amountB = users[_user][_policyToken].amountB;\r\n    }\r\n\r\n    /**\r\n     * @notice Emergency stop ILM\r\n     * @param _policyToken Policy token address to be stopped\r\n     */\r\n    function emergencyStop(address _policyToken) external onlyOwner {\r\n        pairs[_policyToken].status = Status.Stopped;\r\n    }\r\n\r\n    /**\r\n     * @notice Emergency restart ILM\r\n     * @param _policyToken Policy token address to be restarted\r\n     */\r\n    function emergencyRestart(address _policyToken) external onlyOwner {\r\n        pairs[_policyToken].status = Status.Active;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Start a new ILM round\r\n     * @dev A new lp token will be deployed when starting a new ILM round\r\n     *      It will have a special farming reward pool\r\n     * @param _policyToken Policy token address\r\n     * @param _stablecoin Stablecoin address\r\n     * @param _ILMDeadline Deadline of ILM period\r\n     */\r\n    function startILM(\r\n        address _policyToken,\r\n        address _stablecoin,\r\n        uint256 _ILMDeadline\r\n    ) external onlyOwner {\r\n        // Get policy token name & Check if this policy token exists\r\n        // The check is inside policy core contract\r\n        string memory policyTokenName = IPolicyCore(policyCore)\r\n            .findNamebyAddress(_policyToken);\r\n\r\n        // Check if the stablecoin is supported\r\n        bool isSupported = IPolicyCore(policyCore).supportedStablecoin(\r\n            _stablecoin\r\n        );\r\n        if (!isSupported) revert ILM__StablecoinNotSupport();\r\n\r\n        // The deadline for ILM can not be later than the policy token deadline\r\n        uint256 policyTokenDeadline = (\r\n            IPolicyCore(policyCore).getPolicyTokenInfo(policyTokenName)\r\n        ).deadline;\r\n        if (_ILMDeadline >= policyTokenDeadline) revert ILM__WrongILMDeadline();\r\n\r\n        PairInfo storage pair = pairs[_policyToken];\r\n        // Update the status\r\n        pair.status = Status.Active;\r\n        pair.stablecoin = _stablecoin;\r\n        pair.ILMDeadline = _ILMDeadline;\r\n\r\n        // Deploy a new ERC20 LP Token\r\n        string memory LPTokenName = string(\r\n            abi.encodePacked(\"ILM-\", policyTokenName)\r\n        );\r\n        address lpTokenAddress = _deployLPToken(LPTokenName);\r\n\r\n        // Record the lptoken address\r\n        pair.lptoken = lpTokenAddress;\r\n\r\n        // Pre-approve the stablecoin for later deposit\r\n        IERC20(_policyToken).approve(router, MAX_UINT256);\r\n\r\n        emit ILMStart(_policyToken, _stablecoin, _ILMDeadline, lpTokenAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Finish a round of ILM\r\n     * @dev The swap pool for the protection token will be deployed with inital liquidity\\\r\n     *      The amount of initial liquidity will be the total amount of the pair\r\n     *      Can be called by any address\r\n     * @param _policyToken Policy token address\r\n     * @param _deadlineForSwap Pool deadline\r\n     * @param _feeRate Fee rate of the swap pool\r\n     */\r\n    function finishILM(\r\n        address _policyToken,\r\n        uint256 _deadlineForSwap,\r\n        uint256 _feeRate\r\n    ) external activePair(_policyToken) {\r\n        PairInfo memory pair = pairs[_policyToken];\r\n\r\n        // Pair status is 1 and passed deadline => can finish ILM\r\n        if (block.timestamp <= pair.ILMDeadline) revert ILM__RoundNotOver();\r\n        if (pair.amountA + pair.amountB == 0) revert ILM__NoDeposit();\r\n\r\n        // Update the status of this pair\r\n        pairs[_policyToken].status = Status.Finished;\r\n\r\n        // Get policy token name\r\n        string memory policyTokenName = IPolicyCore(policyCore)\r\n            .findNamebyAddress(_policyToken);\r\n\r\n        // Deploy a new pool and return the pool address\r\n        address poolAddress = IPolicyCore(policyCore).deployPool(\r\n            policyTokenName,\r\n            pair.stablecoin,\r\n            _deadlineForSwap,\r\n            _feeRate // maximum = 1000 = 100%\r\n        );\r\n        pairs[_policyToken].naughtyPairAddress = poolAddress;\r\n\r\n        // Approval prepration for withdraw liquidity\r\n        INaughtyPair(poolAddress).approve(router, MAX_UINT256);\r\n\r\n        // Add initial liquidity to the pool\r\n        // Zero slippage\r\n        INaughtyRouter(router).addLiquidityWithUSD(\r\n            _policyToken,\r\n            pair.stablecoin,\r\n            pair.amountA,\r\n            pair.amountB,\r\n            pair.amountA,\r\n            pair.amountB,\r\n            address(this),\r\n            block.timestamp + 60\r\n        );\r\n\r\n        emit ILMFinish(\r\n            _policyToken,\r\n            pair.stablecoin,\r\n            poolAddress,\r\n            pair.amountA,\r\n            pair.amountB\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit stablecoin and choose the price\r\n     * @dev Deposit only check the pair status not the deadline\r\n     *      There may be a zero ILM and we still need to deposit some asset to make it start\r\n     *      Anyone wants to enter ILM need to pay some DEG as entrance fee\r\n     *      The ratio is 100:1(usd:deg) and your fee is distributed to the users prior to you\r\n     * @param _policyToken Policy token address\r\n     * @param _stablecoin Stablecoin address\r\n     * @param _amountA Amount of policy token (virtual)\r\n     * @param _amountB Amount of stablecoin (virtual)\r\n     */\r\n    function deposit(\r\n        address _policyToken,\r\n        address _stablecoin,\r\n        uint256 _amountA,\r\n        uint256 _amountB\r\n    ) external activePair(_policyToken) {\r\n        if (_amountA + _amountB < MINIMUM_AMOUNT) revert ILM__ZeroAmount();\r\n        if (_stablecoin != pairs[_policyToken].stablecoin)\r\n            revert ILM__StablecoinNotPaired();\r\n\r\n        uint256 amountToDeposit = _amountA + _amountB;\r\n\r\n        // Every 100usd pay 1 degis\r\n        uint256 decimalDiff = 18 - IERC20Decimals(_stablecoin).decimals();\r\n        uint256 degisToPay = (amountToDeposit * 10**decimalDiff) /\r\n            FEE_DENOMINATOR;\r\n\r\n        // Update the info about deg entrance fee when deposit\r\n        _updateWhenDeposit(\r\n            _policyToken,\r\n            amountToDeposit,\r\n            degisToPay,\r\n            decimalDiff\r\n        );\r\n\r\n        PairInfo storage pair = pairs[_policyToken];\r\n        UserInfo storage user = users[msg.sender][_policyToken];\r\n\r\n        // Update deg record and transfer degis token\r\n        pair.degisAmount += degisToPay;\r\n        IERC20(degis).safeTransferFrom(msg.sender, address(this), degisToPay);\r\n\r\n        // Update the status\r\n        pair.amountA += _amountA;\r\n        pair.amountB += _amountB;\r\n        user.amountA += _amountA;\r\n        user.amountB += _amountB;\r\n\r\n        // Transfer tokens\r\n        IERC20(_stablecoin).safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amountToDeposit\r\n        );\r\n\r\n        // Distribute the lptoken\r\n        address lpToken = pairs[_policyToken].lptoken;\r\n        LPToken(lpToken).mint(msg.sender, amountToDeposit);\r\n\r\n        emit Deposit(_policyToken, _stablecoin, _amountA, _amountB);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw stablecoins\r\n     * @dev Only checks the status not the deadline\r\n     * @param _policyToken Policy token address\r\n     * @param _stablecoin Stablecoin address\r\n     * @param _amountA Amount of policy token (virtual)\r\n     * @param _amountB Amount of stablecoin (virtual)\r\n     */\r\n    function withdraw(\r\n        address _policyToken,\r\n        address _stablecoin,\r\n        uint256 _amountA,\r\n        uint256 _amountB\r\n    ) public activePair(_policyToken) {\r\n        UserInfo memory currentUserInfo = users[msg.sender][_policyToken];\r\n\r\n        // Check if the user has enough tokens to withdraw\r\n        if (currentUserInfo.amountA + currentUserInfo.amountB == 0)\r\n            revert ILM__NoDeposit();\r\n        if (\r\n            _amountA > currentUserInfo.amountA ||\r\n            _amountB > currentUserInfo.amountB\r\n        ) revert ILM__NotEnoughDeposit();\r\n\r\n        PairInfo storage pair = pairs[_policyToken];\r\n        UserInfo storage user = users[msg.sender][_policyToken];\r\n\r\n        // Update status when withdraw\r\n        uint256 degisToWithdraw = (pair.accDegisPerShare *\r\n            (currentUserInfo.amountA + currentUserInfo.amountB)) /\r\n            SCALE -\r\n            currentUserInfo.degisDebt;\r\n\r\n        if (degisToWithdraw > 0) {\r\n            // Degis will be withdrawed to emergency pool, not the user\r\n            uint256 reward = _safeTokenTransfer(\r\n                degis,\r\n                emergencyPool,\r\n                degisToWithdraw\r\n            );\r\n            emit Harvest(emergencyPool, reward);\r\n        }\r\n\r\n        // Update the user's amount and pool's amount\r\n        pair.amountA -= _amountA;\r\n        pair.amountB -= _amountB;\r\n        user.amountA -= _amountA;\r\n        user.amountB -= _amountB;\r\n\r\n        uint256 amountToWithdraw = _amountA + _amountB;\r\n\r\n        // Withdraw stablecoins to the user\r\n        _safeTokenTransfer(_stablecoin, msg.sender, amountToWithdraw);\r\n\r\n        // Burn the lptokens\r\n        LPToken(pair.lptoken).burn(msg.sender, amountToWithdraw);\r\n\r\n        // Update the user debt\r\n        user.degisDebt =\r\n            ((user.amountA + user.amountB) * pair.accDegisPerShare) /\r\n            SCALE;\r\n\r\n        emit Withdraw(\r\n            _policyToken,\r\n            _stablecoin,\r\n            msg.sender,\r\n            _amountA,\r\n            _amountB\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all stablecoins of a certain policy token\r\n     * @param _policyToken Policy token address\r\n     * @param _stablecoin Stablecoin address\r\n     */\r\n    function withdrawAll(address _policyToken, address _stablecoin) external {\r\n        uint256 amounAMax = users[msg.sender][_policyToken].amountA;\r\n        uint256 amounBMax = users[msg.sender][_policyToken].amountB;\r\n\r\n        withdraw(_policyToken, _stablecoin, amounAMax, amounBMax);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim liquidity back\r\n     * @dev You will get back some DEG (depending on how many users deposit after you)\r\n     *      The claim amount is determined by the LP Token balance of you (you can buy from others)\r\n     *      But the DEG reward would only be got once\r\n     *      Your LP token will be burnt and you can not join ILM farming pool again\r\n     * @param _policyToken Policy token address\r\n     * @param _stablecoin Stablecoin address\r\n     * @param _amountAMin Minimum amount of policy token (slippage)\r\n     * @param _amountBMin Minimum amount of stablecoin (slippage)\r\n     */\r\n    function claim(\r\n        address _policyToken,\r\n        address _stablecoin,\r\n        uint256 _amount,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin\r\n    ) external {\r\n        if (_amount == 0) revert ILM__ZeroAmount();\r\n\r\n        PairInfo storage pair = pairs[_policyToken];\r\n\r\n        address lptoken = pair.lptoken;\r\n\r\n        uint256 lpBalance = LPToken(lptoken).balanceOf(msg.sender);\r\n        uint256 lpToClaim = _amount > lpBalance ? lpBalance : _amount;\r\n\r\n        // Total liquidity owned by the pool\r\n        uint256 totalLiquidity = INaughtyPair(pair.naughtyPairAddress)\r\n            .balanceOf(address(this));\r\n\r\n        uint256 lpTotalSupply = LPToken(lptoken).totalSupply();\r\n\r\n        // User's liquidity amount\r\n        uint256 userLiquidity = (lpToClaim * totalLiquidity) / lpTotalSupply;\r\n\r\n        _updateWhenClaim(_policyToken);\r\n\r\n        {\r\n            // Remove liquidity\r\n            (\r\n                uint256 policyTokenAmount,\r\n                uint256 stablecoinAmount\r\n            ) = INaughtyRouter(router).removeLiquidity(\r\n                    _policyToken,\r\n                    _stablecoin,\r\n                    userLiquidity,\r\n                    _amountAMin,\r\n                    _amountBMin,\r\n                    msg.sender,\r\n                    block.timestamp + 60\r\n                );\r\n\r\n            emit Claim(msg.sender, policyTokenAmount, stablecoinAmount);\r\n        }\r\n\r\n        IPolicyCore(policyCore).updateUserQuota(\r\n            msg.sender,\r\n            _policyToken,\r\n            (pair.amountA * lpToClaim) / (pair.amountA + pair.amountB)\r\n        );\r\n\r\n        // Burn the user's lp tokens\r\n        LPToken(lptoken).burn(msg.sender, lpToClaim);\r\n    }\r\n\r\n    /**\r\n     * @notice Emergency withdraw a certain token\r\n     * @param _token Token address\r\n     * @param _amount Token amount\r\n     */\r\n    function emergencyWithdraw(address _token, uint256 _amount) external {\r\n        IERC20(_token).safeTransfer(owner(), _amount);\r\n\r\n        emit EmergencyWithdraw(owner(), _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Approve stablecoins for naughty price contracts\r\n     * @param _stablecoin Stablecoin address\r\n     */\r\n    function approveStablecoin(address _stablecoin) external {\r\n        IERC20(_stablecoin).approve(router, MAX_UINT256);\r\n        IERC20(_stablecoin).approve(policyCore, MAX_UINT256);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Deploy the new lp token for a round\r\n     * @param _name Name of the lp token\r\n     * @return lpTokenAddress Address of the lp token\r\n     */\r\n    function _deployLPToken(string memory _name) internal returns (address) {\r\n        address lpTokenAddress = address(\r\n            new LPToken(address(this), _name, _name)\r\n        );\r\n        return lpTokenAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Safely transfer tokens\r\n     * @param _token Token address\r\n     * @param _receiver Receiver address\r\n     * @param _amount Amount of tokens\r\n     * @return realAmount Real amount that is transferred\r\n     */\r\n    function _safeTokenTransfer(\r\n        address _token,\r\n        address _receiver,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        uint256 balance = IERC20(_token).balanceOf(address(this));\r\n\r\n        if (_amount > balance) {\r\n            IERC20(_token).safeTransfer(_receiver, balance);\r\n            return balance;\r\n        } else {\r\n            IERC20(_token).safeTransfer(_receiver, _amount);\r\n            return _amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update debt & fee distribution\r\n     * @param _policyToken Policy token address\r\n     * @param _usdAmount Amount of stablecoins input\r\n     * @param _degAmount Amount of degis input\r\n     */\r\n    function _updateWhenDeposit(\r\n        address _policyToken,\r\n        uint256 _usdAmount,\r\n        uint256 _degAmount,\r\n        uint256 _decimalDiff\r\n    ) internal {\r\n        PairInfo storage pair = pairs[_policyToken];\r\n\r\n        // If this is the first user, accDegisPerShare = 1e16\r\n        // No debt\r\n        if (pair.degisAmount == 0) {\r\n            pair.accDegisPerShare =\r\n                (SCALE * 10**_decimalDiff) /\r\n                FEE_DENOMINATOR;\r\n            return;\r\n        }\r\n\r\n        UserInfo storage user = users[msg.sender][_policyToken];\r\n\r\n        // Update accDegisPerShare first\r\n        pair.accDegisPerShare +=\r\n            (_degAmount * SCALE) /\r\n            ((pair.amountA + pair.amountB));\r\n\r\n        uint256 currentUserDeposit = user.amountA + user.amountB;\r\n        // If user has deposited before, distribute the deg reward first\r\n        // Pending reward is calculated with the new degisPerShare value\r\n        if (currentUserDeposit > 0) {\r\n            uint256 pendingReward = (currentUserDeposit *\r\n                pair.accDegisPerShare) /\r\n                SCALE -\r\n                user.degisDebt;\r\n\r\n            uint256 reward = _safeTokenTransfer(\r\n                degis,\r\n                msg.sender,\r\n                pendingReward\r\n            );\r\n            emit Harvest(msg.sender, reward);\r\n        }\r\n\r\n        // Update user debt\r\n        user.degisDebt =\r\n            (pair.accDegisPerShare * (currentUserDeposit + _usdAmount)) /\r\n            SCALE;\r\n    }\r\n\r\n    /**\r\n     * @notice Update degis reward when claim\r\n     * @param _policyToken Policy token address\r\n     */\r\n    function _updateWhenClaim(address _policyToken) internal {\r\n        uint256 accDegisPerShare = pairs[_policyToken].accDegisPerShare;\r\n\r\n        UserInfo storage user = users[msg.sender][_policyToken];\r\n\r\n        uint256 userTotalDeposit = user.amountA + user.amountB;\r\n\r\n        uint256 pendingReward = (userTotalDeposit * accDegisPerShare) /\r\n            SCALE -\r\n            user.degisDebt;\r\n\r\n        if (pendingReward > 0) {\r\n            // Update debt\r\n            // Only get deg back when first time claim\r\n            user.degisDebt = (userTotalDeposit * accDegisPerShare) / SCALE;\r\n\r\n            uint256 reward = _safeTokenTransfer(\r\n                degis,\r\n                msg.sender,\r\n                pendingReward\r\n            );\r\n            emit Harvest(msg.sender, reward);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/naughty-price/interfaces/INaughtyRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.10;\r\n\r\ninterface INaughtyRouter {\r\n    function addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityWithUSD(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function removeLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function swapExactTokensforTokens(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _tokenIn,\r\n        address _tokenOut,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 amountOut);\r\n}\r\n"
    },
    "contracts/ILM/ILMToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract ILMToken is ERC20 {\r\n    address public ILMContract;\r\n\r\n    constructor(\r\n        address _ILM,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) ERC20(_name, _symbol) {\r\n        ILMContract = _ILM;\r\n    }\r\n\r\n    modifier onlyILM() {\r\n        require(msg.sender == ILMContract, \"Only ILM\");\r\n        _;\r\n    }\r\n\r\n    function mint(address _to, uint256 _amount) public onlyILM {\r\n        _mint(_to, _amount);\r\n    }\r\n\r\n    function burn(address _to, uint256 _amount) public onlyILM {\r\n        _burn(_to, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/naughty-price/NaughtyPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport {Math} from \"../libraries/Math.sol\";\r\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {ReentrancyGuard} from \"../utils/ReentrancyGuard.sol\";\r\nimport {INaughtyFactory} from \"./interfaces/INaughtyFactory.sol\";\r\n\r\n/**\r\n * @title  Naughty Pair\r\n * @notice This is the contract for the naughtyPrice swapping pair.\r\n *         Every time a new naughtyPrice product is online you need to deploy this contract.\r\n *         The contract will be initialized with two tokens and a deadline.\r\n *         Token0 will be policy tokens and token1 will be stablecoins.\r\n *         The swaps are only availale before the deadline.\r\n */\r\ncontract NaughtyPair is ERC20(\"Naughty Pool LP\", \"NLP\"), ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Minimum liquidity locked\r\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\r\n\r\n    // naughtyFactory contract address\r\n    address public factory;\r\n\r\n    // Token addresses in the pool\r\n    address public token0; // Insurance Token\r\n    address public token1; // USDT\r\n\r\n    uint112 private reserve0; // Amount of Insurance Token\r\n    uint112 private reserve1; // Amount of USDT\r\n\r\n    // Used for modifiers\r\n    bool public unlocked = true;\r\n\r\n    // Every pool will have a deadline\r\n    uint256 public deadline;\r\n\r\n    // Fee Rate, given to LP holders (0 ~ 1000)\r\n    uint256 public feeRate;\r\n\r\n    // reserve0 * reserve1\r\n    uint256 public kLast;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event ReserveUpdated(uint256 reserve0, uint256 reserve1);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amountAIn,\r\n        uint256 amountBIn,\r\n        uint256 amountAOut,\r\n        uint256 amountBOut,\r\n        address indexed to\r\n    );\r\n\r\n    event Mint(address indexed sender, uint256 amountA, uint256 amountB);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amountA,\r\n        uint256 amountB,\r\n        address indexed to\r\n    );\r\n\r\n    constructor() {\r\n        factory = msg.sender; // deployed by factory contract\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Can not swap after the deadline\r\n     * @dev Each pool will have a deadline and it was set when deployed\r\n     *      Does not apply to income maker contract\r\n     */\r\n    modifier beforeDeadline() {\r\n        if (msg.sender != INaughtyFactory(factory).incomeMaker()) {\r\n            require(block.timestamp <= deadline, \"Can not swap after deadline\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Init Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Initialize the contract status after the deployment by factory\r\n     * @param _token0 Token0 address (policy token address)\r\n     * @param _token1 Token1 address (stablecoin address)\r\n     * @param _deadline Deadline for this pool\r\n     * @param _feeRate Fee rate to LP holders (1000 <=> 100%)\r\n     */\r\n    function initialize(\r\n        address _token0,\r\n        address _token1,\r\n        uint256 _deadline,\r\n        uint256 _feeRate\r\n    ) external {\r\n        require(\r\n            msg.sender == factory,\r\n            \"can only be initialized by the factory contract\"\r\n        );\r\n        require(_feeRate <= 1000, \"feeRate over 1.0\");\r\n\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n\r\n        // deadline for the whole pool after which no swap will be allowed\r\n        deadline = _deadline;\r\n\r\n        feeRate = _feeRate;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get reserve0 (Policy token) and reserve1 (stablecoin).\r\n     * @dev This function always put policy token at the first place!\r\n     * @return _reserve0 Reserve of token0\r\n     * @return _reserve1 Reserve of token1\r\n     */\r\n    function getReserves()\r\n        public\r\n        view\r\n        returns (uint112 _reserve0, uint112 _reserve1)\r\n    {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Mint LP Token to liquidity providers\r\n     *         Called when adding liquidity.\r\n     * @param to The user address\r\n     * @return liquidity The LP token amount\r\n     */\r\n    function mint(address to)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 liquidity)\r\n    {\r\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\r\n\r\n        uint256 balance0 = IERC20(token0).balanceOf(address(this)); // policy token balance after deposit\r\n        uint256 balance1 = IERC20(token1).balanceOf(address(this)); // stablecoin balance after deposit\r\n\r\n        uint256 amount0 = balance0 - _reserve0; // just deposit\r\n        uint256 amount1 = balance1 - _reserve1;\r\n\r\n        // Distribute part of the fee to income maker\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n\r\n        uint256 _totalSupply = totalSupply(); // gas savings\r\n        if (_totalSupply == 0) {\r\n            // No liquidity = First add liquidity\r\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\r\n            // Keep minimum liquidity to this contract\r\n            _mint(factory, MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = min(\r\n                (amount0 * _totalSupply) / _reserve0,\r\n                (amount1 * _totalSupply) / _reserve1\r\n            );\r\n        }\r\n\r\n        require(liquidity > 0, \"insufficient liquidity minted\");\r\n        _mint(to, liquidity);\r\n\r\n        _update(balance0, balance1);\r\n\r\n        if (feeOn) kLast = reserve0 * reserve1;\r\n\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens give back the original tokens\r\n     * @param _to User address\r\n     * @return amount0 Amount of token0 to be sent back\r\n     * @return amount1 Amount of token1 to be sent back\r\n     */\r\n    function burn(address _to)\r\n        external\r\n        nonReentrant\r\n        returns (uint256 amount0, uint256 amount1)\r\n    {\r\n        // gas savings\r\n        (uint112 _reserve0, uint112 _reserve1) = getReserves();\r\n        address _token0 = token0;\r\n        address _token1 = token1;\r\n\r\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this)); // policy token balance\r\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this)); // stablecoin balance\r\n\r\n        uint256 liquidity = balanceOf(address(this));\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n\r\n        uint256 _totalSupply = totalSupply(); // gas savings\r\n\r\n        // How many tokens to be sent back\r\n        amount0 = (liquidity * balance0) / _totalSupply;\r\n        amount1 = (liquidity * balance1) / _totalSupply;\r\n\r\n        require(amount0 > 0 && amount1 > 0, \"Insufficient liquidity burned\");\r\n\r\n        // Currently all the liquidity in the pool was just sent by the user, so burn all\r\n        _burn(address(this), liquidity);\r\n\r\n        // Transfer tokens out and update the balance\r\n        IERC20(_token0).safeTransfer(_to, amount0);\r\n        IERC20(_token1).safeTransfer(_to, amount1);\r\n        balance0 = IERC20(_token0).balanceOf(address(this));\r\n        balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        _update(balance0, balance1);\r\n\r\n        if (feeOn) kLast = reserve0 * reserve1;\r\n\r\n        emit Burn(msg.sender, amount0, amount1, _to);\r\n    }\r\n\r\n    /**\r\n     * @notice Finish the swap process\r\n     * @param _amount0Out Amount of token0 to be given out (may be 0)\r\n     * @param _amount1Out Amount of token1 to be given out (may be 0)\r\n     * @param _to Address to receive the swap result\r\n     */\r\n    function swap(\r\n        uint256 _amount0Out,\r\n        uint256 _amount1Out,\r\n        address _to\r\n    ) external beforeDeadline nonReentrant {\r\n        require(\r\n            _amount0Out > 0 || _amount1Out > 0,\r\n            \"Output amount need to be > 0\"\r\n        );\r\n\r\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\r\n        require(\r\n            _amount0Out < _reserve0 && _amount1Out < _reserve1,\r\n            \"Not enough liquidity\"\r\n        );\r\n\r\n        uint256 balance0;\r\n        uint256 balance1;\r\n        {\r\n            // scope for _token{0,1}, avoids stack too deep errors\r\n            address _token0 = token0;\r\n            address _token1 = token1;\r\n            require(_to != _token0 && _to != _token1, \"INVALID_TO\");\r\n\r\n            if (_amount0Out > 0) IERC20(_token0).safeTransfer(_to, _amount0Out);\r\n            if (_amount1Out > 0) IERC20(_token1).safeTransfer(_to, _amount1Out);\r\n\r\n            balance0 = IERC20(_token0).balanceOf(address(this));\r\n            balance1 = IERC20(_token1).balanceOf(address(this));\r\n        }\r\n        uint256 amount0In = balance0 > _reserve0 - _amount0Out\r\n            ? balance0 - (_reserve0 - _amount0Out)\r\n            : 0;\r\n        uint256 amount1In = balance1 > _reserve1 - _amount1Out\r\n            ? balance1 - (_reserve1 - _amount1Out)\r\n            : 0;\r\n\r\n        require(amount0In > 0 || amount1In > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\r\n\r\n        {\r\n            uint256 balance0Adjusted = balance0 * 1000 - amount0In * feeRate;\r\n            uint256 balance1Adjusted = balance1 * 1000 - amount1In * feeRate;\r\n\r\n            require(\r\n                balance0Adjusted * balance1Adjusted >=\r\n                    _reserve0 * _reserve1 * (1000**2),\r\n                \"The remaining x*y is less than K\"\r\n            );\r\n        }\r\n\r\n        _update(balance0, balance1);\r\n\r\n        emit Swap(\r\n            msg.sender,\r\n            amount0In,\r\n            amount1In,\r\n            _amount0Out,\r\n            _amount1Out,\r\n            _to\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Syncrinize the status of this pool\r\n     */\r\n    function sync() external nonReentrant {\r\n        _update(\r\n            IERC20(token0).balanceOf(address(this)),\r\n            IERC20(token1).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ********************************** Internal Functions ********************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Update the reserves of the pool\r\n     * @param balance0 Balance of token0\r\n     * @param balance1 Balance of token1\r\n     */\r\n    function _update(uint256 balance0, uint256 balance1) private {\r\n        uint112 MAX_NUM = type(uint112).max;\r\n        require(balance0 <= MAX_NUM && balance1 <= MAX_NUM, \"Uint112 OVERFLOW\");\r\n\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n\r\n        emit ReserveUpdated(reserve0, reserve1);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the smaller one of two numbers\r\n     * @param x The first number\r\n     * @param y The second number\r\n     * @return z The smaller one\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    function _mintFee(uint112 _reserve0, uint112 _reserve1)\r\n        private\r\n        returns (bool feeOn)\r\n    {\r\n        address incomeMaker = INaughtyFactory(factory).incomeMaker();\r\n\r\n        // If incomeMaker is not zero address, fee is on\r\n        feeOn = incomeMaker != address(0);\r\n\r\n        uint256 _k = kLast;\r\n\r\n        if (feeOn) {\r\n            if (_k != 0) {\r\n                uint256 rootK = Math.sqrt(_reserve0 * _reserve1);\r\n                uint256 rootKLast = Math.sqrt(_k);\r\n\r\n                if (rootK > rootKLast) {\r\n                    uint256 numerator = totalSupply() *\r\n                        (rootK - rootKLast) *\r\n                        10;\r\n\r\n                    // (1 / φ) - 1\r\n                    // Proportion got from factory is based on 100\r\n                    // Use 1000/proportion to make it divided (donominator and numerator both * 10)\r\n                    // p = 40 (2/5) => 1000/40 = 25\r\n                    uint256 incomeMakerProportion = INaughtyFactory(factory)\r\n                        .incomeMakerProportion();\r\n                    uint256 denominator = rootK *\r\n                        (1000 / incomeMakerProportion - 10) +\r\n                        rootKLast *\r\n                        10;\r\n\r\n                    uint256 liquidity = numerator / denominator;\r\n\r\n                    // Mint the liquidity to income maker contract\r\n                    if (liquidity > 0) _mint(incomeMaker, liquidity);\r\n                }\r\n            }\r\n        } else if (_k != 0) {\r\n            kLast = 0;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\nlibrary Math {\r\n    uint256 internal constant WAD = 10**18;\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return ((x * y) + (WAD / 2)) / WAD;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n"
    },
    "contracts/income/IncomeMaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-Later\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../naughty-price/interfaces/INaughtyRouter.sol\";\r\nimport \"../naughty-price/interfaces/INaughtyFactory.sol\";\r\nimport \"../naughty-price/interfaces/INaughtyPair.sol\";\r\n\r\n/**\r\n * @title Degis Maker Contract\r\n * @dev This contract will receive the transaction fee from swap pool\r\n *      Then it will transfer\r\n */\r\ncontract IncomeMaker is OwnableUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constants **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    uint256 public constant UINT256_MAX = type(uint256).max;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    INaughtyRouter public router;\r\n\r\n    INaughtyFactory public factory;\r\n\r\n    address public incomeSharingVault;\r\n\r\n    uint256 public PRICE_SCALE = 1e6;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event IncomeToUSD(\r\n        address policyTokenAddress,\r\n        address stablecoin,\r\n        uint256 amountOut\r\n    );\r\n    event ConvertIncome(\r\n        address caller,\r\n        address policyTokenAddress,\r\n        address stablecoin,\r\n        uint256 policyTokenAmount, // Amount of policy token by burning lp tokens\r\n        uint256 stablecoinAmount, // Amount of stablecoin by burning lp tokens\r\n        uint256 stablecoinBackAmount // Amount of stablecoin by swapping policy tokens\r\n    );\r\n    event EmergencyWithdraw(address token, uint256 amount);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Initialize function\r\n     * @param _router Address of the naughty router\r\n     * @param _factory Address of the naughty factory\r\n     * @param _vault Address of the income sharing vault\r\n     */\r\n    function initialize(\r\n        address _router,\r\n        address _factory,\r\n        address _vault\r\n    ) public initializer {\r\n        __Ownable_init();\r\n\r\n        router = INaughtyRouter(_router);\r\n        factory = INaughtyFactory(_factory);\r\n\r\n        incomeSharingVault = _vault;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Convert the income to stablecoin and transfer to the incomeSharingVault\r\n     * @param _policyToken Address of the policy token\r\n     * @param _stablecoin Address of the stablecoi\r\n     */\r\n    function convertIncome(address _policyToken, address _stablecoin) external {\r\n        // Get the pair\r\n        INaughtyPair pair = INaughtyPair(\r\n            factory.getPairAddress(_policyToken, _stablecoin)\r\n        );\r\n        require(address(pair) != address(0), \"Pair not exist\");\r\n\r\n        // Transfer lp token to the pool and get two tokens\r\n        IERC20(address(pair)).safeTransfer(\r\n            address(pair),\r\n            pair.balanceOf(address(this))\r\n        );\r\n\r\n        // Directly call the pair to burn lp tokens\r\n        (uint256 amount0, uint256 amount1) = pair.burn(address(this));\r\n\r\n        // Finish swap\r\n        uint256 amountOut = _swap(\r\n            _policyToken,\r\n            _stablecoin,\r\n            amount0,\r\n            address(this)\r\n        );\r\n\r\n        // Transfer all stablecoins to income sharing vault\r\n        IERC20(_stablecoin).safeTransfer(\r\n            incomeSharingVault,\r\n            IERC20(_stablecoin).balanceOf(address(this))\r\n        );\r\n\r\n        emit ConvertIncome(\r\n            msg.sender,\r\n            _policyToken,\r\n            _stablecoin,\r\n            amount0,\r\n            amount1,\r\n            amountOut\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Emergency withdraw by the owner\r\n     * @param _token Address of the token\r\n     * @param _amount Amount of the token\r\n     */\r\n    function emergencyWithdraw(address _token, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        IERC20(_token).safeTransfer(msg.sender, _amount);\r\n        emit EmergencyWithdraw(_token, _amount);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Swap policy tokens to stablecoins\r\n     * @param _policyToken Address of policy token\r\n     * @param _stablecoin Address of stablecoin\r\n     * @param _amount Amount of policy token\r\n     * @param _to Address of the receiver\r\n     */\r\n    function _swap(\r\n        address _policyToken,\r\n        address _stablecoin,\r\n        uint256 _amount,\r\n        address _to\r\n    ) internal returns (uint256 amountOut) {\r\n        // Get the pair\r\n        INaughtyPair pair = INaughtyPair(\r\n            factory.getPairAddress(_policyToken, _stablecoin)\r\n        );\r\n        require(address(pair) != address(0), \"Pair not exist\");\r\n\r\n        (uint256 reserve0, uint256 reserve1) = pair.getReserves();\r\n\r\n        uint256 feeRate = pair.feeRate();\r\n\r\n        // Calculate amountIn - fee\r\n        uint256 amountInWithFee = _amount * (1000 - feeRate);\r\n\r\n        // Calculate amountOut\r\n        amountOut =\r\n            (amountInWithFee * reserve1) /\r\n            (reserve0 * 1000 + amountInWithFee);\r\n\r\n        // Transfer policy token and swap\r\n        IERC20(_policyToken).safeTransfer(address(pair), _amount);\r\n        pair.swap(0, amountOut, _to);\r\n    }\r\n}\r\n"
    },
    "contracts/naughty-price/NaughtyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\nimport \"./NPPolicyToken.sol\";\r\nimport \"./NaughtyPair.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {INaughtyPair} from \"./interfaces/INaughtyPair.sol\";\r\nimport {IPolicyCore} from \"./interfaces/IPolicyCore.sol\";\r\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\n/**\r\n * @title Naughty Factory\r\n * @dev Factory contract to deploy new pools periodically\r\n *      Each pool(product) will have a unique naughtyId\r\n *      Each pool will have its pool token\r\n *      PolicyToken - Stablecoin\r\n *      Token 0 may change but Token 1 is always stablecoin.\r\n */\r\n\r\ncontract NaughtyFactory is OwnableUpgradeable {\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // INIT_CODE_HASH for NaughtyPair, may be used in frontend\r\n    bytes32 public constant PAIR_INIT_CODE_HASH =\r\n        keccak256(abi.encodePacked(type(NaughtyPair).creationCode));\r\n\r\n    // PolicyToken Address => StableCoin Address => Pool Address\r\n    mapping(address => mapping(address => address)) getPair;\r\n\r\n    // Store all the pairs' addresses\r\n    address[] public allPairs;\r\n\r\n    // Store all policy tokens' addresses\r\n    address[] public allTokens;\r\n\r\n    // Next pool id to be deployed\r\n    uint256 public _nextId;\r\n\r\n    // Address of policyCore\r\n    address public policyCore;\r\n\r\n    // Address of income maker, part of the transaction fee will be distributed to this address\r\n    address public incomeMaker;\r\n\r\n    // Swap fee proportion to income maker\r\n    uint256 public incomeMakerProportion;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event PolicyCoreAddressChanged(\r\n        address oldPolicyCore,\r\n        address newPolicyCore\r\n    );\r\n    event IncomeMakerProportionChanged(\r\n        uint256 oldProportion,\r\n        uint256 newProportion\r\n    );\r\n    event IncomeMakerAddressChanged(\r\n        address oldIncomeMaker,\r\n        address newIncomeMaker\r\n    );\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function initialize() public initializer {\r\n        __Ownable_init();\r\n        // 40% of swap fee is distributed to income maker contract\r\n        // Can be set later\r\n        incomeMakerProportion = 40;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Modifiers ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Only called by policyCore contract\r\n     */\r\n    modifier onlyPolicyCore() {\r\n        require(msg.sender == policyCore, \"Only called by policyCore contract\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get the all tokens that have been deployed\r\n     * @return tokens All tokens\r\n     */\r\n    function getAllTokens() external view returns (address[] memory) {\r\n        return allTokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the INIT_CODE_HASH for policy tokens with parameters\r\n     * @dev For test/task convinience, pre-compute the address\r\n     *      Ethers.js:\r\n     *      Address = ethers.utils.getCreate2Address(factory address, salt, INIT_CODE_HASH)\r\n     *      salt = keccak256(abi.encodePacked(_policyTokenName))\r\n     * @param _tokenName Name of the policy token to be deployed\r\n     * @param _decimals Token decimals of this policy token\r\n     */\r\n    function getInitCodeHashForPolicyToken(\r\n        string memory _tokenName,\r\n        uint256 _decimals\r\n    ) public view returns (bytes32) {\r\n        bytes memory bytecode = _getPolicyTokenBytecode(_tokenName, _decimals);\r\n        return keccak256(bytecode);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the pair address deployed by the factory\r\n     *         PolicyToken address first, and then stablecoin address\r\n     *         The order of the tokens will be sorted inside the function\r\n     * @param _tokenAddress1 Address of token1\r\n     * @param _tokenAddress2 Address of toekn2\r\n     * @return Pool address of the two tokens\r\n     */\r\n    function getPairAddress(address _tokenAddress1, address _tokenAddress2)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        // Policy token address at the first place\r\n        (address token0, address token1) = IPolicyCore(policyCore)\r\n            .supportedStablecoin(_tokenAddress2)\r\n            ? (_tokenAddress1, _tokenAddress2)\r\n            : (_tokenAddress2, _tokenAddress1);\r\n\r\n        address _pairAddress = getPair[token0][token1];\r\n\r\n        return _pairAddress;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Set Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Remember to call this function to set the policyCore address\r\n     * @dev    Only callable by the owner\r\n     *         < PolicyCore should be the minter of policyToken >\r\n     *         < This process is done inside constructor >\r\n     * @param _policyCore Address of policyCore contract\r\n     */\r\n    function setPolicyCoreAddress(address _policyCore) external onlyOwner {\r\n        emit PolicyCoreAddressChanged(policyCore, _policyCore);\r\n        policyCore = _policyCore;\r\n    }\r\n\r\n    /**\r\n     * @notice Set income maker proportion\r\n     * @dev    Only callable by the owner\r\n     * @param _proportion New proportion to income maker contract\r\n     */\r\n    function setIncomeMakerProportion(uint256 _proportion) external onlyOwner {\r\n        emit IncomeMakerProportionChanged(incomeMakerProportion, _proportion);\r\n        incomeMakerProportion = _proportion;\r\n    }\r\n\r\n    /**\r\n     * @notice Set income maker address\r\n     * @dev Only callable by the owner\r\n     * @param _incomeMaker New income maker address\r\n     */\r\n    function setIncomeMakerAddress(address _incomeMaker) external onlyOwner {\r\n        emit IncomeMakerAddressChanged(incomeMaker, _incomeMaker);\r\n        incomeMaker = _incomeMaker;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Main Functions *********************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice For each round we need to first create the policytoken(ERC20)\r\n     * @param _policyTokenName Name of the policyToken\r\n     * @param _decimals Decimals of the policyToken\r\n     * @return tokenAddress PolicyToken address\r\n     */\r\n    function deployPolicyToken(\r\n        string memory _policyTokenName,\r\n        uint256 _decimals\r\n    ) external onlyPolicyCore returns (address) {\r\n        bytes32 salt = keccak256(abi.encodePacked(_policyTokenName));\r\n\r\n        bytes memory bytecode = _getPolicyTokenBytecode(\r\n            _policyTokenName,\r\n            _decimals\r\n        );\r\n\r\n        address _policTokenAddress = _deploy(bytecode, salt);\r\n\r\n        allTokens.push(_policTokenAddress);\r\n\r\n        _nextId++;\r\n\r\n        return _policTokenAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice After deploy the policytoken and get the address,\r\n     *         we deploy the policyToken - stablecoin pool contract\r\n     * @param _policyTokenAddress Address of policy token\r\n     * @param _stablecoin Address of the stable coin\r\n     * @param _deadline Deadline of the pool\r\n     * @param _feeRate Fee rate given to LP holders\r\n     * @return poolAddress Address of the pool\r\n     */\r\n    function deployPool(\r\n        address _policyTokenAddress,\r\n        address _stablecoin,\r\n        uint256 _deadline,\r\n        uint256 _feeRate\r\n    ) public onlyPolicyCore returns (address) {\r\n        bytes memory bytecode = type(NaughtyPair).creationCode;\r\n\r\n        bytes32 salt = keccak256(\r\n            abi.encodePacked(_policyTokenAddress, _stablecoin)\r\n        );\r\n\r\n        address _poolAddress = _deploy(bytecode, salt);\r\n\r\n        INaughtyPair(_poolAddress).initialize(\r\n            _policyTokenAddress,\r\n            _stablecoin,\r\n            _deadline,\r\n            _feeRate\r\n        );\r\n\r\n        getPair[_policyTokenAddress][_stablecoin] = _poolAddress;\r\n\r\n        allPairs.push(_poolAddress);\r\n\r\n        return _poolAddress;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Deploy function with create2\r\n     * @param code Byte code of the contract (creation code)\r\n     * @param salt Salt for the deployment\r\n     * @return addr The deployed contract address\r\n     */\r\n    function _deploy(bytes memory code, bytes32 salt)\r\n        internal\r\n        returns (address addr)\r\n    {\r\n        assembly {\r\n            addr := create2(0, add(code, 0x20), mload(code), salt)\r\n            if iszero(extcodesize(addr)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the policyToken bytecode (with constructor parameters)\r\n     * @param _tokenName Name of policyToken\r\n     * @param _decimals Decimals of policyToken\r\n     */\r\n    function _getPolicyTokenBytecode(\r\n        string memory _tokenName,\r\n        uint256 _decimals\r\n    ) internal view returns (bytes memory) {\r\n        bytes memory bytecode = type(NPPolicyToken).creationCode;\r\n\r\n        // Encodepacked the parameters\r\n        // The minter is set to be the policyCore address\r\n        return\r\n            abi.encodePacked(\r\n                bytecode,\r\n                abi.encode(_tokenName, _tokenName, policyCore, _decimals)\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/naughty-price/NPPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @title  Policy Token for Naughty Price\r\n * @notice This is the contract for token price policy token.\r\n *         It is a ERC20 token with an owner and a minter.\r\n *         The owner should be the deployer at first.\r\n *         The minter should be the policyCore contract.\r\n * @dev    It is different from the flight delay token.\r\n *         That is an ERC721 NFT and this is an ERC20 token.\r\n */\r\ncontract NPPolicyToken is ERC20 {\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    address public minter;\r\n\r\n    uint256 private tokenDecimals;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event Mint(address account, uint256 amount);\r\n    event Burn(address account, uint256 amount);\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _minter,\r\n        uint256 _decimals\r\n    ) ERC20(_name, _symbol) {\r\n        minter = _minter;\r\n        tokenDecimals = _decimals;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Modifiers **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Only the minter can mint\r\n     */\r\n    modifier onlyMinter() {\r\n        require(msg.sender == minter, \"only minter can call this function\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Main Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Mint some policy tokens\r\n     * @param _account Address to receive the tokens\r\n     * @param _amount Amount to be minted\r\n     */\r\n    function mint(address _account, uint256 _amount) public onlyMinter {\r\n        _mint(_account, _amount);\r\n        emit Mint(_account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn some policy tokens\r\n     * @param _account Address to burn tokens\r\n     * @param _amount Amount to be burned\r\n     */\r\n    function burn(address _account, uint256 _amount) public onlyMinter {\r\n        _burn(_account, _amount);\r\n        emit Burn(_account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the decimals of this token\r\n     * @dev It should be the same as its paired stablecoin\r\n     */\r\n    function decimals() public view override returns (uint8) {\r\n        return uint8(tokenDecimals);\r\n    }\r\n}\r\n"
    },
    "contracts/naughty-price/IDOPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport { IPriceGetter } from \"./interfaces/IPriceGetter.sol\";\r\nimport { IPolicyCore } from \"./interfaces/IPolicyCore.sol\";\r\n\r\nimport { IUniswapV2Pair } from \"./interfaces/IUniswapV2Pair.sol\";\r\nimport { FixedPoint } from \"../libraries/FixedPoint.sol\";\r\nimport { UniswapV2OracleLibrary } from \"../libraries/UniswapV2OracleLibrary.sol\";\r\nimport { UniswapV2Library } from \"../libraries/UniswapV2Library.sol\";\r\n\r\n/**\r\n * @title Price Getter for IDO Protection\r\n *\r\n * @notice This is the contract for getting price feed from DEX\r\n *         IDO projects does not have Chainlink feeds so we use DEX TWAP price as oracle\r\n *\r\n *         Workflow:\r\n *         1. Deploy naughty token for the IDO project and set its type as \"IDO\"\r\n *         2. Add ido price feed info by calling \"addIDOPair\" function\r\n *         3. Set auto tasks start within PERIOD to endTime to sample prices from DEX\r\n *         4. Call \"settleFinalResult\" function in core to settle the final price\r\n */\r\n\r\ncontract IDOPriceGetter is OwnableUpgradeable {\r\n    using FixedPoint for *;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constants **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // WAVAX address\r\n    address public constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\r\n    // address public constant WAVAX = 0xd00ae08403B9bbb9124bB305C09058E32C39A48c; // fuji\r\n\r\n    // Minimum period before endTime to start sampling\r\n    uint256 public constant PERIOD = 60 * 60 * 24 * 2; // 2 days\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Base price getter to transfer the price into USD\r\n    IPriceGetter public basePriceGetter;\r\n\r\n    // Policy Core contract\r\n    IPolicyCore public policyCore;\r\n\r\n    struct IDOPriceInfo {\r\n        address pair; // Pair on TraderJoe\r\n        uint256 decimals; // If no special settings, it would be 0\r\n        uint256 sampleInterval;\r\n        uint256 isToken0;\r\n        uint256 priceAverage;\r\n        uint256 priceCumulativeLast;\r\n        uint256 lastTimestamp;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n    }\r\n    // Policy Base Token Name => IDO Info\r\n    mapping(string => IDOPriceInfo) public priceFeeds;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event SamplePrice(\r\n        string policyToken,\r\n        uint256 priceAverage,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event NewIDOPair(\r\n        string policyToken,\r\n        address pair,\r\n        uint256 decimals,\r\n        uint256 sampleInterval,\r\n        uint256 isToken0\r\n    );\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function initialize(address _priceGetter, address _policyCore)\r\n        public\r\n        initializer\r\n    {\r\n        __Ownable_init();\r\n\r\n        basePriceGetter = IPriceGetter(_priceGetter);\r\n        policyCore = IPolicyCore(_policyCore);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function addIDOPair(\r\n        string calldata _policyToken,\r\n        address _pair,\r\n        uint256 _decimals,\r\n        uint256 _interval,\r\n        uint256 _startTime\r\n    ) external onlyOwner {\r\n        require(IUniswapV2Pair(_pair).token0() != address(0), \"Non exist pair\");\r\n        require(\r\n            IUniswapV2Pair(_pair).token0() == WAVAX ||\r\n                IUniswapV2Pair(_pair).token1() == WAVAX,\r\n            \"Not avax pair\"\r\n        );\r\n        require(\r\n            priceFeeds[_policyToken].pair == address(0),\r\n            \"Pair already exists\"\r\n        );\r\n\r\n        IDOPriceInfo storage newFeed = priceFeeds[_policyToken];\r\n\r\n        newFeed.pair = _pair;\r\n        // Decimals should keep the priceAverage to have 18 decimals\r\n        // WAVAX always have 18 decimals\r\n        // E.g. Pair token both 18 decimals => price decimals 18\r\n        //      (5e18, 10e18) real price 0.5 => we show priceAverage 0.5 * 10^18\r\n        //      Pair token (18, 6) decimals => price decimals 6\r\n        //      (5e18, 10e6) real price 0.5 => we show priceAverage 0.5 * 10^18\r\n        newFeed.decimals = _decimals;\r\n        newFeed.sampleInterval = _interval;\r\n\r\n        // Check if the policy base token is token0\r\n        bool isToken0 = !(IUniswapV2Pair(_pair).token0() == WAVAX);\r\n\r\n        newFeed.isToken0 = isToken0 ? 1 : 0;\r\n\r\n        (, , newFeed.lastTimestamp) = IUniswapV2Pair(_pair).getReserves();\r\n\r\n        // Record the initial priceCumulativeLast\r\n        newFeed.priceCumulativeLast = isToken0\r\n            ? IUniswapV2Pair(_pair).price0CumulativeLast()\r\n            : IUniswapV2Pair(_pair).price1CumulativeLast();\r\n\r\n        uint256 endTime = policyCore\r\n            .getPolicyTokenInfo(_policyToken)\r\n            .settleTimestamp;\r\n\r\n        require(\r\n            _startTime < endTime && _startTime + PERIOD >= endTime,\r\n            \"Wrong start time\"\r\n        );\r\n\r\n        emit NewIDOPair(\r\n            _policyToken,\r\n            _pair,\r\n            _decimals,\r\n            _interval,\r\n            newFeed.isToken0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Set price in avax\r\n     *         Price in avax should be in 1e18\r\n     *\r\n     * @param _policyToken Policy token name\r\n     * @param _price       Price in avax\r\n     */\r\n    function setPrice(string calldata _policyToken, uint256 _price)\r\n        external\r\n        onlyOwner\r\n    {\r\n        priceFeeds[_policyToken].priceAverage = _price;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function samplePrice(string calldata _policyToken) external {\r\n        IDOPriceInfo storage priceFeed = priceFeeds[_policyToken];\r\n\r\n        (\r\n            uint256 price0Cumulative,\r\n            uint256 price1Cumulative,\r\n            uint32 blockTimestamp\r\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(priceFeed.pair);\r\n\r\n        // Time between this sampling and last sampling (seconds)\r\n        uint32 timeElapsed = blockTimestamp - uint32(priceFeed.lastTimestamp);\r\n\r\n        uint256 decimals = priceFeed.decimals;\r\n\r\n        require(\r\n            timeElapsed > priceFeed.sampleInterval,\r\n            \"Minimum sample interval\"\r\n        );\r\n\r\n        // Update priceAverage and priceCumulativeLast\r\n        uint256 newPriceAverage;\r\n\r\n        if (priceFeed.isToken0 > 0) {\r\n            newPriceAverage = FixedPoint\r\n                .uq112x112(\r\n                    uint224(\r\n                        ((price0Cumulative - priceFeed.priceCumulativeLast) *\r\n                            10**decimals) / timeElapsed\r\n                    )\r\n                )\r\n                .decode();\r\n\r\n            priceFeed.priceCumulativeLast = price0Cumulative;\r\n        } else {\r\n            newPriceAverage = FixedPoint\r\n                .uq112x112(\r\n                    uint224(\r\n                        ((price1Cumulative - priceFeed.priceCumulativeLast) *\r\n                            10**decimals) / timeElapsed\r\n                    )\r\n                )\r\n                .decode();\r\n\r\n            priceFeed.priceCumulativeLast = price1Cumulative;\r\n        }\r\n\r\n        priceFeed.priceAverage = newPriceAverage;\r\n\r\n        // Update lastTimestamp\r\n        priceFeed.lastTimestamp = blockTimestamp;\r\n\r\n        emit SamplePrice(_policyToken, newPriceAverage, blockTimestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Get latest price\r\n     *\r\n     * @param _policyToken Policy token name\r\n     *\r\n     * @return price USD price of the base token\r\n     */\r\n    function getLatestPrice(string calldata _policyToken)\r\n        external\r\n        returns (uint256 price)\r\n    {\r\n        uint256 priceInAVAX;\r\n\r\n        // If token0 is WAVAX, use price1Average\r\n        // Else, use price0Average\r\n        priceInAVAX = priceFeeds[_policyToken].priceAverage;\r\n\r\n        require(priceInAVAX > 0, \"Zero Price\");\r\n\r\n        // AVAX price, 1e18 scale\r\n        uint256 avaxPrice = basePriceGetter.getLatestPrice(\"AVAX\");\r\n\r\n        // This final price is also multiplied by 1e18\r\n        price = (avaxPrice * priceInAVAX) / 1e18;\r\n    }\r\n}\r\n"
    },
    "contracts/naughty-price/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity ^0.8.10;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "pragma solidity ^0.8.10;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint256 _x;\r\n    }\r\n\r\n    uint8 private constant RESOLUTION = 112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function div(uq112x112 memory self, uint112 x)\r\n        internal\r\n        pure\r\n        returns (uq112x112 memory)\r\n    {\r\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112(self._x / uint224(x));\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uq144x112 memory)\r\n    {\r\n        uint256 z;\r\n        require(\r\n            y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x),\r\n            \"FixedPoint: MULTIPLICATION_OVERFLOW\"\r\n        );\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator)\r\n        internal\r\n        pure\r\n        returns (uq112x112 memory)\r\n    {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity ^0.8.10;\r\n\r\nimport \"../naughty-price/interfaces/IUniswapV2Pair.sol\";\r\nimport \"./FixedPoint.sol\";\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2**32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(address pair)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 price0Cumulative,\r\n            uint256 price1Cumulative,\r\n            uint32 blockTimestamp\r\n        )\r\n    {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        ) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative +=\r\n                uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\r\n                timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative +=\r\n                uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\r\n                timeElapsed;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/UniswapV2Library.sol": {
      "content": "pragma solidity ^0.8.10;\r\n\r\nimport \"../naughty-price/interfaces/IUniswapV2Pair.sol\";\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n}\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint256;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB)\r\n        internal\r\n        pure\r\n        returns (address token0, address token1)\r\n    {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB\r\n            ? (tokenA, tokenB)\r\n            : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            hex\"ff\",\r\n                            factory,\r\n                            keccak256(abi.encodePacked(token0, token1)),\r\n                            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\r\n            pairFor(factory, tokenA, tokenB)\r\n        ).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0\r\n            ? (reserve0, reserve1)\r\n            : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) internal pure returns (uint256 amountB) {\r\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\r\n        require(\r\n            reserveA > 0 && reserveB > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountIn) {\r\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(\r\n        address factory,\r\n        uint256 amountIn,\r\n        address[] memory path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n        amounts = new uint256[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint256 i; i < path.length - 1; i++) {\r\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\r\n                factory,\r\n                path[i],\r\n                path[i + 1]\r\n            );\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(\r\n        address factory,\r\n        uint256 amountOut,\r\n        address[] memory path\r\n    ) internal view returns (uint256[] memory amounts) {\r\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\r\n        amounts = new uint256[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint256 i = path.length - 1; i > 0; i--) {\r\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\r\n                factory,\r\n                path[i - 1],\r\n                path[i]\r\n            );\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/governance/VoteEscrowedDegis.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { VeERC20Upgradeable } from \"./VeERC20Upgradeable.sol\";\r\nimport { Math } from \"../libraries/Math.sol\";\r\n\r\nimport { IFarmingPool } from \"../farming/interfaces/IFarmingPool.sol\";\r\n\r\n/**\r\n * @title Vote Escrowed Degis\r\n * @notice The staking contract for DEG -> veDEG\r\n *         veDEG:\r\n *            - Boosting the farming reward\r\n *            - Governance\r\n *            - Participate in Initial Liquidity Matching (naughty price)\r\n *            - etc.\r\n *         If you stake degis, you generate veDEG at the current `generationRate` until you reach `maxCap`\r\n *         If you unstake any amount of degis, you will lose all of your veDEG tokens\r\n *\r\n *         There is also an option that you lock your DEG for the max time\r\n *         and get the maximum veDEG balance immediately.\r\n *         !! Attention !!\r\n *         If you stake DEG for the max time for more than once, the lockUntil timestamp will\r\n *         be updated to the latest one.\r\n */\r\ncontract VoteEscrowedDegis is\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    ReentrancyGuardUpgradeable,\r\n    PausableUpgradeable,\r\n    VeERC20Upgradeable\r\n{\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct UserInfo {\r\n        // degis staked by user\r\n        uint256 amount;\r\n        // time of last veDEG claim or first deposit if user has not claimed yet\r\n        uint256 lastRelease;\r\n        // Amount locked for max time\r\n        uint256 amountLocked;\r\n        // Lock until timestamp\r\n        uint256 lockUntil;\r\n    }\r\n\r\n    // User info\r\n    mapping(address => UserInfo) public users;\r\n\r\n    // Degis token\r\n    // IERC20 public constant degis =\r\n    //     IERC20(0x9f285507Ea5B4F33822CA7aBb5EC8953ce37A645);\r\n    IERC20 public degis;\r\n\r\n    // Farming pool\r\n    IFarmingPool public farmingPool;\r\n\r\n    // Max veDEG to staked degis ratio\r\n    // Max veDEG amount = maxCap * degis staked\r\n    uint256 public maxCapRatio;\r\n\r\n    // Rate of veDEG generated per second, per degis staked\r\n    uint256 public generationRate;\r\n\r\n    // Calculation scale\r\n    uint256 public constant SCALE = 1e18;\r\n\r\n    // Whitelist contract checker\r\n    // Contract addresses are by default unable to stake degis, they must be whitelisted\r\n    mapping(address => bool) whitelist;\r\n\r\n    // Locked amount\r\n    mapping(address => uint256) public locked;\r\n\r\n    // NFT Staking contract\r\n    address public nftStaking;\r\n\r\n    mapping(address => uint256) public boosted;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n    event GenerationRateChanged(uint256 oldRate, uint256 newRate);\r\n    event MaxCapRatioChanged(uint256 oldMaxCapRatio, uint256 newMaxCapRatio);\r\n    event WhiteListAdded(address newWhiteList);\r\n    event WhiteListRemoved(address oldWhiteList);\r\n\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event DepositMaxTime(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 lockUntil\r\n    );\r\n    event Withdraw(address indexed user, uint256 amount);\r\n\r\n    event Claimed(address indexed user, uint256 amount);\r\n\r\n    event BurnVeDEG(\r\n        address indexed caller,\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n\r\n    event LockVeDEG(\r\n        address indexed caller,\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n\r\n    event UnlockVeDEG(\r\n        address indexed caller,\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n\r\n    event NFTStakingChanged(address oldNFTStaking, address newNFTStaking);\r\n    event BoostVeDEG(address user, uint256 boostType);\r\n    event UnBoostVeDEG(address user);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Errors ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    error VED__NotWhiteListed();\r\n    error VED__StillLocked();\r\n    error VED__ZeroAddress();\r\n    error VED__ZeroAmount();\r\n    error VED__NotEnoughBalance();\r\n\r\n    error VED__TimeNotPassed();\r\n    error VED__OverLocked();\r\n\r\n    error VED__NotNftStaking();\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function initialize(address _degis, address _farmingPool)\r\n        public\r\n        initializer\r\n    {\r\n        if (_degis == address(0) || _farmingPool == address(0))\r\n            revert VED__ZeroAddress();\r\n\r\n        // Initialize veDEG\r\n        __ERC20_init(\"Vote Escrowed Degis\", \"veDEG\");\r\n        __Ownable_init();\r\n        __ReentrancyGuard_init_unchained();\r\n        __Pausable_init_unchained();\r\n\r\n        // Set generationRate (veDEG per sec per degis staked)\r\n        generationRate = 10**18;\r\n\r\n        // Set maxCap ratio\r\n        maxCapRatio = 100;\r\n\r\n        // Set degis\r\n        degis = IERC20(_degis);\r\n\r\n        // Set farming pool\r\n        farmingPool = IFarmingPool(_farmingPool);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Not callable by smart contract\r\n     * @dev Checked first by msg.sender == tx.origin\r\n     *      Then if the contract is whitelisted, it will still pass the check\r\n     */\r\n    modifier notContract(address _addr) {\r\n        if (_addr != tx.origin) {\r\n            if (!whitelist[_addr]) revert VED__NotWhiteListed();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice No locked veDEG\r\n     * @dev Check the locked balance of a user\r\n     */\r\n    modifier noLocked(address _user) {\r\n        if (locked[_user] > 0) revert VED__StillLocked();\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Calculate the amount of veDEG that can be claimed by user\r\n     * @param _user User address\r\n     * @return claimableAmount Claimable amount of the user\r\n     */\r\n    function claimable(address _user) public view returns (uint256) {\r\n        if (_user == address(0)) revert VED__ZeroAddress();\r\n\r\n        UserInfo memory user = users[_user];\r\n\r\n        // Seconds passed since last claim\r\n        uint256 timePassed = block.timestamp - user.lastRelease;\r\n\r\n        uint256 realCapRatio = _getCapRatio(_user);\r\n\r\n        uint256 pending;\r\n        // Calculate pending amount\r\n        uint256 boostType = boosted[_user];\r\n        // If no boost\r\n        if (boostType == 0) {\r\n            pending = Math.wmul(user.amount, timePassed * generationRate);\r\n        }\r\n        // Normal nft boost\r\n        else if (boostType == 1) {\r\n            pending = Math.wmul(\r\n                user.amount,\r\n                (timePassed * generationRate * 120) / 100\r\n            );\r\n        }\r\n        // Rare nft boost\r\n        else if (boostType == 2) {\r\n            pending = Math.wmul(\r\n                user.amount,\r\n                (timePassed * generationRate * 150) / 100\r\n            );\r\n        }\r\n\r\n        // get user's veDEG balance\r\n        uint256 userVeDEGBalance = balanceOf(_user) -\r\n            user.amountLocked *\r\n            realCapRatio;\r\n\r\n        // user veDEG balance cannot go above user.amount * maxCap\r\n        uint256 veDEGCap = user.amount * realCapRatio;\r\n\r\n        // first, check that user hasn't reached the max limit yet\r\n        if (userVeDEGBalance < veDEGCap) {\r\n            // then, check if pending amount will make user balance overpass maximum amount\r\n            if (userVeDEGBalance + pending > veDEGCap) {\r\n                return veDEGCap - userVeDEGBalance;\r\n            } else {\r\n                return pending;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new whitelist address\r\n     * @dev Only callable by the owner\r\n     * @param _account Address to add\r\n     */\r\n    function addWhitelist(address _account) external onlyOwner {\r\n        whitelist[_account] = true;\r\n        emit WhiteListAdded(_account);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a new whitelist address\r\n     * @dev Only callable by the owner\r\n     * @param _account Address to remove\r\n     */\r\n    function removeWhitelist(address _account) external onlyOwner {\r\n        whitelist[_account] = false;\r\n        emit WhiteListRemoved(_account);\r\n    }\r\n\r\n    /**\r\n     * @notice Set maxCap ratio\r\n     * @param _maxCapRatio the new max ratio\r\n     */\r\n    function setMaxCapRatio(uint256 _maxCapRatio) external onlyOwner {\r\n        if (_maxCapRatio == 0) revert VED__ZeroAmount();\r\n        emit MaxCapRatioChanged(maxCapRatio, _maxCapRatio);\r\n        maxCapRatio = _maxCapRatio;\r\n    }\r\n\r\n    /**\r\n     * @notice Set generationRate\r\n     * @param _generationRate New generation rate\r\n     */\r\n    function setGenerationRate(uint256 _generationRate) external onlyOwner {\r\n        if (_generationRate == 0) revert VED__ZeroAmount();\r\n        emit GenerationRateChanged(generationRate, _generationRate);\r\n        generationRate = _generationRate;\r\n    }\r\n\r\n    function setNFTStaking(address _nftStaking) external onlyOwner {\r\n        emit NFTStakingChanged(nftStaking, _nftStaking);\r\n        nftStaking = _nftStaking;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Depisit degis for veDEG\r\n     * @dev Only EOA or whitelisted contract address\r\n     * @param _amount Amount to deposit\r\n     */\r\n    function deposit(uint256 _amount)\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n        notContract(msg.sender)\r\n    {\r\n        if (_amount == 0) revert VED__ZeroAmount();\r\n\r\n        if (users[msg.sender].amount > 0) {\r\n            // If the user has amount deposited, claim veDEG\r\n            _claim(msg.sender);\r\n\r\n            // Update the amount\r\n            users[msg.sender].amount += _amount;\r\n        } else {\r\n            // add new user to mapping\r\n            users[msg.sender].lastRelease = block.timestamp;\r\n            users[msg.sender].amount = _amount;\r\n        }\r\n\r\n        // Request degis from user\r\n        degis.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit for the max time\r\n     * @dev Release the max amount one time\r\n     */\r\n    function depositMaxTime(uint256 _amount)\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n    {\r\n        if (_amount == 0) revert VED__ZeroAmount();\r\n\r\n        uint256 currentMaxTime = (maxCapRatio * SCALE) / generationRate;\r\n        uint256 lockUntil = block.timestamp + currentMaxTime * 2;\r\n\r\n        users[msg.sender].amountLocked += _amount;\r\n        users[msg.sender].lockUntil = lockUntil;\r\n\r\n        // Request degis from user\r\n        degis.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        uint256 realCapRatio = _getCapRatio(msg.sender);\r\n\r\n        _mint(msg.sender, realCapRatio * _amount);\r\n\r\n        emit DepositMaxTime(msg.sender, _amount, lockUntil);\r\n    }\r\n\r\n    /**\r\n     * @notice Claims accumulated veDEG for flex deposit\r\n     */\r\n    function claim() public nonReentrant whenNotPaused {\r\n        if (users[msg.sender].amount == 0) revert VED__ZeroAmount();\r\n\r\n        _claim(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw degis token\r\n     * @dev User will lose all veDEG once he withdrawed\r\n     * @param _amount Amount to withdraw\r\n     */\r\n    function withdraw(uint256 _amount)\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n        noLocked(msg.sender)\r\n    {\r\n        if (_amount == 0) revert VED__ZeroAmount();\r\n\r\n        UserInfo storage user = users[msg.sender];\r\n        if (user.amount < _amount) revert VED__NotEnoughBalance();\r\n\r\n        // reset last Release timestamp\r\n        user.lastRelease = block.timestamp;\r\n\r\n        // update his balance before burning or sending back degis\r\n        user.amount -= _amount;\r\n\r\n        // get user veDEG balance that must be burned\r\n        // those locked amount will not be calculated\r\n\r\n        uint256 realCapRatio = _getCapRatio(msg.sender);\r\n\r\n        uint256 userVeDEGBalance = balanceOf(msg.sender) -\r\n            user.amountLocked *\r\n            realCapRatio;\r\n\r\n        _burn(msg.sender, userVeDEGBalance);\r\n\r\n        // send back the staked degis\r\n        degis.safeTransfer(msg.sender, _amount);\r\n\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all the locked veDEG\r\n     */\r\n    function withdrawLocked()\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n        noLocked(msg.sender)\r\n    {\r\n        UserInfo memory user = users[msg.sender];\r\n\r\n        if (user.amountLocked == 0) revert VED__ZeroAmount();\r\n        if (block.timestamp < user.lockUntil) revert VED__TimeNotPassed();\r\n\r\n        uint256 realCapRatio = _getCapRatio(msg.sender);\r\n\r\n        _burn(msg.sender, user.amountLocked * realCapRatio);\r\n\r\n        // update his balance before burning or sending back degis\r\n        users[msg.sender].amountLocked = 0;\r\n        users[msg.sender].lockUntil = 0;\r\n\r\n        // send back the staked degis\r\n        degis.safeTransfer(msg.sender, user.amountLocked);\r\n    }\r\n\r\n    /**\r\n     * @notice Lock veDEG token\r\n     * @dev Only whitelisted contract\r\n     *      Income sharing contract will lock veDEG as entrance\r\n     * @param _to User address\r\n     * @param _amount Amount to lock\r\n     */\r\n    function lockVeDEG(address _to, uint256 _amount) external {\r\n        // Only whitelisted contract can lock veDEG\r\n        if (!whitelist[msg.sender]) revert VED__NotWhiteListed();\r\n\r\n        if (locked[_to] + _amount > balanceOf(_to)) revert VED__OverLocked();\r\n\r\n        _lock(_to, _amount);\r\n        emit LockVeDEG(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Unlock veDEG token\r\n     * @param _to User address\r\n     * @param _amount Amount to unlock\r\n     */\r\n    function unlockVeDEG(address _to, uint256 _amount) external {\r\n        // Only whitelisted contract can unlock veDEG\r\n        if (!whitelist[msg.sender]) revert VED__NotWhiteListed();\r\n\r\n        if (locked[_to] < _amount) revert VED__OverLocked();\r\n\r\n        _unlock(_to, _amount);\r\n        emit UnlockVeDEG(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn veDEG\r\n     * @dev Only whitelisted contract\r\n     *      For future use, some contracts may need veDEG for entrance\r\n     * @param _to Address to burn\r\n     * @param _amount Amount to burn\r\n     */\r\n    function burnVeDEG(address _to, uint256 _amount) public {\r\n        // Only whitelisted contract can burn veDEG\r\n        if (!whitelist[msg.sender]) revert VED__NotWhiteListed();\r\n\r\n        _burn(_to, _amount);\r\n        emit BurnVeDEG(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Boost veDEG\r\n     *\r\n     * @dev Only called by nftStaking contract\r\n     *\r\n     * @param _user User address\r\n     * @param _type Boost type (1 = 120%, 2 = 150%)\r\n     */\r\n    function boostVeDEG(address _user, uint256 _type) external {\r\n        if (msg.sender != nftStaking) revert VED__NotNftStaking();\r\n\r\n        require(_type == 1 || _type == 2);\r\n\r\n        boosted[_user] = _type;\r\n\r\n        uint256 boostRatio;\r\n\r\n        if (_type == 1) boostRatio = 20;\r\n        else if (_type == 2) boostRatio = 50;\r\n\r\n        uint256 userBalance = balanceOf(_user);\r\n\r\n        if (userBalance > 0) {\r\n            _mint(_user, (userBalance * boostRatio) / 100);\r\n        }\r\n\r\n        emit BoostVeDEG(_user, _type);\r\n    }\r\n\r\n    /**\r\n     * @notice UnBoost veDEG\r\n     *\r\n     * @dev Only called by nftStaking contract\r\n     *\r\n     * @param _user User address\r\n     */\r\n    function unBoostVeDEG(address _user) external {\r\n        if (msg.sender != nftStaking) revert VED__NotNftStaking();\r\n\r\n        uint256 currentBoostStatus = boosted[_user];\r\n\r\n        if (currentBoostStatus == 0) return;\r\n\r\n        uint256 userBalance = balanceOf(_user);\r\n        uint256 userLocked = locked[_user];\r\n\r\n        if (currentBoostStatus == 1) {\r\n            if (userLocked > 0) revert VED__StillLocked();\r\n            _burn(_user, (userBalance * 20) / 120);\r\n        } else if (currentBoostStatus == 2) {\r\n            if (userLocked > 0) revert VED__StillLocked();\r\n            _burn(_user, (userBalance * 50) / 150);\r\n        }\r\n\r\n        boosted[_user] = 0;\r\n\r\n        emit UnBoostVeDEG(_user);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Finish claiming veDEG\r\n     * @param _user User address\r\n     */\r\n    function _claim(address _user) internal {\r\n        uint256 amount = claimable(_user);\r\n\r\n        // update last release time\r\n        users[_user].lastRelease = block.timestamp;\r\n\r\n        if (amount > 0) {\r\n            emit Claimed(_user, amount);\r\n            _mint(_user, amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update the bonus in farming pool\r\n     * @dev Every time when token is transferred (balance change)\r\n     * @param _user User address\r\n     * @param _newBalance New veDEG balance\r\n     */\r\n    function _afterTokenOperation(address _user, uint256 _newBalance)\r\n        internal\r\n        override\r\n    {\r\n        farmingPool.updateBonus(_user, _newBalance);\r\n    }\r\n\r\n    /**\r\n     * @notice Lock veDEG token\r\n     * @param _to User address\r\n     * @param _amount Amount to lock\r\n     */\r\n    function _lock(address _to, uint256 _amount) internal {\r\n        locked[_to] += _amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Unlock veDEG token\r\n     * @param _to User address\r\n     * @param _amount Amount to unlock\r\n     */\r\n    function _unlock(address _to, uint256 _amount) internal {\r\n        if (locked[_to] < _amount) revert VED__NotEnoughBalance();\r\n        locked[_to] -= _amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Get real cap ratio for a user\r\n     *         The ratio depends on the boost type\r\n     *\r\n     * @param _user User address\r\n     *\r\n     * @return realCapRatio Real cap ratio\r\n     */\r\n    function _getCapRatio(address _user)\r\n        internal\r\n        view\r\n        returns (uint256 realCapRatio)\r\n    {\r\n        uint256 boostType = boosted[_user];\r\n        if (boostType == 0) {\r\n            realCapRatio = maxCapRatio;\r\n        } else if (boostType == 1) {\r\n            realCapRatio = (maxCapRatio * 120) / 100;\r\n        } else if (boostType == 2) {\r\n            realCapRatio = (maxCapRatio * 150) / 100;\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/governance/VeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"./interfaces/IVeERC20.sol\";\r\n\r\n/// @title VeERC20Upgradeable\r\n/// @notice Modified version of ERC20Upgradeable where transfers and allowances are disabled.\r\n/// @dev only minting and burning are allowed. The hook _afterTokenOperation is called after Minting and Burning.\r\ncontract VeERC20Upgradeable is Initializable, ContextUpgradeable, IVeERC20 {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are burned and minted\r\n     */\r\n    event Burn(address indexed account, uint256 value);\r\n    event Mint(address indexed beneficiary, uint256 value);\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    function __ERC20_init(string memory name_, string memory symbol_)\r\n        internal\r\n        onlyInitializing\r\n    {\r\n        __Context_init_unchained();\r\n        __ERC20_init_unchained(name_, symbol_);\r\n    }\r\n\r\n    function __ERC20_init_unchained(string memory name_, string memory symbol_)\r\n        internal\r\n        onlyInitializing\r\n    {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Mint(account, amount);\r\n\r\n        _afterTokenOperation(account, _balances[account]);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Burn(account, amount);\r\n\r\n        _afterTokenOperation(account, _balances[account]);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any minting and burning.\r\n     * @param account the account being affected\r\n     * @param newBalance newBalance after operation\r\n     */\r\n    function _afterTokenOperation(address account, uint256 newBalance)\r\n        internal\r\n        virtual\r\n    {}\r\n\r\n    uint256[45] private __gap;\r\n}\r\n"
    },
    "contracts/farming/interfaces/IFarmingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface IFarmingPool {\r\n    function pendingDegis(uint256 _poolId, address _user)\r\n        external\r\n        returns (uint256);\r\n\r\n    function setStartBlock(uint256 _startBlock) external;\r\n\r\n    function add(\r\n        address _lpToken,\r\n        uint256 _poolId,\r\n        bool _withUpdate\r\n    ) external;\r\n\r\n    function setDegisReward(\r\n        uint256 _poolId,\r\n        uint256 _basicDegisPerBlock,\r\n        uint256 _bonusDegisPerBlock,\r\n        bool _withUpdate\r\n    ) external;\r\n\r\n    function stake(uint256 _poolId, uint256 _amount) external;\r\n\r\n    function withdraw(uint256 _poolId, uint256 _amount) external;\r\n\r\n    function updatePool(uint256 _poolId) external;\r\n\r\n    function massUpdatePools() external;\r\n\r\n    function harvest(uint256 _poolId, address _to) external;\r\n\r\n    function updateBonus(address _user, uint256 _newBalance) external;\r\n}\r\n"
    },
    "contracts/governance/interfaces/IVeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\ninterface IVeERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/farming/DoubleRewarder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"./interfaces/IFarmingPool.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n/**\r\n * @title Degis Double Rewarder Contract\r\n *\r\n * @notice\r\n *\r\n *\r\n *\r\n *\r\n */\r\n\r\ncontract DoubleRewarder is OwnableUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constants **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    uint256 private constant SCALE = 1e12;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    IFarmingPool public farmingPool;\r\n\r\n    mapping(address => bool) public supportedRewardToken;\r\n\r\n    struct PoolInfo {\r\n        address lpToken;\r\n        uint256 rewardPerSecond;\r\n        uint256 accTokenPerShare;\r\n        uint256 lastRewardTimestamp;\r\n    }\r\n\r\n    // Reward token address => pool info\r\n    mapping(address => PoolInfo) public pools;\r\n\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 rewardDebt;\r\n    }\r\n    // User address => user info\r\n    mapping(address => UserInfo) public userInfo;\r\n\r\n    // User address => reward token address => pending reward\r\n    mapping(address => mapping(address => uint256)) public userPendingReward;\r\n\r\n    // Reward token address => claimable\r\n    mapping(address => bool) public claimable;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event DistributeReward(address user, uint256 amount);\r\n\r\n    event NewRewardTokenAdded(address rewardToken);\r\n\r\n    event RewardRateUpdated(uint256 oldRate, uint256 newRate);\r\n\r\n    event RewardClaimable(address rewardToken);\r\n\r\n    event ClaimReward(address rewardToken, address user, uint256 amount);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    modifier onlyFarmingPool() {\r\n        require(msg.sender == address(farmingPool), \"Only farmingPool\");\r\n        _;\r\n    }\r\n\r\n    modifier supported(address _token) {\r\n        require(supportedRewardToken[_token], \"Token not supported\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructor\r\n     *         Only need to set farming pool address\r\n     */\r\n    function initialize(address _farmingPool) public initializer {\r\n        __Ownable_init();\r\n        farmingPool = IFarmingPool(_farmingPool);\r\n    }\r\n\r\n    /**\r\n     * @notice Make a reward token claimable\r\n     */\r\n    function setClaimable(address _rewardToken) external onlyOwner {\r\n        claimable[_rewardToken] = true;\r\n\r\n        emit RewardClaimable(_rewardToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Get pending reward\r\n     *\r\n     * @param _token Reward token address\r\n     * @param _user  User address\r\n     *\r\n     * @return pending Pending reward\r\n     */\r\n    function pendingReward(address _token, address _user)\r\n        external\r\n        view\r\n        supported(_token)\r\n        returns (uint256 pending)\r\n    {\r\n        require(pools[_token].lastRewardTimestamp > 0, \"Non exist pool\");\r\n\r\n        PoolInfo memory pool = pools[_token];\r\n        UserInfo memory user = userInfo[_user];\r\n\r\n        uint256 accTokenPerShare = pool.accTokenPerShare;\r\n\r\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(farmingPool));\r\n\r\n        // If still distributing reward\r\n        if (pool.rewardPerSecond > 0) {\r\n            if (block.timestamp > pool.lastRewardTimestamp && lpSupply > 0) {\r\n                uint256 timeElapsed = block.timestamp -\r\n                    pool.lastRewardTimestamp;\r\n\r\n                uint256 tokenReward = timeElapsed * pool.rewardPerSecond;\r\n\r\n                accTokenPerShare += (tokenReward * SCALE) / lpSupply;\r\n            }\r\n        }\r\n\r\n        pending = ((user.amount * accTokenPerShare) / SCALE) - user.rewardDebt;\r\n    }\r\n\r\n    /**\r\n     * @notice Update double reward pool\r\n     *\r\n     * @param _rewardToken Reward token address\r\n     * @param _lpSupply    LP token balance of farming pool\r\n     */\r\n    function updatePool(address _rewardToken, uint256 _lpSupply)\r\n        public\r\n        supported(_rewardToken)\r\n    {\r\n        PoolInfo storage pool = pools[_rewardToken];\r\n\r\n        if (pool.rewardPerSecond > 0) {\r\n            if (block.timestamp > pool.lastRewardTimestamp && _lpSupply > 0) {\r\n                uint256 timeElapsed = block.timestamp -\r\n                    pool.lastRewardTimestamp;\r\n\r\n                uint256 tokenReward = timeElapsed * pool.rewardPerSecond;\r\n\r\n                pool.accTokenPerShare += (tokenReward * SCALE) / _lpSupply;\r\n            }\r\n        }\r\n\r\n        pool.lastRewardTimestamp = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Set reward speed for a pool\r\n     *\r\n     * @param _lpToken       LP token address\r\n     * @param _rewardToken   Reward token address\r\n     * @param _reward        Reward per second\r\n     */\r\n    function setRewardSpeed(\r\n        address _lpToken,\r\n        address _rewardToken,\r\n        uint256 _reward\r\n    ) external supported(_rewardToken) onlyOwner {\r\n        uint256 lpSupply = IERC20(_lpToken).balanceOf(address(farmingPool));\r\n        updatePool(_rewardToken, lpSupply);\r\n\r\n        emit RewardRateUpdated(pools[_rewardToken].rewardPerSecond, _reward);\r\n\r\n        pools[_rewardToken].rewardPerSecond = _reward;\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new reward token\r\n     *\r\n     * @param _rewardToken Reward token address\r\n     * @param _lpToken     LP token address\r\n     */\r\n    function addRewardToken(address _rewardToken, address _lpToken)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(pools[_rewardToken].lastRewardTimestamp == 0, \"Already exist\");\r\n\r\n        supportedRewardToken[_rewardToken] = true;\r\n\r\n        pools[_rewardToken].lpToken = _lpToken;\r\n\r\n        emit NewRewardTokenAdded(_rewardToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Distribute reward when user get reward in farming pool\r\n     *         User lpAmount will be updated here\r\n     *\r\n     * @param _lpToken     LP token address\r\n     * @param _rewardToken Reward token address\r\n     * @param _user        User address\r\n     * @param _lpAmount    LP amount of user\r\n     * @param _lpSupply    LP token balance of farming pool\r\n     */\r\n    function distributeReward(\r\n        address _lpToken,\r\n        address _rewardToken,\r\n        address _user,\r\n        uint256 _lpAmount,\r\n        uint256 _lpSupply\r\n    ) external onlyFarmingPool supported(_rewardToken) {\r\n        require(pools[_rewardToken].lpToken == _lpToken, \"Not match\");\r\n\r\n        updatePool(_rewardToken, _lpSupply);\r\n\r\n        PoolInfo memory pool = pools[_rewardToken];\r\n        UserInfo storage user = userInfo[_user];\r\n\r\n        // Get pending reward\r\n        uint256 pending = (user.amount * pool.accTokenPerShare) /\r\n            SCALE -\r\n            user.rewardDebt;\r\n\r\n        uint256 prevAmount = user.amount;\r\n\r\n        // Effects before interactions to prevent re-entrancy\r\n        user.amount = _lpAmount;\r\n\r\n        user.rewardDebt = (_lpAmount * pool.accTokenPerShare) / SCALE;\r\n\r\n        if (prevAmount > 0) {\r\n            // uint256 actualReward = _safeRewardTransfer(\r\n            //     _rewardToken,\r\n            //     _user,\r\n            //     pending\r\n            // );\r\n\r\n            // Record the reward and distribute later\r\n            userPendingReward[_user][_rewardToken] += pending;\r\n\r\n            emit DistributeReward(_user, pending);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim pending reward\r\n     *         During IDO protection, the insured token have not been issued yet\r\n     *         So we need to claim the pending reward later (after the farming)\r\n     *\r\n     * @param _rewardToken Reward token address\r\n     */\r\n    function claim(address _rewardToken) external supported(_rewardToken) {\r\n        require(claimable[_rewardToken], \"Not claimable\");\r\n\r\n        uint256 pending = userPendingReward[msg.sender][_rewardToken];\r\n\r\n        uint256 actualAmount = _safeRewardTransfer(\r\n            _rewardToken,\r\n            msg.sender,\r\n            pending\r\n        );\r\n\r\n        // Only record those reward really been transferred\r\n        userPendingReward[msg.sender][_rewardToken] -= actualAmount;\r\n\r\n        emit ClaimReward(_rewardToken, msg.sender, actualAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\r\n     *\r\n     * @param _to     User address\r\n     * @param _amount Amount to transfer\r\n     */\r\n    function _safeRewardTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        uint256 balance = IERC20(_token).balanceOf(address(this));\r\n\r\n        if (_amount > balance) {\r\n            IERC20(_token).safeTransfer(_to, balance);\r\n            return balance;\r\n        } else {\r\n            IERC20(_token).safeTransfer(_to, _amount);\r\n            return _amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw tokens\r\n     *         When stopping double reward, first set the reward speed, then withdraw tokens\r\n     */\r\n    function emergencyWithdraw(address _token) external onlyOwner {\r\n        IERC20(_token).safeTransfer(\r\n            address(msg.sender),\r\n            IERC20(_token).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function clearRewardDebt(address user) external onlyOwner {\r\n        userInfo[user].rewardDebt = 0;\r\n    }\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/income/IncomeSharingVaultV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport { IVeDEG } from \"../governance/interfaces/IVeDEG.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n/**\r\n * @title Degis Income Sharing Contract\r\n * @notice This contract will receive part of the income from Degis products\r\n *         And the income will be shared by DEG holders (in the form of veDEG)\r\n *\r\n *         It is designed to be an ever-lasting reward\r\n *\r\n *         At first the reward is USDC.e and later may be transferred to Shield\r\n *         To enter the income sharing vault, you need to lock some veDEG\r\n *             - When your veDEG is locked, it can not be withdrawed\r\n *\r\n *         The reward is distributed per second like a farming pool\r\n *         The income will come from (to be updated)\r\n *             - IncomeMaker: Collect swap fee in naughty price pool\r\n *             - PolicyCore: Collect deposit/redeem fee in policy core\r\n */\r\ncontract IncomeSharingVaultV2 is\r\n    OwnableUpgradeable,\r\n    PausableUpgradeable,\r\n    ReentrancyGuardUpgradeable\r\n{\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    uint256 public constant SCALE = 1e30;\r\n\r\n    uint256 public roundTime;\r\n\r\n    IVeDEG public veDEG;\r\n\r\n    struct PoolInfo {\r\n        bool available;\r\n        address rewardToken;\r\n        uint256 totalAmount;\r\n        uint256 rewardPerSecond;\r\n        uint256 accRewardPerShare;\r\n        uint256 lastRewardTimestamp;\r\n    }\r\n    // Pool Id\r\n    // 1: USDC.e as reward\r\n    // 2: Shield as reward\r\n    mapping(uint256 => PoolInfo) public pools;\r\n\r\n    struct UserInfo {\r\n        uint256 totalAmount;\r\n        uint256 rewardDebt;\r\n    }\r\n    mapping(uint256 => mapping(address => UserInfo)) public users;\r\n\r\n    uint256 public nextPool;\r\n\r\n    mapping(uint256 => uint256) public lastRewardBalance;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event RoundTimeChanged(uint256 oldRoundTime, uint256 newRoundTime);\r\n    event NewRewardPoolStart(uint256 poolId, address rewardToken);\r\n    event RewardSpeedSet(uint256 poolId, uint256 rewardPerSecond);\r\n    event PoolUpdated(uint256 poolId, uint256 accRewardPerSecond);\r\n    event Harvest(address user, uint256 poolId, uint256 amount);\r\n    event Deposit(address user, uint256 poolId, uint256 amount);\r\n    event Withdraw(address user, uint256 poolId, uint256 amount);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Errors ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Errors start with DIS(Degis Income Sharing)\r\n    error DIS__PoolNotAvailable();\r\n    error DIS__ZeroAmount();\r\n    error DIS__NotEnoughVeDEG();\r\n    error DIS__WrongSpeed();\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function initialize(address _veDEG) public initializer {\r\n        __Ownable_init();\r\n        __Pausable_init();\r\n        __ReentrancyGuard_init();\r\n\r\n        veDEG = IVeDEG(_veDEG);\r\n\r\n        nextPool = 1;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Pending reward\r\n     * @param _poolId Pool Id\r\n     * @param _user   User address\r\n     * @return pendingReward Amount of pending reward\r\n     */\r\n    function pendingReward(uint256 _poolId, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        PoolInfo memory pool = pools[_poolId];\r\n\r\n        if (\r\n            pool.lastRewardTimestamp == 0 ||\r\n            block.timestamp < pool.lastRewardTimestamp\r\n        ) return 0;\r\n\r\n        uint256 accRewardPerShare = pool.accRewardPerShare;\r\n\r\n        if (pool.totalAmount == 0) return 0;\r\n        else {\r\n            UserInfo memory user = users[_poolId][_user];\r\n\r\n            uint256 currentRewardBalance = IERC20(pool.rewardToken).balanceOf(\r\n                address(this)\r\n            );\r\n\r\n            if (currentRewardBalance != lastRewardBalance[_poolId]) {\r\n                uint256 newReward = currentRewardBalance -\r\n                    lastRewardBalance[_poolId];\r\n\r\n                accRewardPerShare += (newReward * SCALE) / pool.totalAmount;\r\n            }\r\n            \r\n            uint256 pending = (user.totalAmount * accRewardPerShare) /\r\n                SCALE -\r\n                user.rewardDebt;\r\n\r\n            return pending;\r\n        }\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Set round time\r\n     * @dev Round time is only used for checking reward speed\r\n     * @param _roundTime Round time in seconds\r\n     */\r\n    function setRoundTime(uint256 _roundTime) external onlyOwner {\r\n        emit RoundTimeChanged(roundTime, _roundTime);\r\n        roundTime = _roundTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Start a new income sharing pool\r\n     * @dev Normally there will be two pools\r\n     *          - USDC.e as reward (1)\r\n     *          - Shield as reward (2)\r\n     * @param _rewardToken Reward token address\r\n     */\r\n    function startPool(address _rewardToken) external onlyOwner {\r\n        PoolInfo storage pool = pools[nextPool++];\r\n\r\n        pool.available = true;\r\n        pool.rewardToken = _rewardToken;\r\n\r\n        emit NewRewardPoolStart(nextPool - 1, _rewardToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Set reward speed for a pool\r\n     * @param _poolId Pool id\r\n     * @param _rewardPerSecond Reward speed\r\n     */\r\n    function setRewardSpeed(uint256 _poolId, uint256 _rewardPerSecond)\r\n        external\r\n    {\r\n        updatePool(_poolId);\r\n\r\n        PoolInfo memory pool = pools[_poolId];\r\n\r\n        // Ensure there is enough reward for this round\r\n        if (\r\n            roundTime * _rewardPerSecond >\r\n            IERC20(pool.rewardToken).balanceOf(address(this))\r\n        ) revert DIS__WrongSpeed();\r\n\r\n        pools[_poolId].rewardPerSecond = _rewardPerSecond;\r\n\r\n        emit RewardSpeedSet(_poolId, _rewardPerSecond);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Deposit\r\n     * @param _poolId Pool Id\r\n     * @param _amount Amount of tokens to deposit\r\n     */\r\n    function deposit(uint256 _poolId, uint256 _amount) external nonReentrant {\r\n        if (!pools[_poolId].available) revert DIS__PoolNotAvailable();\r\n        if (_amount == 0) revert DIS__ZeroAmount();\r\n        if (veDEG.balanceOf(msg.sender) < _amount) revert DIS__NotEnoughVeDEG();\r\n\r\n        updatePool(_poolId);\r\n\r\n        // Lock some veDEG to participate\r\n        veDEG.lockVeDEG(msg.sender, _amount);\r\n\r\n        PoolInfo storage pool = pools[_poolId];\r\n        UserInfo storage user = users[_poolId][msg.sender];\r\n\r\n        if (user.totalAmount > 0) {\r\n            uint256 pending = (pool.accRewardPerShare * user.totalAmount) /\r\n                SCALE -\r\n                user.rewardDebt;\r\n\r\n            uint256 reward = _safeRewardTransfer(\r\n                pool.rewardToken,\r\n                msg.sender,\r\n                pending\r\n            );\r\n            lastRewardBalance[_poolId] -= reward;\r\n            emit Harvest(msg.sender, _poolId, reward);\r\n        }\r\n\r\n        // Update pool amount\r\n        pool.totalAmount += _amount;\r\n\r\n        // Update user amount\r\n        user.totalAmount += _amount;\r\n\r\n        user.rewardDebt = (pool.accRewardPerShare * user.totalAmount) / SCALE;\r\n\r\n        emit Deposit(msg.sender, _poolId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all veDEG\r\n     * @param _poolId Pool Id\r\n     */\r\n    function withdrawAll(uint256 _poolId) external {\r\n        withdraw(_poolId, users[_poolId][msg.sender].totalAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the reward from the pool\r\n     * @param _poolId Pool Id\r\n     * @param _amount Amount to withdraw\r\n     */\r\n    function withdraw(uint256 _poolId, uint256 _amount) public nonReentrant {\r\n        if (_amount == 0) revert DIS__ZeroAmount();\r\n\r\n        PoolInfo storage pool = pools[_poolId];\r\n        UserInfo storage user = users[_poolId][msg.sender];\r\n\r\n        if (user.totalAmount < _amount) revert DIS__NotEnoughVeDEG();\r\n\r\n        updatePool(_poolId);\r\n\r\n        uint256 pending = (pool.accRewardPerShare * user.totalAmount) /\r\n            SCALE -\r\n            user.rewardDebt;\r\n\r\n        uint256 reward = _safeRewardTransfer(\r\n            pool.rewardToken,\r\n            msg.sender,\r\n            pending\r\n        );\r\n        lastRewardBalance[_poolId] -= reward;\r\n        emit Harvest(msg.sender, _poolId, reward);\r\n\r\n        // Update user info\r\n        pool.totalAmount -= _amount;\r\n\r\n        user.totalAmount -= _amount;\r\n        user.rewardDebt = (user.totalAmount * pool.accRewardPerShare) / SCALE;\r\n\r\n        // Unlock veDEG\r\n        veDEG.unlockVeDEG(msg.sender, _amount);\r\n\r\n        emit Withdraw(msg.sender, _poolId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Harvest income reward\r\n     * @param _poolId Pool Id\r\n     * @param _to Reward receiver address\r\n     */\r\n    function harvest(uint256 _poolId, address _to)\r\n        public\r\n        nonReentrant\r\n        whenNotPaused\r\n    {\r\n        updatePool(_poolId);\r\n\r\n        PoolInfo memory pool = pools[_poolId];\r\n        UserInfo storage user = users[_poolId][msg.sender];\r\n\r\n        // pending reward\r\n        uint256 pending = (user.totalAmount * pool.accRewardPerShare) /\r\n            SCALE -\r\n            user.rewardDebt;\r\n\r\n        user.rewardDebt = (user.totalAmount * pool.accRewardPerShare) / SCALE;\r\n\r\n        uint256 reward = _safeRewardTransfer(pool.rewardToken, _to, pending);\r\n        lastRewardBalance[_poolId] -= reward;\r\n\r\n        emit Harvest(msg.sender, _poolId, reward);\r\n    }\r\n\r\n    /**\r\n     * @notice Update pool\r\n     * @param _poolId Pool id\r\n     */\r\n    function updatePool(uint256 _poolId) public {\r\n        PoolInfo storage pool = pools[_poolId];\r\n\r\n        if (block.timestamp <= pool.lastRewardTimestamp) return;\r\n\r\n        uint256 totalAmount = pool.totalAmount;\r\n\r\n        // Current reward balance\r\n        uint256 currentRewardBalance = IERC20(pool.rewardToken).balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        if (\r\n            currentRewardBalance == lastRewardBalance[_poolId] ||\r\n            totalAmount == 0\r\n        ) {\r\n            pool.lastRewardTimestamp = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        // New reward received\r\n        uint256 newReward = currentRewardBalance - lastRewardBalance[_poolId];\r\n\r\n        pool.accRewardPerShare += (newReward * SCALE) / totalAmount;\r\n\r\n        pool.lastRewardTimestamp = block.timestamp;\r\n\r\n        lastRewardBalance[_poolId] = currentRewardBalance;\r\n\r\n        emit PoolUpdated(_poolId, pool.accRewardPerShare);\r\n    }\r\n\r\n    function updateLastRewardBalance(uint256 _poolId) external onlyOwner {\r\n        uint256 currentRewardBalance = IERC20(pools[_poolId].rewardToken)\r\n            .balanceOf(address(this));\r\n        lastRewardBalance[_poolId] = currentRewardBalance;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Finish the reward token transfer\r\n     * @dev Safe means not transfer exceeds the balance of contract\r\n     *      Manually change the reward speed\r\n     * @param _to Address to transfer\r\n     * @param _amount Amount to transfer\r\n     * @return realAmount Real amount transferred\r\n     */\r\n    function _safeRewardTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        uint256 balance = IERC20(_token).balanceOf(address(this));\r\n\r\n        if (_amount > balance) {\r\n            IERC20(_token).safeTransfer(_to, balance);\r\n            return balance;\r\n        } else {\r\n            IERC20(_token).safeTransfer(_to, _amount);\r\n            return _amount;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/governance/interfaces/IVeDEG.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./IVeERC20.sol\";\r\n\r\n/**\r\n * @dev Interface of the VeDEG\r\n */\r\ninterface IVeDEG is IVeERC20 {\r\n    function deposit(uint256 _amount) external;\r\n\r\n    function depositMaxTime(uint256 _amount) external;\r\n\r\n    function claim() external;\r\n\r\n    function withdraw(uint256 _amount) external;\r\n\r\n    function lockVeDEG(address _to, uint256 _amount) external;\r\n\r\n    function unlockVeDEG(address _to, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/income/IncomeSharingVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport { IVeDEG } from \"../governance/interfaces/IVeDEG.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n/**\r\n * @title Degis Income Sharing Contract\r\n * @notice This contract will receive part of the income from Degis products\r\n *         And the income will be shared by DEG holders (in the form of veDEG)\r\n *\r\n *         It is designed to be an ever-lasting reward\r\n *\r\n *         At first the reward is USDC.e and later may be transferred to Shield\r\n *         To enter the income sharing vault, you need to lock some veDEG\r\n *             - When your veDEG is locked, it can not be withdrawed\r\n *\r\n *         The reward is distributed per second like a farming pool\r\n *         The income will come from (to be updated)\r\n *             - IncomeMaker: Collect swap fee in naughty price pool\r\n *             - PolicyCore: Collect deposit/redeem fee in policy core\r\n */\r\ncontract IncomeSharingVault is\r\n    OwnableUpgradeable,\r\n    PausableUpgradeable,\r\n    ReentrancyGuardUpgradeable\r\n{\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    uint256 public constant SCALE = 1e30;\r\n\r\n    uint256 public roundTime;\r\n\r\n    IVeDEG public veDEG;\r\n\r\n    struct PoolInfo {\r\n        bool available;\r\n        address rewardToken;\r\n        uint256 totalAmount;\r\n        uint256 rewardPerSecond;\r\n        uint256 accRewardPerShare;\r\n        uint256 lastRewardTimestamp;\r\n    }\r\n    // Pool Id\r\n    // 1: USDC.e as reward\r\n    // 2: Shield as reward\r\n    mapping(uint256 => PoolInfo) public pools;\r\n\r\n    struct UserInfo {\r\n        uint256 totalAmount;\r\n        uint256 rewardDebt;\r\n    }\r\n    mapping(uint256 => mapping(address => UserInfo)) public users;\r\n\r\n    uint256 public nextPool;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event RoundTimeChanged(uint256 oldRoundTime, uint256 newRoundTime);\r\n    event NewRewardPoolStart(uint256 poolId, address rewardToken);\r\n    event RewardSpeedSet(uint256 poolId, uint256 rewardPerSecond);\r\n    event PoolUpdated(uint256 poolId, uint256 accRewardPerSecond);\r\n    event Harvest(address user, uint256 poolId, uint256 amount);\r\n    event Deposit(address user, uint256 poolId, uint256 amount);\r\n    event Withdraw(address user, uint256 poolId, uint256 amount);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Errors ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Errors start with DIS(Degis Income Sharing)\r\n    error DIS__PoolNotAvailable();\r\n    error DIS__ZeroAmount();\r\n    error DIS__NotEnoughVeDEG();\r\n    error DIS__WrongSpeed();\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function initialize(address _veDEG) public initializer {\r\n        __Ownable_init();\r\n        __Pausable_init();\r\n        __ReentrancyGuard_init();\r\n\r\n        veDEG = IVeDEG(_veDEG);\r\n\r\n        nextPool = 1;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Pending reward\r\n     * @param _poolId Pool Id\r\n     * @param _user   User address\r\n     * @return pendingReward Amount of pending reward\r\n     */\r\n    function pendingReward(uint256 _poolId, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        PoolInfo memory pool = pools[_poolId];\r\n\r\n        if (\r\n            pool.lastRewardTimestamp == 0 ||\r\n            block.timestamp < pool.lastRewardTimestamp\r\n        ) return 0;\r\n\r\n        uint256 accRewardPerShare = pool.accRewardPerShare;\r\n\r\n        if (pool.totalAmount == 0) return 0;\r\n        else {\r\n            UserInfo memory user = users[_poolId][_user];\r\n\r\n            uint256 timePassed = block.timestamp - pool.lastRewardTimestamp;\r\n            uint256 reward = timePassed * pool.rewardPerSecond;\r\n\r\n            // Remainging reward inside the pool\r\n            uint256 remainingReward = IERC20(pool.rewardToken).balanceOf(\r\n                address(this)\r\n            );\r\n\r\n            uint256 finalReward = reward > remainingReward\r\n                ? remainingReward\r\n                : reward;\r\n\r\n            accRewardPerShare += (finalReward * SCALE) / pool.totalAmount;\r\n\r\n            uint256 pending = (user.totalAmount * accRewardPerShare) /\r\n                SCALE -\r\n                user.rewardDebt;\r\n\r\n            return pending;\r\n        }\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Set round time\r\n     * @dev Round time is only used for checking reward speed\r\n     * @param _roundTime Round time in seconds\r\n     */\r\n    function setRoundTime(uint256 _roundTime) external onlyOwner {\r\n        emit RoundTimeChanged(roundTime, _roundTime);\r\n        roundTime = _roundTime;\r\n    }\r\n\r\n    /**\r\n     * @notice Start a new income sharing pool\r\n     * @dev Normally there will be two pools\r\n     *          - USDC.e as reward (1)\r\n     *          - Shield as reward (2)\r\n     * @param _rewardToken Reward token address\r\n     */\r\n    function startPool(address _rewardToken) external onlyOwner {\r\n        PoolInfo storage pool = pools[nextPool++];\r\n\r\n        pool.available = true;\r\n        pool.rewardToken = _rewardToken;\r\n\r\n        emit NewRewardPoolStart(nextPool - 1, _rewardToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Set reward speed for a pool\r\n     * @param _poolId Pool id\r\n     * @param _rewardPerSecond Reward speed\r\n     */\r\n    function setRewardSpeed(uint256 _poolId, uint256 _rewardPerSecond)\r\n        external\r\n    {\r\n        updatePool(_poolId);\r\n\r\n        PoolInfo memory pool = pools[_poolId];\r\n\r\n        // Ensure there is enough reward for this round\r\n        if (\r\n            roundTime * _rewardPerSecond >\r\n            IERC20(pool.rewardToken).balanceOf(address(this))\r\n        ) revert DIS__WrongSpeed();\r\n\r\n        pools[_poolId].rewardPerSecond = _rewardPerSecond;\r\n\r\n        emit RewardSpeedSet(_poolId, _rewardPerSecond);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Deposit\r\n     * @param _poolId Pool Id\r\n     * @param _amount Amount of tokens to deposit\r\n     */\r\n    function deposit(uint256 _poolId, uint256 _amount) external nonReentrant {\r\n        if (!pools[_poolId].available) revert DIS__PoolNotAvailable();\r\n        if (_amount == 0) revert DIS__ZeroAmount();\r\n        if (veDEG.balanceOf(msg.sender) < _amount) revert DIS__NotEnoughVeDEG();\r\n\r\n        updatePool(_poolId);\r\n\r\n        // Lock some veDEG to participate\r\n        veDEG.lockVeDEG(msg.sender, _amount);\r\n\r\n        PoolInfo storage pool = pools[_poolId];\r\n        UserInfo storage user = users[_poolId][msg.sender];\r\n\r\n        if (user.totalAmount > 0) {\r\n            uint256 pending = (pool.accRewardPerShare * user.totalAmount) /\r\n                SCALE -\r\n                user.rewardDebt;\r\n\r\n            uint256 reward = _safeRewardTransfer(\r\n                pool.rewardToken,\r\n                msg.sender,\r\n                pending\r\n            );\r\n            emit Harvest(msg.sender, _poolId, reward);\r\n        }\r\n\r\n        // Update pool amount\r\n        pool.totalAmount += _amount;\r\n\r\n        // Update user amount\r\n        user.totalAmount += _amount;\r\n\r\n        user.rewardDebt = (pool.accRewardPerShare * user.totalAmount) / SCALE;\r\n\r\n        emit Deposit(msg.sender, _poolId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all veDEG\r\n     * @param _poolId Pool Id\r\n     */\r\n    function withdrawAll(uint256 _poolId) external {\r\n        withdraw(_poolId, users[_poolId][msg.sender].totalAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the reward from the pool\r\n     * @param _poolId Pool Id\r\n     * @param _amount Amount to withdraw\r\n     */\r\n    function withdraw(uint256 _poolId, uint256 _amount) public nonReentrant {\r\n        if (_amount == 0) revert DIS__ZeroAmount();\r\n\r\n        PoolInfo storage pool = pools[_poolId];\r\n        UserInfo storage user = users[_poolId][msg.sender];\r\n\r\n        if (user.totalAmount < _amount) revert DIS__NotEnoughVeDEG();\r\n\r\n        updatePool(_poolId);\r\n\r\n        uint256 pending = (pool.accRewardPerShare * user.totalAmount) /\r\n            SCALE -\r\n            user.rewardDebt;\r\n\r\n        uint256 reward = _safeRewardTransfer(\r\n            pool.rewardToken,\r\n            msg.sender,\r\n            pending\r\n        );\r\n        emit Harvest(msg.sender, _poolId, reward);\r\n\r\n        // Update user info\r\n        pool.totalAmount -= _amount;\r\n\r\n        user.totalAmount -= _amount;\r\n        user.rewardDebt = (user.totalAmount * pool.accRewardPerShare) / SCALE;\r\n\r\n        // Unlock veDEG\r\n        veDEG.unlockVeDEG(msg.sender, _amount);\r\n\r\n        emit Withdraw(msg.sender, _poolId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Harvest income reward\r\n     * @param _poolId Pool Id\r\n     * @param _to Reward receiver address\r\n     */\r\n    function harvest(uint256 _poolId, address _to)\r\n        public\r\n        nonReentrant\r\n        whenNotPaused\r\n    {\r\n        updatePool(_poolId);\r\n\r\n        PoolInfo memory pool = pools[_poolId];\r\n        UserInfo storage user = users[_poolId][msg.sender];\r\n\r\n        // pending reward\r\n        uint256 pending = (user.totalAmount * pool.accRewardPerShare) /\r\n            SCALE -\r\n            user.rewardDebt;\r\n\r\n        user.rewardDebt = (user.totalAmount * pool.accRewardPerShare) / SCALE;\r\n\r\n        uint256 reward = _safeRewardTransfer(pool.rewardToken, _to, pending);\r\n\r\n        emit Harvest(msg.sender, _poolId, reward);\r\n    }\r\n\r\n    /**\r\n     * @notice Update pool\r\n     * @param _poolId Pool id\r\n     */\r\n    function updatePool(uint256 _poolId) public {\r\n        PoolInfo storage pool = pools[_poolId];\r\n\r\n        if (block.timestamp <= pool.lastRewardTimestamp) return;\r\n\r\n        uint256 totalAmount = pool.totalAmount;\r\n        uint256 rewardPerSecond = pool.rewardPerSecond;\r\n\r\n        if (totalAmount == 0 || rewardPerSecond == 0) {\r\n            pool.lastRewardTimestamp = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        // Time passed in seconds and total rewards\r\n        uint256 timePassed = block.timestamp - pool.lastRewardTimestamp;\r\n        uint256 reward = timePassed * rewardPerSecond;\r\n\r\n        // Remainging reward inside the pool\r\n        uint256 remainingReward = IERC20(pool.rewardToken).balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        // Can not exceed the max balance of the pool\r\n        uint256 finalReward = reward > remainingReward\r\n            ? remainingReward\r\n            : reward;\r\n\r\n        pool.accRewardPerShare += (finalReward * SCALE) / totalAmount;\r\n\r\n        pool.lastRewardTimestamp = block.timestamp;\r\n\r\n        emit PoolUpdated(_poolId, pool.accRewardPerShare);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Finish the reward token transfer\r\n     * @dev Safe means not transfer exceeds the balance of contract\r\n     *      Manually change the reward speed\r\n     * @param _to Address to transfer\r\n     * @param _amount Amount to transfer\r\n     * @return realAmount Real amount transferred\r\n     */\r\n    function _safeRewardTransfer(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        uint256 balance = IERC20(_token).balanceOf(address(this));\r\n\r\n        if (_amount > balance) {\r\n            IERC20(_token).safeTransfer(_to, balance);\r\n            return balance;\r\n        } else {\r\n            IERC20(_token).safeTransfer(_to, _amount);\r\n            return _amount;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/lucky-box/DegisLotteryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./interfaces/IRandomNumberGenerator.sol\";\r\nimport \"./MathLib.sol\";\r\n\r\n/**\r\n * @title DegisLotteryV2\r\n *\r\n * @dev This lottery uses DEG as tickets and DEG as rewards also\r\n *      Users can pay 10 DEG to buy one ticket and choose four digits for each ticket\r\n *      After the lottery was closed, it will draw a final random number through Chainlink VRF\r\n *      Users get rewards according to the how many numbers they matched with the final number\r\n *\r\n *      Reward distribution:\r\n *      80% of each round prize pool will be distributed to the winners (breakdowns for different levels)\r\n *      20% of each round prize pool will be rolled to next round (except for treasury fee)\r\n *\r\n */\r\n\r\ncontract DegisLotteryV2 is ReentrancyGuardUpgradeable, OwnableUpgradeable {\r\n    using MathLib for uint256;\r\n    using MathLib for int128;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constants **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // Treasury fee\r\n    uint256 public constant MAX_TREASURY_FEE = 2000; // 20%\r\n\r\n    // Ticket numbers\r\n    uint32 public constant MIN_TICKET_NUMBER = 10000;\r\n    uint32 public constant MAX_TICKET_NUMBER = 19999;\r\n\r\n    // Default ticket price\r\n    uint256 public constant DEFAULT_PRICE = 10 ether;\r\n\r\n    // 98% for each extra ticket\r\n    uint256 public constant DISCOUNT_DIVISOR = 98;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    IERC20 public DegisToken;\r\n    IRandomNumberGenerator public randomGenerator;\r\n\r\n    // Address to receive treasury fee\r\n    address public treasury;\r\n\r\n    // Current lottery round\r\n    uint256 public currentLotteryId;\r\n\r\n    // Current ticket id (start from 1)\r\n    uint256 public currentTicketId;\r\n\r\n    // Max amount of tickets can be bought each time\r\n    uint256 public maxNumberTicketsEachTime;\r\n\r\n    // Pending reward to be injected to next round\r\n    uint256 public pendingInjectionNextLottery;\r\n\r\n    enum Status {\r\n        Pending, // Default status\r\n        Open, // Lottery is open, before closing\r\n        Close, // Lottery is closed, after closing before drawing final result\r\n        Claimable // Lottery is claimable, after drawing final result\r\n    }\r\n\r\n    struct Lottery {\r\n        // Slot 1\r\n        Status status; // uint8\r\n        uint32 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%\r\n        uint32 startTime;\r\n        uint32 endTime;\r\n        uint32 finalNumber;\r\n        // Slot 2,3...\r\n        uint256 ticketPrice; // 10\r\n        uint256[4] rewardsBreakdown; // 0: 1 matching number // 3: 4 matching numbers\r\n        uint256[4] rewardPerTicketInBracket;\r\n        uint256[4] countWinnersPerBracket;\r\n        uint256 firstTicketId;\r\n        uint256 firstTicketIdNextRound;\r\n        uint256 amountCollected; // Total prize pool\r\n        uint256 pendingRewards; // Rewards that are not yet claimed\r\n    }\r\n    // lotteryId => Lottery Info\r\n    mapping(uint256 => Lottery) public lotteries;\r\n\r\n    struct Ticket {\r\n        uint32 number;\r\n        address owner;\r\n    }\r\n    // Ticket Id => Ticket Info\r\n    mapping(uint256 => Ticket) public tickets;\r\n\r\n    // lotteryId => (Lucky Number => Total Amount of this number)\r\n    // e.g. In lottery round 3, 10 Tickets are sold with \"11234\": 3 => (11234 => 10)\r\n    mapping(uint256 => mapping(uint32 => uint256))\r\n        public _numberTicketsPerLotteryId;\r\n\r\n    // Keep track of user ticket ids for a given lotteryId\r\n    // User Address => Lottery Round => Tickets\r\n    mapping(address => mapping(uint256 => uint256[])) public _userTicketIds;\r\n\r\n    // Calculator for each bracket\r\n    mapping(uint32 => uint32) public _bracketCalculator;\r\n\r\n    // User address => lotteryId => Amount of tickets has claimed\r\n    mapping(address => mapping(uint256 => uint256)) public userClaimed;\r\n\r\n    // Default config parameters\r\n    // With global parameters, lottery operations can be set as auto tasks\r\n    uint256 public treasuryFee;\r\n    uint256[4] public rewardsBreakdown;\r\n    uint256 public roundLength;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event MaxNumberTicketsEachTimeChanged(\r\n        uint256 oldMaxNumber,\r\n        uint256 newMaxNumber\r\n    );\r\n    event RoundLengthChanged(uint256 oldRoundLength, uint256 newRoundLength);\r\n    event TreasuryChanged(address oldTreasury, address newTreasury);\r\n    event AdminTokenRecovery(address token, uint256 amount);\r\n    event LotteryClose(uint256 indexed lotteryId);\r\n    event LotteryInjection(uint256 indexed lotteryId, uint256 injectedAmount);\r\n    event LotteryOpen(\r\n        uint256 indexed lotteryId,\r\n        uint256 startTime,\r\n        uint256 roundLength,\r\n        uint256 priceTicketInDegis,\r\n        uint256[4] rewardsBreakdown,\r\n        uint256 injectedAmount\r\n    );\r\n    event LotteryNumberDrawn(\r\n        uint256 indexed lotteryId,\r\n        uint256 finalNumber,\r\n        uint256 countWinningTickets\r\n    );\r\n\r\n    event NewRandomGenerator(address indexed randomGenerator);\r\n    event TicketsPurchased(\r\n        address indexed buyer,\r\n        uint256 indexed lotteryId,\r\n        uint256 number,\r\n        uint256 totalPrice\r\n    );\r\n    event TicketsClaim(\r\n        address indexed claimer,\r\n        uint256 amount,\r\n        uint256 indexed lotteryId\r\n    );\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Initialize function\r\n     *\r\n     * @dev RandomNumberGenerator must be deployed prior to this contract\r\n     *\r\n     * @param _degis           Address of DEG\r\n     * @param _randomGenerator Address of the RandomGenerator contract used to work with ChainLink VRF\r\n     */\r\n    function initialize(address _degis, address _randomGenerator)\r\n        public\r\n        initializer\r\n    {\r\n        __Ownable_init();\r\n        __ReentrancyGuard_init_unchained();\r\n\r\n        DegisToken = IERC20(_degis);\r\n        randomGenerator = IRandomNumberGenerator(_randomGenerator);\r\n\r\n        // Set default ticket amount each time\r\n        maxNumberTicketsEachTime = 10;\r\n\r\n        // Set default calculator\r\n        _bracketCalculator[0] = 1;\r\n        _bracketCalculator[1] = 11;\r\n        _bracketCalculator[2] = 111;\r\n        _bracketCalculator[3] = 1111;\r\n\r\n        // Ticket id start from 1\r\n        currentTicketId = 1;\r\n\r\n        // Set default rewards breakdown\r\n        rewardsBreakdown[0] = 1000;\r\n        rewardsBreakdown[1] = 2000;\r\n        rewardsBreakdown[2] = 3000;\r\n        rewardsBreakdown[3] = 4000;\r\n\r\n        // Default treasury fee\r\n        // treasuryFee = 500;\r\n\r\n        // Default round length\r\n        roundLength = 3 days;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Only EOA accounts to participate\r\n     */\r\n    modifier notContract() {\r\n        require(!_isContract(msg.sender), \"Contract not allowed\");\r\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get a user's ticekts in a given lottery round\r\n     *\r\n     * @param _wallet    Address to check owned tickets\r\n     * @param _lotteryId Lottery id to check\r\n     *\r\n     * @return ticketIds Ticket ids this user has in this round\r\n     */\r\n    function viewWalletTicketIds(address _wallet, uint256 _lotteryId)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory ticketIds = _userTicketIds[_wallet][_lotteryId];\r\n        return ticketIds;\r\n    }\r\n\r\n    /**\r\n     * @notice View lottery information\r\n     *\r\n     * @param _startId Start lottery id\r\n     * @param _endId   End lottery id\r\n     *\r\n     * @return allLottery Array of lottery information\r\n     */\r\n    function viewAllLottery(uint256 _startId, uint256 _endId)\r\n        external\r\n        view\r\n        returns (Lottery[] memory)\r\n    {\r\n        Lottery[] memory allLottery = new Lottery[](_endId - _startId + 1);\r\n        for (uint256 i = _startId; i <= _endId; i++) {\r\n            allLottery[i - 1] = lotteries[i];\r\n        }\r\n        return allLottery;\r\n    }\r\n\r\n    /**\r\n     * @notice View ticker numbers for an array of ticket ids\r\n     *\r\n     * @param _ticketIds Array of ticketId\r\n     *\r\n     * @return ticketNumbers Array of ticket numbers\r\n     */\r\n    function viewNumbersPerTicketId(uint256[] calldata _ticketIds)\r\n        external\r\n        view\r\n        returns (uint32[] memory)\r\n    {\r\n        uint256 length = _ticketIds.length;\r\n        uint32[] memory ticketNumbers = new uint32[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            ticketNumbers[i] = tickets[_ticketIds[i]].number;\r\n        }\r\n\r\n        return (ticketNumbers);\r\n    }\r\n\r\n    /**\r\n     * @notice View rewards for a given ticket in a given lottery round\r\n     *\r\n     * @dev This function will help to find the highest prize bracket\r\n     *      But this computation is encouraged to be done off-chain\r\n     *      Better to get bracket first and then call \"_calculateRewardsForTicketId()\"\r\n     *\r\n     * @param _lotteryId Lottery round\r\n     * @param _ticketId  Ticket id\r\n     *\r\n     * @return reward Ticket reward\r\n     */\r\n    function viewRewardsForTicketId(uint256 _lotteryId, uint256 _ticketId)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // Check lottery is in claimable status\r\n        if (lotteries[_lotteryId].status != Status.Claimable) {\r\n            return 0;\r\n        }\r\n\r\n        // Check ticketId is within range\r\n        if (\r\n            lotteries[_lotteryId].firstTicketIdNextRound < _ticketId ||\r\n            lotteries[_lotteryId].firstTicketId > _ticketId\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        // Only calculate prize for the highest bracket\r\n        uint32 highestBracket = _getBracket(_lotteryId, _ticketId);\r\n\r\n        return\r\n            _calculateRewardsForTicketId(_lotteryId, _ticketId, highestBracket);\r\n    }\r\n\r\n    /**\r\n     * @notice View user rewards between rounds\r\n     *\r\n     * @param _user       User address\r\n     * @param _startRound Start lottery id\r\n     * @param _endRound   End lottery id\r\n     *\r\n     * @return userRewards Array of user rewards (round as index)\r\n     */\r\n    function viewUserRewards(\r\n        address _user,\r\n        uint256 _startRound,\r\n        uint256 _endRound\r\n    ) external view returns (uint256[] memory userRewards) {\r\n        userRewards = new uint256[](_endRound - _startRound + 1);\r\n\r\n        for (uint256 i = _startRound; i <= _endRound; ) {\r\n            uint256 ticketAmount = _userTicketIds[_user][i].length;\r\n\r\n            if (ticketAmount > 0) {\r\n                uint256[] memory ticketIds = _userTicketIds[_user][i];\r\n\r\n                for (uint256 j; j < ticketAmount; ) {\r\n                    uint256 reward = viewRewardsForTicketId(i, ticketIds[j]);\r\n                    userRewards[i - 1] += reward;\r\n\r\n                    unchecked {\r\n                        ++j;\r\n                    }\r\n                }\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice View reward per ticket in a given round\r\n     *\r\n     * @return rewardPerTicketInBracket  Reward per ticket in a given round\r\n     */\r\n    function viewRewardPerTicketInBracket(uint256 _lotteryId)\r\n        external\r\n        view\r\n        returns (uint256[4] memory)\r\n    {\r\n        return lotteries[_lotteryId].rewardPerTicketInBracket;\r\n    }\r\n\r\n    /**\r\n     * @notice View winner ticket amount for a given lottery round, for each bracket\r\n     *\r\n     * @return countWinnersPerBracket Array of winner ticket amount for each bracket\r\n     */\r\n    function viewWinnerAmount(uint256 _lotteryId)\r\n        external\r\n        view\r\n        returns (uint256[4] memory)\r\n    {\r\n        return lotteries[_lotteryId].countWinnersPerBracket;\r\n    }\r\n\r\n    /**\r\n     * @notice View rewards breakdown for a given lottery round\r\n     */\r\n    function viewRewardsBreakdown(uint256 _lotteryId)\r\n        external\r\n        view\r\n        returns (uint256[4] memory)\r\n    {\r\n        return lotteries[_lotteryId].rewardsBreakdown;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Set max number can buy/claim each time\r\n     *\r\n     * @param _maxNumber Max number each time\r\n     */\r\n    function setMaxNumberTicketsEachTime(uint256 _maxNumber)\r\n        external\r\n        onlyOwner\r\n    {\r\n        emit MaxNumberTicketsEachTimeChanged(\r\n            maxNumberTicketsEachTime,\r\n            _maxNumber\r\n        );\r\n        maxNumberTicketsEachTime = _maxNumber;\r\n    }\r\n\r\n    /**\r\n     * @notice Set treasury wallet address\r\n     *\r\n     * @param _treasury Treasury address\r\n     */\r\n    function setTreasury(address _treasury) external onlyOwner {\r\n        emit TreasuryChanged(treasury, _treasury);\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Set round length\r\n     *\r\n     * @param _length New round length\r\n     */\r\n    function setRoundLength(uint256 _length) external onlyOwner {\r\n        require(_length > 0, \"Zero round length\");\r\n        emit RoundLengthChanged(roundLength, _length);\r\n        roundLength = _length;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Buy tickets for the current lottery round\r\n     *\r\n     * @dev Need to transfer the 4-digit number to a 5-digit number to be used here (+10000)\r\n     *      Can not be called by a smart contract\r\n     *      Can only purchase in the current round\r\n     *      E.g. You are selecting the number of 1-2-3-4 (lowest to highest)\r\n     *           You will need to pass a number \"14321\"\r\n     *\r\n     * @param _ticketNumbers Array of ticket numbers between 10,000 and 19,999\r\n     */\r\n    function buyTickets(uint32[] calldata _ticketNumbers)\r\n        external\r\n        notContract\r\n        nonReentrant\r\n    {\r\n        uint256 amountToBuy = _ticketNumbers.length;\r\n        require(amountToBuy > 0, \"No tickets are being bought\");\r\n        require(amountToBuy <= maxNumberTicketsEachTime, \"Too many tickets\");\r\n\r\n        // Gas savings\r\n        Lottery storage lottery = lotteries[currentLotteryId];\r\n        uint256 currentRound = currentLotteryId;\r\n        require(lottery.status == Status.Open, \"Round not open\");\r\n\r\n        // Calculate the number of DEG to pay\r\n        uint256 degToPay = _calculateTotalPrice(\r\n            lottery.ticketPrice,\r\n            amountToBuy\r\n        );\r\n\r\n        // Transfer degis tokens to this contract\r\n        DegisToken.transferFrom(msg.sender, address(this), degToPay);\r\n\r\n        // Increase prize pool amount\r\n        lotteries[currentRound].amountCollected += degToPay;\r\n\r\n        // Record the tickets bought\r\n        for (uint256 i; i < amountToBuy; ) {\r\n            uint32 currentTicketNumber = _ticketNumbers[i];\r\n\r\n            require(\r\n                (currentTicketNumber >= MIN_TICKET_NUMBER) &&\r\n                    (currentTicketNumber <= MAX_TICKET_NUMBER),\r\n                \"Ticket number is outside range\"\r\n            );\r\n\r\n            // Used when drawing the prize\r\n            ++_numberTicketsPerLotteryId[currentRound][\r\n                1 + (currentTicketNumber % 10)\r\n            ];\r\n            ++_numberTicketsPerLotteryId[currentRound][\r\n                11 + (currentTicketNumber % 100)\r\n            ];\r\n            ++_numberTicketsPerLotteryId[currentRound][\r\n                111 + (currentTicketNumber % 1000)\r\n            ];\r\n            ++_numberTicketsPerLotteryId[currentRound][\r\n                1111 + (currentTicketNumber % 10000)\r\n            ];\r\n\r\n            // Gas savings\r\n            uint256 ticketId = currentTicketId;\r\n\r\n            // Store this ticket number to the user's record\r\n            _userTicketIds[msg.sender][currentRound].push(ticketId);\r\n\r\n            // Store this ticket number to global ticket state\r\n            Ticket storage newTicket = tickets[ticketId];\r\n            newTicket.number = currentTicketNumber;\r\n            newTicket.owner = msg.sender;\r\n\r\n            // Increase total lottery ticket number\r\n            unchecked {\r\n                ++currentTicketId;\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        emit TicketsPurchased(msg.sender, currentRound, amountToBuy, degToPay);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim winning tickets\r\n     *\r\n     * @dev Callable by users only, not contract\r\n     *\r\n     * @param _lotteryId Lottery id\r\n     * @param _ticketIds Array of ticket ids\r\n     * @param _brackets  Bracket / prize level of each ticket\r\n     */\r\n    function claimTickets(\r\n        uint256 _lotteryId,\r\n        uint256[] calldata _ticketIds,\r\n        uint32[] calldata _brackets\r\n    ) external notContract nonReentrant {\r\n        require(\r\n            lotteries[_lotteryId].status == Status.Claimable,\r\n            \"Round not claimable\"\r\n        );\r\n\r\n        uint256 ticketAmount = _ticketIds.length;\r\n        require(ticketAmount == _brackets.length, \"Not same length\");\r\n        require(ticketAmount > 0, \"No tickets\");\r\n        require(\r\n            ticketAmount <= maxNumberTicketsEachTime,\r\n            \"Too many tickets to claim\"\r\n        );\r\n\r\n        uint256 rewardToTransfer;\r\n\r\n        Lottery storage lottery = lotteries[_lotteryId];\r\n\r\n        for (uint256 i; i < ticketAmount; ) {\r\n            uint256 thisTicketId = _ticketIds[i];\r\n\r\n            // Check the ticket id is inside the range\r\n            require(\r\n                thisTicketId >= lottery.firstTicketId,\r\n                \"Ticket id too small\"\r\n            );\r\n            require(\r\n                thisTicketId < lottery.firstTicketIdNextRound,\r\n                \"Ticket id too large\"\r\n            );\r\n\r\n            // Check the ticket is owned by the user and reset this ticket\r\n            // If the owner is zero address, then it has been claimed\r\n            require(\r\n                msg.sender == tickets[thisTicketId].owner,\r\n                \"Not the ticket owner or already claimed\"\r\n            );\r\n            tickets[thisTicketId].owner = address(0);\r\n\r\n            // Can not pass tickets with no prize\r\n            uint256 rewardForTicketId = _calculateRewardsForTicketId(\r\n                _lotteryId,\r\n                thisTicketId,\r\n                _brackets[i]\r\n            );\r\n            // require(rewardForTicketId > 0, \"No prize\");\r\n\r\n            // If not claiming the highest prize, check if the user has a higher prize\r\n            if (_brackets[i] < 3) {\r\n                require(\r\n                    _calculateRewardsForTicketId(\r\n                        _lotteryId,\r\n                        thisTicketId,\r\n                        _brackets[i] + 1\r\n                    ) == 0,\r\n                    \"Only highest prize\"\r\n                );\r\n            }\r\n\r\n            // Increase the reward to transfer\r\n            rewardToTransfer += rewardForTicketId;\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Record the amount has claimed in this round\r\n        userClaimed[msg.sender][_lotteryId] += ticketAmount;\r\n\r\n        // Transfer the prize to the user\r\n        if (rewardToTransfer > 0) {\r\n            lotteries[_lotteryId].pendingRewards -= rewardToTransfer;\r\n\r\n            DegisToken.transfer(msg.sender, rewardToTransfer);\r\n        }\r\n\r\n        emit TicketsClaim(msg.sender, rewardToTransfer, _lotteryId);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim all winning tickets for a lottery round\r\n     *\r\n     * @dev Callable by users only, not contract\r\n     *      Gas cost may be oversized, recommended to get brackets offchain first\r\n     *      Get brackets offchain and call function \"claimTickets\"\r\n     *\r\n     * @param _lotteryId Lottery id\r\n     */\r\n    function claimAllTickets(uint256 _lotteryId)\r\n        external\r\n        notContract\r\n        nonReentrant\r\n    {\r\n        require(\r\n            lotteries[_lotteryId].status == Status.Claimable,\r\n            \"Round not claimable\"\r\n        );\r\n\r\n        uint256 rewardToTransfer;\r\n\r\n        // Gas savings\r\n        uint256 ticketAmount = _userTicketIds[msg.sender][_lotteryId].length;\r\n\r\n        for (uint256 i; i < ticketAmount; ) {\r\n            uint256 thisTicketId = _userTicketIds[msg.sender][_lotteryId][i];\r\n\r\n            require(\r\n                msg.sender == tickets[thisTicketId].owner,\r\n                \"Not the ticket owner\"\r\n            );\r\n            tickets[thisTicketId].owner = address(0);\r\n\r\n            uint32 highestBracket = _getBracket(_lotteryId, thisTicketId);\r\n            if (highestBracket < 4) {\r\n                uint256 rewardForTicketId = _calculateRewardsForTicketId(\r\n                    _lotteryId,\r\n                    thisTicketId,\r\n                    highestBracket\r\n                );\r\n                rewardToTransfer += rewardForTicketId;\r\n            }\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        if (rewardToTransfer > 0) {\r\n            // Transfer the prize to winner\r\n            DegisToken.transfer(msg.sender, rewardToTransfer);\r\n\r\n            lotteries[_lotteryId].pendingRewards -= rewardToTransfer;\r\n        }\r\n        // Record the amount has claimed in this round\r\n        userClaimed[msg.sender][_lotteryId] = ticketAmount;\r\n\r\n        emit TicketsClaim(msg.sender, rewardToTransfer, _lotteryId);\r\n    }\r\n\r\n    /**\r\n     * @notice Start a new lottery round\r\n     */\r\n    function startLottery() external {\r\n        require(\r\n            (currentLotteryId == 0) ||\r\n                (lotteries[currentLotteryId].status == Status.Claimable),\r\n            \"Wrong status\"\r\n        );\r\n\r\n        // Gas savings\r\n        uint256 currentId = ++currentLotteryId;\r\n\r\n        Lottery storage newLottery = lotteries[currentId];\r\n\r\n        newLottery.status = Status.Open;\r\n        newLottery.startTime = uint32(block.timestamp);\r\n        newLottery.endTime = uint32(block.timestamp + roundLength);\r\n        newLottery.ticketPrice = DEFAULT_PRICE;\r\n        newLottery.rewardsBreakdown = rewardsBreakdown;\r\n        newLottery.treasuryFee = uint32(treasuryFee);\r\n        newLottery.amountCollected = pendingInjectionNextLottery;\r\n        newLottery.firstTicketId = currentTicketId;\r\n\r\n        emit LotteryOpen(\r\n            currentId,\r\n            block.timestamp,\r\n            roundLength,\r\n            DEFAULT_PRICE,\r\n            rewardsBreakdown,\r\n            pendingInjectionNextLottery\r\n        );\r\n\r\n        // Clear record for pending injection\r\n        pendingInjectionNextLottery = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Close a lottery\r\n     *\r\n     * @param _lotteryId Lottery round\r\n     */\r\n    function closeLottery(uint256 _lotteryId) external nonReentrant {\r\n        require(\r\n            lotteries[_lotteryId].status == Status.Open,\r\n            \"this lottery is not open currently\"\r\n        );\r\n\r\n        require(\r\n            block.timestamp > lotteries[_lotteryId].endTime,\r\n            \"Not reach end time\"\r\n        );\r\n\r\n        // Request a random number from the generator\r\n        randomGenerator.requestRandomWords();\r\n\r\n        // Update the lottery status to \"Close\"\r\n        lotteries[_lotteryId].status = Status.Close;\r\n\r\n        emit LotteryClose(_lotteryId);\r\n    }\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in Degis for each group,\r\n               and make this lottery claimable (need to wait for the random generator)\r\n     *\r\n     * @param _lotteryId     Lottery round\r\n     * @param _autoInjection Auto inject funds into next lottery\r\n     */\r\n    function drawFinalNumberAndMakeLotteryClaimable(\r\n        uint256 _lotteryId,\r\n        bool _autoInjection\r\n    ) external nonReentrant {\r\n        require(\r\n            lotteries[_lotteryId].status == Status.Close,\r\n            \"Lottery not closed\"\r\n        );\r\n        require(\r\n            _lotteryId == randomGenerator.latestLotteryId(),\r\n            \"Final number not drawn\"\r\n        );\r\n        require(treasury != address(0), \"Treasury is not set\");\r\n\r\n        // Get the final lucky numbers from randomGenerator\r\n        uint32 finalNumber = uint32(randomGenerator.randomResult());\r\n\r\n        Lottery storage lottery = lotteries[_lotteryId];\r\n\r\n        // Gas savings\r\n        uint256 totalPrize = lottery.amountCollected;\r\n\r\n        // Prize distributed to users\r\n        uint256 amountToWinners = (totalPrize * 8000) / 10000;\r\n\r\n        // (20% - treasuryFee) will go to next round\r\n        uint256 amountToNextLottery = (totalPrize *\r\n            (2000 - lottery.treasuryFee)) / 10000;\r\n\r\n        // Remaining part goes to treasury\r\n        uint256 amountToTreasury = totalPrize -\r\n            amountToWinners -\r\n            amountToNextLottery;\r\n\r\n        // Initialize a number to count addresses in all the previous bracket\r\n        // Ensure that a ticket is not counted several times in different brackets\r\n        uint256 numberAddressesInPreviousBracket;\r\n\r\n        // Calculate prizes for each bracket, starting from the highest one\r\n        for (uint32 i; i < 4; ) {\r\n            uint32 j = 3 - i;\r\n\r\n            // Get transformed winning number\r\n            uint32 transformedWinningNumber = _bracketCalculator[j] +\r\n                (finalNumber % (uint32(10)**(j + 1)));\r\n\r\n            // Amount of winning tickets for this number\r\n            uint256 winningAmount = _numberTicketsPerLotteryId[_lotteryId][\r\n                transformedWinningNumber\r\n            ];\r\n\r\n            // Amount of winners for this bracket\r\n            // Remove those already have higher bracket reward\r\n            lottery.countWinnersPerBracket[j] =\r\n                winningAmount -\r\n                numberAddressesInPreviousBracket;\r\n\r\n            // Check if there are winners for this bracket\r\n            if (winningAmount != numberAddressesInPreviousBracket) {\r\n                // B. If rewards at this bracket are > 0, calculate, else, report the numberAddresses from previous bracket\r\n                if (lottery.rewardsBreakdown[j] != 0) {\r\n                    lottery.rewardPerTicketInBracket[j] =\r\n                        ((lottery.rewardsBreakdown[j] * amountToWinners) /\r\n                            (winningAmount -\r\n                                numberAddressesInPreviousBracket)) /\r\n                        10000;\r\n\r\n                    lottery.pendingRewards +=\r\n                        (lottery.rewardsBreakdown[j] * amountToWinners) /\r\n                        10000;\r\n                }\r\n                // No winners, prize added to the amount to withdraw to treasury\r\n            } else {\r\n                lottery.rewardPerTicketInBracket[j] = 0;\r\n                amountToNextLottery +=\r\n                    (lottery.rewardsBreakdown[j] * amountToWinners) /\r\n                    10000;\r\n            }\r\n\r\n            // Update numberAddressesInPreviousBracket\r\n            numberAddressesInPreviousBracket = winningAmount;\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Update internal statuses for this lottery round\r\n        lottery.finalNumber = finalNumber;\r\n        lottery.status = Status.Claimable;\r\n        lottery.firstTicketIdNextRound = currentTicketId;\r\n\r\n        // If auto injection is on, reinject funds into next lottery\r\n        if (_autoInjection) {\r\n            pendingInjectionNextLottery = amountToNextLottery;\r\n        }\r\n\r\n        // Transfer prize to treasury address\r\n        if (amountToTreasury > 0) {\r\n            DegisToken.transfer(treasury, amountToTreasury);\r\n        }\r\n\r\n        emit LotteryNumberDrawn(\r\n            currentLotteryId,\r\n            finalNumber, // final result for this round\r\n            numberAddressesInPreviousBracket // total winners\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Change the random generator contract address\r\n     *\r\n     * @dev The calls to functions are used to verify the new generator implements them properly.\r\n     *      It is necessary to wait for the VRF response before starting a round.\r\n     *\r\n     * @param _randomGeneratorAddress address of the random generator\r\n     */\r\n    function changeRandomGenerator(address _randomGeneratorAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        // We do not change the generator when a round has not been claimable\r\n        require(\r\n            lotteries[currentLotteryId].status == Status.Claimable,\r\n            \"Round not claimable\"\r\n        );\r\n\r\n        // Request a random number from the new generator\r\n        IRandomNumberGenerator(_randomGeneratorAddress).requestRandomWords();\r\n\r\n        // Get the finalNumber based on the randomResult\r\n        IRandomNumberGenerator(_randomGeneratorAddress).randomResult();\r\n\r\n        // Set the new address\r\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\r\n\r\n        emit NewRandomGenerator(_randomGeneratorAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Inject funds\r\n     *\r\n     * @dev Those DEG transferred to this contract but not by this function\r\n     *      will not be counted for prize pools\r\n     *\r\n     * @param _amount DEG amount to inject\r\n     */\r\n    function injectFunds(uint256 _amount) external {\r\n        uint256 currentRound = currentLotteryId;\r\n\r\n        // Only inject when current round is open\r\n        require(\r\n            lotteries[currentRound].status == Status.Open,\r\n            \"Round not open\"\r\n        );\r\n\r\n        // Update the amount collected for this round\r\n        lotteries[currentRound].amountCollected += _amount;\r\n\r\n        // Transfer DEG\r\n        DegisToken.transferFrom(msg.sender, address(this), _amount);\r\n\r\n        emit LotteryInjection(currentRound, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Recover wrong tokens sent to the contract, only by the owner\r\n     *          All tokens except Degis are wrong tokens\r\n     *\r\n     * @param _tokenAddress Address of the token to withdraw\r\n     * @param _tokenAmount  Token amount to withdraw\r\n     */\r\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_tokenAddress != address(DegisToken), \"Cannot be DEGIS token\");\r\n\r\n        IERC20(_tokenAddress).transfer(address(msg.sender), _tokenAmount);\r\n\r\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Calculate total price when buying many tickets\r\n     *         1 ticket = 100%  2 tickets = 98%  3 tickets = 98% * 98 % ...\r\n     *         Maximum discount: 98% ^ 10 ≈ 82%\r\n     *\r\n     * @param _price Ticket price in DEG\r\n     * @param _num   Number of tickets to be bought\r\n     *\r\n     * @return totalPrice Total price in DEG\r\n     */\r\n    function _calculateTotalPrice(uint256 _price, uint256 _num)\r\n        internal\r\n        pure\r\n        returns (uint256 totalPrice)\r\n    {\r\n        if (_num > 1) {\r\n            uint256 discountNum = _num - 1;\r\n\r\n            totalPrice =\r\n                (_price * _num * (DISCOUNT_DIVISOR**discountNum)) /\r\n                100**discountNum;\r\n        } else {\r\n            totalPrice = _price;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice returns highest bracket a ticket number falls into\r\n     *\r\n     * @param _lotteryId Lottery round\r\n     * @param _ticketId  Ticket id\r\n     */\r\n    function _getBracket(uint256 _lotteryId, uint256 _ticketId)\r\n        internal\r\n        view\r\n        returns (uint32 highestBracket)\r\n    {\r\n        uint32 userNumber = tickets[_ticketId].number;\r\n\r\n        // Retrieve the winning number combination\r\n        uint32 finalNumber = lotteries[_lotteryId].finalNumber;\r\n\r\n        // 3 => highest prize\r\n        // 4 => no prize\r\n        highestBracket = 4;\r\n        for (uint32 i = 1; i <= 4; ++i) {\r\n            if (finalNumber % (uint32(10)**i) == userNumber % (uint32(10)**i)) {\r\n                highestBracket = i - 1;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate rewards for a given ticket\r\n     *\r\n     * @param _lotteryId Lottery id\r\n     * @param _ticketId  Ticket id\r\n     * @param _bracket   Bracket for the ticketId to verify the claim and calculate rewards\r\n     */\r\n    function _calculateRewardsForTicketId(\r\n        uint256 _lotteryId,\r\n        uint256 _ticketId,\r\n        uint32 _bracket\r\n    ) internal view returns (uint256) {\r\n        // Retrieve the user number combination from the ticketId\r\n        uint32 userNumber = tickets[_ticketId].number;\r\n\r\n        // Retrieve the winning number combination\r\n        uint32 finalNumber = lotteries[_lotteryId].finalNumber;\r\n\r\n        // Apply transformation to verify the claim provided by the user is true\r\n        uint32 ts = uint32(10)**(_bracket + 1);\r\n\r\n        uint32 transformedWinningNumber = _bracketCalculator[_bracket] +\r\n            (finalNumber % ts);\r\n        uint32 transformedUserNumber = _bracketCalculator[_bracket] +\r\n            (userNumber % ts);\r\n\r\n        // Confirm that the two transformed numbers are the same\r\n        if (transformedWinningNumber == transformedUserNumber) {\r\n            return lotteries[_lotteryId].rewardPerTicketInBracket[_bracket];\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Reverse the ticket number\r\n     *         E.g. User want to buy \"1234\"\r\n     *              The input number will be 11234\r\n     *              The reversed output will be 14321\r\n     *\r\n     * @param _number Input ticket number\r\n     *\r\n     * @return reversedNumber Reversed number + 10000\r\n     */\r\n    function _reverseTicketNumber(uint256 _number)\r\n        public\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        uint256 initNumber = _number - 10**4;\r\n        uint256 singleNumber = 0;\r\n        uint256 reversedNumber;\r\n\r\n        for (uint256 i; i < 4; ) {\r\n            singleNumber = initNumber % 10;\r\n\r\n            reversedNumber = reversedNumber * 10 + singleNumber;\r\n\r\n            initNumber /= 10;\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return uint32(reversedNumber + 10000);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if an address is a contract\r\n     */\r\n    function _isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n"
    },
    "contracts/lucky-box/interfaces/IRandomNumberGenerator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\ninterface IRandomNumberGenerator {\r\n    /**\r\n     * @notice Views random result\r\n     */\r\n    function getRandomNumber() external;\r\n\r\n    function requestRandomWords() external;\r\n\r\n    function randomResult() external view returns (uint256);\r\n\r\n    function latestLotteryId() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/lucky-box/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\nlibrary MathLib {\r\n    /*\r\n     * Minimum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n    /*\r\n     * Maximum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    function log_2(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            int256 msb = 0;\r\n            int256 xc = x;\r\n            if (xc >= 0x10000000000000000) {\r\n                xc >>= 64;\r\n                msb += 64;\r\n            }\r\n            if (xc >= 0x100000000) {\r\n                xc >>= 32;\r\n                msb += 32;\r\n            }\r\n            if (xc >= 0x10000) {\r\n                xc >>= 16;\r\n                msb += 16;\r\n            }\r\n            if (xc >= 0x100) {\r\n                xc >>= 8;\r\n                msb += 8;\r\n            }\r\n            if (xc >= 0x10) {\r\n                xc >>= 4;\r\n                msb += 4;\r\n            }\r\n            if (xc >= 0x4) {\r\n                xc >>= 2;\r\n                msb += 2;\r\n            }\r\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n            int256 result = (msb - 64) << 64;\r\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\r\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n                ux *= ux;\r\n                uint256 b = ux >> 255;\r\n                ux >>= 127 + b;\r\n                result += bit * int256(b);\r\n            }\r\n\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    function mul(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = (int256(x) * y) >> 64;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function fromUInt(uint256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x <= 0x7FFFFFFFFFFFFFFF);\r\n            return int128(int256(x << 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n     * number rounding down.  Revert on underflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return unsigned 64-bit integer number\r\n     */\r\n    function toUInt(int128 x) internal pure returns (uint64) {\r\n        unchecked {\r\n            require(x >= 0);\r\n            return uint64(uint128(x >> 64));\r\n        }\r\n    }\r\n\r\n    function ln(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            return\r\n                int128(\r\n                    int256(\r\n                        (uint256(int256(log_2(x))) *\r\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\r\n                    )\r\n                );\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/lucky-box/DegisLottery.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../utils/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./interfaces/IRandomNumberGenerator.sol\";\r\n\r\ncontract DegisLottery is ReentrancyGuard, Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    IERC20 public DEGToken;\r\n    IERC20 public USDToken;\r\n    IRandomNumberGenerator public randomGenerator;\r\n\r\n    address public operatorAddress;\r\n\r\n    uint256 public constant TICKET_PRICE = 10 ether;\r\n\r\n    struct Tickets {\r\n        mapping(uint256 => uint256) ticketsWeight;\r\n        mapping(uint256 => uint256) ticketsAmount;\r\n    }\r\n    Tickets poolTickets;\r\n    mapping(address => Tickets) usersTickets;\r\n\r\n    enum Status {\r\n        Pending,\r\n        Open,\r\n        Close,\r\n        Claimable\r\n    }\r\n    struct LotteryInfo {\r\n        Status status;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256[4] stageProportion;\r\n        uint256[4] stageReward;\r\n        uint256[4] stageAmount;\r\n        uint256[4] stageWeight;\r\n        uint256 totalRewards;\r\n        uint256 pendingRewards;\r\n        uint256 finalNumber;\r\n    }\r\n    mapping(uint256 => LotteryInfo) public lotteries;\r\n\r\n    uint256 public rewardsToNextLottery;\r\n\r\n    uint256 public allPendingRewards;\r\n\r\n    uint256 public rewardBalance;\r\n\r\n    uint256 public currentLotteryId; // Total Rounds\r\n\r\n    mapping(address => uint256) public checkPoint;\r\n    mapping(address => uint256) public usersTotalRewards;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public usersRewards;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event TicketsPurchase(\r\n        address indexed buyer,\r\n        uint256 indexed lotteryId,\r\n        uint256 totalAmount\r\n    );\r\n    event TicketsRedeem(\r\n        address indexed redeemer,\r\n        uint256 indexed lotteryId,\r\n        uint256 totalAmount\r\n    );\r\n    event LotteryOpen(\r\n        uint256 indexed lotteryId,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        uint256 totalRewards\r\n    );\r\n    event LotteryNumberDrawn(\r\n        uint256 indexed lotteryId,\r\n        uint256 finalNumber,\r\n        uint256 pendingRewards\r\n    );\r\n\r\n    event ReceiveRewards(\r\n        address indexed claimer,\r\n        uint256 amount,\r\n        uint256 indexed lotteryId\r\n    );\r\n\r\n    event LotteryClose(uint256 indexed lotteryId, uint256 timestamp);\r\n\r\n    event LotteryFundInjection(\r\n        uint256 indexed lotteryId,\r\n        uint256 injectedAmount\r\n    );\r\n    event RandomNumberGeneratorChanged(\r\n        address oldGenerator,\r\n        address newGenerator\r\n    );\r\n    event OperatorAddressChanged(address oldOperator, address newOperator);\r\n    event AdminTokenRecovery(address indexed token, uint256 amount);\r\n\r\n    event UpdateBalance(\r\n        uint256 lotteryId,\r\n        uint256 oldBalance,\r\n        uint256 newBalance\r\n    );\r\n\r\n    /**\r\n     * @notice Constructor function\r\n     * @dev RandomNumberGenerator must be deployed prior to this contract\r\n     * @param _DEGTokenAddress Address of the DEG token (for buying tickets)\r\n     * @param _USDTokenAddress Address of the USD token (for prize distribution)\r\n     * @param _randomGeneratorAddress Address of the RandomGenerator contract used to work with ChainLink VRF\r\n     */\r\n    constructor(\r\n        address _DEGTokenAddress,\r\n        address _USDTokenAddress,\r\n        address _randomGeneratorAddress\r\n    ) Ownable(msg.sender) {\r\n        DEGToken = IERC20(_DEGTokenAddress);\r\n        USDToken = IERC20(_USDTokenAddress);\r\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Not contract address\r\n     */\r\n    modifier notContract() {\r\n        require(!_isContract(msg.sender), \"Contract not allowed\");\r\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Only the operator or owner\r\n     */\r\n    modifier onlyOperator() {\r\n        require(\r\n            msg.sender == operatorAddress || msg.sender == owner(),\r\n            \"Not operator or owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function getCurrentRoundWeight() public view returns (uint256) {\r\n        return ((currentLotteryId + 24) * 1000000) / (currentLotteryId + 12);\r\n    }\r\n\r\n    /**\r\n     * @notice Get pool tickets info\r\n     * @dev May be a huge number, avoid reading this frequently\r\n     * @param _startIndex Start number\r\n     * @param _stopIndex Stop number\r\n     * @param _position Which level to check (0, 1, 2, 3), use 0 to check the 4-digit number\r\n     */\r\n    function getPoolTicketsInfo(\r\n        uint256 _startIndex,\r\n        uint256 _stopIndex,\r\n        uint256 _position\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        uint256 length = _stopIndex - _startIndex + 1;\r\n\r\n        uint256[] memory ticketsNumber = new uint256[](length);\r\n        uint256[] memory ticketsAmount = new uint256[](length);\r\n        uint256[] memory ticketsWeight = new uint256[](length);\r\n\r\n        for (uint256 i = _startIndex; i <= _stopIndex; i++) {\r\n            uint256 encodedNumber = _encodeNumber(i, _position);\r\n\r\n            ticketsNumber[i - _startIndex] = i;\r\n            ticketsAmount[i - _startIndex] = poolTickets.ticketsAmount[\r\n                encodedNumber\r\n            ];\r\n            ticketsWeight[i - _startIndex] = poolTickets.ticketsWeight[\r\n                encodedNumber\r\n            ];\r\n        }\r\n        return (ticketsNumber, ticketsAmount, ticketsWeight);\r\n    }\r\n\r\n    /**\r\n     * @notice Get user tickets info\r\n     */\r\n    function getUserTicketsInfo(\r\n        address user,\r\n        uint256 _startIndex,\r\n        uint256 _stopIndex,\r\n        uint256 position\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        uint256 length = _stopIndex - _startIndex + 1;\r\n\r\n        uint256[] memory ticketsNumber = new uint256[](length);\r\n        uint256[] memory ticketsAmount = new uint256[](length);\r\n        uint256[] memory ticketsWeight = new uint256[](length);\r\n\r\n        for (uint256 i = _startIndex; i <= _stopIndex; i++) {\r\n            uint256 encodedNumber = _encodeNumber(i, position);\r\n            ticketsNumber[i - _startIndex] = i;\r\n            ticketsAmount[i - _startIndex] = usersTickets[user].ticketsAmount[\r\n                encodedNumber\r\n            ];\r\n            ticketsWeight[i - _startIndex] = usersTickets[user].ticketsWeight[\r\n                encodedNumber\r\n            ];\r\n        }\r\n        return (ticketsNumber, ticketsAmount, ticketsWeight);\r\n    }\r\n\r\n    /**\r\n     * @notice Get lottery stage info\r\n     */\r\n    function getLotteriesStageInfo(uint256 _lotteryId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory stageProportion,\r\n            uint256[] memory stageReward,\r\n            uint256[] memory stageAmount,\r\n            uint256[] memory stageWeight\r\n        )\r\n    {\r\n        stageProportion = new uint256[](4);\r\n        stageReward = new uint256[](4);\r\n        stageAmount = new uint256[](4);\r\n        stageWeight = new uint256[](4);\r\n\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            stageProportion[i] = lotteries[_lotteryId].stageProportion[i];\r\n            stageReward[i] = lotteries[_lotteryId].stageReward[i];\r\n            stageAmount[i] = lotteries[_lotteryId].stageAmount[i];\r\n            stageWeight[i] = lotteries[_lotteryId].stageWeight[i];\r\n        }\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Set operator address\r\n     * @dev Only callable by the owner\r\n     * @param _operatorAddress address of the operator\r\n     */\r\n    function setOperatorAddress(address _operatorAddress) external onlyOwner {\r\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\r\n\r\n        emit OperatorAddressChanged(operatorAddress, _operatorAddress);\r\n        operatorAddress = _operatorAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set Random Number Generator contract address\r\n     * @dev Only callable by the owner\r\n     * @param _randomNumberGenerator Address of the Random Number Generator contract\r\n     */\r\n    function setRandomNumberGenerator(address _randomNumberGenerator)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _randomNumberGenerator != address(0),\r\n            \"Can not be zero address\"\r\n        );\r\n        emit RandomNumberGeneratorChanged(\r\n            address(randomGenerator),\r\n            _randomNumberGenerator\r\n        );\r\n\r\n        randomGenerator = IRandomNumberGenerator(_randomNumberGenerator);\r\n    }\r\n\r\n    /**\r\n     * @notice Change the end time of current round (only if it was set a wrong number)\r\n     * @dev Normally this function is not needed\r\n     * @param _endTime New end time\r\n     */\r\n    function setEndTime(uint256 _endTime) external onlyOwner {\r\n        uint256 currentId = currentLotteryId;\r\n        require(\r\n            lotteries[currentId].status == Status.Open,\r\n            \"Only change endtime when Lottery open\"\r\n        );\r\n\r\n        lotteries[currentId].endTime = _endTime;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Start the lottery\r\n     * @dev Callable only by operator\r\n     * @param _endTime EndTime of the lottery (UNIX timestamp in s)\r\n     * @param _stageProportion Breakdown of rewards per bracket\r\n     * @dev Stage proportion must sum to 10,000(100 <=> 1)\r\n     */\r\n    function startLottery(\r\n        uint256 _endTime,\r\n        uint256[4] calldata _stageProportion\r\n    ) external onlyOperator {\r\n        require(\r\n            (currentLotteryId == 0) ||\r\n                (lotteries[currentLotteryId].status == Status.Claimable),\r\n            \"Not time to start lottery\"\r\n        );\r\n\r\n        require(\r\n            (_stageProportion[0] +\r\n                _stageProportion[1] +\r\n                _stageProportion[2] +\r\n                _stageProportion[3]) <= 10000,\r\n            \"Total rewards of each bracket should <= 10000\"\r\n        );\r\n\r\n        updateBalance();\r\n\r\n        // gas saving\r\n        uint256 id = ++currentLotteryId;\r\n\r\n        // Do not init those have default values at first\r\n        LotteryInfo storage newLottery = lotteries[id];\r\n        newLottery.status = Status.Open;\r\n        newLottery.startTime = block.timestamp;\r\n        newLottery.endTime = _endTime;\r\n        newLottery.stageProportion = _stageProportion;\r\n        newLottery.totalRewards = rewardsToNextLottery;\r\n\r\n        // First emit the event\r\n        emit LotteryOpen(id, block.timestamp, _endTime, rewardsToNextLottery);\r\n\r\n        // Clear rewards to next lottery\r\n        rewardsToNextLottery = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Close a lottery\r\n     * @dev Callable by any address and need to meet the endtime condition\r\n     * @dev Normally it's automatically called by our contract\r\n     */\r\n    function closeLottery() external nonReentrant {\r\n        updateBalance();\r\n\r\n        // gas saving\r\n        uint256 currentId = currentLotteryId;\r\n\r\n        require(\r\n            lotteries[currentId].status == Status.Open,\r\n            \"Current lottery is not open\"\r\n        );\r\n\r\n        require(\r\n            block.timestamp >= lotteries[currentId].endTime,\r\n            \"Not time to close lottery\"\r\n        );\r\n\r\n        lotteries[currentId].endTime = block.timestamp;\r\n\r\n        // Request a random number from the generator\r\n        // With VRF, the response may need some time to be generated\r\n        randomGenerator.getRandomNumber();\r\n\r\n        // Update the lottery status\r\n        lotteries[currentId].status = Status.Close;\r\n\r\n        emit LotteryClose(currentId, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Buy tickets for the current lottery round\r\n     * @dev Can not be called by a smart contract\r\n     * @param _ticketNumbers array of ticket numbers between 0 and 9999\r\n     * @param _ticketAmounts array of ticket amount\r\n     */\r\n    function buyTickets(\r\n        uint256[] calldata _ticketNumbers,\r\n        uint256[] calldata _ticketAmounts\r\n    ) external notContract nonReentrant {\r\n        require(_ticketNumbers.length != 0, \"No tickets are being bought\");\r\n        require(\r\n            _ticketNumbers.length == _ticketAmounts.length,\r\n            \"Different lengths\"\r\n        );\r\n\r\n        // gas saving\r\n        uint256 currentId = currentLotteryId;\r\n\r\n        require(\r\n            lotteries[currentId].status == Status.Open,\r\n            \"Current lottery is not open\"\r\n        );\r\n\r\n        if (checkPoint[msg.sender] == 0) {\r\n            checkPoint[msg.sender] = currentId;\r\n        }\r\n\r\n        if (checkPoint[msg.sender] < currentId) {\r\n            receiveRewards(currentId - 1);\r\n        }\r\n\r\n        // Get the weight of current round (round is a global content)\r\n        uint256 roundWeight = getCurrentRoundWeight();\r\n\r\n        // Total amount of tickets will be bought\r\n        uint256 totalAmount;\r\n\r\n        for (uint256 i = 0; i < _ticketNumbers.length; i++) {\r\n            _buyTicket(\r\n                poolTickets,\r\n                _ticketNumbers[i],\r\n                _ticketAmounts[i],\r\n                roundWeight * _ticketAmounts[i]\r\n            );\r\n            _buyTicket(\r\n                usersTickets[msg.sender],\r\n                _ticketNumbers[i],\r\n                _ticketAmounts[i],\r\n                roundWeight * _ticketAmounts[i]\r\n            );\r\n            totalAmount += _ticketAmounts[i];\r\n        }\r\n\r\n        // Transfer degis\r\n        DEGToken.safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            totalAmount * TICKET_PRICE\r\n        );\r\n\r\n        emit TicketsPurchase(msg.sender, currentId, totalAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Redeem tickets for all lottery\r\n     * @param _ticketNumbers Array of ticket numbers\r\n     * @dev Callable by users\r\n     */\r\n    function redeemTickets(uint256[] calldata _ticketNumbers)\r\n        external\r\n        notContract\r\n        nonReentrant\r\n    {\r\n        require(_ticketNumbers.length != 0, \"No tickets are being redeem\");\r\n\r\n        uint256 currentId = currentLotteryId;\r\n\r\n        require(\r\n            lotteries[currentId].status == Status.Open,\r\n            \"Sorry, current lottery is not open\"\r\n        );\r\n\r\n        if (checkPoint[msg.sender] < currentId) {\r\n            receiveRewards(currentId - 1);\r\n        }\r\n\r\n        uint256 totalAmount;\r\n        for (uint256 i; i < _ticketNumbers.length; i++) {\r\n            uint256 encodedNumber = _encodeNumber(_ticketNumbers[i], 3);\r\n\r\n            uint256 ticketAmount = usersTickets[msg.sender].ticketsAmount[\r\n                encodedNumber\r\n            ];\r\n            uint256 ticketWeight = usersTickets[msg.sender].ticketsWeight[\r\n                encodedNumber\r\n            ];\r\n            _redeemTicket(\r\n                poolTickets,\r\n                _ticketNumbers[i],\r\n                ticketAmount,\r\n                ticketWeight\r\n            );\r\n            _redeemTicket(\r\n                usersTickets[msg.sender],\r\n                _ticketNumbers[i],\r\n                ticketAmount,\r\n                ticketWeight\r\n            );\r\n            totalAmount += ticketAmount;\r\n        }\r\n\r\n        require(totalAmount != 0, \"No tickets are being redeemed\");\r\n\r\n        DEGToken.safeTransfer(msg.sender, totalAmount * TICKET_PRICE);\r\n\r\n        emit TicketsRedeem(msg.sender, currentId, totalAmount);\r\n    }\r\n\r\n    function updateBalance() public {\r\n        uint256 curBalance = USDToken.balanceOf(address(this));\r\n        uint256 preBalance = rewardBalance;\r\n\r\n        uint256 currentId = currentLotteryId;\r\n\r\n        Status currentStatus = lotteries[currentId].status;\r\n\r\n        if (currentStatus == Status.Open) {\r\n            lotteries[currentId].totalRewards =\r\n                lotteries[currentId].totalRewards +\r\n                curBalance -\r\n                preBalance;\r\n        } else {\r\n            rewardsToNextLottery =\r\n                rewardsToNextLottery +\r\n                curBalance -\r\n                preBalance;\r\n        }\r\n\r\n        rewardBalance = curBalance;\r\n\r\n        emit UpdateBalance(currentId, preBalance, curBalance);\r\n    }\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in DEG for each group,\r\n     *         and make this lottery claimable (need to wait for the random generator)\r\n     * @dev Callable by any address\r\n     */\r\n    function drawLottery() external nonReentrant {\r\n        uint256 currentId = currentLotteryId;\r\n        require(\r\n            lotteries[currentId].status == Status.Close,\r\n            \"this lottery has not closed, you should first close it\"\r\n        );\r\n        require(\r\n            currentId == randomGenerator.latestLotteryId(),\r\n            \"the final number has not been drawn\"\r\n        );\r\n\r\n        updateBalance();\r\n\r\n        // Get the final lucky numbers from randomGenerator\r\n        uint256 finalNumber = randomGenerator.randomResult();\r\n\r\n        uint256 lastAmount;\r\n        uint256 lastWeight;\r\n\r\n        LotteryInfo storage currentLottery = lotteries[currentId];\r\n\r\n        uint256 tempPendingRewards;\r\n\r\n        for (uint256 j = 0; j < 4; j++) {\r\n            uint256 i = 3 - j;\r\n\r\n            uint256 encodedNumber = _encodeNumber(finalNumber, i);\r\n\r\n            currentLottery.stageAmount[i] =\r\n                poolTickets.ticketsAmount[encodedNumber] -\r\n                lastAmount;\r\n            lastAmount = poolTickets.ticketsAmount[encodedNumber];\r\n\r\n            currentLottery.stageWeight[i] =\r\n                poolTickets.ticketsWeight[encodedNumber] -\r\n                lastWeight;\r\n            lastWeight = poolTickets.ticketsWeight[encodedNumber];\r\n\r\n            if (currentLottery.stageAmount[i] == 0)\r\n                currentLottery.stageReward[i] = 0;\r\n            else\r\n                currentLottery.stageReward[i] =\r\n                    (currentLottery.stageProportion[i] *\r\n                        currentLottery.totalRewards) /\r\n                    10000;\r\n\r\n            tempPendingRewards += currentLottery.stageReward[i];\r\n        }\r\n        currentLottery.pendingRewards += tempPendingRewards;\r\n\r\n        rewardsToNextLottery =\r\n            currentLottery.totalRewards -\r\n            currentLottery.pendingRewards;\r\n\r\n        require(\r\n            allPendingRewards + currentLottery.totalRewards <=\r\n                USDToken.balanceOf(address(this)),\r\n            \"Wrong USD amount\"\r\n        );\r\n\r\n        // Update internal statuses for this lottery round\r\n        currentLottery.finalNumber = finalNumber;\r\n        currentLottery.status = Status.Claimable;\r\n\r\n        // Update all pending rewards\r\n        allPendingRewards += currentLottery.pendingRewards;\r\n\r\n        emit LotteryNumberDrawn(\r\n            currentLotteryId,\r\n            finalNumber, // final result for this round\r\n            lotteries[currentLotteryId].pendingRewards\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Receive award from a lottery\r\n     * @param _lotteryId lottery id\r\n     * @param user user address\r\n     */\r\n    function pendingReward(uint256 _lotteryId, address user)\r\n        public\r\n        view\r\n        returns (uint256 reward)\r\n    {\r\n        uint256 lastWeight;\r\n        uint256 finalNumber = lotteries[_lotteryId].finalNumber;\r\n\r\n        for (uint256 j; j < 4; j++) {\r\n            uint256 i = 3 - j;\r\n\r\n            uint256 encodedNumber = _encodeNumber(finalNumber, i);\r\n\r\n            uint256 weight = usersTickets[user].ticketsWeight[encodedNumber] -\r\n                lastWeight;\r\n\r\n            lastWeight += weight;\r\n\r\n            if (lotteries[_lotteryId].stageWeight[i] != 0) {\r\n                reward +=\r\n                    (lotteries[_lotteryId].stageReward[i] * weight) /\r\n                    lotteries[_lotteryId].stageWeight[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Receive all awards from lottery before lottery id\r\n     * @param _lotteryId lottery id\r\n     * @dev Callable by users only, not contract!\r\n     */\r\n    function receiveRewards(uint256 _lotteryId) public notContract {\r\n        require(\r\n            lotteries[_lotteryId].status == Status.Claimable,\r\n            \"This round not claimable\"\r\n        );\r\n\r\n        require(\r\n            checkPoint[msg.sender] <= _lotteryId,\r\n            \"All rewards have been received\"\r\n        );\r\n\r\n        uint256 reward;\r\n\r\n        for (\r\n            uint256 round = checkPoint[msg.sender];\r\n            round <= _lotteryId;\r\n            round++\r\n        ) {\r\n            uint256 roundReward = pendingReward(round, msg.sender);\r\n            reward += roundReward;\r\n\r\n            lotteries[round].pendingRewards -= roundReward;\r\n\r\n            usersRewards[msg.sender][round] = roundReward;\r\n            usersTotalRewards[msg.sender] += roundReward;\r\n        }\r\n        checkPoint[msg.sender] = _lotteryId + 1;\r\n\r\n        allPendingRewards -= reward;\r\n\r\n        // Transfer the prize to winner\r\n        if (reward != 0) {\r\n            USDToken.safeTransfer(msg.sender, reward);\r\n        }\r\n        emit ReceiveRewards(msg.sender, reward, _lotteryId);\r\n    }\r\n\r\n    /**\r\n     * @notice Recover wrong tokens sent to the contract\r\n     * @dev    Only callable by the owner\r\n     * @dev    All tokens except DEG and USD are wrong tokens\r\n     * @param _tokenAddress the address of the token to withdraw\r\n     * @param _tokenAmount token amount to withdraw\r\n     */\r\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_tokenAddress != address(DEGToken), \"Cannot recover DEG token\");\r\n\r\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\r\n\r\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Internal Functions ********************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Update the status to finish buying a ticket\r\n     * @param tickets Tickets to update\r\n     * @param _ticketNumber Original number of the ticket\r\n     * @param _ticketAmount Amount of this number are being bought\r\n     * @param _ticketWeight Weight of this ticket, depends on round\r\n     */\r\n    function _buyTicket(\r\n        Tickets storage tickets,\r\n        uint256 _ticketNumber,\r\n        uint256 _ticketAmount,\r\n        uint256 _ticketWeight\r\n    ) internal {\r\n        for (uint256 i; i < 4; i++) {\r\n            uint256 encodedNumber = _encodeNumber(_ticketNumber, i);\r\n            tickets.ticketsWeight[encodedNumber] += _ticketWeight;\r\n            tickets.ticketsAmount[encodedNumber] += _ticketAmount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update the status to finish redeeming a ticket\r\n     * @param tickets Tickets to update\r\n     * @param _ticketNumber Original number of the ticket\r\n     * @param _ticketAmount Amount of this number are being redeemed\r\n     * @param _ticketWeight Weight of this ticket, depends on round\r\n     */\r\n    function _redeemTicket(\r\n        Tickets storage tickets,\r\n        uint256 _ticketNumber,\r\n        uint256 _ticketAmount,\r\n        uint256 _ticketWeight\r\n    ) internal {\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            uint256 encodedNumber = _encodeNumber(_ticketNumber, i);\r\n            tickets.ticketsWeight[encodedNumber] -= _ticketWeight;\r\n            tickets.ticketsAmount[encodedNumber] -= _ticketAmount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the encoded number form\r\n     * @param _number The original number\r\n     * @param _position The number's position/level (0, 1, 2, 3)\r\n     */\r\n    function _encodeNumber(uint256 _number, uint256 _position)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (_number % (10**(_position + 1))) + _position * 10000;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if an address is a contract\r\n     */\r\n    function _isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function _viewUserTicketAmount(address user, uint256 encodedNumber)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return usersTickets[user].ticketsAmount[encodedNumber];\r\n    }\r\n\r\n    function _viewUserTicketWeight(address user, uint256 encodedNumber)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return usersTickets[user].ticketsWeight[encodedNumber];\r\n    }\r\n\r\n    function viewUserAllTicketsInfo(address user, uint256 maxAmount)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256\r\n        )\r\n    {\r\n        uint256[] memory ticketsNumber = new uint256[](maxAmount);\r\n        uint256[] memory ticketsAmount = new uint256[](maxAmount);\r\n        uint256[] memory ticketsWeight = new uint256[](maxAmount);\r\n\r\n        uint256 amount;\r\n        uint256 number;\r\n        uint256 i0;\r\n        uint256 i1;\r\n        uint256 i2;\r\n        uint256 i3;\r\n\r\n        for (i0; i0 <= 9; i0++) {\r\n            number = i0;\r\n            if (_viewUserTicketAmount(user, _encodeNumber(number, 0)) == 0)\r\n                continue;\r\n            for (i1 = 0; i1 <= 9; i1++) {\r\n                number = i0 + i1 * 10;\r\n                if (_viewUserTicketAmount(user, _encodeNumber(number, 1)) == 0)\r\n                    continue;\r\n                for (i2 = 0; i2 <= 9; i2++) {\r\n                    number = i0 + i1 * 10 + i2 * 100;\r\n                    if (\r\n                        _viewUserTicketAmount(user, _encodeNumber(number, 2)) ==\r\n                        0\r\n                    ) continue;\r\n                    for (i3 = 0; i3 <= 9; i3++) {\r\n                        number = i0 + i1 * 10 + i2 * 100 + i3 * 1000;\r\n                        if (\r\n                            _viewUserTicketAmount(\r\n                                user,\r\n                                _encodeNumber(number, 3)\r\n                            ) == 0\r\n                        ) continue;\r\n                        ticketsNumber[amount] = number;\r\n                        ticketsAmount[amount] = _viewUserTicketAmount(\r\n                            user,\r\n                            _encodeNumber(number, 3)\r\n                        );\r\n                        ticketsWeight[amount] = _viewUserTicketWeight(\r\n                            user,\r\n                            _encodeNumber(number, 3)\r\n                        );\r\n                        amount++;\r\n                        if (amount >= maxAmount)\r\n                            return (\r\n                                ticketsNumber,\r\n                                ticketsAmount,\r\n                                ticketsWeight,\r\n                                amount\r\n                            );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return (ticketsNumber, ticketsAmount, ticketsWeight, amount);\r\n    }\r\n\r\n    function viewUserRewardsInfo(\r\n        address user,\r\n        uint256 _startRound,\r\n        uint256 _endRound\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        require(\r\n            _startRound <= _endRound,\r\n            \"End lottery smaller than start lottery\"\r\n        );\r\n        require(_endRound <= currentLotteryId, \"End lottery round not open\");\r\n\r\n        require(\r\n            lotteries[_endRound].status == Status.Claimable,\r\n            \"this round of lottery are not ready for claiming\"\r\n        );\r\n\r\n        uint256[] memory lotteryIds = new uint256[](\r\n            _endRound - _startRound + 1\r\n        );\r\n        uint256[] memory userRewards = new uint256[](\r\n            _endRound - _startRound + 1\r\n        );\r\n        uint256[] memory userDrawed = new uint256[](\r\n            _endRound - _startRound + 1\r\n        );\r\n        uint256 userStartLotteryId = checkPoint[user];\r\n        for (uint256 i = _startRound; i <= _endRound; i++) {\r\n            lotteryIds[i - _startRound] = i;\r\n            if (i < userStartLotteryId) {\r\n                userDrawed[i - _startRound] = 1;\r\n                userRewards[i - _startRound] = usersRewards[user][i];\r\n            } else {\r\n                userDrawed[i - _startRound] = 0;\r\n                userRewards[i - _startRound] = pendingReward(i, user);\r\n            }\r\n        }\r\n        return (lotteryIds, userRewards, userDrawed);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/TransparentUpgradeableProxy.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\r\n\r\n/**\r\n * @dev This contract implements a proxy that is upgradeable by an admin.\r\n *\r\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\r\n * clashing], which can potentially be used in an attack, this contract uses the\r\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\r\n * things that go hand in hand:\r\n *\r\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\r\n * that call matches one of the admin functions exposed by the proxy itself.\r\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\r\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\r\n * \"admin cannot fallback to proxy target\".\r\n *\r\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\r\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\r\n * to sudden errors when trying to call a function from the proxy implementation.\r\n *\r\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\r\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\r\n */\r\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\r\n    /**\r\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\r\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\r\n     */\r\n    constructor(\r\n        address _logic,\r\n        address admin_,\r\n        bytes memory _data\r\n    ) payable ERC1967Proxy(_logic, _data) {\r\n        assert(\r\n            _ADMIN_SLOT ==\r\n                bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)\r\n        );\r\n        _changeAdmin(admin_);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\r\n     */\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _getAdmin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\r\n     */\r\n    function admin() external ifAdmin returns (address admin_) {\r\n        admin_ = _getAdmin();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\r\n     */\r\n    function implementation()\r\n        external\r\n        ifAdmin\r\n        returns (address implementation_)\r\n    {\r\n        implementation_ = _implementation();\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\r\n     */\r\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\r\n        _changeAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\r\n     */\r\n    function upgradeTo(address newImplementation) external ifAdmin {\r\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\r\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\r\n     * proxied contract.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n        external\r\n        payable\r\n        ifAdmin\r\n    {\r\n        _upgradeToAndCall(newImplementation, data, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _admin() internal view virtual returns (address) {\r\n        return _getAdmin();\r\n    }\r\n\r\n    /**\r\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\r\n     */\r\n    function _beforeFallback() internal virtual override {\r\n        require(\r\n            msg.sender != _getAdmin(),\r\n            \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\"\r\n        );\r\n        super._beforeFallback();\r\n    }\r\n}\r\n"
    },
    "contracts/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/ProxyAdmin.sol)\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./TransparentUpgradeableProxy.sol\";\r\nimport \"../utils/Ownable.sol\";\r\n\r\n/**\r\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\r\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\r\n */\r\ncontract ProxyAdmin is Ownable {\r\n    constructor() Ownable(msg.sender) {}\r\n\r\n    /**\r\n     * @dev Returns the current implementation of `proxy`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function getProxyImplementation(TransparentUpgradeableProxy proxy)\r\n        public\r\n        view\r\n        virtual\r\n        returns (address)\r\n    {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\r\n            hex\"5c60da1b\"\r\n        );\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin of `proxy`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function getProxyAdmin(TransparentUpgradeableProxy proxy)\r\n        public\r\n        view\r\n        virtual\r\n        returns (address)\r\n    {\r\n        // We need to manually run the static call since the getter cannot be flagged as view\r\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\r\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\r\n            hex\"f851a440\"\r\n        );\r\n        require(success);\r\n        return abi.decode(returndata, (address));\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of `proxy` to `newAdmin`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the current admin of `proxy`.\r\n     */\r\n    function changeProxyAdmin(\r\n        TransparentUpgradeableProxy proxy,\r\n        address newAdmin\r\n    ) public virtual onlyOwner {\r\n        proxy.changeAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation)\r\n        public\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        proxy.upgradeTo(implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\r\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - This contract must be the admin of `proxy`.\r\n     */\r\n    function upgradeAndCall(\r\n        TransparentUpgradeableProxy proxy,\r\n        address implementation,\r\n        bytes memory data\r\n    ) public payable virtual onlyOwner {\r\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\r\n    }\r\n}\r\n"
    },
    "contracts/farming/FarmingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport {OwnableWithoutContext} from \"../utils/OwnableWithoutContext.sol\";\r\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport {IDegisToken} from \"../tokens/interfaces/IDegisToken.sol\";\r\nimport {Math} from \"../libraries/Math.sol\";\r\nimport {IVeDEG} from \"../governance/interfaces/IVeDEG.sol\";\r\n\r\n/**\r\n * @title  Farming Pool\r\n * @notice This contract is for LPToken mining on Degis\r\n * @dev    The pool id starts from 1 rather than 0\r\n *         The degis reward is calculated by timestamp rather than block number\r\n *\r\n *         VeDEG will boost the farming speed by having a extra reward type\r\n *         The extra reward is shared by those staking lptokens with veDEG balances\r\n *         Every time the veDEG balance change, the reward will be updated\r\n */\r\ncontract FarmingPool is OwnableWithoutContext, ReentrancyGuard, Pausable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for IDegisToken;\r\n    using Math for uint256;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    string public constant name = \"Degis LP Farming Pool\";\r\n\r\n    // The reward token is degis\r\n    IDegisToken public degis;\r\n\r\n    // The bonus reward depends on veDEG\r\n    IVeDEG public veDEG;\r\n\r\n    // SCALE/Precision used for calculating rewards\r\n    uint256 public constant SCALE = 1e12;\r\n\r\n    // PoolId starts from 1\r\n    uint256 public _nextPoolId;\r\n\r\n    // Farming starts from a certain block timestamp\r\n    // To keep the same with naughty price pools, we change from block numbers to timestamps\r\n    uint256 public startTimestamp;\r\n\r\n    struct PoolInfo {\r\n        address lpToken; // LPToken address\r\n        uint256 basicDegisPerSecond; // Basic Reward speed\r\n        uint256 bonusDegisPerSecond; // Bonus reward speed\r\n        uint256 lastRewardTimestamp; // Last reward timestamp\r\n        uint256 accDegisPerShare; // Accumulated degis per share (for those without veDEG boosting)\r\n        uint256 accDegisPerBonusShare; // Accumulated degis per bonus share (for those with veDEG boosting)\r\n        uint256 totalBonus; // Total bonus factors\r\n    }\r\n    PoolInfo[] public poolList;\r\n\r\n    // lptoken address => poolId\r\n    mapping(address => uint256) public poolMapping;\r\n\r\n    // poolId => alreadyFarming\r\n    mapping(uint256 => bool) public isFarming;\r\n\r\n    struct UserInfo {\r\n        uint256 rewardDebt; // degis reward debt\r\n        uint256 stakingBalance; // the amount of a user's staking in the pool\r\n        uint256 bonus; // user bonus point (by veDEG balance)\r\n    }\r\n    // poolId => userAddress => userInfo\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event StartTimestampChanged(uint256 startTimestamp);\r\n    event Stake(address staker, uint256 poolId, uint256 amount);\r\n    event Withdraw(address staker, uint256 poolId, uint256 amount);\r\n    event Harvest(\r\n        address staker,\r\n        address rewardReceiver,\r\n        uint256 poolId,\r\n        uint256 pendingReward\r\n    );\r\n    event NewPoolAdded(\r\n        address lpToken,\r\n        uint256 basicDegisPerSecond,\r\n        uint256 bonusDegisPerSecond\r\n    );\r\n    event FarmingPoolStarted(uint256 poolId, uint256 timestamp);\r\n    event FarmingPoolStopped(uint256 poolId, uint256 timestamp);\r\n    event DegisRewardChanged(\r\n        uint256 poolId,\r\n        uint256 basicDegisPerSecond,\r\n        uint256 bonusDegisPerSecond\r\n    );\r\n    event PoolUpdated(\r\n        uint256 poolId,\r\n        uint256 accDegisPerShare,\r\n        uint256 accDegisPerBonusShare\r\n    );\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    constructor(address _degis) OwnableWithoutContext(msg.sender) {\r\n        degis = IDegisToken(_degis);\r\n\r\n        // Start from 1\r\n        _nextPoolId = 1;\r\n\r\n        poolList.push(\r\n            PoolInfo({\r\n                lpToken: address(0),\r\n                basicDegisPerSecond: 0,\r\n                bonusDegisPerSecond: 0,\r\n                lastRewardTimestamp: 0,\r\n                accDegisPerShare: 0,\r\n                accDegisPerBonusShare: 0,\r\n                totalBonus: 0\r\n            })\r\n        );\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice The address can not be zero\r\n     */\r\n    modifier notZeroAddress(address _address) {\r\n        require(_address != address(0), \"Zero address\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice The pool is still in farming\r\n     */\r\n    modifier stillFarming(uint256 _poolId) {\r\n        require(isFarming[_poolId], \"Pool is not farming\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** View Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Check the amount of pending degis reward\r\n     * @param _poolId PoolId of this farming pool\r\n     * @param _user User address\r\n     * @return pendingDegisAmount Amount of pending degis\r\n     */\r\n    function pendingDegis(uint256 _poolId, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        PoolInfo memory poolInfo = poolList[_poolId];\r\n\r\n        if (\r\n            poolInfo.lastRewardTimestamp == 0 ||\r\n            block.timestamp < poolInfo.lastRewardTimestamp ||\r\n            block.timestamp < startTimestamp\r\n        ) return 0;\r\n\r\n        UserInfo memory user = userInfo[_poolId][_user];\r\n\r\n        // Total lp token balance\r\n        uint256 lp_balance = IERC20(poolInfo.lpToken).balanceOf(address(this));\r\n\r\n        // Accumulated shares to be calculated\r\n        uint256 accDegisPerShare = poolInfo.accDegisPerShare;\r\n        uint256 accDegisPerBonusShare = poolInfo.accDegisPerBonusShare;\r\n\r\n        if (lp_balance == 0) return 0;\r\n        else {\r\n            // If the pool is still farming, update the info\r\n            if (isFarming[_poolId]) {\r\n                // Deigs amount given to this pool\r\n                uint256 timePassed = block.timestamp -\r\n                    poolInfo.lastRewardTimestamp;\r\n                uint256 basicReward = poolInfo.basicDegisPerSecond * timePassed;\r\n                // Update accDegisPerShare\r\n                // LPToken may have different decimals\r\n                accDegisPerShare += (basicReward * SCALE) / lp_balance;\r\n\r\n                // If there is any bonus reward\r\n                if (poolInfo.totalBonus > 0) {\r\n                    uint256 bonusReward = poolInfo.bonusDegisPerSecond *\r\n                        timePassed;\r\n                    accDegisPerBonusShare +=\r\n                        (bonusReward * SCALE) /\r\n                        poolInfo.totalBonus;\r\n                }\r\n            }\r\n\r\n            // If the pool has stopped, not update the info\r\n            uint256 pending = (user.stakingBalance *\r\n                accDegisPerShare +\r\n                user.bonus *\r\n                accDegisPerBonusShare) /\r\n                SCALE -\r\n                user.rewardDebt;\r\n\r\n            return pending;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total pool list\r\n     * @return pooList Total pool list\r\n     */\r\n    function getPoolList() external view returns (PoolInfo[] memory) {\r\n        return poolList;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a user's balance\r\n     * @param _poolId Id of the pool\r\n     * @param _user User address\r\n     * @return balance User's balance (lpToken)\r\n     */\r\n    function getUserBalance(uint256 _poolId, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return userInfo[_poolId][_user].stakingBalance;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Set Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function setVeDEG(address _veDEG) external onlyOwner {\r\n        veDEG = IVeDEG(_veDEG);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the start block timestamp\r\n     * @param _startTimestamp New start block timestamp\r\n     */\r\n    function setStartTimestamp(uint256 _startTimestamp)\r\n        external\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n        // Can only be set before any pool is added\r\n        require(\r\n            _nextPoolId == 1,\r\n            \"Can not set start timestamp after adding a pool\"\r\n        );\r\n\r\n        startTimestamp = _startTimestamp;\r\n        emit StartTimestampChanged(_startTimestamp);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Main Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Add a new lp into the pool\r\n     * @dev Can only be called by the owner\r\n     *      The reward speed can be 0 and set later by setDegisReward function\r\n     * @param _lpToken LP token address\r\n     * @param _basicDegisPerSecond Basic reward speed(per second) for this new pool\r\n     * @param _bonusDegisPerSecond Bonus reward speed(per second) for this new pool\r\n     * @param _withUpdate Whether update all pools' status\r\n     */\r\n    function add(\r\n        address _lpToken,\r\n        uint256 _basicDegisPerSecond,\r\n        uint256 _bonusDegisPerSecond,\r\n        bool _withUpdate\r\n    ) public notZeroAddress(_lpToken) onlyOwner whenNotPaused {\r\n        // Check if already exists, if the poolId is 0, that means not in the pool\r\n        require(!_alreadyInPool(_lpToken), \"Already in the pool\");\r\n\r\n        if (_bonusDegisPerSecond > 0)\r\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\r\n\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n\r\n        uint256 lastRewardTimestamp = block.timestamp > startTimestamp\r\n            ? block.timestamp\r\n            : startTimestamp;\r\n\r\n        // Push this new pool into the list\r\n        poolList.push(\r\n            PoolInfo({\r\n                lpToken: _lpToken,\r\n                basicDegisPerSecond: _basicDegisPerSecond,\r\n                bonusDegisPerSecond: _bonusDegisPerSecond,\r\n                lastRewardTimestamp: lastRewardTimestamp,\r\n                accDegisPerShare: 0,\r\n                accDegisPerBonusShare: 0,\r\n                totalBonus: 0\r\n            })\r\n        );\r\n\r\n        // Store the poolId and set the farming status to true\r\n        if (_basicDegisPerSecond > 0) isFarming[_nextPoolId] = true;\r\n\r\n        poolMapping[_lpToken] = _nextPoolId++;\r\n\r\n        emit NewPoolAdded(_lpToken, _basicDegisPerSecond, _bonusDegisPerSecond);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the degisPerSecond for a specific pool (set to 0 to stop farming)\r\n     * @param _poolId Id of the farming pool\r\n     * @param _basicDegisPerSecond New basic reward amount per second\r\n     * @param _bonusDegisPerSecond New bonus reward amount per second\r\n     * @param _withUpdate Whether update all pools\r\n     */\r\n    function setDegisReward(\r\n        uint256 _poolId,\r\n        uint256 _basicDegisPerSecond,\r\n        uint256 _bonusDegisPerSecond,\r\n        bool _withUpdate\r\n    ) public onlyOwner whenNotPaused {\r\n        // Ensure there already exists this pool\r\n        require(poolList[_poolId].lastRewardTimestamp != 0, \"Pool not exists\");\r\n\r\n        if (_bonusDegisPerSecond > 0)\r\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\r\n\r\n        if (_withUpdate) massUpdatePools();\r\n        else updatePool(_poolId);\r\n\r\n        // Not farming now + reward > 0 => Restart\r\n        if (isFarming[_poolId] == false && _basicDegisPerSecond > 0) {\r\n            isFarming[_poolId] = true;\r\n            emit FarmingPoolStarted(_poolId, block.timestamp);\r\n        }\r\n\r\n        if (_basicDegisPerSecond == 0) {\r\n            isFarming[_poolId] = false;\r\n            emit FarmingPoolStopped(_poolId, block.timestamp);\r\n        } else {\r\n            poolList[_poolId].basicDegisPerSecond = _basicDegisPerSecond;\r\n            poolList[_poolId].bonusDegisPerSecond = _bonusDegisPerSecond;\r\n            emit DegisRewardChanged(\r\n                _poolId,\r\n                _basicDegisPerSecond,\r\n                _bonusDegisPerSecond\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Stake LP token into the farming pool\r\n     * @dev Can only stake to the pools that are still farming\r\n     * @param _poolId Id of the farming pool\r\n     * @param _amount Staking amount\r\n     */\r\n    function stake(uint256 _poolId, uint256 _amount)\r\n        public\r\n        nonReentrant\r\n        whenNotPaused\r\n        stillFarming(_poolId)\r\n    {\r\n        require(_amount > 0, \"Can not stake zero\");\r\n\r\n        PoolInfo storage pool = poolList[_poolId];\r\n        UserInfo storage user = userInfo[_poolId][msg.sender];\r\n\r\n        // Must update first\r\n        updatePool(_poolId);\r\n\r\n        // First distribute the reward if exists\r\n        if (user.stakingBalance > 0) {\r\n            uint256 pending = (user.stakingBalance *\r\n                pool.accDegisPerShare +\r\n                user.bonus *\r\n                pool.accDegisPerBonusShare) /\r\n                SCALE -\r\n                user.rewardDebt;\r\n\r\n            // Real reward amount\r\n            uint256 reward = _safeDegisTransfer(msg.sender, pending);\r\n            emit Harvest(msg.sender, msg.sender, _poolId, reward);\r\n        }\r\n\r\n        // Actual deposit amount\r\n        uint256 actualAmount = _safeLPTransfer(\r\n            false,\r\n            pool.lpToken,\r\n            msg.sender,\r\n            _amount\r\n        );\r\n\r\n        user.stakingBalance += actualAmount;\r\n\r\n        if (address(veDEG) != address(0)) {\r\n            // Update the user's bonus if veDEG boosting is on\r\n            uint256 oldBonus = user.bonus;\r\n            user.bonus = (user.stakingBalance * veDEG.balanceOf(msg.sender))\r\n                .sqrt();\r\n            // Update the pool's total bonus\r\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\r\n        }\r\n\r\n        user.rewardDebt =\r\n            (user.stakingBalance *\r\n                pool.accDegisPerShare +\r\n                user.bonus *\r\n                pool.accDegisPerBonusShare) /\r\n            SCALE;\r\n\r\n        emit Stake(msg.sender, _poolId, actualAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw lptoken from the pool\r\n     * @param _poolId Id of the farming pool\r\n     * @param _amount Amount of lp tokens to withdraw\r\n     */\r\n    function withdraw(uint256 _poolId, uint256 _amount)\r\n        public\r\n        nonReentrant\r\n        whenNotPaused\r\n    {\r\n        require(_amount > 0, \"Zero amount\");\r\n\r\n        PoolInfo storage pool = poolList[_poolId];\r\n        UserInfo storage user = userInfo[_poolId][msg.sender];\r\n\r\n        require(user.stakingBalance >= _amount, \"Not enough stakingBalance\");\r\n\r\n        // Update if the pool is still farming\r\n        // Users can withdraw even after the pool stopped\r\n        if (isFarming[_poolId]) updatePool(_poolId);\r\n\r\n        uint256 pending = (user.stakingBalance *\r\n            pool.accDegisPerShare +\r\n            user.bonus *\r\n            pool.accDegisPerBonusShare) /\r\n            SCALE -\r\n            user.rewardDebt;\r\n\r\n        uint256 reward = _safeDegisTransfer(msg.sender, pending);\r\n        emit Harvest(msg.sender, msg.sender, _poolId, reward);\r\n\r\n        uint256 actualAmount = _safeLPTransfer(\r\n            true,\r\n            pool.lpToken,\r\n            msg.sender,\r\n            _amount\r\n        );\r\n\r\n        user.stakingBalance -= actualAmount;\r\n\r\n        // Update the user's bonus when veDEG boosting is on\r\n        if (address(veDEG) != address(0)) {\r\n            uint256 oldBonus = user.bonus;\r\n            user.bonus = (user.stakingBalance * veDEG.balanceOf(msg.sender))\r\n                .sqrt();\r\n            // Update the pool's total bonus\r\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\r\n        }\r\n\r\n        user.rewardDebt =\r\n            (user.stakingBalance *\r\n                pool.accDegisPerShare +\r\n                user.bonus *\r\n                pool.accDegisPerBonusShare) /\r\n            SCALE;\r\n\r\n        emit Withdraw(msg.sender, _poolId, actualAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Harvest the degis reward and can be sent to another address\r\n     * @param _poolId Id of the farming pool\r\n     * @param _to Receiver of degis rewards\r\n     */\r\n    function harvest(uint256 _poolId, address _to)\r\n        public\r\n        nonReentrant\r\n        whenNotPaused\r\n    {\r\n        // Only update the pool when it is still in farming\r\n        if (isFarming[_poolId]) updatePool(_poolId);\r\n\r\n        PoolInfo memory pool = poolList[_poolId];\r\n        UserInfo storage user = userInfo[_poolId][msg.sender];\r\n\r\n        uint256 pendingReward = (user.stakingBalance *\r\n            pool.accDegisPerShare +\r\n            user.bonus *\r\n            pool.accDegisPerBonusShare) /\r\n            SCALE -\r\n            user.rewardDebt;\r\n\r\n        require(pendingReward > 0, \"No pending reward\");\r\n\r\n        // Update the reward debt\r\n        user.rewardDebt =\r\n            (user.stakingBalance *\r\n                pool.accDegisPerShare +\r\n                user.bonus *\r\n                pool.accDegisPerBonusShare) /\r\n            SCALE;\r\n\r\n        // Transfer the reward\r\n        uint256 reward = _safeDegisTransfer(_to, pendingReward);\r\n\r\n        emit Harvest(msg.sender, _to, _poolId, reward);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the pool's reward status\r\n     * @param _poolId Id of the farming pool\r\n     */\r\n    function updatePool(uint256 _poolId) public {\r\n        PoolInfo storage pool = poolList[_poolId];\r\n        if (block.timestamp <= pool.lastRewardTimestamp) {\r\n            return;\r\n        }\r\n\r\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\r\n\r\n        // No LP deposited, then just update the lastRewardTimestamp\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardTimestamp = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        uint256 timePassed = block.timestamp - pool.lastRewardTimestamp;\r\n\r\n        uint256 basicReward = timePassed * pool.basicDegisPerSecond;\r\n        uint256 bonusReward = timePassed * pool.bonusDegisPerSecond;\r\n\r\n        pool.accDegisPerShare += (basicReward * SCALE) / lpSupply;\r\n\r\n        if (pool.totalBonus == 0) {\r\n            pool.accDegisPerBonusShare = 0;\r\n        } else {\r\n            pool.accDegisPerBonusShare +=\r\n                (bonusReward * SCALE) /\r\n                pool.totalBonus;\r\n        }\r\n\r\n        // Don't forget to set the farming pool as minter\r\n        degis.mintDegis(address(this), basicReward + bonusReward);\r\n\r\n        pool.lastRewardTimestamp = block.timestamp;\r\n\r\n        emit PoolUpdated(\r\n            _poolId,\r\n            pool.accDegisPerShare,\r\n            pool.accDegisPerBonusShare\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update all farming pools (except for those stopped ones)\r\n     * @dev Can be called by anyone\r\n     *      Only update those active pools\r\n     */\r\n    function massUpdatePools() public {\r\n        uint256 length = poolList.length;\r\n        for (uint256 poolId; poolId < length; poolId++) {\r\n            if (isFarming[poolId] == false) continue;\r\n            else updatePool(poolId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update a user's bonus\r\n     * @dev When veDEG has balance change\r\n     *      Only called by veDEG contract\r\n     * @param _user User address\r\n     * @param _newVeDEGBalance New veDEG balance\r\n     */\r\n    function updateBonus(address _user, uint256 _newVeDEGBalance) external {\r\n        require(msg.sender == address(veDEG), \"Only veDEG contract\");\r\n\r\n        // loop over each pool : beware gas cost!\r\n        uint256 length = poolList.length;\r\n\r\n        for (uint256 poolId; poolId < length; ++poolId) {\r\n            // Skip if the pool is not farming\r\n            if (!isFarming[poolId]) continue;\r\n\r\n            UserInfo storage user = userInfo[poolId][_user];\r\n            // Skip if user doesn't have any deposit in the pool\r\n            if (user.stakingBalance == 0) continue;\r\n\r\n            PoolInfo storage pool = poolList[poolId];\r\n\r\n            // first, update pool\r\n            updatePool(poolId);\r\n\r\n            // get oldFactor\r\n            uint256 oldFactor = user.bonus; // get old factor\r\n            // calculate newFactor\r\n            uint256 newFactor = (_newVeDEGBalance * user.stakingBalance).sqrt();\r\n            // update user factor\r\n            user.bonus = newFactor;\r\n            // update reward debt, take into account newFactor\r\n            user.rewardDebt =\r\n                (user.stakingBalance *\r\n                    pool.accDegisPerShare +\r\n                    newFactor *\r\n                    pool.accDegisPerBonusShare) /\r\n                SCALE;\r\n\r\n            // Update the pool's total bonus\r\n            pool.totalBonus = pool.totalBonus + newFactor - oldFactor;\r\n        }\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ********************************** Internal Functions ********************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Check if a lptoken has been added into the pool before\r\n     * @dev This can also be written as a modifier\r\n     * @param _lpToken LP token address\r\n     * @return _isInPool Wether this lp is already in pool\r\n     */\r\n    function _alreadyInPool(address _lpToken)\r\n        internal\r\n        view\r\n        returns (bool _isInPool)\r\n    {\r\n        uint256 poolId = poolMapping[_lpToken];\r\n\r\n        _isInPool = (poolId != 0) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\r\n     * @param _to User's address\r\n     * @param _amount Amount to transfer\r\n     */\r\n    function _safeDegisTransfer(address _to, uint256 _amount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 poolDegisBalance = degis.balanceOf(address(this));\r\n        require(poolDegisBalance > 0, \"No Degis token in the pool\");\r\n\r\n        if (_amount > poolDegisBalance) {\r\n            degis.safeTransfer(_to, poolDegisBalance);\r\n            return (poolDegisBalance);\r\n        } else {\r\n            degis.safeTransfer(_to, _amount);\r\n            return _amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Finish the transfer of LP Token\r\n     * @dev The lp token may have loss during transfer\r\n     * @param _out Whether the lp token is out\r\n     * @param _lpToken LP token address\r\n     * @param _user User address\r\n     * @param _amount Amount of lp tokens\r\n     */\r\n    function _safeLPTransfer(\r\n        bool _out,\r\n        address _lpToken,\r\n        address _user,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        uint256 poolBalanceBefore = IERC20(_lpToken).balanceOf(address(this));\r\n\r\n        if (_out) IERC20(_lpToken).safeTransfer(_user, _amount);\r\n        else IERC20(_lpToken).safeTransferFrom(_user, address(this), _amount);\r\n\r\n        uint256 poolBalanceAfter = IERC20(_lpToken).balanceOf(address(this));\r\n\r\n        return\r\n            _out\r\n                ? poolBalanceBefore - poolBalanceAfter\r\n                : poolBalanceAfter - poolBalanceBefore;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/governance/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (governance/TimelockController.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\n\r\n/**\r\n * @dev Contract module which acts as a timelocked controller. When set as the\r\n * owner of an `Ownable` smart contract, it enforces a timelock on all\r\n * `onlyOwner` maintenance operations. This gives time for users of the\r\n * controlled contract to exit before a potentially dangerous maintenance\r\n * operation is applied.\r\n *\r\n * By default, this contract is self administered, meaning administration tasks\r\n * have to go through the timelock process. The proposer (resp executor) role\r\n * is in charge of proposing (resp executing) operations. A common use case is\r\n * to position this {TimelockController} as the owner of a smart contract, with\r\n * a multisig or a DAO as the sole proposer.\r\n *\r\n * _Available since v3.3._\r\n */\r\ncontract TimelockController is AccessControl {\r\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\r\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\r\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\r\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\r\n\r\n    mapping(bytes32 => uint256) private _timestamps;\r\n    uint256 private _minDelay;\r\n\r\n    /**\r\n     * @dev Emitted when a call is scheduled as part of operation `id`.\r\n     */\r\n    event CallScheduled(\r\n        bytes32 indexed id,\r\n        uint256 indexed index,\r\n        address target,\r\n        uint256 value,\r\n        bytes data,\r\n        bytes32 predecessor,\r\n        uint256 delay\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a call is performed as part of operation `id`.\r\n     */\r\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\r\n\r\n    /**\r\n     * @dev Emitted when operation `id` is cancelled.\r\n     */\r\n    event Cancelled(bytes32 indexed id);\r\n\r\n    /**\r\n     * @dev Emitted when the minimum delay for future operations is modified.\r\n     */\r\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\r\n\r\n    /**\r\n     * @dev Initializes the contract with a given `minDelay`.\r\n     */\r\n    constructor(\r\n        uint256 minDelay,\r\n        address[] memory proposers,\r\n        address[] memory executors\r\n    ) {\r\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\r\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\r\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\r\n\r\n        // deployer + self administration\r\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\r\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\r\n\r\n        // register proposers\r\n        for (uint256 i = 0; i < proposers.length; ++i) {\r\n            _setupRole(PROPOSER_ROLE, proposers[i]);\r\n        }\r\n\r\n        // register executors\r\n        for (uint256 i = 0; i < executors.length; ++i) {\r\n            _setupRole(EXECUTOR_ROLE, executors[i]);\r\n        }\r\n\r\n        _minDelay = minDelay;\r\n        emit MinDelayChange(0, minDelay);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only by a certain role. In\r\n     * addition to checking the sender's role, `address(0)` 's role is also\r\n     * considered. Granting a role to `address(0)` is equivalent to enabling\r\n     * this role for everyone.\r\n     */\r\n    modifier onlyRoleOrOpenRole(bytes32 role) {\r\n        if (!hasRole(role, address(0))) {\r\n            _checkRole(role, _msgSender());\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @dev Returns whether an id correspond to a registered operation. This\r\n     * includes both Pending, Ready and Done operations.\r\n     */\r\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\r\n        return getTimestamp(id) > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether an operation is pending or not.\r\n     */\r\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\r\n        return getTimestamp(id) > _DONE_TIMESTAMP;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether an operation is ready or not.\r\n     */\r\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\r\n        uint256 timestamp = getTimestamp(id);\r\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether an operation is done or not.\r\n     */\r\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\r\n        return getTimestamp(id) == _DONE_TIMESTAMP;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\r\n     * unset operations, 1 for done operations).\r\n     */\r\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\r\n        return _timestamps[id];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the minimum delay for an operation to become valid.\r\n     *\r\n     * This value can be changed by executing an operation that calls `updateDelay`.\r\n     */\r\n    function getMinDelay() public view virtual returns (uint256 duration) {\r\n        return _minDelay;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the identifier of an operation containing a single\r\n     * transaction.\r\n     */\r\n    function hashOperation(\r\n        address target,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes32 predecessor,\r\n        bytes32 salt\r\n    ) public pure virtual returns (bytes32 hash) {\r\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the identifier of an operation containing a batch of\r\n     * transactions.\r\n     */\r\n    function hashOperationBatch(\r\n        address[] calldata targets,\r\n        uint256[] calldata values,\r\n        bytes[] calldata datas,\r\n        bytes32 predecessor,\r\n        bytes32 salt\r\n    ) public pure virtual returns (bytes32 hash) {\r\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\r\n    }\r\n\r\n    /**\r\n     * @dev Schedule an operation containing a single transaction.\r\n     *\r\n     * Emits a {CallScheduled} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'proposer' role.\r\n     */\r\n    function schedule(\r\n        address target,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes32 predecessor,\r\n        bytes32 salt,\r\n        uint256 delay\r\n    ) public virtual onlyRole(PROPOSER_ROLE) {\r\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\r\n        _schedule(id, delay);\r\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\r\n    }\r\n\r\n    /**\r\n     * @dev Schedule an operation containing a batch of transactions.\r\n     *\r\n     * Emits one {CallScheduled} event per transaction in the batch.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'proposer' role.\r\n     */\r\n    function scheduleBatch(\r\n        address[] calldata targets,\r\n        uint256[] calldata values,\r\n        bytes[] calldata datas,\r\n        bytes32 predecessor,\r\n        bytes32 salt,\r\n        uint256 delay\r\n    ) public virtual onlyRole(PROPOSER_ROLE) {\r\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\r\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\r\n\r\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\r\n        _schedule(id, delay);\r\n        for (uint256 i = 0; i < targets.length; ++i) {\r\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Schedule an operation that is to becomes valid after a given delay.\r\n     */\r\n    function _schedule(bytes32 id, uint256 delay) private {\r\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\r\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\r\n        _timestamps[id] = block.timestamp + delay;\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel an operation.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'proposer' role.\r\n     */\r\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\r\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\r\n        delete _timestamps[id];\r\n\r\n        emit Cancelled(id);\r\n    }\r\n\r\n    /**\r\n     * @dev Execute an (ready) operation containing a single transaction.\r\n     *\r\n     * Emits a {CallExecuted} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'executor' role.\r\n     */\r\n    function execute(\r\n        address target,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes32 predecessor,\r\n        bytes32 salt\r\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\r\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\r\n        _beforeCall(id, predecessor);\r\n        _call(id, 0, target, value, data);\r\n        _afterCall(id);\r\n    }\r\n\r\n    /**\r\n     * @dev Execute an (ready) operation containing a batch of transactions.\r\n     *\r\n     * Emits one {CallExecuted} event per transaction in the batch.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'executor' role.\r\n     */\r\n    function executeBatch(\r\n        address[] calldata targets,\r\n        uint256[] calldata values,\r\n        bytes[] calldata datas,\r\n        bytes32 predecessor,\r\n        bytes32 salt\r\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\r\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\r\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\r\n\r\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\r\n        _beforeCall(id, predecessor);\r\n        for (uint256 i = 0; i < targets.length; ++i) {\r\n            _call(id, i, targets[i], values[i], datas[i]);\r\n        }\r\n        _afterCall(id);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks before execution of an operation's calls.\r\n     */\r\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\r\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\r\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\r\n    }\r\n\r\n    /**\r\n     * @dev Checks after execution of an operation's calls.\r\n     */\r\n    function _afterCall(bytes32 id) private {\r\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\r\n        _timestamps[id] = _DONE_TIMESTAMP;\r\n    }\r\n\r\n    /**\r\n     * @dev Execute an operation's call.\r\n     *\r\n     * Emits a {CallExecuted} event.\r\n     */\r\n    function _call(\r\n        bytes32 id,\r\n        uint256 index,\r\n        address target,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) private {\r\n        (bool success, ) = target.call{value: value}(data);\r\n        require(success, \"TimelockController: underlying transaction reverted\");\r\n\r\n        emit CallExecuted(id, index, target, value, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the minimum timelock duration for future operations.\r\n     *\r\n     * Emits a {MinDelayChange} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\r\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\r\n     */\r\n    function updateDelay(uint256 newDelay) external virtual {\r\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\r\n        emit MinDelayChange(_minDelay, newDelay);\r\n        _minDelay = newDelay;\r\n    }\r\n}\r\n"
    },
    "contracts/farming/PurchaseIncentiveVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\npragma solidity ^0.8.10;\r\n\r\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../tokens/interfaces/IDegisToken.sol\";\r\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport \"hardhat/console.sol\";\r\n/**\r\n * @title  Purchase Incentive Vault\r\n * @notice This is the purchase incentive vault for staking buyer tokens\r\n *         Users first stake their buyer tokens and wait for distribution\r\n *         About every 24 hours, the reward will be calculated to users' account\r\n *         After disrtribution, reward will be updated\r\n *              but it still need to be manually claimed.\r\n *\r\n *         Buyer tokens can only be used once\r\n *         You can withdraw your buyer token within the same round (current round)\r\n *         They can not be withdrawed if the round was settled\r\n */\r\ncontract PurchaseIncentiveVault is\r\n    OwnableUpgradeable,\r\n    PausableUpgradeable,\r\n    ReentrancyGuardUpgradeable\r\n{\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    string public constant name = \"Degis Purchase Incentive Vault\";\r\n\r\n    // Buyer Token & Degis Token SCALE = 1e18\r\n    uint256 public constant SCALE = 1e18;\r\n\r\n    // Other contracts\r\n    IERC20 buyerToken;\r\n    IDegisToken degis;\r\n\r\n    // Current round number\r\n    uint256 public currentRound;\r\n\r\n    // Degis reward per round\r\n    uint256 public degisPerRound;\r\n\r\n    // The interval will only limit the distribution (not the staking)\r\n    uint256 public distributionInterval;\r\n\r\n    // Last distribution block\r\n    uint256 public lastDistribution;\r\n\r\n    // Max round for one claim\r\n    // When upgrade this parameter, redeploy the contract\r\n    uint256 public constant MAX_ROUND = 50;\r\n\r\n    struct RoundInfo {\r\n        uint256 shares;\r\n        address[] users;\r\n        bool hasDistributed;\r\n        uint256 degisPerShare;\r\n    }\r\n    mapping(uint256 => RoundInfo) public rounds;\r\n\r\n    struct UserInfo {\r\n        uint256 lastRewardRoundIndex;\r\n        uint256[] pendingRounds;\r\n    }\r\n    mapping(address => UserInfo) public users;\r\n\r\n    // User address => Round number => User shares\r\n    mapping(address => mapping(uint256 => uint256)) public userSharesInRound;\r\n\r\n    uint256[] threshold;\r\n    uint256[] piecewise;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event DegisRewardChanged(\r\n        uint256 oldRewardPerRound,\r\n        uint256 newRewardPerRound\r\n    );\r\n    event DistributionIntervalChanged(uint256 oldInterval, uint256 newInterval);\r\n    event Stake(\r\n        address userAddress,\r\n        uint256 currentRound,\r\n        uint256 actualAmount\r\n    );\r\n    event Redeem(address userAddress, uint256 currentRound, uint256 amount);\r\n    event RewardClaimed(address userAddress, uint256 userReward);\r\n    event RoundSettled(uint256 currentRound, uint256 blockNumber);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Errors ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    error PIV__NotPassedInterval();\r\n    error PIV__ZeroAmount();\r\n    error PIV__NotEnoughBuyerTokens();\r\n    error PIV__AlreadyDistributed();\r\n    error PIV__NoPendingRound();\r\n    error PIV__ClaimedAll();\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function initialize(address _buyerToken, address _degisToken)\r\n        public\r\n        initializer\r\n    {\r\n        __Ownable_init();\r\n        __Pausable_init();\r\n        __ReentrancyGuard_init();\r\n\r\n        // Initialize two tokens\r\n        buyerToken = IERC20(_buyerToken);\r\n        degis = IDegisToken(_degisToken);\r\n\r\n        // Initialize the last distribution time\r\n        lastDistribution = block.timestamp;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Check if admins can distribute now\r\n     * @dev Should pass the distribution interval\r\n     */\r\n    modifier hasPassedInterval() {\r\n        if (block.timestamp - lastDistribution <= distributionInterval)\r\n            revert PIV__NotPassedInterval();\r\n\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get the amount of users in _round, used for distribution\r\n     * @param _round Round number to check\r\n     * @return totalUsers Total amount of users in _round\r\n     */\r\n    function getTotalUsersInRound(uint256 _round)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return rounds[_round].users.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the user addresses in _round\r\n     * @param _round Round number to check\r\n     * @return users All user addresses in this round\r\n     */\r\n    function getUsersInRound(uint256 _round)\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return rounds[_round].users;\r\n    }\r\n\r\n    /**\r\n     * @notice Get user's pending rounds\r\n     * @param _user User address to check\r\n     * @return pendingRounds User's pending rounds\r\n     */\r\n    function getUserPendingRounds(address _user)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return users[_user].pendingRounds;\r\n    }\r\n\r\n    /**\r\n     * @notice Get your shares in the current round\r\n     * @param _user Address of the user\r\n     * @param _round Round number\r\n     * @return userShares User's shares in the current round\r\n     */\r\n    function getUserShares(address _user, uint256 _round)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return userSharesInRound[_user][_round];\r\n    }\r\n\r\n    /**\r\n     * @notice Get a user's pending reward\r\n     * @param _user User address\r\n     * @return userPendingReward User's pending reward\r\n     */\r\n    function pendingReward(address _user)\r\n        external\r\n        view\r\n        returns (uint256 userPendingReward)\r\n    {\r\n        UserInfo memory user = users[_user];\r\n\r\n        // Total rounds that need to be distributed\r\n        uint256 length = user.pendingRounds.length - user.lastRewardRoundIndex;\r\n\r\n        // Start from last reward round index\r\n        uint256 startIndex = user.lastRewardRoundIndex;\r\n\r\n        for (uint256 i = startIndex; i < startIndex + length; i++) {\r\n            uint256 round = user.pendingRounds[i];\r\n\r\n            userPendingReward +=\r\n                (rounds[round].degisPerShare *\r\n                    userSharesInRound[_user][round]) /\r\n                SCALE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get degis reward per round\r\n     * @dev Depends on the total shares in this round\r\n     * @return rewardPerRound Degis reward per round\r\n     */\r\n    function getRewardPerRound() public view returns (uint256 rewardPerRound) {\r\n        uint256 buyerBalance = rounds[currentRound].shares;\r\n\r\n        uint256[] memory thresholdM = threshold;\r\n\r\n        // If no piecewise is set, use the default degisPerRound\r\n        if (thresholdM.length == 0) rewardPerRound = degisPerRound;\r\n        else {\r\n            for (uint256 i = thresholdM.length - 1; i >= 0; ) {\r\n                if (buyerBalance >= thresholdM[i]) {\r\n                    rewardPerRound = piecewise[i];\r\n                    break;\r\n                }\r\n                unchecked {\r\n                    --i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function pause() external onlyOwner {\r\n        super._pause();\r\n    }\r\n\r\n    function unpause() external onlyOwner {\r\n        super._unpause();\r\n    }\r\n\r\n    /**\r\n     * @notice Set degis distribution per round\r\n     * @param _degisPerRound Degis distribution per round\r\n     */\r\n    function setDegisPerRound(uint256 _degisPerRound) external onlyOwner {\r\n        emit DegisRewardChanged(degisPerRound, _degisPerRound);\r\n        degisPerRound = _degisPerRound;\r\n    }\r\n\r\n    /**\r\n     * @notice Set a new distribution interval\r\n     * @param _newInterval The new interval\r\n     */\r\n    function setDistributionInterval(uint256 _newInterval) external onlyOwner {\r\n        emit DistributionIntervalChanged(distributionInterval, _newInterval);\r\n        distributionInterval = _newInterval;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the threshold and piecewise reward\r\n     * @param _threshold The threshold\r\n     * @param _reward The piecewise reward\r\n     */\r\n    function setPiecewise(\r\n        uint256[] calldata _threshold,\r\n        uint256[] calldata _reward\r\n    ) external onlyOwner {\r\n        threshold = _threshold;\r\n        piecewise = _reward;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Stake buyer tokens into this contract\r\n     * @param _amount Amount of buyer tokens to stake\r\n     */\r\n    function stake(uint256 _amount) external nonReentrant whenNotPaused {\r\n        if (_amount == 0) revert PIV__ZeroAmount();\r\n\r\n        // Save gas\r\n        uint256 round = currentRound;\r\n\r\n        // User info of msg.sender\r\n        UserInfo storage user = users[msg.sender];\r\n\r\n        // If the user has not staked in this round, record this new user to the users array\r\n        if (userSharesInRound[msg.sender][round] == 0) {\r\n            rounds[round].users.push(msg.sender);\r\n        }\r\n\r\n        userSharesInRound[msg.sender][round] += _amount;\r\n\r\n        uint256 length = user.pendingRounds.length;\r\n        // Only add the round if it's not in the array\r\n        // Condition 1: length == 0 => no pending rounds => add this round\r\n        // Condition 2: length != 0 && last pending round is not the current round => add this round\r\n        if (\r\n            length == 0 ||\r\n            (length != 0 && user.pendingRounds[length - 1] != round)\r\n        ) user.pendingRounds.push(round);\r\n\r\n        // Update the total shares\r\n        rounds[round].shares += _amount;\r\n\r\n        // Finish the token transfer (need approval)\r\n        buyerToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        emit Stake(msg.sender, round, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Redeem buyer token from the vault\r\n     * @param _amount Amount to redeem\r\n     */\r\n    function redeem(uint256 _amount) external nonReentrant whenNotPaused {\r\n        if (_amount == 0) revert PIV__ZeroAmount();\r\n\r\n        uint256 round = currentRound;\r\n\r\n        uint256 userBalance = userSharesInRound[msg.sender][round];\r\n        if (userBalance < _amount) revert PIV__NotEnoughBuyerTokens();\r\n\r\n        userSharesInRound[msg.sender][round] -= _amount;\r\n\r\n        // If redeem all buyer tokens, remove this round from the user's pending rounds\r\n        if (userSharesInRound[msg.sender][round] == 0) {\r\n            users[msg.sender].pendingRounds.pop();\r\n        }\r\n\r\n        rounds[round].shares -= _amount;\r\n\r\n        // Finish the buyer token transfer\r\n        buyerToken.safeTransfer(msg.sender, _amount);\r\n\r\n        emit Redeem(msg.sender, round, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Setttle the current round\r\n     * @dev Callable by any address, must pass the distribution interval\r\n     */\r\n    function settleCurrentRound() external hasPassedInterval whenNotPaused {\r\n        RoundInfo storage info = rounds[currentRound];\r\n        if (info.hasDistributed) revert PIV__AlreadyDistributed();\r\n\r\n        uint256 totalShares = info.shares;\r\n        uint256 totalReward = getRewardPerRound();\r\n\r\n        // If no one staked, no reward\r\n        if (totalShares == 0) info.degisPerShare = 0;\r\n        else info.degisPerShare = (totalReward * SCALE) / totalShares;\r\n\r\n        info.hasDistributed = true;\r\n\r\n        emit RoundSettled(currentRound, block.timestamp);\r\n\r\n        // Update current round, ++ save little gas\r\n        ++currentRound;\r\n\r\n        // Update last distribution time\r\n        lastDistribution = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice User can claim his own reward\r\n     */\r\n    function claim() external nonReentrant whenNotPaused {\r\n        UserInfo memory user = users[msg.sender];\r\n\r\n        if (user.pendingRounds.length == 0) revert PIV__NoPendingRound();\r\n\r\n        uint256 roundsToClaim = user.pendingRounds.length -\r\n            user.lastRewardRoundIndex;\r\n\r\n        if (roundsToClaim == 0) revert PIV__ClaimedAll();\r\n\r\n        if (user.pendingRounds[user.pendingRounds.length - 1] == currentRound) {\r\n            roundsToClaim -= 1;\r\n        }\r\n\r\n        uint256 startIndex = user.lastRewardRoundIndex;\r\n\r\n        // MAX_ROUND to claim each time\r\n        if (roundsToClaim > MAX_ROUND) {\r\n            roundsToClaim = MAX_ROUND;\r\n            users[msg.sender].lastRewardRoundIndex += MAX_ROUND;\r\n        } else users[msg.sender].lastRewardRoundIndex += roundsToClaim;\r\n\r\n        uint256 userPendingReward;\r\n        \r\n\r\n        for (uint256 i = startIndex; i < startIndex + roundsToClaim;) {\r\n            uint256 round = user.pendingRounds[i];\r\n\r\n            userPendingReward +=\r\n                (rounds[round].degisPerShare *\r\n                    userSharesInRound[msg.sender][round]) /\r\n                SCALE;\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Mint reward to user\r\n        degis.mintDegis(msg.sender, userPendingReward);\r\n    }\r\n}\r\n"
    },
    "contracts/proxy/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init(address _initialOwner) internal onlyInitializing {\r\n        __Ownable_init_unchained(_initialOwner);\r\n    }\r\n\r\n    function __Ownable_init_unchained(address _initialOwner)\r\n        internal\r\n        onlyInitializing\r\n    {\r\n        _transferOwnership(_initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n"
    },
    "contracts/farming/FarmingPoolUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\npragma solidity ^0.8.10;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\r\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport { IDegisToken } from \"../tokens/interfaces/IDegisToken.sol\";\r\nimport { Math } from \"../libraries/Math.sol\";\r\nimport { IVeDEG } from \"../governance/interfaces/IVeDEG.sol\";\r\nimport { IDoubleRewarder } from \"./interfaces/IDoubleRewarder.sol\";\r\n\r\n/**\r\n * @title  Farming Pool\r\n * @notice This contract is for LPToken mining on Degis\r\n * @dev    The pool id starts from 1 rather than 0\r\n *         The degis reward is calculated by timestamp rather than block number\r\n *\r\n *         VeDEG will boost the farming speed by having a extra reward type\r\n *         The extra reward is shared by those staking lptokens with veDEG balances\r\n *         Every time the veDEG balance change, the reward will be updated\r\n *\r\n *         The basic reward depends on the liquidity inside the pool (optional)\r\n *         Update with a piecewise function\r\n *         liquidity amount:   |---------------|------------------|----------------\r\n *                             0           threshold 1        threshold 2\r\n *          reward speed:            speed1          speed2             speed3\r\n *\r\n *         The speed update will be updated one tx after the last tx that triggers the threshold\r\n *         The reward update will be another one tx later\r\n *\r\n *         This piecewise-style reward can be used or not for each pool to decide\r\n *         Ways to start pools: 1) set the basic reward to >0 2) set the piecewise and threshold to >0\r\n *                 stop pools: 1) set the basic reward to 0 2) set the piecewise and threshold to 0\r\n *\r\n *         Double Reward\r\n *\r\n */\r\ncontract FarmingPoolUpgradeable is\r\n    Initializable,\r\n    OwnableUpgradeable,\r\n    ReentrancyGuardUpgradeable,\r\n    PausableUpgradeable\r\n{\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for IDegisToken;\r\n    using Math for uint256;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    string public constant name = \"Degis LP Farming Pool\";\r\n\r\n    // The reward token is degis\r\n    IDegisToken public degis;\r\n\r\n    // The bonus reward depends on veDEG\r\n    IVeDEG public veDEG;\r\n\r\n    // SCALE/Precision used for calculating rewards\r\n    uint256 public constant SCALE = 1e12;\r\n\r\n    // PoolId starts from 1\r\n    uint256 public _nextPoolId;\r\n\r\n    // Farming starts from a certain block timestamp\r\n    // To keep the same with naughty price pools, we change from block numbers to timestamps\r\n    uint256 public startTimestamp;\r\n\r\n    struct PoolInfo {\r\n        address lpToken; // LPToken address\r\n        uint256 basicDegisPerSecond; // Basic Reward speed\r\n        uint256 bonusDegisPerSecond; // Bonus reward speed\r\n        uint256 lastRewardTimestamp; // Last reward timestamp\r\n        uint256 accDegisPerShare; // Accumulated degis per share (for those without veDEG boosting)\r\n        uint256 accDegisPerBonusShare; // Accumulated degis per bonus share (for those with veDEG boosting)\r\n        uint256 totalBonus; // Total bonus factors\r\n    }\r\n    PoolInfo[] public poolList;\r\n\r\n    // lptoken address => poolId\r\n    mapping(address => uint256) public poolMapping;\r\n\r\n    // poolId => alreadyFarming\r\n    mapping(uint256 => bool) public isFarming;\r\n\r\n    struct UserInfo {\r\n        uint256 rewardDebt; // degis reward debt\r\n        uint256 stakingBalance; // the amount of a user's staking in the pool\r\n        uint256 bonus; // user bonus point (by veDEG balance)\r\n    }\r\n    // poolId => userAddress => userInfo\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n    // Extra claimable balance when updating bonus from veDEG\r\n    mapping(uint256 => mapping(address => uint256)) public extraClaimable;\r\n\r\n    // Reward speed change with liquidity inside contract\r\n    mapping(uint256 => uint256[]) public thresholdBasic;\r\n    mapping(uint256 => uint256[]) public piecewiseBasic;\r\n\r\n    // This state variable is collapased\r\n    uint256 public currentRewardLevel;\r\n\r\n    mapping(uint256 => uint256) public poolRewardLevel;\r\n\r\n    // Double reward token for a pool\r\n    mapping(uint256 => address) public doubleRewarder;\r\n\r\n    IDoubleRewarder public doubleRewarderContract;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event StartTimestampChanged(uint256 startTimestamp);\r\n    event Stake(address staker, uint256 poolId, uint256 amount);\r\n    event Withdraw(address staker, uint256 poolId, uint256 amount);\r\n    event Harvest(\r\n        address staker,\r\n        address rewardReceiver,\r\n        uint256 poolId,\r\n        uint256 pendingReward\r\n    );\r\n    event NewPoolAdded(\r\n        address lpToken,\r\n        uint256 basicDegisPerSecond,\r\n        uint256 bonusDegisPerSecond\r\n    );\r\n    event FarmingPoolStarted(uint256 poolId, uint256 timestamp);\r\n    event FarmingPoolStopped(uint256 poolId, uint256 timestamp);\r\n    event DegisRewardChanged(\r\n        uint256 poolId,\r\n        uint256 basicDegisPerSecond,\r\n        uint256 bonusDegisPerSecond\r\n    );\r\n    event PoolUpdated(\r\n        uint256 poolId,\r\n        uint256 accDegisPerShare,\r\n        uint256 accDegisPerBonusShare\r\n    );\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function initialize(address _degis) public initializer {\r\n        require(_degis != address(0), \"Zero address\");\r\n\r\n        __Ownable_init();\r\n        __ReentrancyGuard_init_unchained();\r\n        __Pausable_init_unchained();\r\n\r\n        degis = IDegisToken(_degis);\r\n\r\n        // Start from 1\r\n        _nextPoolId = 1;\r\n\r\n        poolList.push(\r\n            PoolInfo({\r\n                lpToken: address(0),\r\n                basicDegisPerSecond: 0,\r\n                bonusDegisPerSecond: 0,\r\n                lastRewardTimestamp: 0,\r\n                accDegisPerShare: 0,\r\n                accDegisPerBonusShare: 0,\r\n                totalBonus: 0\r\n            })\r\n        );\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice The address can not be zero\r\n     */\r\n    modifier notZeroAddress(address _address) {\r\n        require(_address != address(0), \"Zero address\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice The pool is still in farming\r\n     */\r\n    modifier stillFarming(uint256 _poolId) {\r\n        require(isFarming[_poolId], \"Pool is not farming\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** View Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Check the amount of pending degis reward\r\n     * @param _poolId PoolId of this farming pool\r\n     * @param _user User address\r\n     * @return pendingDegisAmount Amount of pending degis\r\n     */\r\n    function pendingDegis(uint256 _poolId, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        PoolInfo memory poolInfo = poolList[_poolId];\r\n\r\n        if (\r\n            poolInfo.lastRewardTimestamp == 0 ||\r\n            block.timestamp < poolInfo.lastRewardTimestamp ||\r\n            block.timestamp < startTimestamp\r\n        ) return 0;\r\n\r\n        UserInfo memory user = userInfo[_poolId][_user];\r\n\r\n        // Total lp token balance\r\n        uint256 lp_balance = IERC20(poolInfo.lpToken).balanceOf(address(this));\r\n\r\n        // Accumulated shares to be calculated\r\n        uint256 accDegisPerShare = poolInfo.accDegisPerShare;\r\n        uint256 accDegisPerBonusShare = poolInfo.accDegisPerBonusShare;\r\n\r\n        if (lp_balance == 0) return 0;\r\n        else {\r\n            // If the pool is still farming, update the info\r\n            if (isFarming[_poolId]) {\r\n                // Deigs amount given to this pool\r\n                uint256 timePassed = block.timestamp -\r\n                    poolInfo.lastRewardTimestamp;\r\n                uint256 basicReward = poolInfo.basicDegisPerSecond * timePassed;\r\n                // Update accDegisPerShare\r\n                // LPToken may have different decimals\r\n                accDegisPerShare += (basicReward * SCALE) / lp_balance;\r\n\r\n                // If there is any bonus reward\r\n                if (poolInfo.totalBonus > 0) {\r\n                    uint256 bonusReward = poolInfo.bonusDegisPerSecond *\r\n                        timePassed;\r\n                    accDegisPerBonusShare +=\r\n                        (bonusReward * SCALE) /\r\n                        poolInfo.totalBonus;\r\n                }\r\n            }\r\n\r\n            // If the pool has stopped, not update the info\r\n            uint256 pending = (user.stakingBalance *\r\n                accDegisPerShare +\r\n                user.bonus *\r\n                accDegisPerBonusShare) /\r\n                SCALE +\r\n                extraClaimable[_poolId][_user] -\r\n                user.rewardDebt;\r\n\r\n            return pending;\r\n        }\r\n    }\r\n\r\n    function pendingDoubleReward(uint256 _poolId, address _user)\r\n        external\r\n        view\r\n        returns (address doubleRewardToken, uint256 pending)\r\n    {\r\n        doubleRewardToken = doubleRewarder[_poolId];\r\n\r\n        pending = doubleRewarderContract.pendingReward(\r\n            doubleRewardToken,\r\n            _user\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total pool list\r\n     * @return pooList Total pool list\r\n     */\r\n    function getPoolList() external view returns (PoolInfo[] memory) {\r\n        return poolList;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a user's balance\r\n     * @param _poolId Id of the pool\r\n     * @param _user User address\r\n     * @return balance User's balance (lpToken)\r\n     */\r\n    function getUserBalance(uint256 _poolId, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return userInfo[_poolId][_user].stakingBalance;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Set Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function setVeDEG(address _veDEG) external onlyOwner {\r\n        veDEG = IVeDEG(_veDEG);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the start block timestamp\r\n     * @param _startTimestamp New start block timestamp\r\n     */\r\n    function setStartTimestamp(uint256 _startTimestamp)\r\n        external\r\n        onlyOwner\r\n        whenNotPaused\r\n    {\r\n        // Can only be set before any pool is added\r\n        require(\r\n            _nextPoolId == 1,\r\n            \"Can not set start timestamp after adding a pool\"\r\n        );\r\n\r\n        startTimestamp = _startTimestamp;\r\n        emit StartTimestampChanged(_startTimestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Set piecewise reward and threshold\r\n     * @param _poolId Id of the pool\r\n     * @param _threshold Piecewise threshold\r\n     * @param _reward Piecewise reward\r\n     */\r\n    function setPiecewise(\r\n        uint256 _poolId,\r\n        uint256[] calldata _threshold,\r\n        uint256[] calldata _reward\r\n    ) external onlyOwner {\r\n        thresholdBasic[_poolId] = _threshold;\r\n        piecewiseBasic[_poolId] = _reward;\r\n\r\n        // If reward for mimimum level is > 0, update isFarming\r\n        if (_reward[0] > 0) isFarming[_poolId] = true;\r\n        else isFarming[_poolId] = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Set double rewarder contract\r\n     */\r\n    function setDoubleRewarderContract(address _rewarder) external onlyOwner {\r\n        doubleRewarderContract = IDoubleRewarder(_rewarder);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Main Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Add a new lp into the pool\r\n     * @dev Can only be called by the owner\r\n     *      The reward speed can be 0 and set later by setDegisReward function\r\n     *      The pool may have a double reward token\r\n     *\r\n     * @param _lpToken             LP token address\r\n     * @param _basicDegisPerSecond Basic reward speed(per second) for this new pool\r\n     * @param _bonusDegisPerSecond Bonus reward speed(per second) for this new pool\r\n     * @param _withUpdate          Whether update all pools' status\r\n     * @param _doubleRewardToken   Double reward token address\r\n     *\r\n     */\r\n    function add(\r\n        address _lpToken,\r\n        uint256 _basicDegisPerSecond,\r\n        uint256 _bonusDegisPerSecond,\r\n        bool _withUpdate,\r\n        address _doubleRewardToken\r\n    ) public notZeroAddress(_lpToken) onlyOwner whenNotPaused {\r\n        // Check if already exists, if the poolId is 0, that means not in the pool\r\n        require(!_alreadyInPool(_lpToken), \"Already in the pool\");\r\n\r\n        if (_bonusDegisPerSecond > 0)\r\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\r\n\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n\r\n        uint256 lastRewardTimestamp = block.timestamp > startTimestamp\r\n            ? block.timestamp\r\n            : startTimestamp;\r\n\r\n        // Push this new pool into the list\r\n        poolList.push(\r\n            PoolInfo({\r\n                lpToken: _lpToken,\r\n                basicDegisPerSecond: _basicDegisPerSecond,\r\n                bonusDegisPerSecond: _bonusDegisPerSecond,\r\n                lastRewardTimestamp: lastRewardTimestamp,\r\n                accDegisPerShare: 0,\r\n                accDegisPerBonusShare: 0,\r\n                totalBonus: 0\r\n            })\r\n        );\r\n\r\n        // Store the poolId and set the farming status to true\r\n        if (_basicDegisPerSecond > 0) isFarming[_nextPoolId] = true;\r\n\r\n        uint256 currentId = _nextPoolId++;\r\n\r\n        poolMapping[_lpToken] = currentId;\r\n\r\n        emit NewPoolAdded(_lpToken, _basicDegisPerSecond, _bonusDegisPerSecond);\r\n\r\n        // Record double reward token\r\n        doubleRewarder[currentId] = _doubleRewardToken;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the degisPerSecond for a specific pool (set to 0 to stop farming)\r\n     *\r\n     * @param _poolId              Id of the farming pool\r\n     * @param _basicDegisPerSecond New basic reward amount per second\r\n     * @param _bonusDegisPerSecond New bonus reward amount per second\r\n     * @param _withUpdate          Whether update all pools\r\n     */\r\n    function setDegisReward(\r\n        uint256 _poolId,\r\n        uint256 _basicDegisPerSecond,\r\n        uint256 _bonusDegisPerSecond,\r\n        bool _withUpdate\r\n    ) public onlyOwner whenNotPaused {\r\n        // Ensure there already exists this pool\r\n        require(poolList[_poolId].lastRewardTimestamp != 0, \"Pool not exists\");\r\n\r\n        if (_bonusDegisPerSecond > 0)\r\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\r\n\r\n        if (_withUpdate) massUpdatePools();\r\n        else updatePool(_poolId);\r\n\r\n        // Not farming now + reward > 0 => Restart\r\n        if (isFarming[_poolId] == false && _basicDegisPerSecond > 0) {\r\n            isFarming[_poolId] = true;\r\n            emit FarmingPoolStarted(_poolId, block.timestamp);\r\n        }\r\n\r\n        if (_basicDegisPerSecond == 0) {\r\n            isFarming[_poolId] = false;\r\n            poolList[_poolId].basicDegisPerSecond = 0;\r\n            poolList[_poolId].bonusDegisPerSecond = 0;\r\n            emit FarmingPoolStopped(_poolId, block.timestamp);\r\n        } else {\r\n            poolList[_poolId].basicDegisPerSecond = _basicDegisPerSecond;\r\n            poolList[_poolId].bonusDegisPerSecond = _bonusDegisPerSecond;\r\n            emit DegisRewardChanged(\r\n                _poolId,\r\n                _basicDegisPerSecond,\r\n                _bonusDegisPerSecond\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Stake LP token into the farming pool\r\n     *\r\n     * @dev Can only stake to the pools that are still farming\r\n     *\r\n     * @param _poolId Id of the farming pool\r\n     * @param _amount Staking amount\r\n     */\r\n    function stake(uint256 _poolId, uint256 _amount)\r\n        public\r\n        nonReentrant\r\n        whenNotPaused\r\n        stillFarming(_poolId)\r\n    {\r\n        require(_amount > 0, \"Can not stake zero\");\r\n\r\n        PoolInfo storage pool = poolList[_poolId];\r\n        UserInfo storage user = userInfo[_poolId][msg.sender];\r\n\r\n        // Must update first\r\n        updatePool(_poolId);\r\n\r\n        // First distribute the reward if exists\r\n        if (user.stakingBalance > 0) {\r\n            uint256 pending = (user.stakingBalance *\r\n                pool.accDegisPerShare +\r\n                user.bonus *\r\n                pool.accDegisPerBonusShare) /\r\n                SCALE +\r\n                extraClaimable[_poolId][msg.sender] -\r\n                user.rewardDebt;\r\n\r\n            // Clear the extra record (has been distributed)\r\n            extraClaimable[_poolId][msg.sender] = 0;\r\n\r\n            // Real reward amount by safe transfer\r\n            uint256 reward = _safeDegisTransfer(msg.sender, pending);\r\n            emit Harvest(msg.sender, msg.sender, _poolId, reward);\r\n        }\r\n\r\n        // Actual deposit amount\r\n        uint256 actualAmount = _safeLPTransfer(\r\n            false,\r\n            pool.lpToken,\r\n            msg.sender,\r\n            _amount\r\n        );\r\n\r\n        user.stakingBalance += actualAmount;\r\n\r\n        if (address(veDEG) != address(0)) {\r\n            // Update the user's bonus if veDEG boosting is on\r\n            uint256 oldBonus = user.bonus;\r\n            user.bonus = (user.stakingBalance * veDEG.balanceOf(msg.sender))\r\n                .sqrt();\r\n            // Update the pool's total bonus\r\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\r\n        }\r\n\r\n        // Double reward distribution\r\n        if (doubleRewarder[_poolId] != address(0)) {\r\n            uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\r\n            doubleRewarderContract.distributeReward(\r\n                pool.lpToken,\r\n                doubleRewarder[_poolId],\r\n                msg.sender,\r\n                user.stakingBalance,\r\n                lpSupply - actualAmount\r\n            );\r\n        }\r\n\r\n        user.rewardDebt =\r\n            (user.stakingBalance *\r\n                pool.accDegisPerShare +\r\n                user.bonus *\r\n                pool.accDegisPerBonusShare) /\r\n            SCALE;\r\n\r\n        emit Stake(msg.sender, _poolId, actualAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw lptoken from the pool\\\r\n     *\r\n     * @param _poolId Id of the farming pool\r\n     * @param _amount Amount of lp tokens to withdraw\r\n     */\r\n    function withdraw(uint256 _poolId, uint256 _amount)\r\n        public\r\n        nonReentrant\r\n        whenNotPaused\r\n    {\r\n        require(_amount > 0, \"Zero amount\");\r\n\r\n        PoolInfo storage pool = poolList[_poolId];\r\n        UserInfo storage user = userInfo[_poolId][msg.sender];\r\n\r\n        require(user.stakingBalance >= _amount, \"Not enough stakingBalance\");\r\n\r\n        // Update if the pool is still farming\r\n        // Users can withdraw even after the pool stopped\r\n        if (isFarming[_poolId]) updatePool(_poolId);\r\n        else {\r\n            pool.lastRewardTimestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 pending = (user.stakingBalance *\r\n            pool.accDegisPerShare +\r\n            user.bonus *\r\n            pool.accDegisPerBonusShare) /\r\n            SCALE +\r\n            extraClaimable[_poolId][msg.sender] -\r\n            user.rewardDebt;\r\n\r\n        // Clear the extra record (has been distributed)\r\n        extraClaimable[_poolId][msg.sender] = 0;\r\n\r\n        // Real reward amount by safe transfer\r\n        uint256 reward = _safeDegisTransfer(msg.sender, pending);\r\n        emit Harvest(msg.sender, msg.sender, _poolId, reward);\r\n\r\n        uint256 actualAmount = _safeLPTransfer(\r\n            true,\r\n            pool.lpToken,\r\n            msg.sender,\r\n            _amount\r\n        );\r\n\r\n        user.stakingBalance -= actualAmount;\r\n\r\n        // Update the user's bonus when veDEG boosting is on\r\n        if (address(veDEG) != address(0)) {\r\n            uint256 oldBonus = user.bonus;\r\n            user.bonus = (user.stakingBalance * veDEG.balanceOf(msg.sender))\r\n                .sqrt();\r\n            // Update the pool's total bonus\r\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\r\n        }\r\n\r\n        // Double reward distribution\r\n        if (doubleRewarder[_poolId] != address(0)) {\r\n            uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\r\n            doubleRewarderContract.distributeReward(\r\n                pool.lpToken,\r\n                doubleRewarder[_poolId],\r\n                msg.sender,\r\n                user.stakingBalance,\r\n                lpSupply + actualAmount\r\n            );\r\n        }\r\n\r\n        user.rewardDebt =\r\n            (user.stakingBalance *\r\n                pool.accDegisPerShare +\r\n                user.bonus *\r\n                pool.accDegisPerBonusShare) /\r\n            SCALE;\r\n\r\n        emit Withdraw(msg.sender, _poolId, actualAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Harvest the degis reward and can be sent to another address\r\n     *\r\n     * @param _poolId Id of the farming pool\r\n     * @param _to     Receiver of degis rewards\r\n     */\r\n    function harvest(uint256 _poolId, address _to)\r\n        public\r\n        nonReentrant\r\n        whenNotPaused\r\n    {\r\n        // Only update the pool when it is still in farming\r\n        if (isFarming[_poolId]) updatePool(_poolId);\r\n        else {\r\n            poolList[_poolId].lastRewardTimestamp = block.timestamp;\r\n        }\r\n\r\n        PoolInfo memory pool = poolList[_poolId];\r\n        UserInfo storage user = userInfo[_poolId][msg.sender];\r\n\r\n        uint256 pendingReward = (user.stakingBalance *\r\n            pool.accDegisPerShare +\r\n            user.bonus *\r\n            pool.accDegisPerBonusShare) /\r\n            SCALE +\r\n            extraClaimable[_poolId][msg.sender] -\r\n            user.rewardDebt;\r\n\r\n        extraClaimable[_poolId][msg.sender] = 0;\r\n\r\n        require(pendingReward > 0, \"No pending reward\");\r\n\r\n        // Double reward distribution\r\n        if (doubleRewarder[_poolId] != address(0)) {\r\n            uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\r\n            doubleRewarderContract.distributeReward(\r\n                pool.lpToken,\r\n                doubleRewarder[_poolId],\r\n                msg.sender,\r\n                user.stakingBalance,\r\n                lpSupply\r\n            );\r\n        }\r\n\r\n        // Update the reward debt\r\n        user.rewardDebt =\r\n            (user.stakingBalance *\r\n                pool.accDegisPerShare +\r\n                user.bonus *\r\n                pool.accDegisPerBonusShare) /\r\n            SCALE;\r\n\r\n        // Transfer the reward\r\n        uint256 reward = _safeDegisTransfer(_to, pendingReward);\r\n\r\n        emit Harvest(msg.sender, _to, _poolId, reward);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the pool's reward status\r\n     * @param _poolId Id of the farming pool\r\n     */\r\n    function updatePool(uint256 _poolId) public {\r\n        PoolInfo storage pool = poolList[_poolId];\r\n        if (block.timestamp <= pool.lastRewardTimestamp) {\r\n            return;\r\n        }\r\n\r\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\r\n\r\n        // No LP deposited, then just update the lastRewardTimestamp\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardTimestamp = block.timestamp;\r\n            return;\r\n        }\r\n\r\n        uint256 timePassed = block.timestamp - pool.lastRewardTimestamp;\r\n\r\n        uint256 basicReward = timePassed * pool.basicDegisPerSecond;\r\n        uint256 bonusReward = timePassed * pool.bonusDegisPerSecond;\r\n\r\n        pool.accDegisPerShare += (basicReward * SCALE) / lpSupply;\r\n\r\n        if (pool.totalBonus == 0) {\r\n            pool.accDegisPerBonusShare = 0;\r\n        } else {\r\n            pool.accDegisPerBonusShare +=\r\n                (bonusReward * SCALE) /\r\n                pool.totalBonus;\r\n        }\r\n\r\n        // Don't forget to set the farming pool as minter\r\n        degis.mintDegis(address(this), basicReward + bonusReward);\r\n\r\n        pool.lastRewardTimestamp = block.timestamp;\r\n\r\n        uint256 currentPoolLevel = poolRewardLevel[_poolId];\r\n\r\n        // Update the new reward speed\r\n        // Only if the threshold are already set\r\n        if (thresholdBasic[_poolId].length > 0) {\r\n            uint256 currentLiquidity = thresholdBasic[_poolId][\r\n                currentPoolLevel\r\n            ];\r\n            if (\r\n                currentPoolLevel < thresholdBasic[_poolId].length - 1 &&\r\n                lpSupply >= thresholdBasic[_poolId][currentPoolLevel + 1]\r\n            ) {\r\n                _updateRewardSpeed(_poolId);\r\n            } else if (lpSupply < currentLiquidity) {\r\n                _updateRewardSpeed(_poolId);\r\n            }\r\n        }\r\n\r\n        emit PoolUpdated(\r\n            _poolId,\r\n            pool.accDegisPerShare,\r\n            pool.accDegisPerBonusShare\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update all farming pools (except for those stopped ones)\r\n     * @dev Can be called by anyone\r\n     *      Only update those active pools\r\n     */\r\n    function massUpdatePools() public {\r\n        uint256 length = poolList.length;\r\n        for (uint256 poolId = 1; poolId < length; ++poolId) {\r\n            if (isFarming[poolId] == false) {\r\n                poolList[poolId].lastRewardTimestamp = block.timestamp;\r\n                continue;\r\n            } else updatePool(poolId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update a user's bonus\r\n     * @dev When veDEG has balance change\r\n     *      Only called by veDEG contract\r\n     * @param _user User address\r\n     * @param _newVeDEGBalance New veDEG balance\r\n     */\r\n    function updateBonus(address _user, uint256 _newVeDEGBalance) external {\r\n        require(msg.sender == address(veDEG), \"Only veDEG contract\");\r\n\r\n        // loop over each pool : beware gas cost!\r\n        uint256 length = poolList.length;\r\n\r\n        for (uint256 poolId; poolId < length; ++poolId) {\r\n            // Skip if the pool is not farming\r\n            if (!isFarming[poolId]) continue;\r\n\r\n            UserInfo storage user = userInfo[poolId][_user];\r\n            // Skip if user doesn't have any deposit in the pool\r\n            if (user.stakingBalance == 0) continue;\r\n\r\n            PoolInfo storage pool = poolList[poolId];\r\n\r\n            // first, update pool\r\n            updatePool(poolId);\r\n\r\n            // Update the extra claimable amount\r\n            uint256 pending = (user.stakingBalance *\r\n                pool.accDegisPerShare +\r\n                user.bonus *\r\n                pool.accDegisPerBonusShare) /\r\n                SCALE -\r\n                user.rewardDebt;\r\n            extraClaimable[poolId][_user] += pending;\r\n\r\n            // get oldFactor\r\n            uint256 oldFactor = user.bonus; // get old factor\r\n            // calculate newFactor\r\n            uint256 newFactor = (_newVeDEGBalance * user.stakingBalance).sqrt();\r\n            // update user factor\r\n            user.bonus = newFactor;\r\n            // update reward debt, take into account newFactor\r\n            user.rewardDebt =\r\n                (user.stakingBalance *\r\n                    pool.accDegisPerShare +\r\n                    newFactor *\r\n                    pool.accDegisPerBonusShare) /\r\n                SCALE;\r\n\r\n            // Update the pool's total bonus\r\n            pool.totalBonus = pool.totalBonus + newFactor - oldFactor;\r\n        }\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ********************************** Internal Functions ********************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Check if a lptoken has been added into the pool before\r\n     * @dev This can also be written as a modifier\r\n     * @param _lpToken LP token address\r\n     * @return _isInPool Wether this lp is already in pool\r\n     */\r\n    function _alreadyInPool(address _lpToken)\r\n        internal\r\n        view\r\n        returns (bool _isInPool)\r\n    {\r\n        uint256 poolId = poolMapping[_lpToken];\r\n\r\n        _isInPool = (poolId != 0) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\r\n     * @param _to User's address\r\n     * @param _amount Amount to transfer\r\n     */\r\n    function _safeDegisTransfer(address _to, uint256 _amount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 poolDegisBalance = degis.balanceOf(address(this));\r\n        require(poolDegisBalance > 0, \"No Degis token in the pool\");\r\n\r\n        if (_amount > poolDegisBalance) {\r\n            degis.safeTransfer(_to, poolDegisBalance);\r\n            return (poolDegisBalance);\r\n        } else {\r\n            degis.safeTransfer(_to, _amount);\r\n            return _amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Finish the transfer of LP Token\r\n     * @dev The lp token may have loss during transfer\r\n     * @param _out Whether the lp token is out\r\n     * @param _lpToken LP token address\r\n     * @param _user User address\r\n     * @param _amount Amount of lp tokens\r\n     */\r\n    function _safeLPTransfer(\r\n        bool _out,\r\n        address _lpToken,\r\n        address _user,\r\n        uint256 _amount\r\n    ) internal returns (uint256) {\r\n        uint256 poolBalanceBefore = IERC20(_lpToken).balanceOf(address(this));\r\n\r\n        if (_out) IERC20(_lpToken).safeTransfer(_user, _amount);\r\n        else IERC20(_lpToken).safeTransferFrom(_user, address(this), _amount);\r\n\r\n        uint256 poolBalanceAfter = IERC20(_lpToken).balanceOf(address(this));\r\n\r\n        return\r\n            _out\r\n                ? poolBalanceBefore - poolBalanceAfter\r\n                : poolBalanceAfter - poolBalanceBefore;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the reward speed\r\n     * @param _poolId Pool ID\r\n     */\r\n    function _updateRewardSpeed(uint256 _poolId) internal {\r\n        uint256 currentBasicBalance = IERC20(poolList[_poolId].lpToken)\r\n            .balanceOf(address(this));\r\n\r\n        uint256 basicRewardSpeed;\r\n\r\n        for (uint256 i = thresholdBasic[_poolId].length - 1; i >= 0; --i) {\r\n            if (currentBasicBalance >= thresholdBasic[_poolId][i]) {\r\n                basicRewardSpeed = piecewiseBasic[_poolId][i];\r\n                // record current reward level\r\n                poolRewardLevel[_poolId] = i;\r\n                break;\r\n            } else continue;\r\n        }\r\n\r\n        poolList[_poolId].basicDegisPerSecond = basicRewardSpeed;\r\n    }\r\n}\r\n"
    },
    "contracts/farming/interfaces/IDoubleRewarder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.13;\r\n\r\ninterface IDoubleRewarder {\r\n    function distributeReward(\r\n        address lpToken,\r\n        address rewardToken,\r\n        address user,\r\n        uint256 userAmount,\r\n        uint256 lpSupply\r\n    ) external;\r\n\r\n    // Get the pending reward\r\n    function pendingReward(address _token, address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    // Get the reward token address\r\n    function rewardToken() external view returns (address);\r\n}\r\n"
    },
    "contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\r\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() initializer {}\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\r\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\r\n        // contract may have been reentered.\r\n        require(\r\n            _initializing ? _isConstructor() : !_initialized,\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} modifier, directly or indirectly.\r\n     */\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    function _isConstructor() private view returns (bool) {\r\n        return !AddressUpgradeable.isContract(address(this));\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockUSD.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @notice This is the MockUSD used in testnet\r\n *         Maximum mint amount is 500k for each user.\r\n *         Maximum mint amount for every single tx is 100k.\r\n */\r\ncontract MockUSD is ERC20 {\r\n    uint256 public constant INITIAL_SUPPLY = 100000 * 1e6;\r\n\r\n    constructor() ERC20(\"MOCKUSD\", \"USDC\") {\r\n        // When first deployed, give the owner some coins\r\n        _mint(msg.sender, INITIAL_SUPPLY);\r\n    }\r\n\r\n    // Everyone can mint, have fun for test\r\n    function mint(address _account, uint256 _amount) public {\r\n        _mint(_account, _amount);\r\n    }\r\n\r\n    // 6 decimals to mock stablecoins\r\n    function decimals() public pure override returns (uint8) {\r\n        return 6;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @notice MockERC20 for test\r\n * @dev MockUSD has 6 decimals, this contract is 18 decimals\r\n */\r\ncontract MockERC20 is ERC20 {\r\n    constructor() ERC20(\"MockERC20\", \"ERC20\") {}\r\n\r\n    // Everyone can mint, have fun for test\r\n    function mint(address _account, uint256 _amount) public {\r\n        _mint(_account, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/miserable-flight/SigManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\r\nimport \"../utils/Ownable.sol\";\r\n\r\n/**\r\n * @title  Signature Manager\r\n * @notice Signature is used when submitting new applications.\r\n *         The premium should be decided by the pricing model and be signed by a private key.\r\n *         Other submissions will not be accepted.\r\n *         Please keep the signer key safe.\r\n */\r\ncontract SigManager is Ownable {\r\n    using ECDSA for bytes32;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Variables *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    mapping(address => bool) public isValidSigner;\r\n\r\n    bytes32 public _SUBMIT_APPLICATION_TYPEHASH;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event SignerAdded(address _newSigner);\r\n    event SignerRemoved(address _oldSigner);\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    constructor() Ownable(msg.sender) {\r\n        _SUBMIT_APPLICATION_TYPEHASH = keccak256(\r\n            \"5G is great, physical lab is difficult to find\"\r\n        );\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************** Modifiers *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @dev This modifier uses assert which means this error should never happens\r\n     */\r\n    modifier validAddress(address _address) {\r\n        assert(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Add a signer into valid signer list\r\n     * @param _newSigner The new signer address\r\n     */\r\n    function addSigner(address _newSigner)\r\n        external\r\n        validAddress(_newSigner)\r\n        onlyOwner\r\n    {\r\n        require(!isValidSigner[_newSigner], \"Already a signer\");\r\n\r\n        isValidSigner[_newSigner] = true;\r\n\r\n        emit SignerAdded(_newSigner);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a signer from the valid signer list\r\n     * @param _oldSigner The old signer address to be removed\r\n     */\r\n    function removeSigner(address _oldSigner)\r\n        external\r\n        validAddress(_oldSigner)\r\n        onlyOwner\r\n    {\r\n        require(isValidSigner[_oldSigner], \"Not a signer\");\r\n\r\n        isValidSigner[_oldSigner] = false;\r\n\r\n        emit SignerRemoved(_oldSigner);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Check signature when buying a new policy (avoid arbitrary premium amount)\r\n     * @param signature 65 bytes array: [[v (1)], [r (32)], [s (32)]]\r\n     * @param _flightNumber Flight number\r\n     * @param _departureTimestamp Flight departure timestamp\r\n     * @param _landingDate Flight landing date\r\n     * @param _user User address\r\n     * @param _premium Policy premium\r\n     * @param _deadline Deadline of a this signature\r\n     */\r\n    function checkSignature(\r\n        bytes calldata signature,\r\n        string memory _flightNumber,\r\n        uint256 _departureTimestamp,\r\n        uint256 _landingDate,\r\n        address _user,\r\n        uint256 _premium,\r\n        uint256 _deadline\r\n    ) external view {\r\n        bytes32 hashedFlightNumber = keccak256(bytes(_flightNumber));\r\n\r\n        bytes32 hashData = keccak256(\r\n            abi.encodePacked(\r\n                _SUBMIT_APPLICATION_TYPEHASH,\r\n                hashedFlightNumber,\r\n                _departureTimestamp,\r\n                _landingDate,\r\n                _user,\r\n                _premium,\r\n                _deadline\r\n            )\r\n        );\r\n        address signer = hashData.toEthSignedMessageHash().recover(signature);\r\n\r\n        require(isValidSigner[signer], \"Only submitted by authorized signers\");\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockPTP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.13;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract MockPTP {\r\n    function swap(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromAmount,\r\n        uint256 minimumToAmount,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 actualToAmount, uint256 haircut) {\r\n        require(block.timestamp < deadline, \"Deadline has passed\");\r\n        require(fromToken != address(0), \"ZERO\");\r\n        require(toToken != address(0), \"ZERO\");\r\n        require(fromToken != toToken, \"SAME_ADDRESS\");\r\n        require(fromAmount > 0, \"ZERO_FROM_AMOUNT\");\r\n        require(to != address(0), \"ZERO\");\r\n\r\n        IERC20 fromERC20 = IERC20(fromToken);\r\n        // Asset fromAsset = _assetOf(fromToken);\r\n        // Asset toAsset = _assetOf(toToken);\r\n\r\n        // // Intrapool swapping only\r\n        // require(\r\n        //     toAsset.aggregateAccount() == fromAsset.aggregateAccount(),\r\n        //     \"DIFF_AGG_ACC\"\r\n        // );\r\n\r\n        // (actualToAmount, haircut) = _quoteFrom(fromAsset, toAsset, fromAmount);\r\n\r\n        fromERC20.transferFrom(msg.sender, fromToken, fromAmount);\r\n\r\n        actualToAmount = fromAmount;\r\n        haircut = 0;\r\n\r\n        require(minimumToAmount <= actualToAmount, \"AMOUNT_TOO_LOW\");\r\n        // fromAsset.addCash(fromAmount);\r\n        // toAsset.removeCash(actualToAmount);\r\n        // toAsset.addLiability(_dividend(haircut, _retentionRatio));\r\n        // toAsset.transferUnderlyingToken(to, actualToAmount);\r\n    }\r\n}\r\n"
    },
    "contracts/EmergencyPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./utils/Ownable.sol\";\r\n\r\n/**\r\n * @title  Emergency Pool\r\n * @notice Emergency pool in degis will keep a reserve vault for emergency usage.\r\n *         The asset comes from part of the product's income (currently 10%).\r\n *         Users can also stake funds into this contract manually.\r\n *         The owner has the right to withdraw funds from emergency pool and it would be passed to community governance.\r\n */\r\ncontract EmergencyPool is Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Variables **************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    string public name = \"Degis Emergency Pool\";\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    event Deposit(\r\n        address indexed tokenAddress,\r\n        address indexed userAddress,\r\n        uint256 amount\r\n    );\r\n    event Withdraw(\r\n        address indexed tokenAddress,\r\n        address indexed userAddress,\r\n        uint256 amount\r\n    );\r\n    event UseFund(\r\n        address indexed tokenAddress,\r\n        address indexed userAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    constructor() Ownable(msg.sender) {}\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Main Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Manually stake into the pool\r\n     * @param _tokenAddress Address of the ERC20 token\r\n     * @param _amount The amount that the user want to stake\r\n     */\r\n    function deposit(address _tokenAddress, uint256 _amount) external {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n\r\n        IERC20(_tokenAddress).safeTransferFrom(\r\n            _msgSender(),\r\n            address(this),\r\n            _amount\r\n        );\r\n\r\n        emit Deposit(_tokenAddress, _msgSender(), _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the asset when emergency (only by the owner)\r\n     * @dev The ownership need to be transferred to another contract in the future\r\n     * @param _tokenAddress Address of the ERC20 token\r\n     * @param _amount The amount that the user want to unstake\r\n     */\r\n    function emergencyWithdraw(address _tokenAddress, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\r\n        require(_amount <= balance, \"Insufficient funds\");\r\n\r\n        IERC20(_tokenAddress).safeTransfer(owner(), _amount);\r\n        emit Withdraw(_tokenAddress, owner(), _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Use emergency pool fund\r\n     * @param _tokenAddress Address of the ERC20 token\r\n     * @param _receiver Address of the receiver\r\n     * @param _amount The amount to use    \r\n     */\r\n    function useFund(\r\n        address _tokenAddress,\r\n        address _receiver,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\r\n        require(_amount <= balance, \"Insufficient funds\");\r\n\r\n        IERC20(_tokenAddress).safeTransfer(_receiver, _amount);\r\n        emit UseFund(_tokenAddress, _receiver, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/SafePRBMathTester.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./SafePRBMath.sol\";\r\n\r\ncontract SafePRBMathTester {\r\n    function avg(uint256 x, uint256 y) public pure returns (uint256 result) {\r\n        return SafePRBMath.avg(x, y);\r\n    }\r\n\r\n    function ceil(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.ceil(x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) public pure returns (uint256 result) {\r\n        return SafePRBMath.div(x, y);\r\n    }\r\n\r\n    function e() public pure returns (uint256 result) {\r\n        return SafePRBMath.e();\r\n    }\r\n\r\n    function exp(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.exp(x);\r\n    }\r\n\r\n    function exp2(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.exp2(x);\r\n    }\r\n\r\n    function floor(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.floor(x);\r\n    }\r\n\r\n    function frac(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.frac(x);\r\n    }\r\n\r\n    function fromUint(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.fromUint(x);\r\n    }\r\n\r\n    function gm(uint256 x, uint256 y) public pure returns (uint256 result) {\r\n        return SafePRBMath.gm(x, y);\r\n    }\r\n\r\n    function inv(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.inv(x);\r\n    }\r\n\r\n    function ln(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.ln(x);\r\n    }\r\n\r\n    function log10(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.log10(x);\r\n    }\r\n\r\n    function log2(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.log2(x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) public pure returns (uint256 result) {\r\n        return SafePRBMath.mul(x, y);\r\n    }\r\n\r\n    function pi() public pure returns (uint256 result) {\r\n        return SafePRBMath.pi();\r\n    }\r\n\r\n    function pow(uint256 x, uint256 y) public pure returns (uint256 result) {\r\n        return SafePRBMath.pow(x, y);\r\n    }\r\n\r\n    function powu(uint256 x, uint256 y) public pure returns (uint256 result) {\r\n        return SafePRBMath.powu(x, y);\r\n    }\r\n\r\n    function scale() public pure returns (uint256 result) {\r\n        return SafePRBMath.scale();\r\n    }\r\n\r\n    function sqrt(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.sqrt(x);\r\n    }\r\n\r\n    function toUint(uint256 x) public pure returns (uint256 result) {\r\n        return SafePRBMath.toUint(x);\r\n    }\r\n}\r\n"
    },
    "contracts/tokens/BuyerToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.10;\r\n\r\nimport \"../utils/ERC20PermitWithMultipleMinters.sol\";\r\n\r\n/**\r\n * @title  Buyer Token\r\n * @notice Buyer tokens are distributed to buyers corresponding to the usd value they spend.\r\n *         Users can deposit their buyer tokens into PurchaseIncentiveVault.\r\n *         Periodical reward will be given to the participants in PurchaseIncentiveVault.\r\n *         When distributing purchase incentive reward, the buyer tokens will be burned.\r\n * @dev    Need to set the correct minters and burners when reploying this contract.\r\n */\r\ncontract BuyerToken is ERC20PermitWithMultipleMinters {\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Constructor *************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    constructor() ERC20PermitWithMultipleMinters(\"DegisBuyerToken\", \"DBT\") {}\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *********************************** Main Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Mint buyer tokens\r\n     * @param  _account Receiver's address\r\n     * @param  _amount  Amount to be minted\r\n     */\r\n    function mintBuyerToken(address _account, uint256 _amount) external {\r\n        mint(_account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn buyer tokens\r\n     * @param  _account Receiver's address\r\n     * @param  _amount  Amount to be burned\r\n     */\r\n    function burnBuyerToken(address _account, uint256 _amount) external {\r\n        burn(_account, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/naughty-price/PriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/*\r\n //======================================================================\\\\\r\n //======================================================================\\\\\r\n    *******         **********     ***********     *****     ***********\r\n    *      *        *              *                 *       *\r\n    *        *      *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     *              *                 *       *\r\n    *         *     **********     *       *****     *       ***********\r\n    *         *     *              *         *       *                 *\r\n    *         *     *              *         *       *                 *\r\n    *        *      *              *         *       *                 *\r\n    *      *        *              *         *       *                 *\r\n    *******         **********     ***********     *****     ***********\r\n \\\\======================================================================//\r\n \\\\======================================================================//\r\n*/\r\n\r\npragma solidity ^0.8.10;\r\n\r\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport { Ownable } from \"../utils/Ownable.sol\";\r\n\r\n/**\r\n * @title  Price Getter\r\n * @notice This is the contract for getting price feed from chainlink.\r\n *         The contract will keep a record from tokenName => priceFeed Address.\r\n *         Got the sponsorship and collaboration with Chainlink.\r\n * @dev    The price from chainlink priceFeed has different decimals, be careful.\r\n */\r\ncontract PriceGetter is Ownable {\r\n    struct PriceFeedInfo {\r\n        address priceFeedAddress;\r\n        uint256 decimals;\r\n    }\r\n    // Use token name (string) as the mapping key\r\n    // Should set the correct orginal token name\r\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Events ***************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n    event PriceFeedChanged(\r\n        string tokenName,\r\n        address feedAddress,\r\n        uint256 decimals\r\n    );\r\n\r\n    event LatestPriceGet(\r\n        uint80 roundID,\r\n        int256 price,\r\n        uint256 startedAt,\r\n        uint256 timeStamp,\r\n        uint80 answeredInRound\r\n    );\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Constructor ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Constructor function, initialize some price feeds\r\n     *         The first supported tokens are AVAX, BTC and ETH\r\n     */\r\n    constructor() Ownable(msg.sender) {\r\n        // Avalanche data feed addresses and decimals\r\n        priceFeedInfo[\"AVAX\"] = PriceFeedInfo(\r\n            0x0A77230d17318075983913bC2145DB16C7366156,\r\n            8\r\n        );\r\n\r\n        priceFeedInfo[\"ETH\"] = PriceFeedInfo(\r\n            0x976B3D034E162d8bD72D6b9C989d545b839003b0,\r\n            8\r\n        );\r\n\r\n        priceFeedInfo[\"BTC\"] = PriceFeedInfo(\r\n            0x2779D32d5166BAaa2B2b658333bA7e6Ec0C65743,\r\n            8\r\n        );\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // *************************************** Modifiers ************************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Can not give zero address\r\n     */\r\n    modifier notZeroAddress(address _address) {\r\n        require(_address != address(0), \"Zero address\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ View Functions ************************************ //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************ Set Functions ************************************* //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Set a price feed oracle address for a token\r\n     * @dev Only callable by the owner\r\n     *      The price result decimal should be less than 18\r\n     * @param _tokenName   Address of the token\r\n     * @param _feedAddress Price feed oracle address\r\n     * @param _decimals    Decimals of this price feed service\r\n     */\r\n    function setPriceFeed(\r\n        string memory _tokenName,\r\n        address _feedAddress,\r\n        uint256 _decimals\r\n    ) public onlyOwner notZeroAddress(_feedAddress) {\r\n        require(_decimals <= 18, \"Too many decimals\");\r\n        priceFeedInfo[_tokenName] = PriceFeedInfo(_feedAddress, _decimals);\r\n\r\n        emit PriceFeedChanged(_tokenName, _feedAddress, _decimals);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------- //\r\n    // ************************************* Main Functions *********************************** //\r\n    // ---------------------------------------------------------------------------------------- //\r\n\r\n    /**\r\n     * @notice Get latest price of a token\r\n     * @param _tokenName Address of the token\r\n     * @return price The latest price\r\n     */\r\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\r\n        PriceFeedInfo memory priceFeed = priceFeedInfo[_tokenName];\r\n\r\n        (\r\n            uint80 roundID,\r\n            int256 price,\r\n            uint256 startedAt,\r\n            uint256 timeStamp,\r\n            uint80 answeredInRound\r\n        ) = AggregatorV3Interface(priceFeed.priceFeedAddress).latestRoundData();\r\n\r\n        // require(price > 0, \"Only accept price that > 0\");\r\n        if (price < 0) price = 0;\r\n\r\n        emit LatestPriceGet(\r\n            roundID,\r\n            price,\r\n            startedAt,\r\n            timeStamp,\r\n            answeredInRound\r\n        );\r\n        // Transfer the result decimals\r\n        uint256 finalPrice = uint256(price) * (10**(18 - priceFeed.decimals));\r\n\r\n        return finalPrice;\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}