{
  "0xc53d8ebb0d917eb0152f3e2ea4ca425f75fcbbc12d4d75d69e59540dc94013f9": {
    "name": "ProxyAdmin",
    "deployment": {
      "_format": "hh-sol-artifact-1",
      "contractName": "ProxyAdmin",
      "sourceName": "contracts/proxy/ProxyAdmin.sol",
      "abi": [
        {
          "inputs": [],
          "stateMutability": "nonpayable",
          "type": "constructor"
        },
        {
          "anonymous": false,
          "inputs": [
            {
              "indexed": true,
              "internalType": "address",
              "name": "previousOwner",
              "type": "address"
            },
            {
              "indexed": true,
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "OwnershipTransferred",
          "type": "event"
        },
        {
          "inputs": [
            {
              "internalType": "contract TransparentUpgradeableProxy",
              "name": "proxy",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "newAdmin",
              "type": "address"
            }
          ],
          "name": "changeProxyAdmin",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract TransparentUpgradeableProxy",
              "name": "proxy",
              "type": "address"
            }
          ],
          "name": "getProxyAdmin",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract TransparentUpgradeableProxy",
              "name": "proxy",
              "type": "address"
            }
          ],
          "name": "getProxyImplementation",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "owner",
          "outputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "renounceOwnership",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "newOwner",
              "type": "address"
            }
          ],
          "name": "transferOwnership",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract TransparentUpgradeableProxy",
              "name": "proxy",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "implementation",
              "type": "address"
            }
          ],
          "name": "upgrade",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "contract TransparentUpgradeableProxy",
              "name": "proxy",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "implementation",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "name": "upgradeAndCall",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        }
      ],
      "bytecode": "0x608060405234801561001057600080fd5b503361001b81610021565b50610071565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6108b5806100806000396000f3fe60806040526004361061007b5760003560e01c80639623609d1161004e5780639623609d1461010b57806399a88ec41461011e578063f2fde38b1461013e578063f3b7dead1461015e57600080fd5b8063204e1c7a14610080578063715018a6146100b65780637eff275e146100cd5780638da5cb5b146100ed575b600080fd5b34801561008c57600080fd5b506100a061009b366004610505565b61017e565b6040516100ad9190610535565b60405180910390f35b3480156100c257600080fd5b506100cb610204565b005b3480156100d957600080fd5b506100cb6100e8366004610557565b610252565b3480156100f957600080fd5b506000546001600160a01b03166100a0565b6100cb61011936600461068f565b6102ed565b34801561012a57600080fd5b506100cb610139366004610557565b61038d565b34801561014a57600080fd5b506100cb6101593660046106fa565b6103f2565b34801561016a57600080fd5b506100a0610179366004610505565b61045d565b6000806000836001600160a01b03166040516101999061072c565b600060405180830381855afa9150503d80600081146101d4576040519150601f19603f3d011682016040523d82523d6000602084013e6101d9565b606091505b5091509150816101e857600080fd5b808060200190518101906101fc9190610740565b949350505050565b336102176000546001600160a01b031690565b6001600160a01b0316146102465760405162461bcd60e51b815260040161023d90610761565b60405180910390fd5b6102506000610478565b565b336102656000546001600160a01b031690565b6001600160a01b03161461028b5760405162461bcd60e51b815260040161023d90610761565b6040516308f2839760e41b81526001600160a01b03831690638f283970906102b7908490600401610535565b600060405180830381600087803b1580156102d157600080fd5b505af11580156102e5573d6000803e3d6000fd5b505050505050565b336103006000546001600160a01b031690565b6001600160a01b0316146103265760405162461bcd60e51b815260040161023d90610761565b60405163278f794360e11b81526001600160a01b03841690634f1ef28690349061035690869086906004016107fd565b6000604051808303818588803b15801561036f57600080fd5b505af1158015610383573d6000803e3d6000fd5b5050505050505050565b336103a06000546001600160a01b031690565b6001600160a01b0316146103c65760405162461bcd60e51b815260040161023d90610761565b604051631b2ce7f360e11b81526001600160a01b03831690633659cfe6906102b7908490600401610535565b336104056000546001600160a01b031690565b6001600160a01b03161461042b5760405162461bcd60e51b815260040161023d90610761565b6001600160a01b0381166104515760405162461bcd60e51b815260040161023d9061081d565b61045a81610478565b50565b6000806000836001600160a01b031660405161019990610876565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006001600160a01b0382165b92915050565b60006104d5826104c8565b6104ef816104db565b811461045a57600080fd5b80356104d5816104e6565b60006020828403121561051a5761051a600080fd5b60006101fc84846104fa565b61052f816104c8565b82525050565b602081016104d58284610526565b6104ef816104c8565b80356104d581610543565b6000806040838503121561056d5761056d600080fd5b600061057985856104fa565b925050602061058a8582860161054c565b9150509250929050565b634e487b7160e01b600052604160045260246000fd5b601f19601f830116810181811067ffffffffffffffff821117156105d0576105d0610594565b6040525050565b60006105e260405190565b90506105ee82826105aa565b919050565b600067ffffffffffffffff82111561060d5761060d610594565b601f19601f83011660200192915050565b82818337506000910152565b600061063d610638846105f3565b6105d7565b90508281526020810184848401111561065857610658600080fd5b61066384828561061e565b509392505050565b600082601f83011261067f5761067f600080fd5b81356101fc84826020860161062a565b6000806000606084860312156106a7576106a7600080fd5b60006106b386866104fa565b93505060206106c48682870161054c565b925050604084013567ffffffffffffffff8111156106e4576106e4600080fd5b6106f08682870161066b565b9150509250925092565b60006020828403121561070f5761070f600080fd5b60006101fc848461054c565b635c60da1b60e01b81525b60040190565b6105ee8161071b565b80516104d581610543565b60006020828403121561075557610755600080fd5b60006101fc8484610735565b60208082528181019081527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726040830152606082016104d5565b60005b838110156107b657818101518382015260200161079e565b838111156107c5576000848401525b50505050565b60006107d5825190565b8084526020840193506107ec81856020860161079b565b601f01601f19169290920192915050565b6040810161080b8285610526565b81810360208301526101fc81846107cb565b602080825281016104d581602681527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160208201526564647265737360d01b604082015260600190565b6303e1469160e61b8152610726565b6105ee8161086756fea2646970667358221220b2e73e40ff4f6664e6a342d26cbd1b6d2f85e1850495fb416ec82fd3c0054ba464736f6c634300080a0033",
      "deployedBytecode": "0x60806040526004361061007b5760003560e01c80639623609d1161004e5780639623609d1461010b57806399a88ec41461011e578063f2fde38b1461013e578063f3b7dead1461015e57600080fd5b8063204e1c7a14610080578063715018a6146100b65780637eff275e146100cd5780638da5cb5b146100ed575b600080fd5b34801561008c57600080fd5b506100a061009b366004610505565b61017e565b6040516100ad9190610535565b60405180910390f35b3480156100c257600080fd5b506100cb610204565b005b3480156100d957600080fd5b506100cb6100e8366004610557565b610252565b3480156100f957600080fd5b506000546001600160a01b03166100a0565b6100cb61011936600461068f565b6102ed565b34801561012a57600080fd5b506100cb610139366004610557565b61038d565b34801561014a57600080fd5b506100cb6101593660046106fa565b6103f2565b34801561016a57600080fd5b506100a0610179366004610505565b61045d565b6000806000836001600160a01b03166040516101999061072c565b600060405180830381855afa9150503d80600081146101d4576040519150601f19603f3d011682016040523d82523d6000602084013e6101d9565b606091505b5091509150816101e857600080fd5b808060200190518101906101fc9190610740565b949350505050565b336102176000546001600160a01b031690565b6001600160a01b0316146102465760405162461bcd60e51b815260040161023d90610761565b60405180910390fd5b6102506000610478565b565b336102656000546001600160a01b031690565b6001600160a01b03161461028b5760405162461bcd60e51b815260040161023d90610761565b6040516308f2839760e41b81526001600160a01b03831690638f283970906102b7908490600401610535565b600060405180830381600087803b1580156102d157600080fd5b505af11580156102e5573d6000803e3d6000fd5b505050505050565b336103006000546001600160a01b031690565b6001600160a01b0316146103265760405162461bcd60e51b815260040161023d90610761565b60405163278f794360e11b81526001600160a01b03841690634f1ef28690349061035690869086906004016107fd565b6000604051808303818588803b15801561036f57600080fd5b505af1158015610383573d6000803e3d6000fd5b5050505050505050565b336103a06000546001600160a01b031690565b6001600160a01b0316146103c65760405162461bcd60e51b815260040161023d90610761565b604051631b2ce7f360e11b81526001600160a01b03831690633659cfe6906102b7908490600401610535565b336104056000546001600160a01b031690565b6001600160a01b03161461042b5760405162461bcd60e51b815260040161023d90610761565b6001600160a01b0381166104515760405162461bcd60e51b815260040161023d9061081d565b61045a81610478565b50565b6000806000836001600160a01b031660405161019990610876565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006001600160a01b0382165b92915050565b60006104d5826104c8565b6104ef816104db565b811461045a57600080fd5b80356104d5816104e6565b60006020828403121561051a5761051a600080fd5b60006101fc84846104fa565b61052f816104c8565b82525050565b602081016104d58284610526565b6104ef816104c8565b80356104d581610543565b6000806040838503121561056d5761056d600080fd5b600061057985856104fa565b925050602061058a8582860161054c565b9150509250929050565b634e487b7160e01b600052604160045260246000fd5b601f19601f830116810181811067ffffffffffffffff821117156105d0576105d0610594565b6040525050565b60006105e260405190565b90506105ee82826105aa565b919050565b600067ffffffffffffffff82111561060d5761060d610594565b601f19601f83011660200192915050565b82818337506000910152565b600061063d610638846105f3565b6105d7565b90508281526020810184848401111561065857610658600080fd5b61066384828561061e565b509392505050565b600082601f83011261067f5761067f600080fd5b81356101fc84826020860161062a565b6000806000606084860312156106a7576106a7600080fd5b60006106b386866104fa565b93505060206106c48682870161054c565b925050604084013567ffffffffffffffff8111156106e4576106e4600080fd5b6106f08682870161066b565b9150509250925092565b60006020828403121561070f5761070f600080fd5b60006101fc848461054c565b635c60da1b60e01b81525b60040190565b6105ee8161071b565b80516104d581610543565b60006020828403121561075557610755600080fd5b60006101fc8484610735565b60208082528181019081527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726040830152606082016104d5565b60005b838110156107b657818101518382015260200161079e565b838111156107c5576000848401525b50505050565b60006107d5825190565b8084526020840193506107ec81856020860161079b565b601f01601f19169290920192915050565b6040810161080b8285610526565b81810360208301526101fc81846107cb565b602080825281016104d581602681527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160208201526564647265737360d01b604082015260600190565b6303e1469160e61b8152610726565b6105ee8161086756fea2646970667358221220b2e73e40ff4f6664e6a342d26cbd1b6d2f85e1850495fb416ec82fd3c0054ba464736f6c634300080a0033",
      "linkReferences": {},
      "deployedLinkReferences": {},
      "devdoc": {
        "details": "This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.",
        "kind": "dev",
        "methods": {
          "changeProxyAdmin(address,address)": {
            "details": "Changes the admin of `proxy` to `newAdmin`. Requirements: - This contract must be the current admin of `proxy`."
          },
          "getProxyAdmin(address)": {
            "details": "Returns the current admin of `proxy`. Requirements: - This contract must be the admin of `proxy`."
          },
          "getProxyImplementation(address)": {
            "details": "Returns the current implementation of `proxy`. Requirements: - This contract must be the admin of `proxy`."
          },
          "renounceOwnership()": {
            "details": "Renouncing ownership will leave the contract without an owner,         thereby removing any functionality that is only available to the owner."
          },
          "transferOwnership(address)": {
            "details": "Can only be called by the current owner.",
            "params": {
              "newOwner": "Address of the new owner"
            }
          },
          "upgrade(address,address)": {
            "details": "Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}. Requirements: - This contract must be the admin of `proxy`."
          },
          "upgradeAndCall(address,address,bytes)": {
            "details": "Upgrades `proxy` to `implementation` and calls a function on the new implementation. See {TransparentUpgradeableProxy-upgradeToAndCall}. Requirements: - This contract must be the admin of `proxy`."
          }
        },
        "version": 1
      },
      "evm": {
        "bytecode": {
          "functionDebugData": {
            "@_23962": {
              "entryPoint": null,
              "id": 23962,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@_25923": {
              "entryPoint": null,
              "id": 25923,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@_transferOwnership_26003": {
              "entryPoint": 33,
              "id": 26003,
              "parameterSlots": 1,
              "returnSlots": 0
            }
          },
          "generatedSources": [],
          "linkReferences": {},
          "object": "608060405234801561001057600080fd5b503361001b81610021565b50610071565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6108b5806100806000396000f3fe60806040526004361061007b5760003560e01c80639623609d1161004e5780639623609d1461010b57806399a88ec41461011e578063f2fde38b1461013e578063f3b7dead1461015e57600080fd5b8063204e1c7a14610080578063715018a6146100b65780637eff275e146100cd5780638da5cb5b146100ed575b600080fd5b34801561008c57600080fd5b506100a061009b366004610505565b61017e565b6040516100ad9190610535565b60405180910390f35b3480156100c257600080fd5b506100cb610204565b005b3480156100d957600080fd5b506100cb6100e8366004610557565b610252565b3480156100f957600080fd5b506000546001600160a01b03166100a0565b6100cb61011936600461068f565b6102ed565b34801561012a57600080fd5b506100cb610139366004610557565b61038d565b34801561014a57600080fd5b506100cb6101593660046106fa565b6103f2565b34801561016a57600080fd5b506100a0610179366004610505565b61045d565b6000806000836001600160a01b03166040516101999061072c565b600060405180830381855afa9150503d80600081146101d4576040519150601f19603f3d011682016040523d82523d6000602084013e6101d9565b606091505b5091509150816101e857600080fd5b808060200190518101906101fc9190610740565b949350505050565b336102176000546001600160a01b031690565b6001600160a01b0316146102465760405162461bcd60e51b815260040161023d90610761565b60405180910390fd5b6102506000610478565b565b336102656000546001600160a01b031690565b6001600160a01b03161461028b5760405162461bcd60e51b815260040161023d90610761565b6040516308f2839760e41b81526001600160a01b03831690638f283970906102b7908490600401610535565b600060405180830381600087803b1580156102d157600080fd5b505af11580156102e5573d6000803e3d6000fd5b505050505050565b336103006000546001600160a01b031690565b6001600160a01b0316146103265760405162461bcd60e51b815260040161023d90610761565b60405163278f794360e11b81526001600160a01b03841690634f1ef28690349061035690869086906004016107fd565b6000604051808303818588803b15801561036f57600080fd5b505af1158015610383573d6000803e3d6000fd5b5050505050505050565b336103a06000546001600160a01b031690565b6001600160a01b0316146103c65760405162461bcd60e51b815260040161023d90610761565b604051631b2ce7f360e11b81526001600160a01b03831690633659cfe6906102b7908490600401610535565b336104056000546001600160a01b031690565b6001600160a01b03161461042b5760405162461bcd60e51b815260040161023d90610761565b6001600160a01b0381166104515760405162461bcd60e51b815260040161023d9061081d565b61045a81610478565b50565b6000806000836001600160a01b031660405161019990610876565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006001600160a01b0382165b92915050565b60006104d5826104c8565b6104ef816104db565b811461045a57600080fd5b80356104d5816104e6565b60006020828403121561051a5761051a600080fd5b60006101fc84846104fa565b61052f816104c8565b82525050565b602081016104d58284610526565b6104ef816104c8565b80356104d581610543565b6000806040838503121561056d5761056d600080fd5b600061057985856104fa565b925050602061058a8582860161054c565b9150509250929050565b634e487b7160e01b600052604160045260246000fd5b601f19601f830116810181811067ffffffffffffffff821117156105d0576105d0610594565b6040525050565b60006105e260405190565b90506105ee82826105aa565b919050565b600067ffffffffffffffff82111561060d5761060d610594565b601f19601f83011660200192915050565b82818337506000910152565b600061063d610638846105f3565b6105d7565b90508281526020810184848401111561065857610658600080fd5b61066384828561061e565b509392505050565b600082601f83011261067f5761067f600080fd5b81356101fc84826020860161062a565b6000806000606084860312156106a7576106a7600080fd5b60006106b386866104fa565b93505060206106c48682870161054c565b925050604084013567ffffffffffffffff8111156106e4576106e4600080fd5b6106f08682870161066b565b9150509250925092565b60006020828403121561070f5761070f600080fd5b60006101fc848461054c565b635c60da1b60e01b81525b60040190565b6105ee8161071b565b80516104d581610543565b60006020828403121561075557610755600080fd5b60006101fc8484610735565b60208082528181019081527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726040830152606082016104d5565b60005b838110156107b657818101518382015260200161079e565b838111156107c5576000848401525b50505050565b60006107d5825190565b8084526020840193506107ec81856020860161079b565b601f01601f19169290920192915050565b6040810161080b8285610526565b81810360208301526101fc81846107cb565b602080825281016104d581602681527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160208201526564647265737360d01b604082015260600190565b6303e1469160e61b8152610726565b6105ee8161086756fea2646970667358221220b2e73e40ff4f6664e6a342d26cbd1b6d2f85e1850495fb416ec82fd3c0054ba464736f6c634300080a0033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP CALLER PUSH2 0x1B DUP2 PUSH2 0x21 JUMP JUMPDEST POP PUSH2 0x71 JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 DUP2 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT DUP4 AND DUP2 OR DUP5 SSTORE PUSH1 0x40 MLOAD SWAP2 SWAP1 SWAP3 AND SWAP3 DUP4 SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH2 0x8B5 DUP1 PUSH2 0x80 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x7B JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x9623609D GT PUSH2 0x4E JUMPI DUP1 PUSH4 0x9623609D EQ PUSH2 0x10B JUMPI DUP1 PUSH4 0x99A88EC4 EQ PUSH2 0x11E JUMPI DUP1 PUSH4 0xF2FDE38B EQ PUSH2 0x13E JUMPI DUP1 PUSH4 0xF3B7DEAD EQ PUSH2 0x15E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x204E1C7A EQ PUSH2 0x80 JUMPI DUP1 PUSH4 0x715018A6 EQ PUSH2 0xB6 JUMPI DUP1 PUSH4 0x7EFF275E EQ PUSH2 0xCD JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0xED JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x8C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xA0 PUSH2 0x9B CALLDATASIZE PUSH1 0x4 PUSH2 0x505 JUMP JUMPDEST PUSH2 0x17E JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xAD SWAP2 SWAP1 PUSH2 0x535 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xC2 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xCB PUSH2 0x204 JUMP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xD9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xCB PUSH2 0xE8 CALLDATASIZE PUSH1 0x4 PUSH2 0x557 JUMP JUMPDEST PUSH2 0x252 JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xF9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH2 0xA0 JUMP JUMPDEST PUSH2 0xCB PUSH2 0x119 CALLDATASIZE PUSH1 0x4 PUSH2 0x68F JUMP JUMPDEST PUSH2 0x2ED JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x12A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xCB PUSH2 0x139 CALLDATASIZE PUSH1 0x4 PUSH2 0x557 JUMP JUMPDEST PUSH2 0x38D JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x14A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xCB PUSH2 0x159 CALLDATASIZE PUSH1 0x4 PUSH2 0x6FA JUMP JUMPDEST PUSH2 0x3F2 JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x16A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xA0 PUSH2 0x179 CALLDATASIZE PUSH1 0x4 PUSH2 0x505 JUMP JUMPDEST PUSH2 0x45D JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x40 MLOAD PUSH2 0x199 SWAP1 PUSH2 0x72C JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 GAS STATICCALL SWAP2 POP POP RETURNDATASIZE DUP1 PUSH1 0x0 DUP2 EQ PUSH2 0x1D4 JUMPI PUSH1 0x40 MLOAD SWAP2 POP PUSH1 0x1F NOT PUSH1 0x3F RETURNDATASIZE ADD AND DUP3 ADD PUSH1 0x40 MSTORE RETURNDATASIZE DUP3 MSTORE RETURNDATASIZE PUSH1 0x0 PUSH1 0x20 DUP5 ADD RETURNDATACOPY PUSH2 0x1D9 JUMP JUMPDEST PUSH1 0x60 SWAP2 POP JUMPDEST POP SWAP2 POP SWAP2 POP DUP2 PUSH2 0x1E8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 DUP1 PUSH1 0x20 ADD SWAP1 MLOAD DUP2 ADD SWAP1 PUSH2 0x1FC SWAP2 SWAP1 PUSH2 0x740 JUMP JUMPDEST SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST CALLER PUSH2 0x217 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x246 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x250 PUSH1 0x0 PUSH2 0x478 JUMP JUMPDEST JUMP JUMPDEST CALLER PUSH2 0x265 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x28B JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x8F28397 PUSH1 0xE4 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 PUSH4 0x8F283970 SWAP1 PUSH2 0x2B7 SWAP1 DUP5 SWAP1 PUSH1 0x4 ADD PUSH2 0x535 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x2D1 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x2E5 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP JUMP JUMPDEST CALLER PUSH2 0x300 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x326 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x278F7943 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND SWAP1 PUSH4 0x4F1EF286 SWAP1 CALLVALUE SWAP1 PUSH2 0x356 SWAP1 DUP7 SWAP1 DUP7 SWAP1 PUSH1 0x4 ADD PUSH2 0x7FD JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x36F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x383 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP POP POP JUMP JUMPDEST CALLER PUSH2 0x3A0 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x3C6 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x1B2CE7F3 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 PUSH4 0x3659CFE6 SWAP1 PUSH2 0x2B7 SWAP1 DUP5 SWAP1 PUSH1 0x4 ADD PUSH2 0x535 JUMP JUMPDEST CALLER PUSH2 0x405 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x42B JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND PUSH2 0x451 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x81D JUMP JUMPDEST PUSH2 0x45A DUP2 PUSH2 0x478 JUMP JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x40 MLOAD PUSH2 0x199 SWAP1 PUSH2 0x876 JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 DUP2 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT DUP4 AND DUP2 OR DUP5 SSTORE PUSH1 0x40 MLOAD SWAP2 SWAP1 SWAP3 AND SWAP3 DUP4 SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x4D5 DUP3 PUSH2 0x4C8 JUMP JUMPDEST PUSH2 0x4EF DUP2 PUSH2 0x4DB JUMP JUMPDEST DUP2 EQ PUSH2 0x45A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 CALLDATALOAD PUSH2 0x4D5 DUP2 PUSH2 0x4E6 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x51A JUMPI PUSH2 0x51A PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x1FC DUP5 DUP5 PUSH2 0x4FA JUMP JUMPDEST PUSH2 0x52F DUP2 PUSH2 0x4C8 JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x20 DUP2 ADD PUSH2 0x4D5 DUP3 DUP5 PUSH2 0x526 JUMP JUMPDEST PUSH2 0x4EF DUP2 PUSH2 0x4C8 JUMP JUMPDEST DUP1 CALLDATALOAD PUSH2 0x4D5 DUP2 PUSH2 0x543 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0x56D JUMPI PUSH2 0x56D PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x579 DUP6 DUP6 PUSH2 0x4FA JUMP JUMPDEST SWAP3 POP POP PUSH1 0x20 PUSH2 0x58A DUP6 DUP3 DUP7 ADD PUSH2 0x54C JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND DUP2 ADD DUP2 DUP2 LT PUSH8 0xFFFFFFFFFFFFFFFF DUP3 GT OR ISZERO PUSH2 0x5D0 JUMPI PUSH2 0x5D0 PUSH2 0x594 JUMP JUMPDEST PUSH1 0x40 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x5E2 PUSH1 0x40 MLOAD SWAP1 JUMP JUMPDEST SWAP1 POP PUSH2 0x5EE DUP3 DUP3 PUSH2 0x5AA JUMP JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH8 0xFFFFFFFFFFFFFFFF DUP3 GT ISZERO PUSH2 0x60D JUMPI PUSH2 0x60D PUSH2 0x594 JUMP JUMPDEST PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND PUSH1 0x20 ADD SWAP3 SWAP2 POP POP JUMP JUMPDEST DUP3 DUP2 DUP4 CALLDATACOPY POP PUSH1 0x0 SWAP2 ADD MSTORE JUMP JUMPDEST PUSH1 0x0 PUSH2 0x63D PUSH2 0x638 DUP5 PUSH2 0x5F3 JUMP JUMPDEST PUSH2 0x5D7 JUMP JUMPDEST SWAP1 POP DUP3 DUP2 MSTORE PUSH1 0x20 DUP2 ADD DUP5 DUP5 DUP5 ADD GT ISZERO PUSH2 0x658 JUMPI PUSH2 0x658 PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x663 DUP5 DUP3 DUP6 PUSH2 0x61E JUMP JUMPDEST POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x67F JUMPI PUSH2 0x67F PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH2 0x1FC DUP5 DUP3 PUSH1 0x20 DUP7 ADD PUSH2 0x62A JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x6A7 JUMPI PUSH2 0x6A7 PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x6B3 DUP7 DUP7 PUSH2 0x4FA JUMP JUMPDEST SWAP4 POP POP PUSH1 0x20 PUSH2 0x6C4 DUP7 DUP3 DUP8 ADD PUSH2 0x54C JUMP JUMPDEST SWAP3 POP POP PUSH1 0x40 DUP5 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT ISZERO PUSH2 0x6E4 JUMPI PUSH2 0x6E4 PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x6F0 DUP7 DUP3 DUP8 ADD PUSH2 0x66B JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x70F JUMPI PUSH2 0x70F PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x1FC DUP5 DUP5 PUSH2 0x54C JUMP JUMPDEST PUSH4 0x5C60DA1B PUSH1 0xE0 SHL DUP2 MSTORE JUMPDEST PUSH1 0x4 ADD SWAP1 JUMP JUMPDEST PUSH2 0x5EE DUP2 PUSH2 0x71B JUMP JUMPDEST DUP1 MLOAD PUSH2 0x4D5 DUP2 PUSH2 0x543 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x755 JUMPI PUSH2 0x755 PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x1FC DUP5 DUP5 PUSH2 0x735 JUMP JUMPDEST PUSH1 0x20 DUP1 DUP3 MSTORE DUP2 DUP2 ADD SWAP1 DUP2 MSTORE PUSH32 0x4F776E61626C653A2063616C6C6572206973206E6F7420746865206F776E6572 PUSH1 0x40 DUP4 ADD MSTORE PUSH1 0x60 DUP3 ADD PUSH2 0x4D5 JUMP JUMPDEST PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x7B6 JUMPI DUP2 DUP2 ADD MLOAD DUP4 DUP3 ADD MSTORE PUSH1 0x20 ADD PUSH2 0x79E JUMP JUMPDEST DUP4 DUP2 GT ISZERO PUSH2 0x7C5 JUMPI PUSH1 0x0 DUP5 DUP5 ADD MSTORE JUMPDEST POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x7D5 DUP3 MLOAD SWAP1 JUMP JUMPDEST DUP1 DUP5 MSTORE PUSH1 0x20 DUP5 ADD SWAP4 POP PUSH2 0x7EC DUP2 DUP6 PUSH1 0x20 DUP7 ADD PUSH2 0x79B JUMP JUMPDEST PUSH1 0x1F ADD PUSH1 0x1F NOT AND SWAP3 SWAP1 SWAP3 ADD SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x40 DUP2 ADD PUSH2 0x80B DUP3 DUP6 PUSH2 0x526 JUMP JUMPDEST DUP2 DUP2 SUB PUSH1 0x20 DUP4 ADD MSTORE PUSH2 0x1FC DUP2 DUP5 PUSH2 0x7CB JUMP JUMPDEST PUSH1 0x20 DUP1 DUP3 MSTORE DUP2 ADD PUSH2 0x4D5 DUP2 PUSH1 0x26 DUP2 MSTORE PUSH32 0x4F776E61626C653A206E6577206F776E657220697320746865207A65726F2061 PUSH1 0x20 DUP3 ADD MSTORE PUSH6 0x646472657373 PUSH1 0xD0 SHL PUSH1 0x40 DUP3 ADD MSTORE PUSH1 0x60 ADD SWAP1 JUMP JUMPDEST PUSH4 0x3E14691 PUSH1 0xE6 SHL DUP2 MSTORE PUSH2 0x726 JUMP JUMPDEST PUSH2 0x5EE DUP2 PUSH2 0x867 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xB2 0xE7 RETURNDATACOPY BLOCKHASH SELFDESTRUCT 0x4F PUSH7 0x64E6A342D26CBD SHL PUSH14 0x2F85E1850495FB416EC82FD3C005 0x4B LOG4 PUSH5 0x736F6C6343 STOP ADDMOD EXP STOP CALLER ",
          "sourceMap": "472:2612:100:-:0;;;509:36;;;;;;;;;-1:-1:-1;531:10:100;506:33:112;531:10:100;506:18:112;:33::i;:::-;461:85;472:2612:100;;2035:187:112;2108:16;2127:6;;-1:-1:-1;;;;;2143:17:112;;;-1:-1:-1;;;;;;2143:17:112;;;;;;2175:40;;2127:6;;;;;;;2175:40;;2108:16;2175:40;2098:124;2035:187;:::o;472:2612:100:-;;;;;;;"
        },
        "deployedBytecode": {
          "functionDebugData": {
            "@_transferOwnership_26003": {
              "entryPoint": 1144,
              "id": 26003,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@changeProxyAdmin_24048": {
              "entryPoint": 594,
              "id": 24048,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "@getProxyAdmin_24030": {
              "entryPoint": 1117,
              "id": 24030,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@getProxyImplementation_23996": {
              "entryPoint": 382,
              "id": 23996,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "@owner_25932": {
              "entryPoint": null,
              "id": 25932,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "@renounceOwnership_25960": {
              "entryPoint": 516,
              "id": 25960,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "@transferOwnership_25983": {
              "entryPoint": 1010,
              "id": 25983,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "@upgradeAndCall_24090": {
              "entryPoint": 749,
              "id": 24090,
              "parameterSlots": 3,
              "returnSlots": 0
            },
            "@upgrade_24066": {
              "entryPoint": 909,
              "id": 24066,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "abi_decode_address": {
              "entryPoint": 1356,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_address_payable_fromMemory": {
              "entryPoint": 1845,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_available_length_bytes": {
              "entryPoint": 1578,
              "id": null,
              "parameterSlots": 3,
              "returnSlots": 1
            },
            "abi_decode_bytes": {
              "entryPoint": 1643,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_contract_TransparentUpgradeableProxy": {
              "entryPoint": 1274,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_address": {
              "entryPoint": 1786,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_address_payable_fromMemory": {
              "entryPoint": 1856,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_contract$_TransparentUpgradeableProxy_$4160": {
              "entryPoint": 1285,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_decode_tuple_t_contract$_TransparentUpgradeableProxy_$4160t_address": {
              "entryPoint": 1367,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 2
            },
            "abi_decode_tuple_t_contract$_TransparentUpgradeableProxy_$4160t_addresst_bytes_memory_ptr": {
              "entryPoint": 1679,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 3
            },
            "abi_encode_address": {
              "entryPoint": 1318,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "abi_encode_bytes": {
              "entryPoint": 1995,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_stringliteral": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_stringliteral_245f": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_stringliteral_96a4": {
              "entryPoint": 1819,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_stringliteral_cb23": {
              "entryPoint": 2151,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_packed_t_stringliteral_96a4c6be7716f5be15d118c16bd1d464cb27f01187d0b9218993a5d488a47c29__to_t_bytes_memory_ptr__nonPadded_inplace_fromStack_reversed": {
              "entryPoint": 1836,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_packed_t_stringliteral_cb23cf6c353ccb16f0d92c8e6b5c5b425654e65dd07e2d295b394de4cf15afb7__to_t_bytes_memory_ptr__nonPadded_inplace_fromStack_reversed": {
              "entryPoint": 2166,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_address__to_t_address__fromStack_reversed": {
              "entryPoint": 1333,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_address_t_bytes_memory_ptr__to_t_address_t_bytes_memory_ptr__fromStack_reversed": {
              "entryPoint": 2045,
              "id": null,
              "parameterSlots": 3,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_stringliteral_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe__to_t_string_memory_ptr__fromStack_reversed": {
              "entryPoint": 2077,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "abi_encode_tuple_t_stringliteral_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe__to_t_string_memory_ptr__fromStack_reversed": {
              "entryPoint": 1889,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "allocate_memory": {
              "entryPoint": 1495,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "allocate_unbounded": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 0,
              "returnSlots": 1
            },
            "array_allocation_size_bytes": {
              "entryPoint": 1523,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "array_length_bytes": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "array_storeLengthForEncoding_bytes_nonPadded_inplace": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "array_storeLengthForEncoding_string": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 1
            },
            "cleanup_address_payable": {
              "entryPoint": 1224,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "cleanup_contract_TransparentUpgradeableProxy": {
              "entryPoint": 1243,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "cleanup_uint160": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "copy_calldata_to_memory": {
              "entryPoint": 1566,
              "id": null,
              "parameterSlots": 3,
              "returnSlots": 0
            },
            "copy_memory_to_memory": {
              "entryPoint": 1947,
              "id": null,
              "parameterSlots": 3,
              "returnSlots": 0
            },
            "finalize_allocation": {
              "entryPoint": 1450,
              "id": null,
              "parameterSlots": 2,
              "returnSlots": 0
            },
            "panic_error_0x41": {
              "entryPoint": 1428,
              "id": null,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 0,
              "returnSlots": 0
            },
            "round_up_to_mul_of": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 1
            },
            "store_literal_in_memory_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "store_literal_in_memory_96a4c6be7716f5be15d118c16bd1d464cb27f01187d0b9218993a5d488a47c29": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "store_literal_in_memory_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "store_literal_in_memory_cb23cf6c353ccb16f0d92c8e6b5c5b425654e65dd07e2d295b394de4cf15afb7": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "validator_revert_address": {
              "entryPoint": 1347,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "validator_revert_address_payable": {
              "entryPoint": null,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 0
            },
            "validator_revert_contract_TransparentUpgradeableProxy": {
              "entryPoint": 1254,
              "id": null,
              "parameterSlots": 1,
              "returnSlots": 0
            }
          },
          "generatedSources": [
            {
              "ast": {
                "nodeType": "YulBlock",
                "src": "0:10298:120",
                "statements": [
                  {
                    "nodeType": "YulBlock",
                    "src": "6:3:120",
                    "statements": []
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "58:23:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "60:19:120",
                          "value": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "76:2:120",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "70:5:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "70:9:120"
                          },
                          "variableNames": [
                            {
                              "name": "memPtr",
                              "nodeType": "YulIdentifier",
                              "src": "60:6:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "allocate_unbounded",
                    "nodeType": "YulFunctionDefinition",
                    "returnVariables": [
                      {
                        "name": "memPtr",
                        "nodeType": "YulTypedName",
                        "src": "47:6:120",
                        "type": ""
                      }
                    ],
                    "src": "14:67:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "179:16:120",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "188:1:120",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "191:1:120",
                                "type": "",
                                "value": "0"
                              }
                            ],
                            "functionName": {
                              "name": "revert",
                              "nodeType": "YulIdentifier",
                              "src": "181:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "181:12:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "181:12:120"
                        }
                      ]
                    },
                    "name": "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b",
                    "nodeType": "YulFunctionDefinition",
                    "src": "86:109:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "247:58:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "257:42:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "272:5:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "287:3:120",
                                        "type": "",
                                        "value": "160"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "292:1:120",
                                        "type": "",
                                        "value": "1"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "shl",
                                      "nodeType": "YulIdentifier",
                                      "src": "283:3:120"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "283:11:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "296:1:120",
                                    "type": "",
                                    "value": "1"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "279:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "279:19:120"
                              }
                            ],
                            "functionName": {
                              "name": "and",
                              "nodeType": "YulIdentifier",
                              "src": "268:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "268:31:120"
                          },
                          "variableNames": [
                            {
                              "name": "cleaned",
                              "nodeType": "YulIdentifier",
                              "src": "257:7:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "cleanup_uint160",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "225:5:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "cleaned",
                        "nodeType": "YulTypedName",
                        "src": "235:7:120",
                        "type": ""
                      }
                    ],
                    "src": "200:105:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "365:49:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "375:33:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "402:5:120"
                              }
                            ],
                            "functionName": {
                              "name": "cleanup_uint160",
                              "nodeType": "YulIdentifier",
                              "src": "386:15:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "386:22:120"
                          },
                          "variableNames": [
                            {
                              "name": "cleaned",
                              "nodeType": "YulIdentifier",
                              "src": "375:7:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "cleanup_address_payable",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "343:5:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "cleaned",
                        "nodeType": "YulTypedName",
                        "src": "353:7:120",
                        "type": ""
                      }
                    ],
                    "src": "310:104:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "495:57:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "505:41:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "540:5:120"
                              }
                            ],
                            "functionName": {
                              "name": "cleanup_address_payable",
                              "nodeType": "YulIdentifier",
                              "src": "516:23:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "516:30:120"
                          },
                          "variableNames": [
                            {
                              "name": "cleaned",
                              "nodeType": "YulIdentifier",
                              "src": "505:7:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "cleanup_contract_TransparentUpgradeableProxy",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "473:5:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "cleaned",
                        "nodeType": "YulTypedName",
                        "src": "483:7:120",
                        "type": ""
                      }
                    ],
                    "src": "419:133:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "631:106:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "715:16:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "724:1:120",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "727:1:120",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "717:6:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "717:12:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "717:12:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "654:5:120"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "706:5:120"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "cleanup_contract_TransparentUpgradeableProxy",
                                      "nodeType": "YulIdentifier",
                                      "src": "661:44:120"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "661:51:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "651:2:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "651:62:120"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "644:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "644:70:120"
                          },
                          "nodeType": "YulIf",
                          "src": "641:90:120"
                        }
                      ]
                    },
                    "name": "validator_revert_contract_TransparentUpgradeableProxy",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "620:5:120",
                        "type": ""
                      }
                    ],
                    "src": "557:180:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "825:114:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "835:29:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "857:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "844:12:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "844:20:120"
                          },
                          "variableNames": [
                            {
                              "name": "value",
                              "nodeType": "YulIdentifier",
                              "src": "835:5:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "927:5:120"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_contract_TransparentUpgradeableProxy",
                              "nodeType": "YulIdentifier",
                              "src": "873:53:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "873:60:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "873:60:120"
                        }
                      ]
                    },
                    "name": "abi_decode_contract_TransparentUpgradeableProxy",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "offset",
                        "nodeType": "YulTypedName",
                        "src": "799:6:120",
                        "type": ""
                      },
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "807:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "815:5:120",
                        "type": ""
                      }
                    ],
                    "src": "742:197:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1050:286:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1104:103:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b",
                                    "nodeType": "YulIdentifier",
                                    "src": "1118:77:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1118:79:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1118:79:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "1071:7:120"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1080:9:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "1067:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1067:23:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1092:2:120",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "1063:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1063:32:120"
                          },
                          "nodeType": "YulIf",
                          "src": "1060:147:120"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "1216:15:120",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "1230:1:120",
                            "type": "",
                            "value": "0"
                          },
                          "variables": [
                            {
                              "name": "offset",
                              "nodeType": "YulTypedName",
                              "src": "1220:6:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "1240:90:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1302:9:120"
                                  },
                                  {
                                    "name": "offset",
                                    "nodeType": "YulIdentifier",
                                    "src": "1313:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "1298:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1298:22:120"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "1322:7:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_contract_TransparentUpgradeableProxy",
                              "nodeType": "YulIdentifier",
                              "src": "1250:47:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1250:80:120"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "1240:6:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_contract$_TransparentUpgradeableProxy_$4160",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1016:9:120",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "1027:7:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1039:6:120",
                        "type": ""
                      }
                    ],
                    "src": "944:392:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1385:59:120",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "1402:3:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "1431:5:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "cleanup_address_payable",
                                  "nodeType": "YulIdentifier",
                                  "src": "1407:23:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1407:30:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "1395:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1395:43:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1395:43:120"
                        }
                      ]
                    },
                    "name": "abi_encode_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "1369:5:120",
                        "type": ""
                      },
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "1376:3:120",
                        "type": ""
                      }
                    ],
                    "src": "1341:103:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1550:96:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "1560:26:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "1572:9:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "1583:2:120",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "1568:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1568:18:120"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "1560:4:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "1614:6:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "1626:9:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "1637:1:120",
                                    "type": "",
                                    "value": "0"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "1622:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1622:17:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_encode_address",
                              "nodeType": "YulIdentifier",
                              "src": "1595:18:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1595:45:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1595:45:120"
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_address__to_t_address__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "1519:9:120",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "1530:6:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "1541:4:120",
                        "type": ""
                      }
                    ],
                    "src": "1449:197:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1696:85:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "1759:16:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1768:1:120",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "1771:1:120",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "1761:6:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "1761:12:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "1761:12:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "1719:5:120"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "1750:5:120"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "cleanup_address_payable",
                                      "nodeType": "YulIdentifier",
                                      "src": "1726:23:120"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "1726:30:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "1716:2:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "1716:41:120"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "1709:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1709:49:120"
                          },
                          "nodeType": "YulIf",
                          "src": "1706:69:120"
                        }
                      ]
                    },
                    "name": "validator_revert_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "1685:5:120",
                        "type": ""
                      }
                    ],
                    "src": "1651:130:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "1840:85:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "1850:29:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "1872:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "1859:12:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1859:20:120"
                          },
                          "variableNames": [
                            {
                              "name": "value",
                              "nodeType": "YulIdentifier",
                              "src": "1850:5:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "1913:5:120"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_address",
                              "nodeType": "YulIdentifier",
                              "src": "1888:24:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "1888:31:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "1888:31:120"
                        }
                      ]
                    },
                    "name": "abi_decode_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "offset",
                        "nodeType": "YulTypedName",
                        "src": "1814:6:120",
                        "type": ""
                      },
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "1822:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "1830:5:120",
                        "type": ""
                      }
                    ],
                    "src": "1786:139:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2053:385:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "2107:103:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b",
                                    "nodeType": "YulIdentifier",
                                    "src": "2121:77:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "2121:79:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "2121:79:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "2074:7:120"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2083:9:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "2070:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2070:23:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2095:2:120",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "2066:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2066:32:120"
                          },
                          "nodeType": "YulIf",
                          "src": "2063:147:120"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "2219:15:120",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "2233:1:120",
                            "type": "",
                            "value": "0"
                          },
                          "variables": [
                            {
                              "name": "offset",
                              "nodeType": "YulTypedName",
                              "src": "2223:6:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "2243:90:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2305:9:120"
                                  },
                                  {
                                    "name": "offset",
                                    "nodeType": "YulIdentifier",
                                    "src": "2316:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2301:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2301:22:120"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "2325:7:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_contract_TransparentUpgradeableProxy",
                              "nodeType": "YulIdentifier",
                              "src": "2253:47:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2253:80:120"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "2243:6:120"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "2342:18:120",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "2358:2:120",
                            "type": "",
                            "value": "32"
                          },
                          "variables": [
                            {
                              "name": "offset_1",
                              "nodeType": "YulTypedName",
                              "src": "2346:8:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "2369:63:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "2402:9:120"
                                  },
                                  {
                                    "name": "offset_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "2413:8:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2398:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2398:24:120"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "2424:7:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address",
                              "nodeType": "YulIdentifier",
                              "src": "2379:18:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2379:53:120"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nodeType": "YulIdentifier",
                              "src": "2369:6:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_contract$_TransparentUpgradeableProxy_$4160t_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "2011:9:120",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "2022:7:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "2034:6:120",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "2042:6:120",
                        "type": ""
                      }
                    ],
                    "src": "1930:508:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2492:54:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "2502:38:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "2520:5:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2527:2:120",
                                    "type": "",
                                    "value": "31"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "2516:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2516:14:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2536:2:120",
                                    "type": "",
                                    "value": "31"
                                  }
                                ],
                                "functionName": {
                                  "name": "not",
                                  "nodeType": "YulIdentifier",
                                  "src": "2532:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2532:7:120"
                              }
                            ],
                            "functionName": {
                              "name": "and",
                              "nodeType": "YulIdentifier",
                              "src": "2512:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2512:28:120"
                          },
                          "variableNames": [
                            {
                              "name": "result",
                              "nodeType": "YulIdentifier",
                              "src": "2502:6:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "round_up_to_mul_of",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "2471:5:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "result",
                        "nodeType": "YulTypedName",
                        "src": "2481:6:120",
                        "type": ""
                      }
                    ],
                    "src": "2443:103:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2583:95:120",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2600:1:120",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2607:3:120",
                                    "type": "",
                                    "value": "224"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2612:10:120",
                                    "type": "",
                                    "value": "0x4e487b71"
                                  }
                                ],
                                "functionName": {
                                  "name": "shl",
                                  "nodeType": "YulIdentifier",
                                  "src": "2603:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2603:20:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2593:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2593:31:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2593:31:120"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2640:1:120",
                                "type": "",
                                "value": "4"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2643:4:120",
                                "type": "",
                                "value": "0x41"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2633:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2633:15:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2633:15:120"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2664:1:120",
                                "type": "",
                                "value": "0"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2667:4:120",
                                "type": "",
                                "value": "0x24"
                              }
                            ],
                            "functionName": {
                              "name": "revert",
                              "nodeType": "YulIdentifier",
                              "src": "2657:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2657:15:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2657:15:120"
                        }
                      ]
                    },
                    "name": "panic_error_0x41",
                    "nodeType": "YulFunctionDefinition",
                    "src": "2551:127:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2730:199:120",
                      "statements": [
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "2740:55:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "memPtr",
                                "nodeType": "YulIdentifier",
                                "src": "2762:6:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "size",
                                    "nodeType": "YulIdentifier",
                                    "src": "2789:4:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "round_up_to_mul_of",
                                  "nodeType": "YulIdentifier",
                                  "src": "2770:18:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2770:24:120"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "2758:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2758:37:120"
                          },
                          "variables": [
                            {
                              "name": "newFreePtr",
                              "nodeType": "YulTypedName",
                              "src": "2744:10:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "2870:22:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x41",
                                    "nodeType": "YulIdentifier",
                                    "src": "2872:16:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "2872:18:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "2872:18:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "newFreePtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "2813:10:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "2825:18:120",
                                    "type": "",
                                    "value": "0xffffffffffffffff"
                                  }
                                ],
                                "functionName": {
                                  "name": "gt",
                                  "nodeType": "YulIdentifier",
                                  "src": "2810:2:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2810:34:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "newFreePtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "2849:10:120"
                                  },
                                  {
                                    "name": "memPtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "2861:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "lt",
                                  "nodeType": "YulIdentifier",
                                  "src": "2846:2:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "2846:22:120"
                              }
                            ],
                            "functionName": {
                              "name": "or",
                              "nodeType": "YulIdentifier",
                              "src": "2807:2:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2807:62:120"
                          },
                          "nodeType": "YulIf",
                          "src": "2804:88:120"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "2908:2:120",
                                "type": "",
                                "value": "64"
                              },
                              {
                                "name": "newFreePtr",
                                "nodeType": "YulIdentifier",
                                "src": "2912:10:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "2901:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2901:22:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "2901:22:120"
                        }
                      ]
                    },
                    "name": "finalize_allocation",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "memPtr",
                        "nodeType": "YulTypedName",
                        "src": "2712:6:120",
                        "type": ""
                      },
                      {
                        "name": "size",
                        "nodeType": "YulTypedName",
                        "src": "2720:4:120",
                        "type": ""
                      }
                    ],
                    "src": "2683:246:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "2979:88:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "2989:30:120",
                          "value": {
                            "arguments": [],
                            "functionName": {
                              "name": "allocate_unbounded",
                              "nodeType": "YulIdentifier",
                              "src": "2999:18:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "2999:20:120"
                          },
                          "variableNames": [
                            {
                              "name": "memPtr",
                              "nodeType": "YulIdentifier",
                              "src": "2989:6:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "memPtr",
                                "nodeType": "YulIdentifier",
                                "src": "3048:6:120"
                              },
                              {
                                "name": "size",
                                "nodeType": "YulIdentifier",
                                "src": "3056:4:120"
                              }
                            ],
                            "functionName": {
                              "name": "finalize_allocation",
                              "nodeType": "YulIdentifier",
                              "src": "3028:19:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3028:33:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3028:33:120"
                        }
                      ]
                    },
                    "name": "allocate_memory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "size",
                        "nodeType": "YulTypedName",
                        "src": "2959:4:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "memPtr",
                        "nodeType": "YulTypedName",
                        "src": "2968:6:120",
                        "type": ""
                      }
                    ],
                    "src": "2934:133:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3129:147:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3173:22:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "panic_error_0x41",
                                    "nodeType": "YulIdentifier",
                                    "src": "3175:16:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3175:18:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3175:18:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "3145:6:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3153:18:120",
                                "type": "",
                                "value": "0xffffffffffffffff"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "3142:2:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3142:30:120"
                          },
                          "nodeType": "YulIf",
                          "src": "3139:56:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3204:34:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "3231:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "round_up_to_mul_of",
                              "nodeType": "YulIdentifier",
                              "src": "3212:18:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3212:26:120"
                          },
                          "variableNames": [
                            {
                              "name": "size",
                              "nodeType": "YulIdentifier",
                              "src": "3204:4:120"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "3247:23:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "size",
                                "nodeType": "YulIdentifier",
                                "src": "3259:4:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3265:4:120",
                                "type": "",
                                "value": "0x20"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "3255:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3255:15:120"
                          },
                          "variableNames": [
                            {
                              "name": "size",
                              "nodeType": "YulIdentifier",
                              "src": "3247:4:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "array_allocation_size_bytes",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "length",
                        "nodeType": "YulTypedName",
                        "src": "3109:6:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "size",
                        "nodeType": "YulTypedName",
                        "src": "3120:4:120",
                        "type": ""
                      }
                    ],
                    "src": "3072:204:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3336:82:120",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "dst",
                                "nodeType": "YulIdentifier",
                                "src": "3359:3:120"
                              },
                              {
                                "name": "src",
                                "nodeType": "YulIdentifier",
                                "src": "3364:3:120"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "3369:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "calldatacopy",
                              "nodeType": "YulIdentifier",
                              "src": "3346:12:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3346:30:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3346:30:120"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dst",
                                    "nodeType": "YulIdentifier",
                                    "src": "3396:3:120"
                                  },
                                  {
                                    "name": "length",
                                    "nodeType": "YulIdentifier",
                                    "src": "3401:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3392:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3392:16:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3410:1:120",
                                "type": "",
                                "value": "0"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3385:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3385:27:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3385:27:120"
                        }
                      ]
                    },
                    "name": "copy_calldata_to_memory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "src",
                        "nodeType": "YulTypedName",
                        "src": "3314:3:120",
                        "type": ""
                      },
                      {
                        "name": "dst",
                        "nodeType": "YulTypedName",
                        "src": "3319:3:120",
                        "type": ""
                      },
                      {
                        "name": "length",
                        "nodeType": "YulTypedName",
                        "src": "3324:6:120",
                        "type": ""
                      }
                    ],
                    "src": "3281:137:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3497:342:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "3507:61:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "length",
                                    "nodeType": "YulIdentifier",
                                    "src": "3560:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "array_allocation_size_bytes",
                                  "nodeType": "YulIdentifier",
                                  "src": "3532:27:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3532:35:120"
                              }
                            ],
                            "functionName": {
                              "name": "allocate_memory",
                              "nodeType": "YulIdentifier",
                              "src": "3516:15:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3516:52:120"
                          },
                          "variableNames": [
                            {
                              "name": "array",
                              "nodeType": "YulIdentifier",
                              "src": "3507:5:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "array",
                                "nodeType": "YulIdentifier",
                                "src": "3584:5:120"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "3591:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "3577:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3577:21:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3577:21:120"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "3607:27:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "array",
                                "nodeType": "YulIdentifier",
                                "src": "3622:5:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "3629:4:120",
                                "type": "",
                                "value": "0x20"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "3618:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3618:16:120"
                          },
                          "variables": [
                            {
                              "name": "dst",
                              "nodeType": "YulTypedName",
                              "src": "3611:3:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3680:103:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b",
                                    "nodeType": "YulIdentifier",
                                    "src": "3694:77:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3694:79:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3694:79:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "src",
                                    "nodeType": "YulIdentifier",
                                    "src": "3653:3:120"
                                  },
                                  {
                                    "name": "length",
                                    "nodeType": "YulIdentifier",
                                    "src": "3658:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "3649:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3649:16:120"
                              },
                              {
                                "name": "end",
                                "nodeType": "YulIdentifier",
                                "src": "3667:3:120"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "3646:2:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3646:25:120"
                          },
                          "nodeType": "YulIf",
                          "src": "3643:140:120"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "src",
                                "nodeType": "YulIdentifier",
                                "src": "3816:3:120"
                              },
                              {
                                "name": "dst",
                                "nodeType": "YulIdentifier",
                                "src": "3821:3:120"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "3826:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "copy_calldata_to_memory",
                              "nodeType": "YulIdentifier",
                              "src": "3792:23:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3792:41:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "3792:41:120"
                        }
                      ]
                    },
                    "name": "abi_decode_available_length_bytes",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "src",
                        "nodeType": "YulTypedName",
                        "src": "3466:3:120",
                        "type": ""
                      },
                      {
                        "name": "length",
                        "nodeType": "YulTypedName",
                        "src": "3471:6:120",
                        "type": ""
                      },
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "3479:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "array",
                        "nodeType": "YulTypedName",
                        "src": "3487:5:120",
                        "type": ""
                      }
                    ],
                    "src": "3423:416:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "3896:292:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "3953:103:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b",
                                    "nodeType": "YulIdentifier",
                                    "src": "3967:77:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "3967:79:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "3967:79:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "arguments": [
                                      {
                                        "name": "offset",
                                        "nodeType": "YulIdentifier",
                                        "src": "3924:6:120"
                                      },
                                      {
                                        "kind": "number",
                                        "nodeType": "YulLiteral",
                                        "src": "3932:4:120",
                                        "type": "",
                                        "value": "0x1f"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "add",
                                      "nodeType": "YulIdentifier",
                                      "src": "3920:3:120"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "3920:17:120"
                                  },
                                  {
                                    "name": "end",
                                    "nodeType": "YulIdentifier",
                                    "src": "3939:3:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "slt",
                                  "nodeType": "YulIdentifier",
                                  "src": "3916:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "3916:27:120"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "3909:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "3909:35:120"
                          },
                          "nodeType": "YulIf",
                          "src": "3906:150:120"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "4065:34:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "4092:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "4079:12:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4079:20:120"
                          },
                          "variables": [
                            {
                              "name": "length",
                              "nodeType": "YulTypedName",
                              "src": "4069:6:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "4108:74:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "offset",
                                    "nodeType": "YulIdentifier",
                                    "src": "4155:6:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4163:4:120",
                                    "type": "",
                                    "value": "0x20"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4151:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4151:17:120"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "4170:6:120"
                              },
                              {
                                "name": "end",
                                "nodeType": "YulIdentifier",
                                "src": "4178:3:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_available_length_bytes",
                              "nodeType": "YulIdentifier",
                              "src": "4117:33:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4117:65:120"
                          },
                          "variableNames": [
                            {
                              "name": "array",
                              "nodeType": "YulIdentifier",
                              "src": "4108:5:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_bytes",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "offset",
                        "nodeType": "YulTypedName",
                        "src": "3870:6:120",
                        "type": ""
                      },
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "3878:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "array",
                        "nodeType": "YulTypedName",
                        "src": "3886:5:120",
                        "type": ""
                      }
                    ],
                    "src": "3844:344:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "4342:668:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "4396:103:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b",
                                    "nodeType": "YulIdentifier",
                                    "src": "4410:77:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4410:79:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4410:79:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "4363:7:120"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4372:9:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "4359:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4359:23:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4384:2:120",
                                "type": "",
                                "value": "96"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "4355:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4355:32:120"
                          },
                          "nodeType": "YulIf",
                          "src": "4352:147:120"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "4508:15:120",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "4522:1:120",
                            "type": "",
                            "value": "0"
                          },
                          "variables": [
                            {
                              "name": "offset",
                              "nodeType": "YulTypedName",
                              "src": "4512:6:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "4532:90:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4594:9:120"
                                  },
                                  {
                                    "name": "offset",
                                    "nodeType": "YulIdentifier",
                                    "src": "4605:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4590:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4590:22:120"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "4614:7:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_contract_TransparentUpgradeableProxy",
                              "nodeType": "YulIdentifier",
                              "src": "4542:47:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4542:80:120"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "4532:6:120"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "4631:18:120",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "4647:2:120",
                            "type": "",
                            "value": "32"
                          },
                          "variables": [
                            {
                              "name": "offset_1",
                              "nodeType": "YulTypedName",
                              "src": "4635:8:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "4658:63:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4691:9:120"
                                  },
                                  {
                                    "name": "offset_1",
                                    "nodeType": "YulIdentifier",
                                    "src": "4702:8:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4687:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4687:24:120"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "4713:7:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address",
                              "nodeType": "YulIdentifier",
                              "src": "4668:18:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4668:53:120"
                          },
                          "variableNames": [
                            {
                              "name": "value1",
                              "nodeType": "YulIdentifier",
                              "src": "4658:6:120"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "4730:48:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4763:9:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "4774:2:120",
                                    "type": "",
                                    "value": "64"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4759:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4759:18:120"
                              }
                            ],
                            "functionName": {
                              "name": "calldataload",
                              "nodeType": "YulIdentifier",
                              "src": "4746:12:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4746:32:120"
                          },
                          "variables": [
                            {
                              "name": "offset_2",
                              "nodeType": "YulTypedName",
                              "src": "4734:8:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "4831:103:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b",
                                    "nodeType": "YulIdentifier",
                                    "src": "4845:77:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "4845:79:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "4845:79:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "offset_2",
                                "nodeType": "YulIdentifier",
                                "src": "4793:8:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "4803:18:120",
                                "type": "",
                                "value": "0xffffffffffffffff"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "4790:2:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4790:32:120"
                          },
                          "nodeType": "YulIf",
                          "src": "4787:147:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "4943:61:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "4974:9:120"
                                  },
                                  {
                                    "name": "offset_2",
                                    "nodeType": "YulIdentifier",
                                    "src": "4985:8:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "4970:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "4970:24:120"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "4996:7:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_bytes",
                              "nodeType": "YulIdentifier",
                              "src": "4953:16:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "4953:51:120"
                          },
                          "variableNames": [
                            {
                              "name": "value2",
                              "nodeType": "YulIdentifier",
                              "src": "4943:6:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_contract$_TransparentUpgradeableProxy_$4160t_addresst_bytes_memory_ptr",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "4292:9:120",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "4303:7:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "4315:6:120",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "4323:6:120",
                        "type": ""
                      },
                      {
                        "name": "value2",
                        "nodeType": "YulTypedName",
                        "src": "4331:6:120",
                        "type": ""
                      }
                    ],
                    "src": "4193:817:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5085:257:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "5139:103:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b",
                                    "nodeType": "YulIdentifier",
                                    "src": "5153:77:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "5153:79:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "5153:79:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "5106:7:120"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "5115:9:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "5102:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5102:23:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5127:2:120",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "5098:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5098:32:120"
                          },
                          "nodeType": "YulIf",
                          "src": "5095:147:120"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "5251:15:120",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "5265:1:120",
                            "type": "",
                            "value": "0"
                          },
                          "variables": [
                            {
                              "name": "offset",
                              "nodeType": "YulTypedName",
                              "src": "5255:6:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "5275:61:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "5308:9:120"
                                  },
                                  {
                                    "name": "offset",
                                    "nodeType": "YulIdentifier",
                                    "src": "5319:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "5304:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5304:22:120"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "5328:7:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address",
                              "nodeType": "YulIdentifier",
                              "src": "5285:18:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5285:51:120"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "5275:6:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_address",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "5051:9:120",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "5062:7:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "5074:6:120",
                        "type": ""
                      }
                    ],
                    "src": "5015:327:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5441:22:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "5443:18:120",
                          "value": {
                            "name": "pos",
                            "nodeType": "YulIdentifier",
                            "src": "5458:3:120"
                          },
                          "variableNames": [
                            {
                              "name": "updated_pos",
                              "nodeType": "YulIdentifier",
                              "src": "5443:11:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "array_storeLengthForEncoding_bytes_nonPadded_inplace",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "5409:3:120",
                        "type": ""
                      },
                      {
                        "name": "length",
                        "nodeType": "YulTypedName",
                        "src": "5414:6:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "updated_pos",
                        "nodeType": "YulTypedName",
                        "src": "5425:11:120",
                        "type": ""
                      }
                    ],
                    "src": "5347:116:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5578:60:120",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "memPtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "5599:6:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5607:1:120",
                                    "type": "",
                                    "value": "0"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "5595:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5595:14:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5615:3:120",
                                    "type": "",
                                    "value": "224"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "5620:10:120",
                                    "type": "",
                                    "value": "0x5c60da1b"
                                  }
                                ],
                                "functionName": {
                                  "name": "shl",
                                  "nodeType": "YulIdentifier",
                                  "src": "5611:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "5611:20:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "5588:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5588:44:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5588:44:120"
                        }
                      ]
                    },
                    "name": "store_literal_in_memory_96a4c6be7716f5be15d118c16bd1d464cb27f01187d0b9218993a5d488a47c29",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "memPtr",
                        "nodeType": "YulTypedName",
                        "src": "5566:6:120",
                        "type": ""
                      }
                    ],
                    "src": "5468:170:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "5698:212:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "5708:67:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "5768:3:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5773:1:120",
                                "type": "",
                                "value": "4"
                              }
                            ],
                            "functionName": {
                              "name": "array_storeLengthForEncoding_bytes_nonPadded_inplace",
                              "nodeType": "YulIdentifier",
                              "src": "5715:52:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5715:60:120"
                          },
                          "variableNames": [
                            {
                              "name": "pos",
                              "nodeType": "YulIdentifier",
                              "src": "5708:3:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "5873:3:120"
                              }
                            ],
                            "functionName": {
                              "name": "store_literal_in_memory_96a4c6be7716f5be15d118c16bd1d464cb27f01187d0b9218993a5d488a47c29",
                              "nodeType": "YulIdentifier",
                              "src": "5784:88:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5784:93:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "5784:93:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "5886:18:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "5897:3:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "5902:1:120",
                                "type": "",
                                "value": "4"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "5893:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "5893:11:120"
                          },
                          "variableNames": [
                            {
                              "name": "end",
                              "nodeType": "YulIdentifier",
                              "src": "5886:3:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_stringliteral_96a4",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "5682:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "5690:3:120",
                        "type": ""
                      }
                    ],
                    "src": "5643:267:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "6106:76:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "6116:41:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "6153:3:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_encode_stringliteral_96a4",
                              "nodeType": "YulIdentifier",
                              "src": "6123:29:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6123:34:120"
                          },
                          "variableNames": [
                            {
                              "name": "pos",
                              "nodeType": "YulIdentifier",
                              "src": "6116:3:120"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "6166:10:120",
                          "value": {
                            "name": "pos",
                            "nodeType": "YulIdentifier",
                            "src": "6173:3:120"
                          },
                          "variableNames": [
                            {
                              "name": "end",
                              "nodeType": "YulIdentifier",
                              "src": "6166:3:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_packed_t_stringliteral_96a4c6be7716f5be15d118c16bd1d464cb27f01187d0b9218993a5d488a47c29__to_t_bytes_memory_ptr__nonPadded_inplace_fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "6090:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "6098:3:120",
                        "type": ""
                      }
                    ],
                    "src": "5915:267:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "6240:85:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "6303:16:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "6312:1:120",
                                      "type": "",
                                      "value": "0"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "6315:1:120",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "revert",
                                    "nodeType": "YulIdentifier",
                                    "src": "6305:6:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "6305:12:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "6305:12:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "6263:5:120"
                                  },
                                  {
                                    "arguments": [
                                      {
                                        "name": "value",
                                        "nodeType": "YulIdentifier",
                                        "src": "6294:5:120"
                                      }
                                    ],
                                    "functionName": {
                                      "name": "cleanup_address_payable",
                                      "nodeType": "YulIdentifier",
                                      "src": "6270:23:120"
                                    },
                                    "nodeType": "YulFunctionCall",
                                    "src": "6270:30:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "eq",
                                  "nodeType": "YulIdentifier",
                                  "src": "6260:2:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "6260:41:120"
                              }
                            ],
                            "functionName": {
                              "name": "iszero",
                              "nodeType": "YulIdentifier",
                              "src": "6253:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6253:49:120"
                          },
                          "nodeType": "YulIf",
                          "src": "6250:69:120"
                        }
                      ]
                    },
                    "name": "validator_revert_address_payable",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "6229:5:120",
                        "type": ""
                      }
                    ],
                    "src": "6187:138:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "6403:86:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "6413:22:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "offset",
                                "nodeType": "YulIdentifier",
                                "src": "6428:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "6422:5:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6422:13:120"
                          },
                          "variableNames": [
                            {
                              "name": "value",
                              "nodeType": "YulIdentifier",
                              "src": "6413:5:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "6477:5:120"
                              }
                            ],
                            "functionName": {
                              "name": "validator_revert_address_payable",
                              "nodeType": "YulIdentifier",
                              "src": "6444:32:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6444:39:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "6444:39:120"
                        }
                      ]
                    },
                    "name": "abi_decode_address_payable_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "offset",
                        "nodeType": "YulTypedName",
                        "src": "6377:6:120",
                        "type": ""
                      },
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "6385:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "6393:5:120",
                        "type": ""
                      }
                    ],
                    "src": "6330:159:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "6583:276:120",
                      "statements": [
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "6637:103:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [],
                                  "functionName": {
                                    "name": "revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b",
                                    "nodeType": "YulIdentifier",
                                    "src": "6651:77:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "6651:79:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "6651:79:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "dataEnd",
                                    "nodeType": "YulIdentifier",
                                    "src": "6604:7:120"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "6613:9:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "6600:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "6600:23:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "6625:2:120",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "slt",
                              "nodeType": "YulIdentifier",
                              "src": "6596:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6596:32:120"
                          },
                          "nodeType": "YulIf",
                          "src": "6593:147:120"
                        },
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "6749:15:120",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "6763:1:120",
                            "type": "",
                            "value": "0"
                          },
                          "variables": [
                            {
                              "name": "offset",
                              "nodeType": "YulTypedName",
                              "src": "6753:6:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "6773:80:120",
                          "value": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "6825:9:120"
                                  },
                                  {
                                    "name": "offset",
                                    "nodeType": "YulIdentifier",
                                    "src": "6836:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "6821:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "6821:22:120"
                              },
                              {
                                "name": "dataEnd",
                                "nodeType": "YulIdentifier",
                                "src": "6845:7:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_decode_address_payable_fromMemory",
                              "nodeType": "YulIdentifier",
                              "src": "6783:37:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6783:70:120"
                          },
                          "variableNames": [
                            {
                              "name": "value0",
                              "nodeType": "YulIdentifier",
                              "src": "6773:6:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_decode_tuple_t_address_payable_fromMemory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "6549:9:120",
                        "type": ""
                      },
                      {
                        "name": "dataEnd",
                        "nodeType": "YulTypedName",
                        "src": "6560:7:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "6572:6:120",
                        "type": ""
                      }
                    ],
                    "src": "6494:365:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "6941:73:120",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "6958:3:120"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "6963:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "6951:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6951:19:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "6951:19:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "6979:29:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "6998:3:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "7003:4:120",
                                "type": "",
                                "value": "0x20"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "6994:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "6994:14:120"
                          },
                          "variableNames": [
                            {
                              "name": "updated_pos",
                              "nodeType": "YulIdentifier",
                              "src": "6979:11:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "array_storeLengthForEncoding_string",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "6909:3:120",
                        "type": ""
                      },
                      {
                        "name": "length",
                        "nodeType": "YulTypedName",
                        "src": "6914:6:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "updated_pos",
                        "nodeType": "YulTypedName",
                        "src": "6925:11:120",
                        "type": ""
                      }
                    ],
                    "src": "6864:150:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "7129:74:120",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "memPtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "7150:6:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "7158:1:120",
                                    "type": "",
                                    "value": "0"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "7146:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "7146:14:120"
                              },
                              {
                                "hexValue": "4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "7162:34:120",
                                "type": "",
                                "value": "Ownable: caller is not the owner"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "7139:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "7139:58:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "7139:58:120"
                        }
                      ]
                    },
                    "name": "store_literal_in_memory_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "memPtr",
                        "nodeType": "YulTypedName",
                        "src": "7117:6:120",
                        "type": ""
                      }
                    ],
                    "src": "7019:184:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "7258:197:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "7268:51:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "7311:3:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "7316:2:120",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "array_storeLengthForEncoding_string",
                              "nodeType": "YulIdentifier",
                              "src": "7275:35:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "7275:44:120"
                          },
                          "variableNames": [
                            {
                              "name": "pos",
                              "nodeType": "YulIdentifier",
                              "src": "7268:3:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "7417:3:120"
                              }
                            ],
                            "functionName": {
                              "name": "store_literal_in_memory_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe",
                              "nodeType": "YulIdentifier",
                              "src": "7328:88:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "7328:93:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "7328:93:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "7430:19:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "7441:3:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "7446:2:120",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "7437:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "7437:12:120"
                          },
                          "variableNames": [
                            {
                              "name": "end",
                              "nodeType": "YulIdentifier",
                              "src": "7430:3:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_stringliteral",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "7242:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "7250:3:120",
                        "type": ""
                      }
                    ],
                    "src": "7208:247:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "7634:145:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "7644:26:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "7656:9:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "7667:2:120",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "7652:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "7652:18:120"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "7644:4:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "7690:9:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "7701:1:120",
                                    "type": "",
                                    "value": "0"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "7686:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "7686:17:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "tail",
                                    "nodeType": "YulIdentifier",
                                    "src": "7709:4:120"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "7715:9:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "7705:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "7705:20:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "7679:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "7679:47:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "7679:47:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "7735:38:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "tail",
                                "nodeType": "YulIdentifier",
                                "src": "7768:4:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_encode_stringliteral",
                              "nodeType": "YulIdentifier",
                              "src": "7743:24:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "7743:30:120"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "7735:4:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_stringliteral_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe__to_t_string_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "7611:9:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "7625:4:120",
                        "type": ""
                      }
                    ],
                    "src": "7460:319:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "7833:26:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "7835:22:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "7851:5:120"
                              }
                            ],
                            "functionName": {
                              "name": "mload",
                              "nodeType": "YulIdentifier",
                              "src": "7845:5:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "7845:12:120"
                          },
                          "variableNames": [
                            {
                              "name": "length",
                              "nodeType": "YulIdentifier",
                              "src": "7835:6:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "array_length_bytes",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "7812:5:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "length",
                        "nodeType": "YulTypedName",
                        "src": "7822:6:120",
                        "type": ""
                      }
                    ],
                    "src": "7784:75:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "7917:205:120",
                      "statements": [
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "7927:10:120",
                          "value": {
                            "kind": "number",
                            "nodeType": "YulLiteral",
                            "src": "7936:1:120",
                            "type": "",
                            "value": "0"
                          },
                          "variables": [
                            {
                              "name": "i",
                              "nodeType": "YulTypedName",
                              "src": "7931:1:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "7996:63:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "arguments": [
                                        {
                                          "name": "dst",
                                          "nodeType": "YulIdentifier",
                                          "src": "8021:3:120"
                                        },
                                        {
                                          "name": "i",
                                          "nodeType": "YulIdentifier",
                                          "src": "8026:1:120"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "add",
                                        "nodeType": "YulIdentifier",
                                        "src": "8017:3:120"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "8017:11:120"
                                    },
                                    {
                                      "arguments": [
                                        {
                                          "arguments": [
                                            {
                                              "name": "src",
                                              "nodeType": "YulIdentifier",
                                              "src": "8040:3:120"
                                            },
                                            {
                                              "name": "i",
                                              "nodeType": "YulIdentifier",
                                              "src": "8045:1:120"
                                            }
                                          ],
                                          "functionName": {
                                            "name": "add",
                                            "nodeType": "YulIdentifier",
                                            "src": "8036:3:120"
                                          },
                                          "nodeType": "YulFunctionCall",
                                          "src": "8036:11:120"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "mload",
                                        "nodeType": "YulIdentifier",
                                        "src": "8030:5:120"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "8030:18:120"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "8010:6:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "8010:39:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "8010:39:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "i",
                                "nodeType": "YulIdentifier",
                                "src": "7957:1:120"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "7960:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "lt",
                              "nodeType": "YulIdentifier",
                              "src": "7954:2:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "7954:13:120"
                          },
                          "nodeType": "YulForLoop",
                          "post": {
                            "nodeType": "YulBlock",
                            "src": "7968:19:120",
                            "statements": [
                              {
                                "nodeType": "YulAssignment",
                                "src": "7970:15:120",
                                "value": {
                                  "arguments": [
                                    {
                                      "name": "i",
                                      "nodeType": "YulIdentifier",
                                      "src": "7979:1:120"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "7982:2:120",
                                      "type": "",
                                      "value": "32"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "add",
                                    "nodeType": "YulIdentifier",
                                    "src": "7975:3:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "7975:10:120"
                                },
                                "variableNames": [
                                  {
                                    "name": "i",
                                    "nodeType": "YulIdentifier",
                                    "src": "7970:1:120"
                                  }
                                ]
                              }
                            ]
                          },
                          "pre": {
                            "nodeType": "YulBlock",
                            "src": "7950:3:120",
                            "statements": []
                          },
                          "src": "7946:113:120"
                        },
                        {
                          "body": {
                            "nodeType": "YulBlock",
                            "src": "8085:31:120",
                            "statements": [
                              {
                                "expression": {
                                  "arguments": [
                                    {
                                      "arguments": [
                                        {
                                          "name": "dst",
                                          "nodeType": "YulIdentifier",
                                          "src": "8098:3:120"
                                        },
                                        {
                                          "name": "length",
                                          "nodeType": "YulIdentifier",
                                          "src": "8103:6:120"
                                        }
                                      ],
                                      "functionName": {
                                        "name": "add",
                                        "nodeType": "YulIdentifier",
                                        "src": "8094:3:120"
                                      },
                                      "nodeType": "YulFunctionCall",
                                      "src": "8094:16:120"
                                    },
                                    {
                                      "kind": "number",
                                      "nodeType": "YulLiteral",
                                      "src": "8112:1:120",
                                      "type": "",
                                      "value": "0"
                                    }
                                  ],
                                  "functionName": {
                                    "name": "mstore",
                                    "nodeType": "YulIdentifier",
                                    "src": "8087:6:120"
                                  },
                                  "nodeType": "YulFunctionCall",
                                  "src": "8087:27:120"
                                },
                                "nodeType": "YulExpressionStatement",
                                "src": "8087:27:120"
                              }
                            ]
                          },
                          "condition": {
                            "arguments": [
                              {
                                "name": "i",
                                "nodeType": "YulIdentifier",
                                "src": "8074:1:120"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "8077:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "gt",
                              "nodeType": "YulIdentifier",
                              "src": "8071:2:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8071:13:120"
                          },
                          "nodeType": "YulIf",
                          "src": "8068:48:120"
                        }
                      ]
                    },
                    "name": "copy_memory_to_memory",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "src",
                        "nodeType": "YulTypedName",
                        "src": "7895:3:120",
                        "type": ""
                      },
                      {
                        "name": "dst",
                        "nodeType": "YulTypedName",
                        "src": "7900:3:120",
                        "type": ""
                      },
                      {
                        "name": "length",
                        "nodeType": "YulTypedName",
                        "src": "7905:6:120",
                        "type": ""
                      }
                    ],
                    "src": "7864:258:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "8176:232:120",
                      "statements": [
                        {
                          "nodeType": "YulVariableDeclaration",
                          "src": "8186:39:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "value",
                                "nodeType": "YulIdentifier",
                                "src": "8219:5:120"
                              }
                            ],
                            "functionName": {
                              "name": "array_length_bytes",
                              "nodeType": "YulIdentifier",
                              "src": "8200:18:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8200:25:120"
                          },
                          "variables": [
                            {
                              "name": "length",
                              "nodeType": "YulTypedName",
                              "src": "8190:6:120",
                              "type": ""
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "8234:55:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "8277:3:120"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "8282:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "array_storeLengthForEncoding_string",
                              "nodeType": "YulIdentifier",
                              "src": "8241:35:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8241:48:120"
                          },
                          "variableNames": [
                            {
                              "name": "pos",
                              "nodeType": "YulIdentifier",
                              "src": "8234:3:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "value",
                                    "nodeType": "YulIdentifier",
                                    "src": "8324:5:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "8331:4:120",
                                    "type": "",
                                    "value": "0x20"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "8320:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "8320:16:120"
                              },
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "8338:3:120"
                              },
                              {
                                "name": "length",
                                "nodeType": "YulIdentifier",
                                "src": "8343:6:120"
                              }
                            ],
                            "functionName": {
                              "name": "copy_memory_to_memory",
                              "nodeType": "YulIdentifier",
                              "src": "8298:21:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8298:52:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "8298:52:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "8359:43:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "8370:3:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "length",
                                    "nodeType": "YulIdentifier",
                                    "src": "8394:6:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "round_up_to_mul_of",
                                  "nodeType": "YulIdentifier",
                                  "src": "8375:18:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "8375:26:120"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "8366:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8366:36:120"
                          },
                          "variableNames": [
                            {
                              "name": "end",
                              "nodeType": "YulIdentifier",
                              "src": "8359:3:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_bytes",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "value",
                        "nodeType": "YulTypedName",
                        "src": "8153:5:120",
                        "type": ""
                      },
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "8160:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "8168:3:120",
                        "type": ""
                      }
                    ],
                    "src": "8127:281:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "8560:200:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "8570:26:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "8582:9:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "8593:2:120",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "8578:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8578:18:120"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "8570:4:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "value0",
                                "nodeType": "YulIdentifier",
                                "src": "8624:6:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "8636:9:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "8647:1:120",
                                    "type": "",
                                    "value": "0"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "8632:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "8632:17:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_encode_address",
                              "nodeType": "YulIdentifier",
                              "src": "8605:18:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8605:45:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "8605:45:120"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "8670:9:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "8681:2:120",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "8666:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "8666:18:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "tail",
                                    "nodeType": "YulIdentifier",
                                    "src": "8690:4:120"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "8696:9:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "8686:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "8686:20:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "8659:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8659:48:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "8659:48:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "8716:38:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "value1",
                                "nodeType": "YulIdentifier",
                                "src": "8741:6:120"
                              },
                              {
                                "name": "tail",
                                "nodeType": "YulIdentifier",
                                "src": "8749:4:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_encode_bytes",
                              "nodeType": "YulIdentifier",
                              "src": "8724:16:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8724:30:120"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "8716:4:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_address_t_bytes_memory_ptr__to_t_address_t_bytes_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "8521:9:120",
                        "type": ""
                      },
                      {
                        "name": "value1",
                        "nodeType": "YulTypedName",
                        "src": "8532:6:120",
                        "type": ""
                      },
                      {
                        "name": "value0",
                        "nodeType": "YulTypedName",
                        "src": "8540:6:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "8551:4:120",
                        "type": ""
                      }
                    ],
                    "src": "8413:347:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "8875:116:120",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "memPtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "8896:6:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "8904:1:120",
                                    "type": "",
                                    "value": "0"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "8892:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "8892:14:120"
                              },
                              {
                                "hexValue": "4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "8908:34:120",
                                "type": "",
                                "value": "Ownable: new owner is the zero a"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "8885:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8885:58:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "8885:58:120"
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "memPtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "8963:6:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "8971:2:120",
                                    "type": "",
                                    "value": "32"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "8959:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "8959:15:120"
                              },
                              {
                                "hexValue": "646472657373",
                                "kind": "string",
                                "nodeType": "YulLiteral",
                                "src": "8976:8:120",
                                "type": "",
                                "value": "ddress"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "8952:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "8952:33:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "8952:33:120"
                        }
                      ]
                    },
                    "name": "store_literal_in_memory_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "memPtr",
                        "nodeType": "YulTypedName",
                        "src": "8863:6:120",
                        "type": ""
                      }
                    ],
                    "src": "8765:226:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "9051:197:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "9061:51:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "9104:3:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "9109:2:120",
                                "type": "",
                                "value": "38"
                              }
                            ],
                            "functionName": {
                              "name": "array_storeLengthForEncoding_string",
                              "nodeType": "YulIdentifier",
                              "src": "9068:35:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "9068:44:120"
                          },
                          "variableNames": [
                            {
                              "name": "pos",
                              "nodeType": "YulIdentifier",
                              "src": "9061:3:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "9210:3:120"
                              }
                            ],
                            "functionName": {
                              "name": "store_literal_in_memory_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe",
                              "nodeType": "YulIdentifier",
                              "src": "9121:88:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "9121:93:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "9121:93:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "9223:19:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "9234:3:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "9239:2:120",
                                "type": "",
                                "value": "64"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "9230:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "9230:12:120"
                          },
                          "variableNames": [
                            {
                              "name": "end",
                              "nodeType": "YulIdentifier",
                              "src": "9223:3:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_stringliteral_245f",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "9035:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "9043:3:120",
                        "type": ""
                      }
                    ],
                    "src": "8996:252:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "9427:150:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "9437:26:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "headStart",
                                "nodeType": "YulIdentifier",
                                "src": "9449:9:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "9460:2:120",
                                "type": "",
                                "value": "32"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "9445:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "9445:18:120"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "9437:4:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "9483:9:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "9494:1:120",
                                    "type": "",
                                    "value": "0"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "9479:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "9479:17:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "name": "tail",
                                    "nodeType": "YulIdentifier",
                                    "src": "9502:4:120"
                                  },
                                  {
                                    "name": "headStart",
                                    "nodeType": "YulIdentifier",
                                    "src": "9508:9:120"
                                  }
                                ],
                                "functionName": {
                                  "name": "sub",
                                  "nodeType": "YulIdentifier",
                                  "src": "9498:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "9498:20:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "9472:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "9472:47:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "9472:47:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "9528:43:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "tail",
                                "nodeType": "YulIdentifier",
                                "src": "9566:4:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_encode_stringliteral_245f",
                              "nodeType": "YulIdentifier",
                              "src": "9536:29:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "9536:35:120"
                          },
                          "variableNames": [
                            {
                              "name": "tail",
                              "nodeType": "YulIdentifier",
                              "src": "9528:4:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_t_stringliteral_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe__to_t_string_memory_ptr__fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "headStart",
                        "nodeType": "YulTypedName",
                        "src": "9404:9:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "tail",
                        "nodeType": "YulTypedName",
                        "src": "9418:4:120",
                        "type": ""
                      }
                    ],
                    "src": "9253:324:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "9692:60:120",
                      "statements": [
                        {
                          "expression": {
                            "arguments": [
                              {
                                "arguments": [
                                  {
                                    "name": "memPtr",
                                    "nodeType": "YulIdentifier",
                                    "src": "9713:6:120"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "9721:1:120",
                                    "type": "",
                                    "value": "0"
                                  }
                                ],
                                "functionName": {
                                  "name": "add",
                                  "nodeType": "YulIdentifier",
                                  "src": "9709:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "9709:14:120"
                              },
                              {
                                "arguments": [
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "9729:3:120",
                                    "type": "",
                                    "value": "230"
                                  },
                                  {
                                    "kind": "number",
                                    "nodeType": "YulLiteral",
                                    "src": "9734:10:120",
                                    "type": "",
                                    "value": "0x03e14691"
                                  }
                                ],
                                "functionName": {
                                  "name": "shl",
                                  "nodeType": "YulIdentifier",
                                  "src": "9725:3:120"
                                },
                                "nodeType": "YulFunctionCall",
                                "src": "9725:20:120"
                              }
                            ],
                            "functionName": {
                              "name": "mstore",
                              "nodeType": "YulIdentifier",
                              "src": "9702:6:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "9702:44:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "9702:44:120"
                        }
                      ]
                    },
                    "name": "store_literal_in_memory_cb23cf6c353ccb16f0d92c8e6b5c5b425654e65dd07e2d295b394de4cf15afb7",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "memPtr",
                        "nodeType": "YulTypedName",
                        "src": "9680:6:120",
                        "type": ""
                      }
                    ],
                    "src": "9582:170:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "9812:212:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "9822:67:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "9882:3:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "9887:1:120",
                                "type": "",
                                "value": "4"
                              }
                            ],
                            "functionName": {
                              "name": "array_storeLengthForEncoding_bytes_nonPadded_inplace",
                              "nodeType": "YulIdentifier",
                              "src": "9829:52:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "9829:60:120"
                          },
                          "variableNames": [
                            {
                              "name": "pos",
                              "nodeType": "YulIdentifier",
                              "src": "9822:3:120"
                            }
                          ]
                        },
                        {
                          "expression": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "9987:3:120"
                              }
                            ],
                            "functionName": {
                              "name": "store_literal_in_memory_cb23cf6c353ccb16f0d92c8e6b5c5b425654e65dd07e2d295b394de4cf15afb7",
                              "nodeType": "YulIdentifier",
                              "src": "9898:88:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "9898:93:120"
                          },
                          "nodeType": "YulExpressionStatement",
                          "src": "9898:93:120"
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "10000:18:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "10011:3:120"
                              },
                              {
                                "kind": "number",
                                "nodeType": "YulLiteral",
                                "src": "10016:1:120",
                                "type": "",
                                "value": "4"
                              }
                            ],
                            "functionName": {
                              "name": "add",
                              "nodeType": "YulIdentifier",
                              "src": "10007:3:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "10007:11:120"
                          },
                          "variableNames": [
                            {
                              "name": "end",
                              "nodeType": "YulIdentifier",
                              "src": "10000:3:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_stringliteral_cb23",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "9796:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "9804:3:120",
                        "type": ""
                      }
                    ],
                    "src": "9757:267:120"
                  },
                  {
                    "body": {
                      "nodeType": "YulBlock",
                      "src": "10220:76:120",
                      "statements": [
                        {
                          "nodeType": "YulAssignment",
                          "src": "10230:41:120",
                          "value": {
                            "arguments": [
                              {
                                "name": "pos",
                                "nodeType": "YulIdentifier",
                                "src": "10267:3:120"
                              }
                            ],
                            "functionName": {
                              "name": "abi_encode_stringliteral_cb23",
                              "nodeType": "YulIdentifier",
                              "src": "10237:29:120"
                            },
                            "nodeType": "YulFunctionCall",
                            "src": "10237:34:120"
                          },
                          "variableNames": [
                            {
                              "name": "pos",
                              "nodeType": "YulIdentifier",
                              "src": "10230:3:120"
                            }
                          ]
                        },
                        {
                          "nodeType": "YulAssignment",
                          "src": "10280:10:120",
                          "value": {
                            "name": "pos",
                            "nodeType": "YulIdentifier",
                            "src": "10287:3:120"
                          },
                          "variableNames": [
                            {
                              "name": "end",
                              "nodeType": "YulIdentifier",
                              "src": "10280:3:120"
                            }
                          ]
                        }
                      ]
                    },
                    "name": "abi_encode_tuple_packed_t_stringliteral_cb23cf6c353ccb16f0d92c8e6b5c5b425654e65dd07e2d295b394de4cf15afb7__to_t_bytes_memory_ptr__nonPadded_inplace_fromStack_reversed",
                    "nodeType": "YulFunctionDefinition",
                    "parameters": [
                      {
                        "name": "pos",
                        "nodeType": "YulTypedName",
                        "src": "10204:3:120",
                        "type": ""
                      }
                    ],
                    "returnVariables": [
                      {
                        "name": "end",
                        "nodeType": "YulTypedName",
                        "src": "10212:3:120",
                        "type": ""
                      }
                    ],
                    "src": "10029:267:120"
                  }
                ]
              },
              "contents": "{\n    { }\n    function allocate_unbounded() -> memPtr\n    { memPtr := mload(64) }\n    function revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b()\n    { revert(0, 0) }\n    function cleanup_uint160(value) -> cleaned\n    {\n        cleaned := and(value, sub(shl(160, 1), 1))\n    }\n    function cleanup_address_payable(value) -> cleaned\n    {\n        cleaned := cleanup_uint160(value)\n    }\n    function cleanup_contract_TransparentUpgradeableProxy(value) -> cleaned\n    {\n        cleaned := cleanup_address_payable(value)\n    }\n    function validator_revert_contract_TransparentUpgradeableProxy(value)\n    {\n        if iszero(eq(value, cleanup_contract_TransparentUpgradeableProxy(value))) { revert(0, 0) }\n    }\n    function abi_decode_contract_TransparentUpgradeableProxy(offset, end) -> value\n    {\n        value := calldataload(offset)\n        validator_revert_contract_TransparentUpgradeableProxy(value)\n    }\n    function abi_decode_tuple_t_contract$_TransparentUpgradeableProxy_$4160(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32)\n        {\n            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b()\n        }\n        let offset := 0\n        value0 := abi_decode_contract_TransparentUpgradeableProxy(add(headStart, offset), dataEnd)\n    }\n    function abi_encode_address(value, pos)\n    {\n        mstore(pos, cleanup_address_payable(value))\n    }\n    function abi_encode_tuple_t_address__to_t_address__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        abi_encode_address(value0, add(headStart, 0))\n    }\n    function validator_revert_address(value)\n    {\n        if iszero(eq(value, cleanup_address_payable(value))) { revert(0, 0) }\n    }\n    function abi_decode_address(offset, end) -> value\n    {\n        value := calldataload(offset)\n        validator_revert_address(value)\n    }\n    function abi_decode_tuple_t_contract$_TransparentUpgradeableProxy_$4160t_address(headStart, dataEnd) -> value0, value1\n    {\n        if slt(sub(dataEnd, headStart), 64)\n        {\n            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b()\n        }\n        let offset := 0\n        value0 := abi_decode_contract_TransparentUpgradeableProxy(add(headStart, offset), dataEnd)\n        let offset_1 := 32\n        value1 := abi_decode_address(add(headStart, offset_1), dataEnd)\n    }\n    function round_up_to_mul_of(value) -> result\n    {\n        result := and(add(value, 31), not(31))\n    }\n    function panic_error_0x41()\n    {\n        mstore(0, shl(224, 0x4e487b71))\n        mstore(4, 0x41)\n        revert(0, 0x24)\n    }\n    function finalize_allocation(memPtr, size)\n    {\n        let newFreePtr := add(memPtr, round_up_to_mul_of(size))\n        if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr)) { panic_error_0x41() }\n        mstore(64, newFreePtr)\n    }\n    function allocate_memory(size) -> memPtr\n    {\n        memPtr := allocate_unbounded()\n        finalize_allocation(memPtr, size)\n    }\n    function array_allocation_size_bytes(length) -> size\n    {\n        if gt(length, 0xffffffffffffffff) { panic_error_0x41() }\n        size := round_up_to_mul_of(length)\n        size := add(size, 0x20)\n    }\n    function copy_calldata_to_memory(src, dst, length)\n    {\n        calldatacopy(dst, src, length)\n        mstore(add(dst, length), 0)\n    }\n    function abi_decode_available_length_bytes(src, length, end) -> array\n    {\n        array := allocate_memory(array_allocation_size_bytes(length))\n        mstore(array, length)\n        let dst := add(array, 0x20)\n        if gt(add(src, length), end)\n        {\n            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b()\n        }\n        copy_calldata_to_memory(src, dst, length)\n    }\n    function abi_decode_bytes(offset, end) -> array\n    {\n        if iszero(slt(add(offset, 0x1f), end))\n        {\n            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b()\n        }\n        let length := calldataload(offset)\n        array := abi_decode_available_length_bytes(add(offset, 0x20), length, end)\n    }\n    function abi_decode_tuple_t_contract$_TransparentUpgradeableProxy_$4160t_addresst_bytes_memory_ptr(headStart, dataEnd) -> value0, value1, value2\n    {\n        if slt(sub(dataEnd, headStart), 96)\n        {\n            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b()\n        }\n        let offset := 0\n        value0 := abi_decode_contract_TransparentUpgradeableProxy(add(headStart, offset), dataEnd)\n        let offset_1 := 32\n        value1 := abi_decode_address(add(headStart, offset_1), dataEnd)\n        let offset_2 := calldataload(add(headStart, 64))\n        if gt(offset_2, 0xffffffffffffffff)\n        {\n            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b()\n        }\n        value2 := abi_decode_bytes(add(headStart, offset_2), dataEnd)\n    }\n    function abi_decode_tuple_t_address(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32)\n        {\n            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b()\n        }\n        let offset := 0\n        value0 := abi_decode_address(add(headStart, offset), dataEnd)\n    }\n    function array_storeLengthForEncoding_bytes_nonPadded_inplace(pos, length) -> updated_pos\n    { updated_pos := pos }\n    function store_literal_in_memory_96a4c6be7716f5be15d118c16bd1d464cb27f01187d0b9218993a5d488a47c29(memPtr)\n    {\n        mstore(add(memPtr, 0), shl(224, 0x5c60da1b))\n    }\n    function abi_encode_stringliteral_96a4(pos) -> end\n    {\n        pos := array_storeLengthForEncoding_bytes_nonPadded_inplace(pos, 4)\n        store_literal_in_memory_96a4c6be7716f5be15d118c16bd1d464cb27f01187d0b9218993a5d488a47c29(pos)\n        end := add(pos, 4)\n    }\n    function abi_encode_tuple_packed_t_stringliteral_96a4c6be7716f5be15d118c16bd1d464cb27f01187d0b9218993a5d488a47c29__to_t_bytes_memory_ptr__nonPadded_inplace_fromStack_reversed(pos) -> end\n    {\n        pos := abi_encode_stringliteral_96a4(pos)\n        end := pos\n    }\n    function validator_revert_address_payable(value)\n    {\n        if iszero(eq(value, cleanup_address_payable(value))) { revert(0, 0) }\n    }\n    function abi_decode_address_payable_fromMemory(offset, end) -> value\n    {\n        value := mload(offset)\n        validator_revert_address_payable(value)\n    }\n    function abi_decode_tuple_t_address_payable_fromMemory(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32)\n        {\n            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b()\n        }\n        let offset := 0\n        value0 := abi_decode_address_payable_fromMemory(add(headStart, offset), dataEnd)\n    }\n    function array_storeLengthForEncoding_string(pos, length) -> updated_pos\n    {\n        mstore(pos, length)\n        updated_pos := add(pos, 0x20)\n    }\n    function store_literal_in_memory_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe(memPtr)\n    {\n        mstore(add(memPtr, 0), \"Ownable: caller is not the owner\")\n    }\n    function abi_encode_stringliteral(pos) -> end\n    {\n        pos := array_storeLengthForEncoding_string(pos, 32)\n        store_literal_in_memory_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe(pos)\n        end := add(pos, 32)\n    }\n    function abi_encode_tuple_t_stringliteral_9924ebdf1add33d25d4ef888e16131f0a5687b0580a36c21b5c301a6c462effe__to_t_string_memory_ptr__fromStack_reversed(headStart) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(add(headStart, 0), sub(tail, headStart))\n        tail := abi_encode_stringliteral(tail)\n    }\n    function array_length_bytes(value) -> length\n    { length := mload(value) }\n    function copy_memory_to_memory(src, dst, length)\n    {\n        let i := 0\n        for { } lt(i, length) { i := add(i, 32) }\n        {\n            mstore(add(dst, i), mload(add(src, i)))\n        }\n        if gt(i, length) { mstore(add(dst, length), 0) }\n    }\n    function abi_encode_bytes(value, pos) -> end\n    {\n        let length := array_length_bytes(value)\n        pos := array_storeLengthForEncoding_string(pos, length)\n        copy_memory_to_memory(add(value, 0x20), pos, length)\n        end := add(pos, round_up_to_mul_of(length))\n    }\n    function abi_encode_tuple_t_address_t_bytes_memory_ptr__to_t_address_t_bytes_memory_ptr__fromStack_reversed(headStart, value1, value0) -> tail\n    {\n        tail := add(headStart, 64)\n        abi_encode_address(value0, add(headStart, 0))\n        mstore(add(headStart, 32), sub(tail, headStart))\n        tail := abi_encode_bytes(value1, tail)\n    }\n    function store_literal_in_memory_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe(memPtr)\n    {\n        mstore(add(memPtr, 0), \"Ownable: new owner is the zero a\")\n        mstore(add(memPtr, 32), \"ddress\")\n    }\n    function abi_encode_stringliteral_245f(pos) -> end\n    {\n        pos := array_storeLengthForEncoding_string(pos, 38)\n        store_literal_in_memory_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe(pos)\n        end := add(pos, 64)\n    }\n    function abi_encode_tuple_t_stringliteral_245f15ff17f551913a7a18385165551503906a406f905ac1c2437281a7cd0cfe__to_t_string_memory_ptr__fromStack_reversed(headStart) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(add(headStart, 0), sub(tail, headStart))\n        tail := abi_encode_stringliteral_245f(tail)\n    }\n    function store_literal_in_memory_cb23cf6c353ccb16f0d92c8e6b5c5b425654e65dd07e2d295b394de4cf15afb7(memPtr)\n    {\n        mstore(add(memPtr, 0), shl(230, 0x03e14691))\n    }\n    function abi_encode_stringliteral_cb23(pos) -> end\n    {\n        pos := array_storeLengthForEncoding_bytes_nonPadded_inplace(pos, 4)\n        store_literal_in_memory_cb23cf6c353ccb16f0d92c8e6b5c5b425654e65dd07e2d295b394de4cf15afb7(pos)\n        end := add(pos, 4)\n    }\n    function abi_encode_tuple_packed_t_stringliteral_cb23cf6c353ccb16f0d92c8e6b5c5b425654e65dd07e2d295b394de4cf15afb7__to_t_bytes_memory_ptr__nonPadded_inplace_fromStack_reversed(pos) -> end\n    {\n        pos := abi_encode_stringliteral_cb23(pos)\n        end := pos\n    }\n}",
              "id": 120,
              "language": "Yul",
              "name": "#utility.yul"
            }
          ],
          "immutableReferences": {},
          "linkReferences": {},
          "object": "60806040526004361061007b5760003560e01c80639623609d1161004e5780639623609d1461010b57806399a88ec41461011e578063f2fde38b1461013e578063f3b7dead1461015e57600080fd5b8063204e1c7a14610080578063715018a6146100b65780637eff275e146100cd5780638da5cb5b146100ed575b600080fd5b34801561008c57600080fd5b506100a061009b366004610505565b61017e565b6040516100ad9190610535565b60405180910390f35b3480156100c257600080fd5b506100cb610204565b005b3480156100d957600080fd5b506100cb6100e8366004610557565b610252565b3480156100f957600080fd5b506000546001600160a01b03166100a0565b6100cb61011936600461068f565b6102ed565b34801561012a57600080fd5b506100cb610139366004610557565b61038d565b34801561014a57600080fd5b506100cb6101593660046106fa565b6103f2565b34801561016a57600080fd5b506100a0610179366004610505565b61045d565b6000806000836001600160a01b03166040516101999061072c565b600060405180830381855afa9150503d80600081146101d4576040519150601f19603f3d011682016040523d82523d6000602084013e6101d9565b606091505b5091509150816101e857600080fd5b808060200190518101906101fc9190610740565b949350505050565b336102176000546001600160a01b031690565b6001600160a01b0316146102465760405162461bcd60e51b815260040161023d90610761565b60405180910390fd5b6102506000610478565b565b336102656000546001600160a01b031690565b6001600160a01b03161461028b5760405162461bcd60e51b815260040161023d90610761565b6040516308f2839760e41b81526001600160a01b03831690638f283970906102b7908490600401610535565b600060405180830381600087803b1580156102d157600080fd5b505af11580156102e5573d6000803e3d6000fd5b505050505050565b336103006000546001600160a01b031690565b6001600160a01b0316146103265760405162461bcd60e51b815260040161023d90610761565b60405163278f794360e11b81526001600160a01b03841690634f1ef28690349061035690869086906004016107fd565b6000604051808303818588803b15801561036f57600080fd5b505af1158015610383573d6000803e3d6000fd5b5050505050505050565b336103a06000546001600160a01b031690565b6001600160a01b0316146103c65760405162461bcd60e51b815260040161023d90610761565b604051631b2ce7f360e11b81526001600160a01b03831690633659cfe6906102b7908490600401610535565b336104056000546001600160a01b031690565b6001600160a01b03161461042b5760405162461bcd60e51b815260040161023d90610761565b6001600160a01b0381166104515760405162461bcd60e51b815260040161023d9061081d565b61045a81610478565b50565b6000806000836001600160a01b031660405161019990610876565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006001600160a01b0382165b92915050565b60006104d5826104c8565b6104ef816104db565b811461045a57600080fd5b80356104d5816104e6565b60006020828403121561051a5761051a600080fd5b60006101fc84846104fa565b61052f816104c8565b82525050565b602081016104d58284610526565b6104ef816104c8565b80356104d581610543565b6000806040838503121561056d5761056d600080fd5b600061057985856104fa565b925050602061058a8582860161054c565b9150509250929050565b634e487b7160e01b600052604160045260246000fd5b601f19601f830116810181811067ffffffffffffffff821117156105d0576105d0610594565b6040525050565b60006105e260405190565b90506105ee82826105aa565b919050565b600067ffffffffffffffff82111561060d5761060d610594565b601f19601f83011660200192915050565b82818337506000910152565b600061063d610638846105f3565b6105d7565b90508281526020810184848401111561065857610658600080fd5b61066384828561061e565b509392505050565b600082601f83011261067f5761067f600080fd5b81356101fc84826020860161062a565b6000806000606084860312156106a7576106a7600080fd5b60006106b386866104fa565b93505060206106c48682870161054c565b925050604084013567ffffffffffffffff8111156106e4576106e4600080fd5b6106f08682870161066b565b9150509250925092565b60006020828403121561070f5761070f600080fd5b60006101fc848461054c565b635c60da1b60e01b81525b60040190565b6105ee8161071b565b80516104d581610543565b60006020828403121561075557610755600080fd5b60006101fc8484610735565b60208082528181019081527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726040830152606082016104d5565b60005b838110156107b657818101518382015260200161079e565b838111156107c5576000848401525b50505050565b60006107d5825190565b8084526020840193506107ec81856020860161079b565b601f01601f19169290920192915050565b6040810161080b8285610526565b81810360208301526101fc81846107cb565b602080825281016104d581602681527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160208201526564647265737360d01b604082015260600190565b6303e1469160e61b8152610726565b6105ee8161086756fea2646970667358221220b2e73e40ff4f6664e6a342d26cbd1b6d2f85e1850495fb416ec82fd3c0054ba464736f6c634300080a0033",
          "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x7B JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x9623609D GT PUSH2 0x4E JUMPI DUP1 PUSH4 0x9623609D EQ PUSH2 0x10B JUMPI DUP1 PUSH4 0x99A88EC4 EQ PUSH2 0x11E JUMPI DUP1 PUSH4 0xF2FDE38B EQ PUSH2 0x13E JUMPI DUP1 PUSH4 0xF3B7DEAD EQ PUSH2 0x15E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 PUSH4 0x204E1C7A EQ PUSH2 0x80 JUMPI DUP1 PUSH4 0x715018A6 EQ PUSH2 0xB6 JUMPI DUP1 PUSH4 0x7EFF275E EQ PUSH2 0xCD JUMPI DUP1 PUSH4 0x8DA5CB5B EQ PUSH2 0xED JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x8C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xA0 PUSH2 0x9B CALLDATASIZE PUSH1 0x4 PUSH2 0x505 JUMP JUMPDEST PUSH2 0x17E JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0xAD SWAP2 SWAP1 PUSH2 0x535 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xC2 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xCB PUSH2 0x204 JUMP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xD9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xCB PUSH2 0xE8 CALLDATASIZE PUSH1 0x4 PUSH2 0x557 JUMP JUMPDEST PUSH2 0x252 JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xF9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH2 0xA0 JUMP JUMPDEST PUSH2 0xCB PUSH2 0x119 CALLDATASIZE PUSH1 0x4 PUSH2 0x68F JUMP JUMPDEST PUSH2 0x2ED JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x12A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xCB PUSH2 0x139 CALLDATASIZE PUSH1 0x4 PUSH2 0x557 JUMP JUMPDEST PUSH2 0x38D JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x14A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xCB PUSH2 0x159 CALLDATASIZE PUSH1 0x4 PUSH2 0x6FA JUMP JUMPDEST PUSH2 0x3F2 JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x16A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xA0 PUSH2 0x179 CALLDATASIZE PUSH1 0x4 PUSH2 0x505 JUMP JUMPDEST PUSH2 0x45D JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x40 MLOAD PUSH2 0x199 SWAP1 PUSH2 0x72C JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 GAS STATICCALL SWAP2 POP POP RETURNDATASIZE DUP1 PUSH1 0x0 DUP2 EQ PUSH2 0x1D4 JUMPI PUSH1 0x40 MLOAD SWAP2 POP PUSH1 0x1F NOT PUSH1 0x3F RETURNDATASIZE ADD AND DUP3 ADD PUSH1 0x40 MSTORE RETURNDATASIZE DUP3 MSTORE RETURNDATASIZE PUSH1 0x0 PUSH1 0x20 DUP5 ADD RETURNDATACOPY PUSH2 0x1D9 JUMP JUMPDEST PUSH1 0x60 SWAP2 POP JUMPDEST POP SWAP2 POP SWAP2 POP DUP2 PUSH2 0x1E8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 DUP1 PUSH1 0x20 ADD SWAP1 MLOAD DUP2 ADD SWAP1 PUSH2 0x1FC SWAP2 SWAP1 PUSH2 0x740 JUMP JUMPDEST SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST CALLER PUSH2 0x217 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x246 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST PUSH2 0x250 PUSH1 0x0 PUSH2 0x478 JUMP JUMPDEST JUMP JUMPDEST CALLER PUSH2 0x265 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x28B JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x8F28397 PUSH1 0xE4 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 PUSH4 0x8F283970 SWAP1 PUSH2 0x2B7 SWAP1 DUP5 SWAP1 PUSH1 0x4 ADD PUSH2 0x535 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x2D1 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x2E5 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP JUMP JUMPDEST CALLER PUSH2 0x300 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x326 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x278F7943 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP5 AND SWAP1 PUSH4 0x4F1EF286 SWAP1 CALLVALUE SWAP1 PUSH2 0x356 SWAP1 DUP7 SWAP1 DUP7 SWAP1 PUSH1 0x4 ADD PUSH2 0x7FD JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x36F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x383 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP POP POP JUMP JUMPDEST CALLER PUSH2 0x3A0 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x3C6 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x1B2CE7F3 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 AND SWAP1 PUSH4 0x3659CFE6 SWAP1 PUSH2 0x2B7 SWAP1 DUP5 SWAP1 PUSH1 0x4 ADD PUSH2 0x535 JUMP JUMPDEST CALLER PUSH2 0x405 PUSH1 0x0 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND SWAP1 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND EQ PUSH2 0x42B JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x761 JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND PUSH2 0x451 JUMPI PUSH1 0x40 MLOAD PUSH3 0x461BCD PUSH1 0xE5 SHL DUP2 MSTORE PUSH1 0x4 ADD PUSH2 0x23D SWAP1 PUSH2 0x81D JUMP JUMPDEST PUSH2 0x45A DUP2 PUSH2 0x478 JUMP JUMPDEST POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP4 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x40 MLOAD PUSH2 0x199 SWAP1 PUSH2 0x876 JUMP JUMPDEST PUSH1 0x0 DUP1 SLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP4 DUP2 AND PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB NOT DUP4 AND DUP2 OR DUP5 SSTORE PUSH1 0x40 MLOAD SWAP2 SWAP1 SWAP3 AND SWAP3 DUP4 SWAP2 PUSH32 0x8BE0079C531659141344CD1FD0A4F28419497F9722A3DAAFE3B4186F6B6457E0 SWAP2 SWAP1 LOG3 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x4D5 DUP3 PUSH2 0x4C8 JUMP JUMPDEST PUSH2 0x4EF DUP2 PUSH2 0x4DB JUMP JUMPDEST DUP2 EQ PUSH2 0x45A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP1 CALLDATALOAD PUSH2 0x4D5 DUP2 PUSH2 0x4E6 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x51A JUMPI PUSH2 0x51A PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x1FC DUP5 DUP5 PUSH2 0x4FA JUMP JUMPDEST PUSH2 0x52F DUP2 PUSH2 0x4C8 JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x20 DUP2 ADD PUSH2 0x4D5 DUP3 DUP5 PUSH2 0x526 JUMP JUMPDEST PUSH2 0x4EF DUP2 PUSH2 0x4C8 JUMP JUMPDEST DUP1 CALLDATALOAD PUSH2 0x4D5 DUP2 PUSH2 0x543 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0x56D JUMPI PUSH2 0x56D PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x579 DUP6 DUP6 PUSH2 0x4FA JUMP JUMPDEST SWAP3 POP POP PUSH1 0x20 PUSH2 0x58A DUP6 DUP3 DUP7 ADD PUSH2 0x54C JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND DUP2 ADD DUP2 DUP2 LT PUSH8 0xFFFFFFFFFFFFFFFF DUP3 GT OR ISZERO PUSH2 0x5D0 JUMPI PUSH2 0x5D0 PUSH2 0x594 JUMP JUMPDEST PUSH1 0x40 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x5E2 PUSH1 0x40 MLOAD SWAP1 JUMP JUMPDEST SWAP1 POP PUSH2 0x5EE DUP3 DUP3 PUSH2 0x5AA JUMP JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH8 0xFFFFFFFFFFFFFFFF DUP3 GT ISZERO PUSH2 0x60D JUMPI PUSH2 0x60D PUSH2 0x594 JUMP JUMPDEST PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND PUSH1 0x20 ADD SWAP3 SWAP2 POP POP JUMP JUMPDEST DUP3 DUP2 DUP4 CALLDATACOPY POP PUSH1 0x0 SWAP2 ADD MSTORE JUMP JUMPDEST PUSH1 0x0 PUSH2 0x63D PUSH2 0x638 DUP5 PUSH2 0x5F3 JUMP JUMPDEST PUSH2 0x5D7 JUMP JUMPDEST SWAP1 POP DUP3 DUP2 MSTORE PUSH1 0x20 DUP2 ADD DUP5 DUP5 DUP5 ADD GT ISZERO PUSH2 0x658 JUMPI PUSH2 0x658 PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x663 DUP5 DUP3 DUP6 PUSH2 0x61E JUMP JUMPDEST POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x67F JUMPI PUSH2 0x67F PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH2 0x1FC DUP5 DUP3 PUSH1 0x20 DUP7 ADD PUSH2 0x62A JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x60 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x6A7 JUMPI PUSH2 0x6A7 PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x6B3 DUP7 DUP7 PUSH2 0x4FA JUMP JUMPDEST SWAP4 POP POP PUSH1 0x20 PUSH2 0x6C4 DUP7 DUP3 DUP8 ADD PUSH2 0x54C JUMP JUMPDEST SWAP3 POP POP PUSH1 0x40 DUP5 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT ISZERO PUSH2 0x6E4 JUMPI PUSH2 0x6E4 PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x6F0 DUP7 DUP3 DUP8 ADD PUSH2 0x66B JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x70F JUMPI PUSH2 0x70F PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x1FC DUP5 DUP5 PUSH2 0x54C JUMP JUMPDEST PUSH4 0x5C60DA1B PUSH1 0xE0 SHL DUP2 MSTORE JUMPDEST PUSH1 0x4 ADD SWAP1 JUMP JUMPDEST PUSH2 0x5EE DUP2 PUSH2 0x71B JUMP JUMPDEST DUP1 MLOAD PUSH2 0x4D5 DUP2 PUSH2 0x543 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x755 JUMPI PUSH2 0x755 PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH2 0x1FC DUP5 DUP5 PUSH2 0x735 JUMP JUMPDEST PUSH1 0x20 DUP1 DUP3 MSTORE DUP2 DUP2 ADD SWAP1 DUP2 MSTORE PUSH32 0x4F776E61626C653A2063616C6C6572206973206E6F7420746865206F776E6572 PUSH1 0x40 DUP4 ADD MSTORE PUSH1 0x60 DUP3 ADD PUSH2 0x4D5 JUMP JUMPDEST PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x7B6 JUMPI DUP2 DUP2 ADD MLOAD DUP4 DUP3 ADD MSTORE PUSH1 0x20 ADD PUSH2 0x79E JUMP JUMPDEST DUP4 DUP2 GT ISZERO PUSH2 0x7C5 JUMPI PUSH1 0x0 DUP5 DUP5 ADD MSTORE JUMPDEST POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH2 0x7D5 DUP3 MLOAD SWAP1 JUMP JUMPDEST DUP1 DUP5 MSTORE PUSH1 0x20 DUP5 ADD SWAP4 POP PUSH2 0x7EC DUP2 DUP6 PUSH1 0x20 DUP7 ADD PUSH2 0x79B JUMP JUMPDEST PUSH1 0x1F ADD PUSH1 0x1F NOT AND SWAP3 SWAP1 SWAP3 ADD SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x40 DUP2 ADD PUSH2 0x80B DUP3 DUP6 PUSH2 0x526 JUMP JUMPDEST DUP2 DUP2 SUB PUSH1 0x20 DUP4 ADD MSTORE PUSH2 0x1FC DUP2 DUP5 PUSH2 0x7CB JUMP JUMPDEST PUSH1 0x20 DUP1 DUP3 MSTORE DUP2 ADD PUSH2 0x4D5 DUP2 PUSH1 0x26 DUP2 MSTORE PUSH32 0x4F776E61626C653A206E6577206F776E657220697320746865207A65726F2061 PUSH1 0x20 DUP3 ADD MSTORE PUSH6 0x646472657373 PUSH1 0xD0 SHL PUSH1 0x40 DUP3 ADD MSTORE PUSH1 0x60 ADD SWAP1 JUMP JUMPDEST PUSH4 0x3E14691 PUSH1 0xE6 SHL DUP2 MSTORE PUSH2 0x726 JUMP JUMPDEST PUSH2 0x5EE DUP2 PUSH2 0x867 JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xB2 0xE7 RETURNDATACOPY BLOCKHASH SELFDESTRUCT 0x4F PUSH7 0x64E6A342D26CBD SHL PUSH14 0x2F85E1850495FB416EC82FD3C005 0x4B LOG4 PUSH5 0x736F6C6343 STOP ADDMOD EXP STOP CALLER ",
          "sourceMap": "472:2612:100:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;714:495;;;;;;;;;;-1:-1:-1;714:495:100;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;1279:101:112;;;;;;;;;;;;;:::i;:::-;;2020:170:100;;;;;;;;;;-1:-1:-1;2020:170:100;;;;;:::i;:::-;;:::i;625:85:112:-;;;;;;;;;;-1:-1:-1;671:7:112;697:6;-1:-1:-1;;;;;697:6:112;625:85;;2838:244:100;;;;;;:::i;:::-;;:::i;2395:177::-;;;;;;;;;;-1:-1:-1;2395:177:100;;;;;:::i;:::-;;:::i;1589:232:112:-;;;;;;;;;;-1:-1:-1;1589:232:112;;;;;:::i;:::-;;:::i;1369:477:100:-;;;;;;;;;;-1:-1:-1;1369:477:100;;;;;:::i;:::-;;:::i;714:495::-;842:7;1023:12;1037:23;1072:5;-1:-1:-1;;;;;1064:25:100;:62;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1022:104;;;;1144:7;1136:16;;;;;;1180:10;1169:33;;;;;;;;;;;;:::i;:::-;1162:40;714:495;-1:-1:-1;;;;714:495:100:o;1279:101:112:-;851:10;840:7;671;697:6;-1:-1:-1;;;;;697:6:112;;625:85;840:7;-1:-1:-1;;;;;840:21:112;;832:66;;;;-1:-1:-1;;;832:66:112;;;;;;;:::i;:::-;;;;;;;;;1343:30:::1;1370:1;1343:18;:30::i;:::-;1279:101::o:0;2020:170:100:-;851:10:112;840:7;671;697:6;-1:-1:-1;;;;;697:6:112;;625:85;840:7;-1:-1:-1;;;;;840:21:112;;832:66;;;;-1:-1:-1;;;832:66:112;;;;;;;:::i;:::-;2156:27:100::1;::::0;-1:-1:-1;;;2156:27:100;;-1:-1:-1;;;;;2156:17:100;::::1;::::0;::::1;::::0;:27:::1;::::0;2174:8;;2156:27:::1;;;:::i;:::-;;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;::::0;::::1;;;;;;;;;2020:170:::0;;:::o;2838:244::-;851:10:112;840:7;671;697:6;-1:-1:-1;;;;;697:6:112;;625:85;840:7;-1:-1:-1;;;;;840:21:112;;832:66;;;;-1:-1:-1;;;832:66:112;;;;;;;:::i;:::-;3013:62:100::1;::::0;-1:-1:-1;;;3013:62:100;;-1:-1:-1;;;;;3013:22:100;::::1;::::0;::::1;::::0;3043:9:::1;::::0;3013:62:::1;::::0;3054:14;;3070:4;;3013:62:::1;;;:::i;:::-;;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;::::0;::::1;;;;;;;;;;2838:244:::0;;;:::o;2395:177::-;851:10:112;840:7;671;697:6;-1:-1:-1;;;;;697:6:112;;625:85;840:7;-1:-1:-1;;;;;840:21:112;;832:66;;;;-1:-1:-1;;;832:66:112;;;;;;;:::i;:::-;2534:31:100::1;::::0;-1:-1:-1;;;2534:31:100;;-1:-1:-1;;;;;2534:15:100;::::1;::::0;::::1;::::0;:31:::1;::::0;2550:14;;2534:31:::1;;;:::i;1589:232:112:-:0;851:10;840:7;671;697:6;-1:-1:-1;;;;;697:6:112;;625:85;840:7;-1:-1:-1;;;;;840:21:112;;832:66;;;;-1:-1:-1;;;832:66:112;;;;;;;:::i;:::-;-1:-1:-1;;;;;1690:22:112;::::1;1669:107;;;;-1:-1:-1::0;;;1669:107:112::1;;;;;;;:::i;:::-;1786:28;1805:8;1786:18;:28::i;:::-;1589:232:::0;:::o;1369:477:100:-;1488:7;1660:12;1674:23;1709:5;-1:-1:-1;;;;;1701:25:100;:62;;;;;:::i;2035:187:112:-;2108:16;2127:6;;-1:-1:-1;;;;;2143:17:112;;;-1:-1:-1;;;;;;2143:17:112;;;;;;2175:40;;2127:6;;;;;;;2175:40;;2108:16;2175:40;2098:124;2035:187;:::o;310:104:120:-;353:7;-1:-1:-1;;;;;268:31:120;;386:22;375:33;310:104;-1:-1:-1;;310:104:120:o;419:133::-;483:7;516:30;540:5;516:30;:::i;557:180::-;661:51;706:5;661:51;:::i;:::-;654:5;651:62;641:90;;727:1;724;717:12;742:197;844:20;;873:60;844:20;873:60;:::i;944:392::-;1039:6;1092:2;1080:9;1071:7;1067:23;1063:32;1060:147;;;1118:79;472:2612:100;;;1118:79:120;1230:1;1250:80;1322:7;1302:9;1250:80;:::i;1341:103::-;1407:30;1431:5;1407:30;:::i;:::-;1402:3;1395:43;;;1341:103::o;1449:197::-;1583:2;1568:18;;1595:45;1572:9;1614:6;1595:45;:::i;1651:130::-;1726:30;1750:5;1726:30;:::i;1786:139::-;1859:20;;1888:31;1859:20;1888:31;:::i;1930:508::-;2034:6;2042;2095:2;2083:9;2074:7;2070:23;2066:32;2063:147;;;2121:79;472:2612:100;;;2121:79:120;2233:1;2253:80;2325:7;2305:9;2253:80;:::i;:::-;2243:90;;;2358:2;2379:53;2424:7;2413:8;2402:9;2398:24;2379:53;:::i;:::-;2369:63;;;1930:508;;;;;:::o;2551:127::-;2612:10;2607:3;2603:20;2600:1;2593:31;2643:4;2640:1;2633:15;2667:4;2664:1;2657:15;2683:246;-1:-1:-1;;2536:2:120;2516:14;;2512:28;2762:6;2758:37;2861:6;2849:10;2846:22;2825:18;2813:10;2810:34;2807:62;2804:88;;;2872:18;;:::i;:::-;2908:2;2901:22;-1:-1:-1;;2683:246:120:o;2934:133::-;2968:6;2999:20;76:2;70:9;;14:67;2999:20;2989:30;;3028:33;3056:4;3048:6;3028:33;:::i;:::-;2934:133;;;:::o;3072:204::-;3120:4;3153:18;3145:6;3142:30;3139:56;;;3175:18;;:::i;:::-;-1:-1:-1;;2536:2:120;2516:14;;2512:28;3265:4;3255:15;;3072:204;-1:-1:-1;;3072:204:120:o;3281:137::-;3369:6;3364:3;3359;3346:30;-1:-1:-1;3410:1:120;3392:16;;3385:27;3281:137::o;3423:416::-;3487:5;3516:52;3532:35;3560:6;3532:35;:::i;:::-;3516:52;:::i;:::-;3507:61;;3591:6;3584:5;3577:21;3629:4;3622:5;3618:16;3667:3;3658:6;3653:3;3649:16;3646:25;3643:140;;;3694:79;472:2612:100;;;3694:79:120;3792:41;3826:6;3821:3;3816;3792:41;:::i;:::-;;3423:416;;;;;:::o;3844:344::-;3886:5;3939:3;3932:4;3924:6;3920:17;3916:27;3906:150;;3967:79;472:2612:100;;;3967:79:120;4092:6;4079:20;4117:65;4178:3;4170:6;4163:4;4155:6;4151:17;4117:65;:::i;4193:817::-;4315:6;4323;4331;4384:2;4372:9;4363:7;4359:23;4355:32;4352:147;;;4410:79;472:2612:100;;;4410:79:120;4522:1;4542:80;4614:7;4594:9;4542:80;:::i;:::-;4532:90;;;4647:2;4668:53;4713:7;4702:8;4691:9;4687:24;4668:53;:::i;:::-;4658:63;;;4774:2;4763:9;4759:18;4746:32;4803:18;4793:8;4790:32;4787:147;;;4845:79;472:2612:100;;;4845:79:120;4953:51;4996:7;4985:8;4974:9;4970:24;4953:51;:::i;:::-;4943:61;;;4193:817;;;;;:::o;5015:327::-;5074:6;5127:2;5115:9;5106:7;5102:23;5098:32;5095:147;;;5153:79;472:2612:100;;;5153:79:120;5265:1;5285:51;5328:7;5308:9;5285:51;:::i;5643:267::-;-1:-1:-1;;;5588:44:120;;5784:93;5902:1;5893:11;;5643:267::o;5915:::-;6123:34;6153:3;6123:34;:::i;6330:159::-;6422:13;;6444:39;6422:13;6444:39;:::i;6494:365::-;6572:6;6625:2;6613:9;6604:7;6600:23;6596:32;6593:147;;;6651:79;472:2612:100;;;6651:79:120;6763:1;6783:70;6845:7;6825:9;6783:70;:::i;7460:319::-;7667:2;7679:47;;;7652:18;;;6951:19;;;7162:34;6994:14;;;7139:58;7437:12;;;7743:30;7208:247;7864:258;7936:1;7946:113;7960:6;7957:1;7954:13;7946:113;;;8036:11;;;8030:18;8017:11;;;8010:39;7982:2;7975:10;7946:113;;;8077:6;8074:1;8071:13;8068:48;;;8112:1;8103:6;8098:3;8094:16;8087:27;8068:48;;7864:258;;;:::o;8127:281::-;8168:3;8200:25;8219:5;7845:12;;7784:75;8200:25;6951:19;;;7003:4;6994:14;;8234:55;;8298:52;8343:6;8338:3;8331:4;8324:5;8320:16;8298:52;:::i;:::-;2536:2;2516:14;-1:-1:-1;;2512:28:120;8366:36;;;;;;-1:-1:-1;;8127:281:120:o;8413:347::-;8593:2;8578:18;;8605:45;8582:9;8624:6;8605:45;:::i;:::-;8696:9;8690:4;8686:20;8681:2;8670:9;8666:18;8659:48;8724:30;8749:4;8741:6;8724:30;:::i;9253:324::-;9460:2;9472:47;;;9445:18;;9536:35;9445:18;9109:2;6951:19;;8908:34;7003:4;6994:14;;8885:58;-1:-1:-1;;;8959:15:120;;;8952:33;9230:12;;;8996:252;9757:267;-1:-1:-1;;;9702:44:120;;9898:93;9582:170;10029:267;10237:34;10267:3;10237:34;:::i"
        },
        "gasEstimates": {
          "creation": {
            "codeDepositCost": "445800",
            "executionCost": "26326",
            "totalCost": "472126"
          },
          "external": {
            "changeProxyAdmin(address,address)": "infinite",
            "getProxyAdmin(address)": "infinite",
            "getProxyImplementation(address)": "infinite",
            "owner()": "infinite",
            "renounceOwnership()": "28170",
            "transferOwnership(address)": "infinite",
            "upgrade(address,address)": "infinite",
            "upgradeAndCall(address,address,bytes)": "infinite"
          }
        },
        "methodIdentifiers": {
          "changeProxyAdmin(address,address)": "7eff275e",
          "getProxyAdmin(address)": "f3b7dead",
          "getProxyImplementation(address)": "204e1c7a",
          "owner()": "8da5cb5b",
          "renounceOwnership()": "715018a6",
          "transferOwnership(address)": "f2fde38b",
          "upgrade(address,address)": "99a88ec4",
          "upgradeAndCall(address,address,bytes)": "9623609d"
        }
      },
      "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract TransparentUpgradeableProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeProxyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TransparentUpgradeableProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TransparentUpgradeableProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TransparentUpgradeableProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TransparentUpgradeableProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\",\"kind\":\"dev\",\"methods\":{\"changeProxyAdmin(address,address)\":{\"details\":\"Changes the admin of `proxy` to `newAdmin`. Requirements: - This contract must be the current admin of `proxy`.\"},\"getProxyAdmin(address)\":{\"details\":\"Returns the current admin of `proxy`. Requirements: - This contract must be the admin of `proxy`.\"},\"getProxyImplementation(address)\":{\"details\":\"Returns the current implementation of `proxy`. Requirements: - This contract must be the admin of `proxy`.\"},\"renounceOwnership()\":{\"details\":\"Renouncing ownership will leave the contract without an owner,         thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Can only be called by the current owner.\",\"params\":{\"newOwner\":\"Address of the new owner\"}},\"upgrade(address,address)\":{\"details\":\"Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}. Requirements: - This contract must be the admin of `proxy`.\"},\"upgradeAndCall(address,address,bytes)\":{\"details\":\"Upgrades `proxy` to `implementation` and calls a function on the new implementation. See {TransparentUpgradeableProxy-upgradeToAndCall}. Requirements: - This contract must be the admin of `proxy`.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"owner()\":{\"notice\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"notice\":\"Leaves the contract without owner. It will not be possible to call         `onlyOwner` functions anymore. Can only be called by the current owner.\"},\"transferOwnership(address)\":{\"notice\":\"Transfers ownership of the contract to a new account (`newOwner`).\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/proxy/ProxyAdmin.sol\":\"ProxyAdmin\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"inliner\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":true,\"yulDetails\":{\"optimizerSteps\":\"dhfoDgvulfnTUtnIf\",\"stackAllocation\":true}},\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xea40bf10119e88ed92ff8f1c72d01b0d2bfc810ad32c87d63ab6f316595d2c91\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            Address.functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _upgradeTo(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfd0d01e9036a03e50a71009749b9bfe7570a8f5b852ea409f794debfdd646dbd\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xdfddefa47c1f11dde2c3b5533c76ccef27a526985c74d9c917deb699d5d46a56\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0x94f08740b99a0997bc8363edb752b38354f730a38c54eb7bdd38a8a22ff34aae\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/TransparentUpgradeableProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\n     */\\n    constructor(\\n        address _logic,\\n        address admin_,\\n        bytes memory _data\\n    ) payable ERC1967Proxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _changeAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        _changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeToAndCall(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _getAdmin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\",\"keccak256\":\"0xbed75cc7d07d1e6dae9eaf2cfe18618620963b00adfe1dbc10dbce9369036933\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9944d1038f27dcebff810d7ba16b3b8058b967173d76874fb72dd7cd84129656\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5d874c66c21369dce8d3fe0b6c41316b0c289e45c0b4a77090c010ac2bb80e61\",\"license\":\"MIT\"},\"contracts/proxy/ProxyAdmin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/ProxyAdmin.sol)\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/**\\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\\n */\\ncontract ProxyAdmin is Ownable {\\n    constructor() Ownable(msg.sender) {}\\n\\n    /**\\n     * @dev Returns the current implementation of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyImplementation(TransparentUpgradeableProxy proxy)\\n        public\\n        view\\n        virtual\\n        returns (address)\\n    {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\\n            hex\\\"5c60da1b\\\"\\n        );\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the current admin of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyAdmin(TransparentUpgradeableProxy proxy)\\n        public\\n        view\\n        virtual\\n        returns (address)\\n    {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\\n            hex\\\"f851a440\\\"\\n        );\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of `proxy` to `newAdmin`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the current admin of `proxy`.\\n     */\\n    function changeProxyAdmin(\\n        TransparentUpgradeableProxy proxy,\\n        address newAdmin\\n    ) public virtual onlyOwner {\\n        proxy.changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        proxy.upgradeTo(implementation);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgradeAndCall(\\n        TransparentUpgradeableProxy proxy,\\n        address implementation,\\n        bytes memory data\\n    ) public payable virtual onlyOwner {\\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n    }\\n}\\n\",\"keccak256\":\"0x3550e67f65f2d5fe0bdfbdfa887b06147203d4c1e0d1c388c7341e79e4883a12\",\"license\":\"MIT\"},\"contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x6fe5115c43db85920e7325c78060272343284628b8367ea986dab63747553dde\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev The owner can be set during deployment, not default to be msg.sender\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor(address _initialOwner) {\\n        _transferOwnership(_initialOwner);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Leaves the contract without owner. It will not be possible to call\\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * @dev    Renouncing ownership will leave the contract without an owner,\\n     *         thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     * @dev    Can only be called by the current owner.\\n     * @param  newOwner Address of the new owner\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     * @dev    Internal function without access restriction.\\n     * @param  newOwner Address of the new owner\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x01872fb0c7277e79dbf69d60aad3ac917dfc22349ce6377d8e388287e4f31e88\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
      "storageLayout": {
        "storage": [
          {
            "astId": 25906,
            "contract": "contracts/proxy/ProxyAdmin.sol:ProxyAdmin",
            "label": "_owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          }
        ],
        "types": {
          "t_address": {
            "encoding": "inplace",
            "label": "address",
            "numberOfBytes": "20"
          }
        }
      },
      "userdoc": {
        "kind": "user",
        "methods": {
          "owner()": {
            "notice": "Returns the address of the current owner."
          },
          "renounceOwnership()": {
            "notice": "Leaves the contract without owner. It will not be possible to call         `onlyOwner` functions anymore. Can only be called by the current owner."
          },
          "transferOwnership(address)": {
            "notice": "Transfers ownership of the contract to a new account (`newOwner`)."
          }
        },
        "version": 1
      },
      "solcInput": "{\n  \"language\": \"Solidity\",\n  \"sources\": {\n    \"contracts/chainlinkMock/FlightOracleMock.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../miserable-flight/interfaces/IPolicyFlow.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/**\\n * @title  Flight Oracle Mock\\n * @notice Mock oracle contract for test.\\n */\\ncontract FlightOracleMock is Ownable {\\n    IPolicyFlow public policyFlow;\\n\\n    uint256 public delayResult; // For test\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event PolicyFlowChanged(address newPolicyFlow);\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Need the address of LINK token on specific network\\n     */\\n    constructor(address _policyFlow) Ownable(msg.sender) {\\n        policyFlow = IPolicyFlow(_policyFlow);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // Only the policyFlow can call some functions\\n    modifier onlyPolicyFlow() {\\n        require(\\n            msg.sender == address(policyFlow),\\n            \\\"Only the policyflow can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Change the policy flow contract address\\n     */\\n    function setPolicyFlow(address _policyFlow) external onlyOwner {\\n        policyFlow = IPolicyFlow(_policyFlow);\\n        emit PolicyFlowChanged(_policyFlow);\\n    }\\n\\n    function setResult(uint256 _delayResult) external {\\n        delayResult = _delayResult;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Creates a request to the specified Oracle contract address\\n     * @dev This function ignores the stored Oracle contract address and\\n     *      will instead send the request to the address specified\\n     * @param _payment Payment to the oracle\\n     * @param _url The URL to fetch data from\\n     * @param _path The dot-delimited path to parse of the response\\n     * @param _times The number to multiply the result by\\n     */\\n    function newOracleRequest(\\n        uint256 _payment,\\n        string memory _url,\\n        string memory _path,\\n        int256 _times\\n    ) public view onlyPolicyFlow returns (bytes32 requestId) {\\n        requestId = keccak256(abi.encodePacked(_payment, _url, _path, _times));\\n\\n        // fulfill(test_hash, delayResult);\\n        return requestId;\\n    }\\n\\n    /**\\n     * @notice The fulfill method from requests created by this contract\\n     * @dev The recordChainlinkFulfillment protects this function from being called\\n     *      by anyone other than the oracle address that the request was sent to\\n     * @param _requestId The ID that was generated for the request\\n     */\\n    function fulfill(bytes32 _requestId) public {\\n        policyFlow.finalSettlement(_requestId, delayResult);\\n    }\\n}\\n\"\n    },\n    \"contracts/miserable-flight/interfaces/IPolicyFlow.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"./IPolicyStruct.sol\\\";\\n\\n/**\\n * @title  IPolicyFlow\\n * @notice This is the interface of PolicyFlow contract.\\n *         Contains some type definations, event list and function declarations.\\n */\\ninterface IPolicyFlow is IPolicyStruct {\\n    /// @notice Function declarations\\n\\n    /// @notice Apply for a new policy\\n    function newApplication(\\n        uint256 _productId,\\n        string memory _flightNumber,\\n        uint256 _premium,\\n        uint256 _departureTimestamp,\\n        uint256 _landingTimestamp,\\n        uint256 _deadline,\\n        bytes calldata signature\\n    ) external returns (uint256 policyId);\\n\\n    /// @notice Start a new claim request\\n    function newClaimRequest(\\n        uint256 _policyId,\\n        string memory _flightNumber,\\n        string memory _timestamp,\\n        string memory _path,\\n        bool _forceUpdate\\n    ) external;\\n\\n    /// @notice View a user's policy info\\n    function viewUserPolicy(address)\\n        external\\n        view\\n        returns (PolicyInfo[] memory);\\n\\n    /// @notice Get the policy info by its policyId\\n    function getPolicyInfoById(uint256)\\n        external\\n        view\\n        returns (PolicyInfo memory);\\n\\n    /// @notice Update when the policy token is transferred to another owner\\n    function policyOwnerTransfer(\\n        uint256,\\n        address,\\n        address\\n    ) external;\\n\\n    /// @notice Do the final settlement when receiving the oracle result\\n    function finalSettlement(bytes32 _requestId, uint256 _result) external;\\n}\\n\"\n    },\n    \"contracts/utils/Ownable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev The owner can be set during deployment, not default to be msg.sender\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor(address _initialOwner) {\\n        _transferOwnership(_initialOwner);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Leaves the contract without owner. It will not be possible to call\\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * @dev    Renouncing ownership will leave the contract without an owner,\\n     *         thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     * @dev    Can only be called by the current owner.\\n     * @param  newOwner Address of the new owner\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     * @dev    Internal function without access restriction.\\n     * @param  newOwner Address of the new owner\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\n    },\n    \"contracts/miserable-flight/interfaces/IPolicyStruct.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface IPolicyStruct {\\n    enum PolicyStatus {\\n        INI,\\n        SOLD,\\n        EXPIRED,\\n        CLAIMED\\n    }\\n\\n    struct PolicyInfo {\\n        uint256 productId;\\n        address buyerAddress;\\n        uint256 policyId;\\n        string flightNumber;\\n        uint256 premium;\\n        uint256 payoff;\\n        uint256 purchaseTimestamp;\\n        uint256 departureTimestamp;\\n        uint256 landingTimestamp;\\n        PolicyStatus status;\\n        bool alreadySettled;\\n        uint256 delayResult;\\n    }\\n}\\n\"\n    },\n    \"contracts/utils/Context.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\n    },\n    \"contracts/staking/StakingPoolFactory.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"./interfaces/IPool.sol\\\";\\nimport \\\"./CoreStakingPool.sol\\\";\\nimport \\\"../tokens/interfaces/IDegisToken.sol\\\";\\n\\ncontract StakingPoolFactory is Ownable {\\n    /// @dev Auxiliary data structure used only in getPoolData() view function\\n    struct PoolData {\\n        // @dev pool token address (Degis / Degis LP Token)\\n        address poolToken;\\n        // @dev pool address\\n        address poolAddress;\\n        // @dev start block\\n        uint256 startBlock;\\n        // @dev pool weight\\n        uint256 degisPerBlock;\\n        // @dev flash pool flag\\n        bool isFlashPool;\\n    }\\n\\n    address public degisToken;\\n\\n    /// @dev Pool token address  => pool address\\n    mapping(address => address) public pools;\\n\\n    /// @dev Keeps track of registered pool addresses, pool address -> whether exists\\n    mapping(address => bool) public poolExists;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @dev Fired in createPool() and _registerPool()\\n     *\\n     * @param by who deploys a new pool\\n     * @param poolToken pool token address\\n     * @param poolAddress deployed pool instance address\\n     * @param degisPerBlock pool weight\\n     * @param isFlashPool flag indicating if pool is a flash pool\\n     */\\n    event PoolRegistered(\\n        address indexed by,\\n        address indexed poolToken,\\n        address indexed poolAddress,\\n        uint256 degisPerBlock,\\n        bool isFlashPool\\n    );\\n\\n    /**\\n     * @notice Change the degis reward for pool\\n     */\\n    event DegisPerBlockChanged(address pool, uint256 degisPerBlock);\\n\\n    /**\\n     * @dev Creates/deploys a factory instance\\n     *\\n     * @param _degisToken Degis token address\\n     */\\n    constructor(address _degisToken) Ownable(msg.sender) {\\n        degisToken = _degisToken;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    function getPoolAddress(address poolToken) external view returns (address) {\\n        return pools[poolToken];\\n    }\\n\\n    function getPoolData(address _poolToken)\\n        public\\n        view\\n        returns (PoolData memory)\\n    {\\n        // get the pool address from the mapping\\n        address poolAddr = pools[_poolToken];\\n\\n        // throw if there is no pool registered for the token specified\\n        require(poolAddr != address(0), \\\"pool not found\\\");\\n\\n        // read pool information from the pool smart contract\\n        // via the pool interface (IPool)\\n        address poolToken = IPool(poolAddr).poolToken();\\n        bool isFlashPool = IPool(poolAddr).isFlashPool();\\n        uint256 startBlock = IPool(poolAddr).startBlock();\\n        uint256 degisPerBlock = IPool(poolAddr).degisPerBlock();\\n\\n        // create the in-memory structure and return it\\n        return\\n            PoolData({\\n                poolToken: poolToken,\\n                poolAddress: poolAddr,\\n                startBlock: startBlock,\\n                degisPerBlock: degisPerBlock,\\n                isFlashPool: isFlashPool\\n            });\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Set degis per block\\n     * @param _pool Address of the staking pool\\n     * @param _degisPerBlock Degis reward per block\\n     */\\n    function setDegisPerBlock(address _pool, uint256 _degisPerBlock)\\n        external\\n        onlyOwner\\n    {\\n        BasePool(_pool).setDegisPerBlock(_degisPerBlock);\\n\\n        emit DegisPerBlockChanged(_pool, _degisPerBlock);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @dev Creates a staking pool and registers it within the factory\\n     * @param poolToken pool token address\\n     * @param startBlock init block to be used for the pool created\\n     * @param degisPerBlock weight of the pool to be created\\n     * @param isFlashPool Whether it is a flash pool\\n     */\\n    function createPool(\\n        address poolToken,\\n        uint256 startBlock,\\n        uint256 degisPerBlock,\\n        bool isFlashPool\\n    ) external onlyOwner {\\n        // create/deploy new core pool instance\\n        IPool pool = new CoreStakingPool(\\n            degisToken,\\n            poolToken,\\n            address(this),\\n            startBlock,\\n            degisPerBlock,\\n            isFlashPool\\n        );\\n\\n        // register it within a factory\\n        _registerPool(address(pool));\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Internal Functions ********************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Register a deployed pool instance within the factory\\n     * @param _poolAddr Address of the already deployed pool instance\\n     */\\n    function _registerPool(address _poolAddr) internal {\\n        // read pool information from the pool smart contract\\n        // via the pool interface (IPool)\\n        address poolToken = IPool(_poolAddr).poolToken();\\n        bool isFlashPool = IPool(_poolAddr).isFlashPool();\\n        uint256 degisPerBlock = IPool(_poolAddr).degisPerBlock();\\n\\n        // ensure that the pool is not already registered within the factory\\n        require(\\n            pools[poolToken] == address(0),\\n            \\\"This pool is already registered\\\"\\n        );\\n\\n        // create pool structure, register it within the factory\\n        pools[poolToken] = _poolAddr;\\n        poolExists[_poolAddr] = true;\\n        // update total pool weight of the factory\\n\\n        // emit an event\\n        emit PoolRegistered(\\n            msg.sender,\\n            poolToken,\\n            _poolAddr,\\n            degisPerBlock,\\n            isFlashPool\\n        );\\n    }\\n\\n    /**\\n     * @notice Mint degis tokens as reward\\n     * @dev With this function, we only need to add factory contract into minterList\\n     * @param _to The address to mint tokens to\\n     * @param _amount Amount of degis tokens to mint\\n     */\\n    function mintReward(address _to, uint256 _amount) external {\\n        // verify that sender is a pool registered withing the factory\\n        require(poolExists[msg.sender], \\\"Only called from pool\\\");\\n\\n        // mint degis tokens as required\\n        IDegisToken(degisToken).mintDegis(_to, _amount);\\n    }\\n}\\n\"\n    },\n    \"contracts/staking/interfaces/IPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title Illuvium Pool\\n *\\n * @notice An abstraction representing a pool, see IlluviumPoolBase for details\\n *\\n * @author Pedro Bergamini, reviewed by Basil Gorin\\n */\\ninterface IPool {\\n    /**\\n     * @dev Deposit is a key data structure used in staking,\\n     *      it represents a unit of stake with its amount, weight and term (time interval)\\n     */\\n    struct Deposit {\\n        // @dev token amount staked\\n        uint256 tokenAmount;\\n        // @dev stake weight\\n        uint256 weight;\\n        // @dev locking period - from\\n        uint256 lockedFrom;\\n        // @dev locking period - until\\n        uint256 lockedUntil;\\n    }\\n\\n    // for the rest of the functions see Soldoc in IlluviumPoolBase\\n\\n    function degisToken() external view returns (address);\\n\\n    function poolToken() external view returns (address);\\n\\n    function isFlashPool() external view returns (bool);\\n\\n    function startBlock() external view returns (uint256);\\n\\n    function degisPerBlock() external view returns (uint256);\\n\\n    function totalWeight() external view returns (uint256);\\n\\n    function accDegisPerWeight() external view returns (uint256);\\n\\n    function pendingRewards(address _user) external view returns (uint256);\\n\\n    function setDegisPerBlock(uint256 _degisPerBlock) external;\\n}\\n\"\n    },\n    \"contracts/staking/CoreStakingPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"./abstracts/BasePool.sol\\\";\\n\\ncontract CoreStakingPool is Ownable, BasePool {\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    constructor(\\n        address _degisToken,\\n        address _poolToken,\\n        address _factory,\\n        uint256 _startBlock,\\n        uint256 _degisPerBlock,\\n        bool _isFlashPool\\n    )\\n        Ownable(msg.sender)\\n        BasePool(\\n            _degisToken,\\n            _poolToken,\\n            _factory,\\n            _startBlock,\\n            _degisPerBlock,\\n            _isFlashPool\\n        )\\n    {}\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Stake function, will call the stake in BasePool\\n     */\\n    function _stake(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _lockUntil\\n    ) internal override {\\n        super._stake(_user, _amount, _lockUntil);\\n    }\\n\\n    /**\\n     * @notice Unstake function, will check some conditions and call the unstake in BasePool\\n     */\\n    function _unstake(\\n        address _user,\\n        uint256 _depositId,\\n        uint256 _amount\\n    ) internal override {\\n        UserInfo storage user = users[_msgSender()];\\n        Deposit memory stakeDeposit = user.deposits[_depositId];\\n        require(\\n            stakeDeposit.lockedFrom == 0 ||\\n                block.timestamp >= stakeDeposit.lockedUntil,\\n            \\\"Deposit not yet unlocked\\\"\\n        );\\n\\n        super._unstake(_user, _depositId, _amount);\\n    }\\n}\\n\"\n    },\n    \"contracts/tokens/interfaces/IDegisToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDegisToken is IERC20, IERC20Permit {\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Functions ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n    function CAP() external view returns (uint256);\\n\\n    /**\\n     * @notice Mint degis tokens\\n     * @param  _account Receiver's address\\n     * @param  _amount Amount to be minted\\n     */\\n    function mintDegis(address _account, uint256 _amount) external;\\n\\n    /**\\n     * @notice Burn degis tokens\\n     * @param  _account Receiver's address\\n     * @param  _amount Amount to be burned\\n     */\\n    function burnDegis(address _account, uint256 _amount) external;\\n}\\n\"\n    },\n    \"contracts/staking/abstracts/BasePool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../interfaces/IPool.sol\\\";\\nimport \\\"../interfaces/IStakingPoolFactory.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../../libraries/SafePRBMath.sol\\\";\\n\\nabstract contract BasePool is IPool, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using SafePRBMath for uint256;\\n\\n    /// @dev Data structure representing token holder using a pool\\n    struct UserInfo {\\n        uint256 tokenAmount;\\n        uint256 totalWeight;\\n        uint256 rewardDebts;\\n        // @dev An array of holder's deposits\\n        Deposit[] deposits;\\n    }\\n    mapping(address => UserInfo) public users;\\n\\n    // Token address staked in this pool\\n    address public poolToken;\\n\\n    // Reward token: degis\\n    address public degisToken;\\n\\n    uint256 public startBlock;\\n\\n    // Degis reward speed\\n    uint256 public degisPerBlock;\\n\\n    bool public isFlashPool;\\n\\n    // Last check point\\n    uint256 public lastRewardBlock;\\n\\n    uint256 public accDegisPerWeight;\\n\\n    // Total weight in the pool\\n    uint256 public totalWeight;\\n\\n    // Factory contract address\\n    address public factory;\\n\\n    // Weight multiplier constants\\n    uint256 internal constant WEIGHT_MULTIPLIER = 1e6;\\n\\n    uint256 internal constant YEAR_STAKE_WEIGHT_MULTIPLIER =\\n        2 * WEIGHT_MULTIPLIER;\\n\\n    uint256 internal constant REWARD_PER_WEIGHT_MULTIPLIER = 1e12;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event Stake(address user, uint256 amount, uint256 lockUntil);\\n\\n    event Unstake(address user, uint256 amount);\\n\\n    event Harvest(address user, uint256 amount);\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    constructor(\\n        address _degisToken,\\n        address _poolToken,\\n        address _factory,\\n        uint256 _startBlock,\\n        uint256 _degisPerBlock,\\n        bool _isFlashPool\\n    ) {\\n        degisToken = _degisToken;\\n        poolToken = _poolToken;\\n        factory = _factory;\\n        isFlashPool = _isFlashPool;\\n\\n        degisPerBlock = _degisPerBlock;\\n\\n        startBlock = _startBlock;\\n\\n        // lastRewardBlock = block.number > startBlock ? block.number : startBlock;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    modifier onlyFactory() {\\n        require(msg.sender == factory, \\\"Only factory\\\");\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    function getUserDeposits(address _user)\\n        external\\n        view\\n        returns (Deposit[] memory)\\n    {\\n        return users[_user].deposits;\\n    }\\n\\n    function pendingRewards(address _user) external view returns (uint256) {\\n        if (block.number < lastRewardBlock || block.number < startBlock)\\n            return 0;\\n\\n        uint256 blocks = block.number - lastRewardBlock;\\n        uint256 degisReward = blocks * degisPerBlock;\\n\\n        // recalculated value for `yieldRewardsPerWeight`\\n        uint256 newDegisPerWeight = rewardToWeight(degisReward, totalWeight) +\\n            accDegisPerWeight;\\n\\n        // based on the rewards per weight value, calculate pending rewards;\\n        UserInfo memory user = users[_user];\\n\\n        uint256 pending = weightToReward(user.totalWeight, newDegisPerWeight) -\\n            user.rewardDebts;\\n\\n        return pending;\\n    }\\n\\n    function rewardToWeight(uint256 reward, uint256 rewardPerWeight)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        // apply the reverse formula and return\\n        return (reward * REWARD_PER_WEIGHT_MULTIPLIER).div(rewardPerWeight);\\n    }\\n\\n    function weightToReward(uint256 weight, uint256 rewardPerWeight)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        // apply the formula and return\\n        return weight.mul(rewardPerWeight) / REWARD_PER_WEIGHT_MULTIPLIER;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n    function setDegisPerBlock(uint256 _degisPerBlock) external onlyFactory {\\n        degisPerBlock = _degisPerBlock;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    function stake(uint256 _amount, uint256 _lockUntil) external {\\n        // delegate call to an internal function\\n        _stake(msg.sender, _amount, _lockUntil);\\n    }\\n\\n    function unstake(uint256 _depositId, uint256 _amount) external {\\n        // delegate call to an internal function\\n        _unstake(msg.sender, _depositId, _amount);\\n    }\\n\\n    function harvest() external {\\n        updatePool();\\n\\n        UserInfo storage user = users[msg.sender];\\n\\n        // calculate pending yield rewards, this value will be returned\\n        uint256 _pendingReward = _pendingRewards(msg.sender);\\n\\n        if (_pendingReward == 0) return;\\n\\n        _safeDegisTransfer(msg.sender, _pendingReward);\\n\\n        user.rewardDebts = weightToReward(user.totalWeight, accDegisPerWeight);\\n\\n        emit Harvest(msg.sender, _pendingReward);\\n    }\\n\\n    function updatePool() public {\\n        if (block.number < lastRewardBlock || block.number < startBlock) return;\\n\\n        uint256 balance = IERC20(poolToken).balanceOf(address(this));\\n\\n        if (balance == 0) {\\n            lastRewardBlock = block.number;\\n            return;\\n        }\\n\\n        uint256 blocks = block.number - lastRewardBlock;\\n\\n        uint256 degisReward = blocks * degisPerBlock;\\n\\n        IStakingPoolFactory(factory).mintReward(address(this), degisReward);\\n\\n        accDegisPerWeight += rewardToWeight(degisReward, totalWeight);\\n\\n        lastRewardBlock = block.number;\\n    }\\n\\n    function _stake(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _lockUntil\\n    ) internal virtual nonReentrant {\\n        require(block.number > startBlock, \\\"Pool not started yet\\\");\\n        require(_amount > 0, \\\"Zero amount\\\");\\n        require(\\n            _lockUntil == 0 ||\\n                (_lockUntil > block.timestamp &&\\n                    _lockUntil - block.timestamp <= 365 days),\\n            \\\"Invalid lock interval\\\"\\n        );\\n\\n        updatePool();\\n\\n        UserInfo storage user = users[_user];\\n\\n        if (user.tokenAmount > 0) {\\n            _distributeReward(_user);\\n        }\\n\\n        uint256 previousBalance = IERC20(poolToken).balanceOf(address(this));\\n        transferPoolTokenFrom(msg.sender, address(this), _amount);\\n        uint256 newBalance = IERC20(poolToken).balanceOf(address(this));\\n\\n        uint256 addedAmount = newBalance - previousBalance;\\n\\n        uint256 lockFrom = _lockUntil > 0 ? block.timestamp : 0;\\n        uint256 lockUntil = _lockUntil;\\n\\n        uint256 stakeWeight = timeToWeight(lockUntil - lockFrom) * addedAmount;\\n\\n        // makes sure stakeWeight is valid\\n        assert(stakeWeight > 0);\\n\\n        // create and save the deposit (append it to deposits array)\\n        Deposit memory deposit = Deposit({\\n            tokenAmount: addedAmount,\\n            weight: stakeWeight,\\n            lockedFrom: lockFrom,\\n            lockedUntil: lockUntil\\n        });\\n        // deposit ID is an index of the deposit in `deposits` array\\n        user.deposits.push(deposit);\\n\\n        // update user record\\n        user.tokenAmount += addedAmount;\\n        user.totalWeight += stakeWeight;\\n        user.rewardDebts = weightToReward(user.totalWeight, accDegisPerWeight);\\n\\n        // update global variable\\n        totalWeight += stakeWeight;\\n\\n        // emit an event\\n        emit Stake(msg.sender, _amount, _lockUntil);\\n    }\\n\\n    /**\\n     * @dev Used internally, mostly by children implementations, see unstake()\\n     * @param _user User address\\n     * @param _depositId deposit ID to unstake from, zero-indexed\\n     * @param _amount amount of tokens to unstake\\n     */\\n    function _unstake(\\n        address _user,\\n        uint256 _depositId,\\n        uint256 _amount\\n    ) internal virtual nonReentrant {\\n        // verify an amount is set\\n        require(_amount > 0, \\\"zero amount\\\");\\n\\n        UserInfo storage user = users[_user];\\n\\n        Deposit storage stakeDeposit = user.deposits[_depositId];\\n\\n        // verify available balance\\n        // if staker address ot deposit doesn't exist this check will fail as well\\n        require(stakeDeposit.tokenAmount >= _amount, \\\"amount exceeds stake\\\");\\n\\n        // update smart contract state\\n        updatePool();\\n        // and process current pending rewards if any\\n        _distributeReward(_user);\\n\\n        // recalculate deposit weight\\n        uint256 previousWeight = stakeDeposit.weight;\\n\\n        uint256 newWeight = timeToWeight(\\n            stakeDeposit.lockedUntil - stakeDeposit.lockedFrom\\n        ) * (stakeDeposit.tokenAmount - _amount);\\n\\n        // update the deposit, or delete it if its depleted\\n        if (stakeDeposit.tokenAmount - _amount == 0) {\\n            delete user.deposits[_depositId];\\n        } else {\\n            stakeDeposit.tokenAmount -= _amount;\\n            stakeDeposit.weight = newWeight;\\n        }\\n\\n        // update user record\\n        user.tokenAmount -= _amount;\\n        user.totalWeight = user.totalWeight - previousWeight + newWeight;\\n        user.rewardDebts = weightToReward(user.totalWeight, accDegisPerWeight);\\n\\n        // update global variable\\n        totalWeight -= (previousWeight - newWeight);\\n\\n        // otherwise just return tokens back to holder\\n        transferPoolToken(msg.sender, _amount);\\n\\n        // emit an event\\n        emit Unstake(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @dev 1 year = 2e6\\n     *      1 week = 1e6\\n     *      2 weeks = 1e6 * ( 1 + 1 / 365)\\n     */\\n    function timeToWeight(uint256 _length)\\n        public\\n        pure\\n        returns (uint256 _weight)\\n    {\\n        _weight = (_length / 365 days) * WEIGHT_MULTIPLIER + WEIGHT_MULTIPLIER;\\n    }\\n\\n    function _pendingRewards(address _staker)\\n        internal\\n        view\\n        returns (uint256 pending)\\n    {\\n        // read user data structure into memory\\n        UserInfo memory user = users[_staker];\\n\\n        // and perform the calculation using the values read\\n        return\\n            weightToReward(user.totalWeight, accDegisPerWeight) -\\n            user.rewardDebts;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Internal Functions ********************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    function _distributeReward(address _user) internal {\\n        uint256 pendingReward = _pendingRewards(_user);\\n\\n        if (pendingReward == 0) return;\\n        else {\\n            _safeDegisTransfer(_user, pendingReward);\\n        }\\n    }\\n\\n    function transferPoolToken(address _to, uint256 _value) internal {\\n        // just delegate call to the target\\n        IERC20(poolToken).safeTransfer(_to, _value);\\n    }\\n\\n    function transferPoolTokenFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) internal {\\n        IERC20(poolToken).safeTransferFrom(_from, _to, _value);\\n    }\\n\\n    /**\\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\\n     * @param _to User's address\\n     * @param _amount Amount to transfer\\n     */\\n    function _safeDegisTransfer(address _to, uint256 _amount) internal {\\n        uint256 totalDegis = IERC20(degisToken).balanceOf(address(this));\\n        if (_amount > totalDegis) {\\n            IERC20(degisToken).safeTransfer(_to, totalDegis);\\n        } else {\\n            IERC20(degisToken).safeTransfer(_to, _amount);\\n        }\\n    }\\n}\\n\"\n    },\n    \"contracts/staking/interfaces/IStakingPoolFactory.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface IStakingPoolFactory {\\n    function createPool(\\n        address _poolToken,\\n        uint256 _startBlock,\\n        uint256 _degisPerBlock\\n    ) external;\\n\\n    function mintReward(address _to, uint256 _amount) external;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/SafePRBMath.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"prb-math/contracts/PRBMath.sol\\\";\\n\\n/**\\n * @notice This prb-math version is 2.4.1\\n *         https://github.com/hifi-finance/prb-math\\n */\\n\\n/// @title PRBMathUD60x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\\n/// maximum values permitted by the Solidity type uint256.\\nlibrary SafePRBMath {\\n    /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\\n    uint256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\n\\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_WHOLE_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function ceil(uint256 x) internal pure returns (uint256 result) {\\n        if (x > MAX_WHOLE_UD60x18) {\\n            revert PRBMathUD60x18__CeilOverflow(x);\\n        }\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"SCALE - remainder\\\" but faster.\\n            let delta := sub(SCALE, remainder)\\n\\n            // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := add(x, mul(delta, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\\n    ///\\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    ///\\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDiv(x, SCALE, y);\\n    }\\n\\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (uint256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp(uint256 x) internal pure returns (uint256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathUD60x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            uint256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n        if (x >= 192e18) {\\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x192x64 = (x << 64) / SCALE;\\n\\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\\n            result = PRBMath.exp2(x192x64);\\n        }\\n    }\\n\\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function floor(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := sub(x, mul(remainder, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x.\\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\\n    function frac(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mod(x, SCALE)\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__FromUintOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\\n    ///\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            uint256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathUD60x18__GmOverflow(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = PRBMath.sqrt(xy);\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\\n    function inv(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function ln(uint256 x) internal pure returns (uint256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 196205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log10(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly multiplication operation, not the \\\"mul\\\" function defined\\n        // in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\\n            default {\\n                result := MAX_UD60x18\\n            }\\n        }\\n\\n        if (result == MAX_UD60x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log2(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\\n\\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255 and SCALE is 1e18.\\n            result = n * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\\n    /// fixed-point number.\\n    /// @dev See the documentation for the \\\"PRBMath.mulDivFixedPoint\\\" function.\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDivFixedPoint(x, y);\\n    }\\n\\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\\n    function pi() internal pure returns (uint256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : uint256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // Calculate the first iteration of the loop in advance.\\n        result = y & 1 > 0 ? x : SCALE;\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        for (y >>= 1; y > 0; y >>= 1) {\\n            x = PRBMath.mulDivFixedPoint(x, x);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (y & 1 > 0) {\\n                result = PRBMath.mulDivFixedPoint(result, x);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\\n    function scale() internal pure returns (uint256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than MAX_UD60x18 / SCALE.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = PRBMath.sqrt(x * SCALE);\\n        }\\n    }\\n\\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/Address.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\n    },\n    \"prb-math/contracts/PRBMath.sol\": {\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\\n\\n/// @notice Emitted when one of the inputs is type(int256).min.\\nerror PRBMath__MulDivSignedInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows int256.\\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is MIN_SD59x18.\\nerror PRBMathSD59x18__AbsInputTooSmall();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMathSD59x18__CeilOverflow(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__DivInputTooSmall();\\n\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\\n\\n/// @notice Emitted when the product of the inputs is negative.\\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\\n\\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\\n\\n/// @notice Emitted when the input is less than or equal to zero.\\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__MulInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is negative.\\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\\n\\n/// @notice Emitted when addition overflows UD60x18.\\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\\n\\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the input is less than 1.\\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows UD60x18.\\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\\n\\n/// @notice Emitted when subtraction underflows UD60x18.\\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\\nlibrary PRBMath {\\n    /// STRUCTS ///\\n\\n    struct SD59x18 {\\n        int256 value;\\n    }\\n\\n    struct UD60x18 {\\n        uint256 value;\\n    }\\n\\n    /// STORAGE ///\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n    /// FUNCTIONS ///\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Has to use 192.64-bit fixed-point numbers.\\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n\\n            // We're doing two things at the same time:\\n            //\\n            //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n            //      rather than 192.\\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n            //\\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n            result *= SCALE;\\n            result >>= (191 - (x >> 64));\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division.\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n        if (prod1 >= denominator) {\\n            revert PRBMath__MulDivOverflow(prod1, denominator);\\n        }\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number.\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\n    ///     1. x * y = type(uint256).max * SCALE\\n    ///     2. (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 >= SCALE) {\\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\\n    ///\\n    /// @dev An extension of \\\"mulDiv\\\" for signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - None of the inputs can be type(int256).min.\\n    /// - The result must fit within int256.\\n    ///\\n    /// @param x The multiplicand as an int256.\\n    /// @param y The multiplier as an int256.\\n    /// @param denominator The divisor as an int256.\\n    /// @return result The result as an int256.\\n    function mulDivSigned(\\n        int256 x,\\n        int256 y,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n            revert PRBMath__MulDivSignedInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x, y and the denominator.\\n        uint256 ax;\\n        uint256 ay;\\n        uint256 ad;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n        }\\n\\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\\n        uint256 rAbs = mulDiv(ax, ay, ad);\\n        if (rAbs > uint256(type(int256).max)) {\\n            revert PRBMath__MulDivSignedOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x, y and the denominator.\\n        uint256 sx;\\n        uint256 sy;\\n        uint256 sd;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n            sd := sgt(denominator, sub(0, 1))\\n        }\\n\\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\\n        // If yes, the result should be negative.\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the closest power of two that is higher than x.\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x8) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\n    },\n    \"contracts/tokens/DegisToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"./interfaces/IDegisToken.sol\\\";\\nimport \\\"../utils/ERC20PermitWithMultipleMinters.sol\\\";\\n\\n/**@title  Degis Token\\n * @notice DegisToken inherits from ERC20 Permit which contains the basic ERC20 implementation.\\n *         DegisToken can use the permit function rather than approve + transferFrom.\\n *\\n *         DegisToken has an owner, a minterList and a burnerList.\\n *         When lauched on mainnet, the owner may be removed or tranferred to a multisig.\\n *         By default, the owner & the first minter will be the one that deploys the contract.\\n *         The minterList should contain FarmingPool and PurchaseIncentiveVault.\\n *         The burnerList should contain EmergencyPool.\\n */\\ncontract DegisToken is ERC20PermitWithMultipleMinters {\\n    // Degis has a total supply of 100 million\\n    uint256 public constant CAP = 1e8 ether;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Constructor *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    constructor() ERC20PermitWithMultipleMinters(\\\"DegisToken\\\", \\\"DEG\\\") {}\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Modifiers **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // Degis toke has a hard cap of 100 million\\n    modifier notExceedCap(uint256 _amount) {\\n        require(\\n            totalSupply() + _amount <= CAP,\\n            \\\"Exceeds the DEG cap (100 million)\\\"\\n        );\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Main Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Mint degis tokens\\n     * @param  _account Receiver's address\\n     * @param  _amount Amount to be minted\\n     */\\n    function mintDegis(address _account, uint256 _amount)\\n        external\\n        notExceedCap(_amount)\\n    {\\n        mint(_account, _amount);\\n    }\\n\\n    /**\\n     * @notice Burn degis tokens\\n     * @param  _account Receiver's address\\n     * @param  _amount Amount to be burned\\n     */\\n    function burnDegis(address _account, uint256 _amount) external {\\n        burn(_account, _amount);\\n    }\\n}\\n\"\n    },\n    \"contracts/utils/ERC20PermitWithMultipleMinters.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\nimport \\\"./OwnableWithoutContext.sol\\\";\\n\\n/**\\n * @title  ERC20 with Multiple Minters and Burners\\n * @notice This is contract used for ERC20 tokens that has multiple minters and burners.\\n * @dev    The minters and burners are some contracts in Degis that need to issue DEG.\\n *         It has basic implementations for ERC20 and also the owner control.\\n *         Even if the owner is renounced to zero address, the token can still be minted/burned.\\n *         DegisToken and BuyerToken are both this kind ERC20 token.\\n */\\ncontract ERC20PermitWithMultipleMinters is ERC20Permit, OwnableWithoutContext {\\n    // List of all minters\\n    mapping(address => bool) public isMinter;\\n\\n    // List of all burners\\n    mapping(address => bool) public isBurner;\\n\\n    event MinterAdded(address newMinter);\\n    event MinterRemoved(address oldMinter);\\n\\n    event BurnerAdded(address newBurner);\\n    event BurnerRemoved(address oldBurner);\\n\\n    event Mint(address indexed account, uint256 amount);\\n    event Burn(address indexed account, uint256 amount);\\n\\n    constructor(string memory name, string memory symbol)\\n        ERC20(name, symbol)\\n        ERC20Permit(name)\\n        OwnableWithoutContext(msg.sender)\\n    {\\n        // After the owner is transferred to multisig governance\\n        // This initial minter should be removed\\n        isMinter[_msgSender()] = true;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Modifiers ****************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     *@notice Check if the msg.sender is in the minter list\\n     */\\n    modifier validMinter(address _sender) {\\n        require(isMinter[_sender], \\\"Invalid minter\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Check if the msg.sender is in the burner list\\n     */\\n    modifier validBurner(address _sender) {\\n        require(isBurner[_sender], \\\"Invalid burner\\\");\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Admin Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Add a new minter into the minterList\\n     * @param _newMinter Address of the new minter\\n     */\\n    function addMinter(address _newMinter) external onlyOwner {\\n        require(!isMinter[_newMinter], \\\"Already a minter\\\");\\n\\n        isMinter[_newMinter] = true;\\n\\n        emit MinterAdded(_newMinter);\\n    }\\n\\n    /**\\n     * @notice Remove a minter from the minterList\\n     * @param _oldMinter Address of the minter to be removed\\n     */\\n    function removeMinter(address _oldMinter) external onlyOwner {\\n        require(isMinter[_oldMinter], \\\"Not a minter\\\");\\n\\n        isMinter[_oldMinter] = false;\\n\\n        emit MinterRemoved(_oldMinter);\\n    }\\n\\n    /**\\n     * @notice Add a new burner into the burnerList\\n     * @param _newBurner Address of the new burner\\n     */\\n    function addBurner(address _newBurner) external onlyOwner {\\n        require(!isBurner[_newBurner], \\\"Already a burner\\\");\\n\\n        isBurner[_newBurner] = true;\\n\\n        emit BurnerAdded(_newBurner);\\n    }\\n\\n    /**\\n     * @notice Remove a minter from the minterList\\n     * @param _oldBurner Address of the minter to be removed\\n     */\\n    function removeBurner(address _oldBurner) external onlyOwner {\\n        require(isMinter[_oldBurner], \\\"Not a burner\\\");\\n\\n        isBurner[_oldBurner] = false;\\n\\n        emit BurnerRemoved(_oldBurner);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Internal Functions ********************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Mint tokens\\n     * @param _account Receiver's address\\n     * @param _amount Amount to be minted\\n     */\\n    function mint(address _account, uint256 _amount)\\n        internal\\n        validMinter(_msgSender())\\n    {\\n        _mint(_account, _amount); // ERC20 method with an event\\n        emit Mint(_account, _amount);\\n    }\\n\\n    /**\\n     * @notice Burn tokens\\n     * @param _account address\\n     * @param _amount amount to be burned\\n     */\\n    function burn(address _account, uint256 _amount)\\n        internal\\n        validBurner(_msgSender())\\n    {\\n        _burn(_account, _amount);\\n        emit Burn(_account, _amount);\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-ERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./draft-IERC20Permit.sol\\\";\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"../../../utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../../../utils/Counters.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    using Counters for Counters.Counter;\\n\\n    mapping(address => Counters.Counter) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private immutable _PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view virtual override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n     *\\n     * _Available since v4.1._\\n     */\\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\\n        Counters.Counter storage nonce = _nonces[owner];\\n        current = nonce.current();\\n        nonce.increment();\\n    }\\n}\\n\"\n    },\n    \"contracts/utils/OwnableWithoutContext.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev The owner can be set during deployment, not default to be msg.sender\\n */\\nabstract contract OwnableWithoutContext {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor(address _initialOwner) {\\n        _transferOwnership(_initialOwner);\\n    }\\n\\n    /**\\n     * @notice Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @notice Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Leaves the contract without owner. It will not be possible to call\\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * @dev    Renouncing ownership will leave the contract without an owner,\\n     *         thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     * @dev    Can only be called by the current owner.\\n     * @param  newOwner Address of the new owner\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n     * @dev    Internal function without access restriction.\\n     * @param  newOwner Address of the new owner\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/Context.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\n    },\n    \"contracts/naughty-price/NaughtyFactory.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\nimport \\\"./NPPolicyToken.sol\\\";\\nimport \\\"./NaughtyPair.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/INaughtyPair.sol\\\";\\nimport \\\"./interfaces/IPolicyCore.sol\\\";\\nimport \\\"../libraries/StringsUtils.sol\\\";\\nimport \\\"../utils/OwnableWithoutContext.sol\\\";\\n\\n/**\\n * @title Naughty Factory\\n * @dev Factory contract to deploy new pools periodically\\n *      Each pool(product) will have a unique naughtyId\\n *      Each pool will have its pool token\\n *      PolicyToken - Stablecoin\\n *      Token 0 may change but Token 1 is always stablecoin.\\n */\\n\\ncontract NaughtyFactory is OwnableWithoutContext {\\n    using StringsUtils for address;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // PolicyToken Address => StableCoin Address => Pool Address\\n    mapping(address => mapping(address => address)) getPair;\\n\\n    // Store all the pairs' addresses\\n    address[] public allPairs;\\n\\n    // Store all policy tokens' addresses\\n    address[] public allTokens;\\n\\n    uint256 public _nextId;\\n\\n    // Address of policyCore\\n    address public policyCore;\\n\\n    // INIT_CODE_HASH for NaughtyPair, may be used in frontend\\n    bytes32 public constant PAIR_INIT_CODE_HASH =\\n        keccak256(abi.encodePacked(type(NaughtyPair).creationCode));\\n\\n    event PolicyCoreAddressChanged(\\n        address oldPolicyCore,\\n        address newPolicyCore\\n    );\\n\\n    constructor() OwnableWithoutContext(msg.sender) {}\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Modifiers ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Ensure the policyCore address is already set\\n     * @dev The naughty pair token may not have minter without this modifier\\n     */\\n    modifier alreadySetPolicyCore() {\\n        require(policyCore != address(0), \\\"Please set the policyCore address\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Only called by policyCore contract\\n     */\\n    modifier onlyPolicyCore() {\\n        require(msg.sender == policyCore, \\\"Only called by policyCore contract\\\");\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Next token to be deployed\\n     * @return Latest token address\\n     */\\n    function getLatestTokenAddress() external view returns (address) {\\n        uint256 currentToken = _nextId - 1;\\n        return allTokens[currentToken];\\n    }\\n\\n    /**\\n     * @notice Get the INIT_CODE_HASH for policy tokens with parameters\\n     * @param _policyTokenName Name of the policy token to be deployed\\n     */\\n    function getInitCodeHashForPolicyToken(\\n        string memory _policyTokenName,\\n        uint256 _tokenDecimals\\n    ) external view returns (bytes32) {\\n        bytes memory bytecode = type(NPPolicyToken).creationCode;\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    bytecode,\\n                    abi.encode(\\n                        _policyTokenName,\\n                        _policyTokenName,\\n                        policyCore,\\n                        _tokenDecimals\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Get the pair address deployed by the factory\\n     *         PolicyToken address first, and then stablecoin address\\n     *         The order of the tokens will be sorted inside the function\\n     * @param _tokenAddress1 Address of token1\\n     * @param _tokenAddress2 Address of toekn2\\n     * @return Pool address of the two tokens\\n     */\\n    function getPairAddress(address _tokenAddress1, address _tokenAddress2)\\n        public\\n        view\\n        returns (address)\\n    {\\n        // Policy token address at the first place\\n        (address token0, address token1) = IPolicyCore(policyCore)\\n            .supportedStablecoin(_tokenAddress2)\\n            ? (_tokenAddress1, _tokenAddress2)\\n            : (_tokenAddress2, _tokenAddress1);\\n\\n        address _pairAddress = getPair[token0][token1];\\n\\n        return _pairAddress;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Set Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Remember to call this function to set the policyCore address\\n     *         < PolicyCore should be the owner of policyToken >\\n     * @param _policyCore Address of policyCore contract\\n     */\\n    function setPolicyCoreAddress(address _policyCore) external onlyOwner {\\n        address oldPolicyCore = policyCore;\\n        policyCore = _policyCore;\\n        emit PolicyCoreAddressChanged(oldPolicyCore, _policyCore);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Main Functions *********************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice After deploy the policytoken and get the address,\\n     *         we deploy the policyToken - stablecoin pool contract\\n     * @param _policyTokenAddress Address of policy token\\n     * @param _stablecoin Address of the stable coin\\n     * @param _deadline Deadline of the pool\\n     * @param _feeRate Fee rate given to LP holders\\n     * @return Address of the pool\\n     */\\n    function deployPool(\\n        address _policyTokenAddress,\\n        address _stablecoin,\\n        uint256 _deadline,\\n        uint256 _feeRate\\n    ) external alreadySetPolicyCore onlyPolicyCore returns (address) {\\n        bytes memory bytecode = type(NaughtyPair).creationCode;\\n\\n        bytes32 salt = keccak256(\\n            abi.encodePacked(\\n                _policyTokenAddress.addressToString(),\\n                _stablecoin.addressToString()\\n            )\\n        );\\n\\n        address _poolAddress = _deploy(bytecode, salt);\\n\\n        INaughtyPair(_poolAddress).initialize(\\n            _policyTokenAddress,\\n            _stablecoin,\\n            _deadline,\\n            _feeRate\\n        );\\n\\n        getPair[_policyTokenAddress][_stablecoin] = _poolAddress;\\n\\n        allPairs.push(_poolAddress);\\n\\n        return _poolAddress;\\n    }\\n\\n    /**\\n     * @notice For each round we need to first create the policytoken(ERC20)\\n     * @param _policyTokenName Name of the policyToken\\n     * @param _decimals Decimals of the policyToken\\n     * @return PolicyToken address\\n     */\\n    function deployPolicyToken(\\n        string memory _policyTokenName,\\n        uint256 _decimals\\n    ) external alreadySetPolicyCore onlyPolicyCore returns (address) {\\n        bytes32 salt = keccak256(abi.encodePacked(_policyTokenName));\\n\\n        bytes memory bytecode = getPolicyTokenBytecode(\\n            _policyTokenName,\\n            _decimals\\n        );\\n\\n        address _policTokenAddress = _deploy(bytecode, salt);\\n\\n        allTokens.push(_policTokenAddress);\\n\\n        _nextId++;\\n\\n        return _policTokenAddress;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Internal Functions ********************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Deploy function with create2\\n     */\\n    function _deploy(bytes memory code, bytes32 salt)\\n        internal\\n        returns (address addr)\\n    {\\n        assembly {\\n            addr := create2(0, add(code, 0x20), mload(code), salt)\\n            if iszero(extcodesize(addr)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the policyToken bytecode (with parameters)\\n     * @dev It is public for test convinience\\n     * @param _tokenName Name of policyToken\\n     */\\n    function getPolicyTokenBytecode(string memory _tokenName, uint256 _decimals)\\n        public\\n        view\\n        returns (bytes memory)\\n    {\\n        bytes memory bytecode = type(NPPolicyToken).creationCode;\\n\\n        // Encodepacked the parameters\\n        // The minter is set to be the policyCore address\\n        return\\n            abi.encodePacked(\\n                bytecode,\\n                abi.encode(_tokenName, _tokenName, policyCore, _decimals)\\n            );\\n    }\\n}\\n\"\n    },\n    \"contracts/naughty-price/NPPolicyToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/**\\n * @title  Policy Token for Naughty Price\\n * @notice This is the contract for token price policy token.\\n *         It is a ERC20 token with an owner and a minter.\\n *         The owner should be the deployer at first.\\n *         The minter should be the policyCore contract.\\n * @dev    It is different from the flight delay token.\\n *         That is an ERC721 NFT and this is an ERC20 token.\\n */\\ncontract NPPolicyToken is ERC20 {\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    address public minter;\\n\\n    uint256 private tokenDecimals;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event Mint(address account, uint256 amount);\\n    event Burn(address account, uint256 amount);\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _minter,\\n        uint256 _decimals\\n    ) ERC20(_name, _symbol) {\\n        minter = _minter;\\n        tokenDecimals = _decimals;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Modifiers **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Only the minter can mint\\n     */\\n    modifier onlyMinter() {\\n        require(msg.sender == minter, \\\"only minter can call this function\\\");\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Main Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Mint some policy tokens\\n     * @param _account Address to receive the tokens\\n     * @param _amount Amount to be minted\\n     */\\n    function mint(address _account, uint256 _amount) public onlyMinter {\\n        _mint(_account, _amount);\\n        emit Mint(_account, _amount);\\n    }\\n\\n    /**\\n     * @notice Burn some policy tokens\\n     * @param _account Address to burn tokens\\n     * @param _amount Amount to be burned\\n     */\\n    function burn(address _account, uint256 _amount) public onlyMinter {\\n        _burn(_account, _amount);\\n        emit Burn(_account, _amount);\\n    }\\n\\n    /**\\n     * @notice Get the decimals of this token\\n     * @dev It should be the same as its paired stablecoin\\n     */\\n    function decimals() public view override returns (uint8) {\\n        return uint8(tokenDecimals);\\n    }\\n}\\n\"\n    },\n    \"contracts/naughty-price/NaughtyPair.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../libraries/Math.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./interfaces/INaughtyFactory.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title  Naughty Pair\\n * @notice This is the contract for the naughtyPrice swapping pair.\\n *         Every time a new naughtyPrice product is online you need to deploy this contract.\\n *         The contract will be initialized with two tokens and a deadline.\\n *         Token0 will be policy tokens and token1 will be stablecoins.\\n *         The swaps are only availale before the deadline.\\n */\\ncontract NaughtyPair is ERC20(\\\"Naughty Pool LP\\\", \\\"NLP\\\"), ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // naughtyFactory contract address\\n    address public factory;\\n\\n    // Token addresses in the pool\\n    address public token0; // Insurance Token\\n    address public token1; // USDT\\n\\n    uint112 private reserve0; // Amount of Insurance Token\\n    uint112 private reserve1; // Amount of USDT\\n\\n    // Used for modifiers\\n    bool public unlocked = true;\\n\\n    // Every pool will have a deadline\\n    uint256 public deadline;\\n\\n    // Fee Rate, given to LP holders (0 ~ 1000)\\n    uint256 public feeRate;\\n\\n    // Minimum liquidity locked\\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event ReserveUpdated(uint256 reserve0, uint256 reserve1);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amountAIn,\\n        uint256 amountBIn,\\n        uint256 amountAOut,\\n        uint256 amountBOut,\\n        address indexed to\\n    );\\n\\n    event Mint(address indexed sender, uint256 amountA, uint256 amountB);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amountA,\\n        uint256 amountB,\\n        address indexed to\\n    );\\n\\n    constructor() {\\n        factory = msg.sender; // deployed by factory contract\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Can not swap after the deadline\\n     * @dev Each pool will have a deadline and it was set when deployed\\n     */\\n    modifier beforeDeadline() {\\n        require(block.timestamp <= deadline, \\\"Can not swap after deadline\\\");\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Init Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Initialize the contract status after the deployment by factory\\n     * @param _token0 Token0 address (policy token address)\\n     * @param _token1 Token1 address (stablecoin address)\\n     * @param _deadline Deadline for this pool\\n     * @param _feeRate Fee rate to LP holders (1000 <=> 100%)\\n     */\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        uint256 _deadline,\\n        uint256 _feeRate\\n    ) external {\\n        require(\\n            msg.sender == factory,\\n            \\\"can only be initialized by the factory contract\\\"\\n        );\\n        require(_feeRate <= 1000, \\\"feeRate over 1.0\\\");\\n\\n        token0 = _token0;\\n        token1 = _token1;\\n\\n        // deadline for the whole pool after which no swap will be allowed\\n        deadline = _deadline;\\n\\n        feeRate = _feeRate;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Get reserve0 (Policy token) and reserve1 (stablecoin).\\n     * @dev This function always put policy token at the first place!\\n     * @return _reserve0 Reserve of token0\\n     * @return _reserve1 Reserve of token1\\n     */\\n    function getReserves()\\n        public\\n        view\\n        returns (uint112 _reserve0, uint112 _reserve1)\\n    {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Mint LP Token to liquidity providers\\n     *         Called when adding liquidity.\\n     * @param to The user address\\n     * @return liquidity The LP token amount\\n     */\\n    function mint(address to)\\n        external\\n        nonReentrant\\n        returns (uint256 liquidity)\\n    {\\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\\n\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this)); // policy token balance after deposit\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this)); // stablecoin balance after deposit\\n\\n        uint256 amount0 = balance0 - _reserve0; // just deposit\\n        uint256 amount1 = balance1 - _reserve1;\\n\\n        uint256 _totalSupply = totalSupply(); // gas savings\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(amount0 * amount1 - MINIMUM_LIQUIDITY);\\n            _mint(address(this), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n        } else {\\n            liquidity = min(\\n                (amount0 * _totalSupply) / _reserve0,\\n                (amount1 * _totalSupply) / _reserve1\\n            );\\n        }\\n\\n        require(liquidity > 0, \\\"insufficient liquidity minted\\\");\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1);\\n\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    /**\\n     * @notice Burn LP tokens give back the original tokens\\n     * @param _to User address\\n     * @return amount0 Amount of token0 to be sent back\\n     * @return amount1 Amount of token1 to be sent back\\n     */\\n    function burn(address _to)\\n        external\\n        nonReentrant\\n        returns (uint256 amount0, uint256 amount1)\\n    {\\n        // (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\\n\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this)); // policy token balance\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this)); // stablecoin balance\\n\\n        console.logUint(balance0);\\n        console.logUint(balance1);\\n\\n        uint256 liquidity = balanceOf(address(this)) - MINIMUM_LIQUIDITY;\\n\\n        console.logUint(liquidity);\\n\\n        uint256 _totalSupply = totalSupply(); // gas savings\\n\\n        console.logUint(_totalSupply);\\n\\n        // How many tokens to be sent back\\n        amount0 = (liquidity * balance0) / _totalSupply;\\n        amount1 = (liquidity * balance1) / _totalSupply;\\n\\n        require(amount0 > 0 && amount1 > 0, \\\"Insufficient liquidity burned\\\");\\n\\n        // Currently all the liquidity in the pool was just sent by the user, so burn all\\n        _burn(address(this), liquidity);\\n\\n        // Transfer tokens out and update the balance\\n        IERC20(token0).safeTransfer(_to, amount0);\\n        IERC20(token1).safeTransfer(_to, amount1);\\n        balance0 = IERC20(token0).balanceOf(address(this));\\n        balance1 = IERC20(token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1);\\n\\n        emit Burn(msg.sender, amount0, amount1, _to);\\n    }\\n\\n    /**\\n     * @notice Finish the swap process\\n     * @param _amount0Out Amount of token0 to be given out (may be 0)\\n     * @param _amount1Out Amount of token1 to be given out (may be 0)\\n     * @param _to Address to receive the swap result\\n     */\\n    function swap(\\n        uint256 _amount0Out,\\n        uint256 _amount1Out,\\n        address _to\\n    ) external beforeDeadline nonReentrant {\\n        require(\\n            _amount0Out > 0 || _amount1Out > 0,\\n            \\\"Output amount need to be >0\\\"\\n        );\\n\\n        (uint256 _reserve0, uint256 _reserve1) = getReserves(); // gas savings\\n        require(\\n            _amount0Out < _reserve0 && _amount1Out < _reserve1,\\n            \\\"Not enough liquidity\\\"\\n        );\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            address _token0 = token0;\\n            address _token1 = token1;\\n            require(_to != _token0 && _to != _token1, \\\"INVALID_TO\\\");\\n\\n            if (_amount0Out > 0) IERC20(_token0).safeTransfer(_to, _amount0Out);\\n            if (_amount1Out > 0) IERC20(_token1).safeTransfer(_to, _amount1Out);\\n\\n            balance0 = IERC20(_token0).balanceOf(address(this));\\n            balance1 = IERC20(_token1).balanceOf(address(this));\\n        }\\n        uint256 amount0In = balance0 > _reserve0 - _amount0Out\\n            ? balance0 - (_reserve0 - _amount0Out)\\n            : 0;\\n        uint256 amount1In = balance1 > _reserve1 - _amount1Out\\n            ? balance1 - (_reserve1 - _amount1Out)\\n            : 0;\\n\\n        require(amount0In > 0 || amount1In > 0, \\\"INSUFFICIENT_INPUT_AMOUNT\\\");\\n\\n        {\\n            uint256 balance0Adjusted = balance0 * 1000 - amount0In * feeRate;\\n            uint256 balance1Adjusted = balance1 * 1000 - amount1In * feeRate;\\n\\n            require(\\n                balance0Adjusted * balance1Adjusted >=\\n                    _reserve0 * _reserve1 * (1000**2),\\n                \\\"The remaining x*y is less than K\\\"\\n            );\\n        }\\n\\n        _update(balance0, balance1);\\n\\n        emit Swap(\\n            msg.sender,\\n            amount0In,\\n            amount1In,\\n            _amount0Out,\\n            _amount1Out,\\n            _to\\n        );\\n    }\\n\\n    /**\\n     * @notice Syncrinize the status of this pool\\n     */\\n    function sync() external nonReentrant {\\n        _update(\\n            IERC20(token0).balanceOf(address(this)),\\n            IERC20(token1).balanceOf(address(this))\\n        );\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ********************************** Internal Functions ********************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Update the reserves of the pool\\n     * @param balance0 Balance of token0\\n     * @param balance1 Balance of token1\\n     */\\n    function _update(uint256 balance0, uint256 balance1) private {\\n        uint112 MAX_NUM = type(uint112).max;\\n        require(balance0 <= MAX_NUM && balance1 <= MAX_NUM, \\\"Uint112 OVERFLOW\\\");\\n\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n\\n        emit ReserveUpdated(reserve0, reserve1);\\n    }\\n\\n    /**\\n     * @notice Get the smaller one of two numbers\\n     * @param x The first number\\n     * @param y The second number\\n     * @return z The smaller one\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n}\\n\"\n    },\n    \"contracts/naughty-price/interfaces/INaughtyPair.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface INaughtyPair is IERC20 {\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function feeRate() external view returns (uint256);\\n\\n    function deadline() external view returns (uint256);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (uint112 _reserve0, uint112 _reserve1);\\n\\n    function swap(\\n        uint256,\\n        uint256,\\n        address\\n    ) external;\\n\\n    function burn(address) external returns (uint256, uint256);\\n\\n    function mint(address) external returns (uint256);\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        uint256 _deadline,\\n        uint256 _feeRate\\n    ) external;\\n}\\n\"\n    },\n    \"contracts/naughty-price/interfaces/IPolicyCore.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface IPolicyCore {\\n    struct PolicyTokenInfo {\\n        address policyTokenAddress;\\n        bool isCall;\\n        uint256 strikePrice;\\n        uint256 deadline;\\n        uint256 settleTimestamp;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Functions ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Find the address by its name\\n     */\\n    function findAddressbyName(string memory _policyTokenName)\\n        external\\n        view\\n        returns (address _policyTokenAddress);\\n\\n    /**\\n     * @notice Find the name by address\\n     */\\n    function findNamebyAddress(address _policyTokenAddress)\\n        external\\n        view\\n        returns (string memory);\\n\\n    /**\\n     * @notice Get the policy token information\\n     */\\n    function getPolicyTokenInfo(string memory _policyTokenName)\\n        external\\n        view\\n        returns (PolicyTokenInfo memory);\\n\\n    function getAllTokens() external view returns (PolicyTokenInfo[] memory);\\n\\n    function getUserQuota(address _user, address _policyTokenAddress)\\n        external\\n        view\\n        returns (uint256 _quota);\\n\\n    function supportedStablecoin(address _coinAddress)\\n        external\\n        view\\n        returns (bool);\\n\\n    function addStablecoin(address _newStablecoin) external;\\n\\n    function setLottery(address _lotteryAddress) external;\\n\\n    function setEmergencyPool(address _emergencyPool) external;\\n\\n    function deployPolicyToken(\\n        string memory _policyTokenName,\\n        bool _isHigher,\\n        uint256 _strikePrice,\\n        uint256 _deadline,\\n        uint256 _round,\\n        uint256 _settleTimestamp\\n    ) external returns (address);\\n\\n    function deployPool(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _poolDeadline\\n    ) external returns (address);\\n\\n    function deposit(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _amount\\n    ) external;\\n\\n    function delegateDeposit(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _amount,\\n        address _user\\n    ) external;\\n\\n    function redeem(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _amount\\n    ) external;\\n\\n    function claim(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _amount\\n    ) external;\\n}\\n\"\n    },\n    \"contracts/libraries/StringsUtils.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUtils {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @notice Bytes to string (not human-readable form)\\n     * @param _bytes Input bytes\\n     * @return stringBytes String form of the bytes\\n     */\\n    function byToString(bytes32 _bytes) internal pure returns (string memory) {\\n        return uintToHexString(uint256(_bytes), 32);\\n    }\\n\\n    /**\\n     * @notice Transfer address to string (not change the content)\\n     * @param _addr Input address\\n     * @return stringAddress String form of the address\\n     */\\n    function addressToString(address _addr)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return uintToHexString(uint256(uint160(_addr)), 20);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function uintToString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function uintToHexString(uint256 value)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return uintToHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function uintToHexString(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/Math.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\n    },\n    \"contracts/utils/ReentrancyGuard.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\n    },\n    \"contracts/naughty-price/interfaces/INaughtyFactory.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface INaughtyFactory {\\n    function getPairAddress(address _tokenAddress1, address _tokenAddress2)\\n        external\\n        view\\n        returns (address);\\n\\n    function deployPolicyToken(\\n        string memory _policyTokenName,\\n        uint256 _decimals\\n    ) external returns (address);\\n\\n    function deployPool(\\n        address _policyTokenAddress,\\n        address _stablecoin,\\n        uint256 _deadline,\\n        uint256 _feeRate\\n    ) external returns (address);\\n}\\n\"\n    },\n    \"hardhat/console.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\n    },\n    \"contracts/naughty-price/PolicyCore.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n/*\\n //======================================================================\\\\\\\\\\n //======================================================================\\\\\\\\\\n    *******         **********     ***********     *****     ***********\\n    *      *        *              *                 *       *\\n    *        *      *              *                 *       *\\n    *         *     *              *                 *       *\\n    *         *     *              *                 *       *\\n    *         *     **********     *       *****     *       ***********\\n    *         *     *              *         *       *                 *\\n    *         *     *              *         *       *                 *\\n    *        *      *              *         *       *                 *\\n    *      *        *              *         *       *                 *\\n    *******         **********     ***********     *****     ***********\\n \\\\\\\\======================================================================//\\n \\\\\\\\======================================================================//\\n*/\\n\\npragma solidity ^0.8.10;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../libraries/StringsUtils.sol\\\";\\nimport \\\"../libraries/SafePRBMath.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"../utils/interfaces/IERC20Decimals.sol\\\";\\nimport \\\"./interfaces/IPriceGetter.sol\\\";\\nimport \\\"./interfaces/INaughtyFactory.sol\\\";\\nimport \\\"./interfaces/INPPolicyToken.sol\\\";\\n\\n/**\\n * @title  PolicyCore\\n * @notice Core logic of Naughty Price Product\\n *         Preset:\\n *              (Done in the naughtyFactory contract)\\n *              1. Deploy policyToken contract\\n *              2. Deploy policyToken-Stablecoin pool contract\\n *         User Interaction:\\n *              1. Deposit Stablecoin and mint PolicyTokens\\n *              2. Redeem their Stablecoin and burn the PolicyTokens (before settlement)\\n *              3. Claim for payout with PolicyTokens (after settlement)\\n *         PolicyTokens are minted with the ratio 1:1 to Stablecoin\\n *         The PolicyTokens are traded in the pool with CFMM (xy=k)\\n *         When the event happens, a PolicyToken can be burned for claiming 1 Stablecoin.\\n *         When the event does not happen, the PolicyToken depositors can\\n *         redeem their 1 deposited Stablecoin\\n * @dev    Most of the functions to be called from outside will use the name of policyToken\\n *         rather than the address (easy to read).\\n *         Other variables or functions still use address to index.\\n *         The rule of policyToken naming is:\\n *              Original Token Name(with decimals) + Strike Price + Lower or Higher + Date\\n *         E.g.  AVAX_30.0_L_2101, BTC_30000.0_L_2102, ETH_8000.0_H_2109\\n *         (the original name need to be the same as in the chainlink oracle)\\n *         There are three decimals for a policy token:\\n *              1. Name decimals: Only for generating the name of policyToken\\n *              2. Token decimals: The decimals of the policyToken\\n *                 (should be the same as the paired stablecoin)\\n *              3. Price decimals: Always 18. The oracle result will be transferred for settlement\\n */\\n\\ncontract PolicyCore is Ownable {\\n    using StringsUtils for uint256;\\n    using SafePRBMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // Factory contract, responsible for deploying new contracts\\n    INaughtyFactory public factory;\\n\\n    // Oracle contract, responsible for getting the final price\\n    IPriceGetter public priceGetter;\\n\\n    // Lottery address\\n    address public lottery;\\n\\n    // Emergency pool contract address\\n    address public emergencyPool;\\n\\n    // Naughty Router contract address\\n    address public naughtyRouter;\\n\\n    struct PolicyTokenInfo {\\n        address policyTokenAddress;\\n        bool isCall;\\n        uint256 nameDecimals; // decimals of the name generation\\n        uint256 tokenDecimals; // decimals of the policy token\\n        uint256 strikePrice;\\n        uint256 deadline;\\n        uint256 settleTimestamp;\\n    }\\n    // Policy toke name => Policy token information\\n    mapping(string => PolicyTokenInfo) public policyTokenInfoMapping;\\n\\n    mapping(address => string) public policyTokenAddressToName;\\n\\n    // Policy token name list\\n    string[] public allPolicyTokens;\\n\\n    // Stablecoin address => Supported or not\\n    mapping(address => bool) public supportedStablecoin;\\n\\n    // Policy token address => Stablecoin address\\n    mapping(address => address) public whichStablecoin;\\n\\n    // PolicyToken => Strike Token (e.g. AVAX30L202101 address => AVAX address)\\n    mapping(address => string) policyTokenToOriginal;\\n\\n    // User Address => Token Address => User Quota Amount\\n    mapping(address => mapping(address => uint256)) userQuota;\\n\\n    // Policy token address => All the depositors for this round\\n    // (store all the depositors in an array)\\n    mapping(address => address[]) public allDepositors;\\n\\n    struct SettlementInfo {\\n        uint256 price;\\n        bool isHappened;\\n        bool alreadySettled;\\n        uint256 currentDistributionIndex;\\n    }\\n    // Policy token address => Settlement result information\\n    mapping(address => SettlementInfo) public settleResult;\\n\\n    mapping(address => uint256) public pendingIncomeToLottery;\\n    mapping(address => uint256) public pendingIncomeToEmergency;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Events ******************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event LotteryChanged(address newLotteryAddress);\\n    event EmergencyPoolChanged(address newEmergencyPool);\\n    event NaughtyRouterChanged(address newRouter);\\n    event PolicyTokenDeployed(\\n        string tokenName,\\n        address tokenAddress,\\n        uint256 tokenDecimals,\\n        uint256 deadline,\\n        uint256 settleTimestamp\\n    );\\n    event PoolDeployed(\\n        address poolAddress,\\n        address policyTokenAddress,\\n        address stablecoin\\n    );\\n    event Deposit(\\n        address userAddress,\\n        string policyTokenName,\\n        address stablecoin,\\n        uint256 amount\\n    );\\n    event DelegateDeposit(\\n        address payerAddress,\\n        address userAddress,\\n        string policyTokenName,\\n        address stablecoin,\\n        uint256 amount\\n    );\\n    event Redeem(\\n        address userAddress,\\n        string policyTokenName,\\n        address stablecoin,\\n        uint256 amount\\n    );\\n    event RedeemAfterSettlement(\\n        address userAddress,\\n        string policyTokenName,\\n        address stablecoin,\\n        uint256 amount\\n    );\\n    event FinalResultSettled(\\n        string _policyTokenName,\\n        uint256 price,\\n        bool isHappened\\n    );\\n    event NewStablecoinAdded(address _newStablecoin);\\n    event PolicyTokensSettledForUsers(\\n        string policyTokenName,\\n        address stablecoin,\\n        uint256 startIndex,\\n        uint256 stopIndex\\n    );\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Constructor, for some addresses\\n     * @param _usdt USDT.e is the first stablecoin supported in the pool\\n     * @param _factory Address of naughty factory\\n     * @param _priceGetter Address of the oracle contract\\n     */\\n    constructor(\\n        address _usdt,\\n        address _factory,\\n        address _priceGetter\\n    ) Ownable(msg.sender) {\\n        // Add the first stablecoin supported\\n        supportedStablecoin[_usdt] = true;\\n\\n        // Initialize the interfaces\\n        factory = INaughtyFactory(_factory);\\n        priceGetter = IPriceGetter(_priceGetter);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Check if this stablecoin is supported\\n     * @param _stablecoin Stablecoin address\\n     */\\n    modifier validStablecoin(address _stablecoin) {\\n        require(\\n            supportedStablecoin[_stablecoin] == true,\\n            \\\"Do not support this stablecoin currently\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Check whether the policy token is paired with this stablecoin\\n     * @param _policyTokenName Policy token name\\n     * @param _stablecoin Stablecoin address\\n     */\\n    modifier validPolicyTokenWithStablecoin(\\n        string memory _policyTokenName,\\n        address _stablecoin\\n    ) {\\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\\n        require(\\n            whichStablecoin[policyTokenAddress] == _stablecoin,\\n            \\\"Invalid policytoken with stablecoin\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Check if the policy token has been deployed, used when deploying pools\\n     * @param _policyTokenName Name of the policy token inside the pair\\n     */\\n    modifier deployedPolicy(string memory _policyTokenName) {\\n        require(\\n            policyTokenInfoMapping[_policyTokenName].policyTokenAddress !=\\n                address(0),\\n            \\\"This policy token has not been deployed, please deploy it first\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Deposit/Redeem/Swap only before deadline\\n     * @dev Each pool will also have this deadline\\n     *      That needs to be set inside naughtyFactory\\n     * @param _policyTokenName Name of the policy token\\n     */\\n    modifier beforeDeadline(string memory _policyTokenName) {\\n        uint256 deadline = policyTokenInfoMapping[_policyTokenName].deadline;\\n        require(\\n            block.timestamp <= deadline,\\n            \\\"Can not deposit/redeem, has passed the deadline\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Can only settle the result after the \\\"_settleTimestamp\\\"\\n     * @param _policyTokenName Name of the policy token\\n     */\\n    modifier afterSettlement(string memory _policyTokenName) {\\n        uint256 settleTimestamp = policyTokenInfoMapping[_policyTokenName]\\n            .settleTimestamp;\\n        require(\\n            block.timestamp >= settleTimestamp,\\n            \\\"Can not settle/claim, have not reached settleTimestamp\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Avoid multiple settlements\\n     * @param _policyTokenName Name of the policy token\\n     */\\n    modifier notAlreadySettled(string memory _policyTokenName) {\\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\\n        require(\\n            settleResult[policyTokenAddress].alreadySettled == false,\\n            \\\"This policy has already been settled\\\"\\n        );\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Find the token address by its name\\n     * @param _policyTokenName Name of the policy token (e.g. \\\"AVAX_30_L_2103\\\")\\n     * @return policyTokenAddress Address of the policy token\\n     */\\n    function findAddressbyName(string memory _policyTokenName)\\n        public\\n        view\\n        returns (address policyTokenAddress)\\n    {\\n        policyTokenAddress = policyTokenInfoMapping[_policyTokenName]\\n            .policyTokenAddress;\\n\\n        require(policyTokenAddress != address(0), \\\"Policy token not found\\\");\\n    }\\n\\n    /**\\n     * @notice Find the token name by its address\\n     * @param _policyTokenAddress Address of the policy token\\n     * @return policyTokenName Name of the policy token\\n     */\\n    function findNamebyAddress(address _policyTokenAddress)\\n        public\\n        view\\n        returns (string memory policyTokenName)\\n    {\\n        policyTokenName = policyTokenAddressToName[_policyTokenAddress];\\n\\n        require(bytes(policyTokenName).length > 0, \\\"Policy name not found\\\");\\n    }\\n\\n    /**\\n     * @notice Find the token information by its name\\n     * @param _policyTokenName Name of the policy token (e.g. \\\"AVAX30L202103\\\")\\n     * @return policyTokenInfo PolicyToken detail information\\n     */\\n    function getPolicyTokenInfo(string memory _policyTokenName)\\n        public\\n        view\\n        returns (PolicyTokenInfo memory)\\n    {\\n        return policyTokenInfoMapping[_policyTokenName];\\n    }\\n\\n    /**\\n     * @notice Get a user's quota for a certain policy token\\n     * @param _user Address of the user to be checked\\n     * @param _policyTokenAddress Address of the policy token\\n     * @return _quota User's quota result\\n     */\\n    function getUserQuota(address _user, address _policyTokenAddress)\\n        external\\n        view\\n        returns (uint256 _quota)\\n    {\\n        _quota = userQuota[_user][_policyTokenAddress];\\n    }\\n\\n    /**\\n     * @notice Get the information about all the tokens\\n     * @return tokensInfo Token information list\\n     */\\n    function getAllTokens() external view returns (PolicyTokenInfo[] memory) {\\n        uint256 length = allPolicyTokens.length;\\n        PolicyTokenInfo[] memory tokensInfo = new PolicyTokenInfo[](length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            tokensInfo[i] = policyTokenInfoMapping[allPolicyTokens[i]];\\n        }\\n\\n        return tokensInfo;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Add a newly supported stablecoin\\n     * @param _newStablecoin Address of the new stablecoin\\n     */\\n    function addStablecoin(address _newStablecoin) external onlyOwner {\\n        supportedStablecoin[_newStablecoin] = true;\\n        emit NewStablecoinAdded(_newStablecoin);\\n    }\\n\\n    /**\\n     * @notice Change the address of lottery\\n     * @param _lotteryAddress Address of the new lottery\\n     */\\n    function setLottery(address _lotteryAddress) external onlyOwner {\\n        lottery = _lotteryAddress;\\n        emit LotteryChanged(_lotteryAddress);\\n    }\\n\\n    /**\\n     * @notice Change the address of emergency pool\\n     * @param _emergencyPool Address of the new emergencyPool\\n     */\\n    function setEmergencyPool(address _emergencyPool) external onlyOwner {\\n        emergencyPool = _emergencyPool;\\n        emit EmergencyPoolChanged(_emergencyPool);\\n    }\\n\\n    /**\\n     * @notice Change the address of naughty router\\n     * @param _router Address of the new naughty router\\n     */\\n    function setNaughtyRouter(address _router) external onlyOwner {\\n        naughtyRouter = _router;\\n        emit NaughtyRouterChanged(_router);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Deploy a new policy token and return the token address\\n     * @dev Only the owner can deploy new policy token\\n     *      The name form is like \\\"AVAX_50_L_202101\\\" and is built inside the contract.\\n     * @param _tokenName Name of the original token (e.g. AVAX, BTC, ETH...)\\n     * @param _stablecoin Address of the stablecoin (Just for check decimals here)\\n     * @param _isCall The policy is for higher or lower than the strike price (call / put)\\n     * @param _nameDecimals Decimals of this token's name (0~18)\\n     * @param _tokenDecimals Decimals of this token's value (0~18) (same as paired stablecoin)\\n     * @param _strikePrice Strike price of the policy (have already been transferred with 1e18)\\n     * @param _deadline Deadline of this policy token (deposit / redeem / swap)\\n     * @param _settleTimestamp Can settle after this timestamp (for oracle)\\n     */\\n    function deployPolicyToken(\\n        string memory _tokenName,\\n        address _stablecoin,\\n        bool _isCall,\\n        uint256 _nameDecimals,\\n        uint256 _tokenDecimals,\\n        uint256 _strikePrice,\\n        uint256 _round,\\n        uint256 _deadline,\\n        uint256 _settleTimestamp\\n    ) external onlyOwner {\\n        require(\\n            _nameDecimals <= 18 && _tokenDecimals <= 18,\\n            \\\"Too many decimals\\\"\\n        );\\n        require(\\n            IERC20Decimals(_stablecoin).decimals() == _tokenDecimals,\\n            \\\"Decimals not paired\\\"\\n        );\\n\\n        require(_deadline > block.timestamp, \\\"Wrong deadline\\\");\\n        require(_settleTimestamp >= _deadline, \\\"Wrong settleTimestamp\\\");\\n\\n        string memory policyTokenName = _generateName(\\n            _tokenName,\\n            _nameDecimals,\\n            _strikePrice,\\n            _isCall,\\n            _round\\n        );\\n        // Deploy a new policy token by the factory contract\\n        address policyTokenAddress = factory.deployPolicyToken(\\n            policyTokenName,\\n            _tokenDecimals\\n        );\\n\\n        // Store the policyToken information in the mapping\\n        policyTokenInfoMapping[policyTokenName] = PolicyTokenInfo(\\n            policyTokenAddress,\\n            _isCall,\\n            _nameDecimals,\\n            _tokenDecimals,\\n            _strikePrice,\\n            _deadline,\\n            _settleTimestamp\\n        );\\n\\n        // Keep the record from policy token to original token\\n        policyTokenToOriginal[policyTokenAddress] = _tokenName;\\n\\n        // Record the address to name mapping\\n        policyTokenAddressToName[policyTokenAddress] = policyTokenName;\\n\\n        // Push the policytokenName into the list\\n        allPolicyTokens.push(policyTokenName);\\n\\n        emit PolicyTokenDeployed(\\n            policyTokenName,\\n            policyTokenAddress,\\n            _tokenDecimals,\\n            _deadline,\\n            _settleTimestamp\\n        );\\n    }\\n\\n    /**\\n     * @notice Deploy a new pair (pool)\\n     * @param _policyTokenName Name of the policy token\\n     * @param _stablecoin Address of the stable coin\\n     * @param _poolDeadline Swapping deadline of the pool (normally the same as the token's deadline)\\n     * @param _feeRate Fee rate given to LP holders\\n     * @return poolAddress The address of the pool just deployed\\n     */\\n    function deployPool(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _poolDeadline,\\n        uint256 _feeRate\\n    )\\n        external\\n        onlyOwner\\n        validStablecoin(_stablecoin)\\n        deployedPolicy(_policyTokenName)\\n        returns (address)\\n    {\\n        require(_poolDeadline > block.timestamp, \\\"Wrong deadline\\\");\\n        require(\\n            _poolDeadline == policyTokenInfoMapping[_policyTokenName].deadline,\\n            \\\"Policy token and pool deadline not the same\\\"\\n        );\\n\\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\\n\\n        // Deploy a new pool (policyToken <=> stablecoin)\\n        address poolAddress = factory.deployPool(\\n            policyTokenAddress,\\n            _stablecoin,\\n            _poolDeadline,\\n            _feeRate\\n        );\\n\\n        // Record the mapping\\n        whichStablecoin[policyTokenAddress] = _stablecoin;\\n\\n        emit PoolDeployed(poolAddress, policyTokenAddress, _stablecoin);\\n\\n        return poolAddress;\\n    }\\n\\n    /**\\n     * @notice Deposit stablecoins and get policy tokens\\n     * @param _policyTokenName Name of the policy token\\n     * @param _stablecoin Address of the stable coin\\n     * @param _amount Amount of stablecoin\\n     */\\n    function deposit(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _amount\\n    )\\n        public\\n        beforeDeadline(_policyTokenName)\\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\\n    {\\n        _deposit(_policyTokenName, _stablecoin, _amount, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Delegate deposit (deposit and mint for other addresses)\\n     * @dev Only called by the router contract\\n     * @param _policyTokenName Name of the policy token\\n     * @param _stablecoin Address of the sable coin\\n     * @param _amount Amount of stablecoin\\n     * @param _user Address to receive the policy tokens\\n     */\\n    function delegateDeposit(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _amount,\\n        address _user\\n    )\\n        external\\n        beforeDeadline(_policyTokenName)\\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\\n    {\\n        require(\\n            msg.sender == naughtyRouter,\\n            \\\"Only the router contract can delegate\\\"\\n        );\\n\\n        _deposit(_policyTokenName, _stablecoin, _amount, _user);\\n\\n        emit DelegateDeposit(\\n            msg.sender,\\n            _user,\\n            _policyTokenName,\\n            _stablecoin,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @notice Burn policy tokens and redeem USDT\\n     * @dev Redeem happens before the deadline and is different from claim/settle\\n     * @param _policyTokenName Name of the policy token\\n     * @param _stablecoin Address of the stablecoin\\n     * @param _amount Amount to redeem\\n     */\\n    function redeem(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _amount\\n    )\\n        public\\n        beforeDeadline(_policyTokenName)\\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\\n    {\\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\\n\\n        // Check if the user has enough quota (quota is only for those who mint policy tokens)\\n        require(\\n            userQuota[msg.sender][policyTokenAddress] >= _amount,\\n            \\\"User's quota not sufficient\\\"\\n        );\\n\\n        userQuota[msg.sender][policyTokenAddress] -= _amount;\\n\\n        if (userQuota[msg.sender][policyTokenAddress] == 0)\\n            delete userQuota[msg.sender][policyTokenAddress];\\n\\n        IERC20(_stablecoin).safeTransfer(msg.sender, _amount);\\n\\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\\n        policyToken.burn(msg.sender, _amount);\\n\\n        emit Redeem(msg.sender, _policyTokenName, _stablecoin, _amount);\\n    }\\n\\n    /**\\n     * @notice Redeem policy tokens and get stablecoins by the user himeself\\n     * @param _policyTokenName Name of the policy token\\n     * @param _stablecoin Address of the stablecoin\\n     */\\n    function redeemAfterSettlement(\\n        string memory _policyTokenName,\\n        address _stablecoin\\n    )\\n        public\\n        afterSettlement(_policyTokenName)\\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\\n    {\\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\\n\\n        // Copy to memory (will not change the result)\\n        SettlementInfo memory result = settleResult[policyTokenAddress];\\n\\n        // Must have got the final price\\n        require(\\n            result.price != 0 && result.alreadySettled,\\n            \\\"Have not got the oracle result\\\"\\n        );\\n\\n        // The event must be \\\"not happend\\\"\\n        require(\\n            result.isHappened == false,\\n            \\\"Only call this function when the event does not happen\\\"\\n        );\\n\\n        // User must have quota because this is for depositors when event not happens\\n        require(\\n            userQuota[msg.sender][policyTokenAddress] > 0,\\n            \\\"No quota, you did not deposit and mint policy tokens before\\\"\\n        );\\n\\n        // Charge 1% Fee when redeem / claim\\n        uint256 amount = userQuota[msg.sender][policyTokenAddress];\\n        uint256 amountWithFee = (amount * 990) / 1000;\\n        uint256 amountToCollect = amount - amountWithFee;\\n\\n        pendingIncomeToLottery[_stablecoin] += (amountToCollect * 8) / 10;\\n        pendingIncomeToEmergency[_stablecoin] +=\\n            amountToCollect -\\n            (amountToCollect * 8) /\\n            10;\\n\\n        // Send back stablecoins directly\\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\\n\\n        // Delete the userQuota storage\\n        delete userQuota[msg.sender][policyTokenAddress];\\n\\n        emit RedeemAfterSettlement(\\n            msg.sender,\\n            _policyTokenName,\\n            _stablecoin,\\n            amountWithFee\\n        );\\n    }\\n\\n    /**\\n     * @notice Claim a payoff based on policy tokens\\n     * @dev It is done after result settlement and only if the result is true\\n     * @param _policyTokenName Name of the policy token\\n     * @param _stablecoin Address of the stable coin\\n     * @param _amount Amount of USDT (also the amount of policy tokens)\\n     */\\n    function claim(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _amount\\n    )\\n        public\\n        afterSettlement(_policyTokenName)\\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\\n    {\\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\\n\\n        // Copy to memory (will not change the result)\\n        SettlementInfo memory result = settleResult[policyTokenAddress];\\n\\n        // Check if we have already settle the final price\\n        require(\\n            result.price != 0 && result.alreadySettled,\\n            \\\"Have not got the oracle result\\\"\\n        );\\n\\n        // Check if the event happens\\n        require(\\n            result.isHappened,\\n            \\\"The result does not happen, you can not claim\\\"\\n        );\\n\\n        // Charge 1% fee\\n        uint256 amountWithFee = (_amount * 990) / 1000;\\n        uint256 amountToCollect = _amount - amountWithFee;\\n\\n        // Update pending income record\\n        pendingIncomeToLottery[_stablecoin] += (amountToCollect * 8) / 10;\\n        pendingIncomeToEmergency[_stablecoin] +=\\n            amountToCollect -\\n            (amountToCollect * 8) /\\n            10;\\n\\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\\n\\n        // Users must have enough policy tokens to claim\\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\\n\\n        // Burn the policy tokens\\n        policyToken.burn(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @notice Get the final price from the PriceGetter contract\\n     * @param _policyTokenName Name of the policy token\\n     */\\n    function settleFinalResult(string memory _policyTokenName)\\n        public\\n        afterSettlement(_policyTokenName)\\n        notAlreadySettled(_policyTokenName)\\n    {\\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\\n\\n        SettlementInfo storage result = settleResult[policyTokenAddress];\\n\\n        // Get the strike token name\\n        string memory originalTokenName = policyTokenToOriginal[\\n            policyTokenAddress\\n        ];\\n\\n        // Get the final price from oracle\\n        uint256 price = IPriceGetter(priceGetter).getLatestPrice(\\n            originalTokenName\\n        );\\n\\n        result.alreadySettled = true;\\n        result.price = price;\\n\\n        PolicyTokenInfo memory policyTokenInfo = policyTokenInfoMapping[\\n            _policyTokenName\\n        ];\\n\\n        // Get the final result\\n        bool situationT1 = (price >= policyTokenInfo.strikePrice) &&\\n            policyTokenInfo.isCall;\\n        bool situationT2 = (price <= policyTokenInfo.strikePrice) &&\\n            !policyTokenInfo.isCall;\\n\\n        bool isHappened = (situationT1 || situationT2) ? true : false;\\n\\n        result.isHappened = isHappened;\\n\\n        emit FinalResultSettled(_policyTokenName, price, isHappened);\\n    }\\n\\n    /**\\n     * @notice Settle the policies when then insurance event do not happen\\n     *         Funds are automatically distributed back to the depositors\\n     * @dev    Take care of the gas cost and can use the _startIndex and _stopIndex to control the size\\n     * @param _policyTokenName Name of policy token\\n     * @param _stablecoin Address of stablecoin\\n     * @param _startIndex Settlement start index\\n     * @param _stopIndex Settlement stop index\\n     */\\n    function settleAllPolicyTokens(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _startIndex,\\n        uint256 _stopIndex\\n    ) public onlyOwner {\\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\\n\\n        // Copy to memory (will not change the result)\\n        SettlementInfo memory result = settleResult[policyTokenAddress];\\n\\n        // Must have got the final price\\n        require(\\n            result.price != 0 && result.alreadySettled == true,\\n            \\\"Have not got the oracle result\\\"\\n        );\\n\\n        // The event must be \\\"not happend\\\"\\n        require(\\n            result.isHappened == false,\\n            \\\"Only call this function when the event does not happen\\\"\\n        );\\n\\n        // Store the amount to collect to lottery and emergency pool\\n        uint256 amountToCollect = 0;\\n\\n        // Length of all depositors for this policy token\\n        uint256 length = allDepositors[policyTokenAddress].length;\\n\\n        require(\\n            result.currentDistributionIndex <= length,\\n            \\\"Have distributed all\\\"\\n        );\\n\\n        // Settle the policies in [_startIndex, _stopIndex)\\n        if (_startIndex == 0 && _stopIndex == 0) {\\n            amountToCollect += _settlePolicy(\\n                policyTokenAddress,\\n                _stablecoin,\\n                0,\\n                length\\n            );\\n\\n            // Update the distribution index for this policy token\\n            settleResult[policyTokenAddress].currentDistributionIndex = length;\\n\\n            // Update pending income record\\n            pendingIncomeToLottery[_stablecoin] += (amountToCollect * 8) / 10;\\n            pendingIncomeToEmergency[_stablecoin] +=\\n                amountToCollect -\\n                (amountToCollect * 8) /\\n                10;\\n\\n            emit PolicyTokensSettledForUsers(\\n                _policyTokenName,\\n                _stablecoin,\\n                0,\\n                length\\n            );\\n        } else {\\n            require(\\n                result.currentDistributionIndex == _startIndex,\\n                \\\"You need to start from the last distribution point\\\"\\n            );\\n            require(_stopIndex < length, \\\"Invalid stop index\\\");\\n\\n            amountToCollect += _settlePolicy(\\n                policyTokenAddress,\\n                _stablecoin,\\n                _startIndex,\\n                _stopIndex\\n            );\\n\\n            // Update the distribution index for this policy token\\n            settleResult[policyTokenAddress]\\n                .currentDistributionIndex = _stopIndex;\\n\\n            // Update pending income record\\n            pendingIncomeToLottery[_stablecoin] += (amountToCollect * 8) / 10;\\n            pendingIncomeToEmergency[_stablecoin] +=\\n                amountToCollect -\\n                (amountToCollect * 8) /\\n                10;\\n\\n            emit PolicyTokensSettledForUsers(\\n                _policyTokenName,\\n                _stablecoin,\\n                _startIndex,\\n                _stopIndex\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Collect the income\\n     * @dev Can be done by anyone, only when there is some income to be distributed\\n     * @param _stablecoin Address of stablecoin\\n     */\\n    function collectIncome(address _stablecoin) public {\\n        require(\\n            lottery != address(0) && emergencyPool != address(0),\\n            \\\"Please set the lottery address\\\"\\n        );\\n\\n        uint256 amountToLottery = pendingIncomeToLottery[_stablecoin];\\n        uint256 amountToEmergency = pendingIncomeToEmergency[_stablecoin];\\n        require(\\n            amountToLottery > 0 && amountToEmergency > 0,\\n            \\\"No pending income\\\"\\n        );\\n\\n        IERC20(_stablecoin).safeTransfer(lottery, amountToLottery);\\n        IERC20(_stablecoin).safeTransfer(emergencyPool, amountToEmergency);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Internal Functions ********************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Finish Deposit\\n     * @param _policyTokenName Name of the policy token\\n     * @param _stablecoin Address of the sable coin\\n     * @param _amount Amount of stablecoin\\n     * @param _user Address to receive the policy tokens\\n     */\\n    function _deposit(\\n        string memory _policyTokenName,\\n        address _stablecoin,\\n        uint256 _amount,\\n        address _user\\n    ) internal {\\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\\n\\n        // If this is the first deposit, store the user address\\n        if (userQuota[_user][policyTokenAddress] == 0) {\\n            allDepositors[policyTokenAddress].push(_user);\\n        }\\n\\n        // Update the user quota\\n        userQuota[_user][policyTokenAddress] += _amount;\\n\\n        // Transfer stablecoins to this contract\\n        IERC20(_stablecoin).safeTransferFrom(_user, address(this), _amount);\\n\\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\\n        // Mint new policy tokens\\n        // Amount need to be transferred\\n        policyToken.mint(_user, _amount);\\n\\n        emit Deposit(_user, _policyTokenName, _stablecoin, _amount);\\n    }\\n\\n    /**\\n     * @notice Settle the policy when the event does not happen\\n     * @param _policyTokenAddress Address of policy token\\n     * @param _stablecoin Address of stable coin\\n     * @param _start Start index\\n     * @param _stop Stop index\\n     */\\n    function _settlePolicy(\\n        address _policyTokenAddress,\\n        address _stablecoin,\\n        uint256 _start,\\n        uint256 _stop\\n    ) internal returns (uint256 amountRemaining) {\\n        for (uint256 i = _start; i < _stop; i++) {\\n            address user = allDepositors[_policyTokenAddress][i];\\n            uint256 amount = userQuota[user][_policyTokenAddress];\\n            uint256 amountWithFee = (amount * 990) / 1000;\\n\\n            if (amountWithFee > 0) {\\n                IERC20(_stablecoin).safeTransfer(user, amountWithFee);\\n                delete userQuota[user][_policyTokenAddress];\\n\\n                // Accumulate the remaining part that will be collected later\\n                amountRemaining += amount - amountWithFee;\\n            } else continue;\\n        }\\n    }\\n\\n    /**\\n     * @notice Generate the policy token name\\n     * @param _tokenName Name of the stike token (BTC, ETH, AVAX...)\\n     * @param _decimals Decimals of the name generation (0,1=>1)\\n     * @param _strikePrice Strike price of the policy (18 decimals)\\n     * @param _isCall The policy's payoff is triggered when higher(true) or lower(false)\\n     * @param _round Round of the policy (e.g. 2112, 2201)\\n     */\\n    function _generateName(\\n        string memory _tokenName,\\n        uint256 _decimals,\\n        uint256 _strikePrice,\\n        bool _isCall,\\n        uint256 _round\\n    ) public pure returns (string memory) {\\n        // The direction is \\\"H\\\"(Call) or \\\"L\\\"(Put)\\n        string memory direction = _isCall ? \\\"H\\\" : \\\"L\\\";\\n\\n        // Integer part of the strike price (12e18 => 12)\\n        uint256 intPart = _strikePrice / 1e18;\\n        // Decimal part of the strike price (1234e16 => 34)\\n        // Can not start with 0 (e.g. 1204e16 => 0 this is incorrect, will revert in next step)\\n        uint256 decimalPart = _strikePrice.frac() / (10**(18 - _decimals));\\n\\n        require(\\n            intPart > 0 && decimalPart > 0,\\n            \\\"Int part and decimal part should > 0\\\"\\n        );\\n\\n        // Combine the string\\n        string memory name = string(\\n            abi.encodePacked(\\n                _tokenName,\\n                \\\"_\\\",\\n                intPart.uintToString(),\\n                \\\".\\\",\\n                decimalPart.uintToString(),\\n                \\\"_\\\",\\n                direction,\\n                \\\"_\\\",\\n                _round.uintToString()\\n            )\\n        );\\n        return name;\\n    }\\n}\\n\"\n    },\n    \"contracts/utils/interfaces/IERC20Decimals.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC20Decimals {\\n    function decimals() external view returns (uint8);\\n}\\n\"\n    },\n    \"contracts/naughty-price/interfaces/IPriceGetter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface IPriceGetter {\\n    function getPriceFeedAddress(string memory _tokenName)\\n        external\\n        view\\n        returns (address);\\n\\n    function setPriceFeed(string memory _tokenName, address _feedAddress)\\n        external;\\n\\n    function getLatestPrice(string memory _tokenName)\\n        external\\n        returns (uint256 _price);\\n}\\n\"\n    },\n    \"contracts/naughty-price/interfaces/INPPolicyToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface INPPolicyToken is IERC20 {\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\n    },\n    \"contracts/naughty-price/NaughtyRouter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../tokens/interfaces/IBuyerToken.sol\\\";\\n\\nimport \\\"./interfaces/INPPolicyToken.sol\\\";\\nimport \\\"./interfaces/INaughtyPair.sol\\\";\\nimport \\\"./interfaces/INaughtyFactory.sol\\\";\\nimport \\\"./interfaces/IPolicyCore.sol\\\";\\n\\nimport \\\"../utils/Ownable.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title  NaughtyRouter\\n * @notice Router for the pool, you can add/remove liquidity or swap A for B.\\n *         Swapping fee rate is 2% and all of them are given to LP.\\n *         Very similar logic with Uniswap V2.\\n *\\n */\\ncontract NaughtyRouter is Ownable {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for INaughtyPair;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // Some other contracts\\n    address public factory;\\n    address public policyCore;\\n    address public buyerToken;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event LiquidityAdded(\\n        address indexed pairAddress,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 liquidity\\n    );\\n\\n    event LiquidityRemoved(\\n        address indexed pairAddress,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 liquidity\\n    );\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    constructor(address _factory, address _buyerToken) Ownable(msg.sender) {\\n        factory = _factory;\\n        buyerToken = _buyerToken;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Transactions are available only before the deadline\\n     * @param _deadLine Deadline of the pool\\n     */\\n    modifier beforeDeadline(uint256 _deadLine) {\\n        require(block.timestamp < _deadLine, \\\"expired transaction\\\");\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Set the address of policyCore\\n     * @param _coreAddress Address of new policyCore\\n     */\\n    function setPolicyCore(address _coreAddress) external onlyOwner {\\n        policyCore = _coreAddress;\\n    }\\n\\n    /**\\n     * @notice Set the address of buyer token\\n     * @param _buyerToken Address of new buyer token\\n     */\\n    function setBuyerToken(address _buyerToken) external onlyOwner {\\n        buyerToken = _buyerToken;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Helper Functions *********************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Add liquidity but only provide stablecoins\\n     * @dev Only difference with addLiquidity is that mintPolicyTokenForUser\\n     * @param _tokenA Address of policyToken\\n     * @param _tokenB Address of stablecoin\\n     * @param _amountADesired Amount of policyToken desired\\n     * @param _amountBDesired Amount of stablecoin desired\\n     * @param _amountAMin Minimum amount of policy token\\n     * @param _amountBMin Minimum amount of stablecoin\\n     * @param _to Address that receive the lp token, normally the user himself\\n     * @param _deadline Transaction will revert after this deadline\\n     */\\n    function addLiquidityWithUSD(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _amountADesired,\\n        uint256 _amountBDesired,\\n        uint256 _amountAMin,\\n        uint256 _amountBMin,\\n        address _to,\\n        uint256 _deadline\\n    ) external beforeDeadline(_deadline) {\\n        require(_checkStablecoin(_tokenB), \\\"Token B should be stablecoin\\\");\\n\\n        // Mint _amountADesired policy tokens for users\\n        _mintPolicyTokensForUser(\\n            _tokenA,\\n            _tokenB,\\n            _amountADesired,\\n            _msgSender()\\n        );\\n\\n        // Add liquidity\\n        {\\n            addLiquidity(\\n                _tokenA,\\n                _tokenB,\\n                _amountADesired,\\n                _amountBDesired,\\n                _amountAMin,\\n                _amountBMin,\\n                _to,\\n                _deadline\\n            );\\n        }\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Add liquidity function\\n     * @param _tokenA Address of policyToken\\n     * @param _tokenB Address of stablecoin\\n     * @param _amountADesired Amount of policyToken desired\\n     * @param _amountBDesired Amount of stablecoin desired\\n     * @param _amountAMin Minimum amoutn of policy token\\n     * @param _amountBMin Minimum amount of stablecoin\\n     * @param _to Address that receive the lp token, normally the user himself\\n     * @param _deadline Transaction will revert after this deadline\\n     * @return amountA Amount of tokenA to be input\\n     * @return amountB Amount of tokenB to be input\\n     * @return liquidity LP token to be mint\\n     */\\n    function addLiquidity(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _amountADesired,\\n        uint256 _amountBDesired,\\n        uint256 _amountAMin,\\n        uint256 _amountBMin,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        public\\n        beforeDeadline(_deadline)\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        )\\n    {\\n        {\\n            (amountA, amountB) = _addLiquidity(\\n                _tokenA,\\n                _tokenB,\\n                _amountADesired,\\n                _amountBDesired,\\n                _amountAMin,\\n                _amountBMin\\n            );\\n        }\\n\\n        address pair = _getPairAddress(_tokenA, _tokenB);\\n\\n        _transferHelper(_tokenA, _msgSender(), pair, amountA);\\n        _transferHelper(_tokenB, _msgSender(), pair, amountB);\\n\\n        liquidity = INaughtyPair(pair).mint(_to);\\n\\n        emit LiquidityAdded(pair, amountA, amountB, liquidity);\\n    }\\n\\n    /**\\n     * @notice Remove liquidity from the pool\\n     * @param _tokenA Address of policy token\\n     * @param _tokenB Address of stablecoin\\n     * @param _liquidity The lptoken amount to be removed\\n     * @param _amountAMin Minimum amount of tokenA given out\\n     * @param _amountBMin Minimum amount of tokenB given out\\n     * @param _to User address\\n     * @param _deadline Deadline of this transaction\\n     * @return amountA Amount of token0 given out\\n     * @return amountB Amount of token1 given out\\n     */\\n    function removeLiquidity(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _liquidity,\\n        uint256 _amountAMin,\\n        uint256 _amountBMin,\\n        address _to,\\n        uint256 _deadline\\n    )\\n        public\\n        beforeDeadline(_deadline)\\n        returns (uint256 amountA, uint256 amountB)\\n    {\\n        address pair = _getPairAddress(_tokenA, _tokenB);\\n\\n        INaughtyPair(pair).safeTransferFrom(_msgSender(), pair, _liquidity); // send liquidity to pair\\n\\n        // Amount0: insurance token\\n        (amountA, amountB) = INaughtyPair(pair).burn(_to);\\n\\n        require(amountA >= _amountAMin, \\\"Insufficient insurance token amount\\\");\\n        require(amountB >= _amountBMin, \\\"Insufficient USDT token\\\");\\n\\n        console.log(\\\"Amount A\\\", amountA);\\n        console.log(\\\"Amount B\\\", amountB);\\n        console.log(\\\"Liquidity\\\", _liquidity);\\n\\n        emit LiquidityRemoved(pair, amountA, amountB, _liquidity);\\n    }\\n\\n    /**\\n     * @notice Amount out is fixed\\n     * @param _amountInMax Maximum token input\\n     * @param _amountOut Fixed token output\\n     * @param _tokenIn Address of input token\\n     * @param _tokenOut Address of output token\\n     * @param _to User address\\n     * @param _deadline Deadline for this specific swap\\n     * @return amountIn Amounts to be really put in\\n     */\\n    function swapTokensforExactTokens(\\n        uint256 _amountInMax,\\n        uint256 _amountOut,\\n        address _tokenIn,\\n        address _tokenOut,\\n        address _to,\\n        uint256 _deadline\\n    ) external beforeDeadline(_deadline) returns (uint256 amountIn) {\\n        address pair = _getPairAddress(_tokenIn, _tokenOut);\\n        require(\\n            block.timestamp <= INaughtyPair(pair).deadline(),\\n            \\\"This pool has been frozen for swapping\\\"\\n        );\\n\\n        bool isBuying = _checkStablecoin(_tokenIn);\\n\\n        uint256 feeRate = INaughtyPair(pair).feeRate();\\n\\n        // Get how many tokens should be put in (the order depends on isBuying)\\n        amountIn = _getAmountIn(\\n            isBuying,\\n            _amountOut,\\n            _tokenIn,\\n            _tokenOut,\\n            feeRate\\n        );\\n\\n        require(amountIn <= _amountInMax, \\\"excessive input amount\\\");\\n\\n        _transferHelper(_tokenIn, _msgSender(), pair, amountIn);\\n\\n        _swap(pair, amountIn, _amountOut, isBuying, _to);\\n    }\\n\\n    /**\\n     * @notice Amount in is fixed\\n     * @param _amountIn Fixed token input\\n     * @param _amountOutMin Minimum token output\\n     * @param _tokenIn Address of input token\\n     * @param _tokenOut Address of output token\\n     * @param _to User address\\n     * @param _deadline Deadline for this specific swap\\n     * @return amountOut Amounts to be really given out\\n     */\\n    function swapExactTokensforTokens(\\n        uint256 _amountIn,\\n        uint256 _amountOutMin,\\n        address _tokenIn,\\n        address _tokenOut,\\n        address _to,\\n        uint256 _deadline\\n    ) external beforeDeadline(_deadline) returns (uint256 amountOut) {\\n        address pair = _getPairAddress(_tokenIn, _tokenOut);\\n        require(\\n            block.timestamp <= INaughtyPair(pair).deadline(),\\n            \\\"This pool has been frozen for swapping\\\"\\n        );\\n\\n        // Check if the tokenIn is stablecoin\\n        bool isBuying = _checkStablecoin(_tokenIn);\\n\\n        uint256 feeRate = INaughtyPair(pair).feeRate();\\n\\n        // Get how many tokens should be given out (the order depends on isBuying)\\n        amountOut = _getAmountOut(\\n            isBuying,\\n            _amountIn,\\n            _tokenIn,\\n            _tokenOut,\\n            feeRate\\n        );\\n        require(amountOut >= _amountOutMin, \\\"excessive output amount\\\");\\n\\n        _transferHelper(_tokenIn, _msgSender(), pair, _amountIn);\\n\\n        _swap(pair, _amountIn, amountOut, isBuying, _to);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Internal Functions ********************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Internal function to finish adding liquidity\\n     * @param _tokenA Address of tokenA\\n     * @param _tokenB Address of tokenB\\n     * @param _amountADesired Amount of tokenA to be added\\n     * @param _amountBDesired Amount of tokenB to be added\\n     * @param _amountAMin Minimum amount of tokenA\\n     * @param _amountBMin Minimum amount of tokenB\\n     * @return amountA Real amount of tokenA\\n     * @return amountB Real amount of tokenB\\n     */\\n    function _addLiquidity(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _amountADesired,\\n        uint256 _amountBDesired,\\n        uint256 _amountAMin,\\n        uint256 _amountBMin\\n    ) private view returns (uint256 amountA, uint256 amountB) {\\n        require(_checkStablecoin(_tokenB), \\\"Please put stablecoin as tokenB\\\");\\n\\n        (uint256 reserveA, uint256 reserveB) = _getReserves(_tokenA, _tokenB);\\n\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (_amountADesired, _amountBDesired);\\n        } else {\\n            uint256 amountBOptimal = _quote(\\n                _amountADesired,\\n                reserveA,\\n                reserveB\\n            );\\n            if (amountBOptimal <= _amountBDesired) {\\n                require(amountBOptimal >= _amountBMin, \\\"INSUFFICIENT_B_AMOUNT\\\");\\n                (amountA, amountB) = (_amountADesired, amountBOptimal);\\n            } else {\\n                uint256 amountAOptimal = _quote(\\n                    _amountBDesired,\\n                    reserveB,\\n                    reserveA\\n                );\\n                require(amountAOptimal <= _amountADesired, \\\"nonono\\\");\\n                require(amountAOptimal >= _amountAMin, \\\"INSUFFICIENT_A_AMOUNT\\\");\\n                (amountA, amountB) = (amountAOptimal, _amountBDesired);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Finish the erc20 transfer operation\\n     * @param _token ERC20 token address\\n     * @param _from Address to give out the token\\n     * @param _to Pair address to receive the token\\n     * @param _amount Transfer amount\\n     */\\n    function _transferHelper(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        IERC20(_token).safeTransferFrom(_from, _to, _amount);\\n    }\\n\\n    /**\\n     * @notice Finish swap process\\n     * @param _pair Address of the pair\\n     * @param _amountIn Amount of tokens put in\\n     * @param _amountOut Amount of tokens get out\\n     * @param _isBuying Whether this is a purchase or a sell\\n     * @param _to Address of the user\\n     */\\n    function _swap(\\n        address _pair,\\n        uint256 _amountIn,\\n        uint256 _amountOut,\\n        bool _isBuying,\\n        address _to\\n    ) internal {\\n        // Only give buyer tokens when this is a purchase\\n        if (_isBuying) {\\n            IBuyerToken(buyerToken).mintBuyerToken(_msgSender(), _amountIn);\\n        }\\n\\n        // If the user is buying policies => amount1Out = 0\\n        // One of these two variables will be 0\\n        uint256 amountAOut = _isBuying ? _amountOut : 0;\\n        uint256 amountBOut = _isBuying ? 0 : _amountOut;\\n\\n        INaughtyPair(_pair).swap(amountAOut, amountBOut, _to);\\n    }\\n\\n    /**\\n     * @notice Used when users only provide stablecoins and want to mint & add liquidity in one step\\n     * @dev Need have approval before (done by the user himself)\\n     * @param _policyTokenAddress Address of the policy token\\n     * @param _stablecoin Address of the stablecoin\\n     * @param _amount Amount to be used for minting policy tokens\\n     * @param _user The user's address\\n     */\\n    function _mintPolicyTokensForUser(\\n        address _policyTokenAddress,\\n        address _stablecoin,\\n        uint256 _amount,\\n        address _user\\n    ) internal {\\n        // Find the policy token name\\n        string memory policyTokenName = IPolicyCore(policyCore)\\n            .findNamebyAddress(_policyTokenAddress);\\n\\n        IPolicyCore(policyCore).delegateDeposit(\\n            policyTokenName,\\n            _stablecoin,\\n            _amount,\\n            _user\\n        );\\n    }\\n\\n    function _checkStablecoin(address _tokenAddress)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return IPolicyCore(policyCore).supportedStablecoin(_tokenAddress);\\n    }\\n\\n    /**\\n     * @notice Fetche the reserves for a pair\\n     * @dev You need to sort the token order by yourself!\\n     *      No matter your input order, the return value will always start with policy token reserve.\\n     */\\n    function _getReserves(address tokenA, address tokenB)\\n        internal\\n        view\\n        returns (uint112 reserveA, uint112 reserveB)\\n    {\\n        address pairAddress = INaughtyFactory(factory).getPairAddress(\\n            tokenA,\\n            tokenB\\n        );\\n\\n        // (Policy token reserve, stablecoin reserve)\\n        (reserveA, reserveB) = INaughtyPair(pairAddress).getReserves();\\n    }\\n\\n    /**\\n     * @notice Get pair address\\n     * @param tokenA TokenA address\\n     * @param tokenB TokenB address\\n     */\\n    function _getPairAddress(address tokenA, address tokenB)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        address pairAddress = INaughtyFactory(factory).getPairAddress(\\n            tokenA,\\n            tokenB\\n        );\\n\\n        return pairAddress;\\n    }\\n\\n    /**\\n     * @notice Used when swap exact tokens for tokens (in is fixed)\\n     * @param isBuying Whether the user is buying policy tokens\\n     * @param _amountIn Amount of tokens put in\\n     * @param _tokenIn Address of the input token\\n     * @param _tokenOut Address of the output token\\n     */\\n    function _getAmountOut(\\n        bool isBuying,\\n        uint256 _amountIn,\\n        address _tokenIn,\\n        address _tokenOut,\\n        uint256 _feeRate\\n    ) internal view returns (uint256 amountOut) {\\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\\n            _tokenIn,\\n            _tokenOut\\n        );\\n\\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\\n        // Get the right order\\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\\n            ? (reserveB, reserveA)\\n            : (reserveA, reserveB);\\n\\n        require(_amountIn > 0, \\\"insufficient input amount\\\");\\n        require(reserveIn > 0 && reserveOut > 0, \\\"insufficient liquidity\\\");\\n\\n        uint256 amountInWithFee = _amountIn * (1000 - _feeRate);\\n        uint256 numerator = amountInWithFee * (reserveOut);\\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\\n\\n        amountOut = numerator / denominator;\\n    }\\n\\n    /**\\n     * @notice Used when swap tokens for exact tokens (out is fixed)\\n     * @param isBuying Whether the user is buying policy tokens\\n     * @param _amountOut Amount of tokens given out\\n     * @param _tokenIn Address of the input token\\n     * @param _tokenOut Address of the output token\\n     */\\n    function _getAmountIn(\\n        bool isBuying,\\n        uint256 _amountOut,\\n        address _tokenIn,\\n        address _tokenOut,\\n        uint256 _feeRate\\n    ) internal view returns (uint256 amountIn) {\\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\\n            _tokenIn,\\n            _tokenOut\\n        );\\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\\n        // Get the right order\\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\\n            ? (reserveB, reserveA)\\n            : (reserveA, reserveB);\\n\\n        require(_amountOut > 0, \\\"insufficient output amount\\\");\\n        require(reserveIn > 0 && reserveOut > 0, \\\"insufficient liquidity\\\");\\n\\n        uint256 numerator = reserveIn * (_amountOut) * 1000;\\n        uint256 denominator = (reserveOut - _amountOut) * (1000 - _feeRate);\\n\\n        amountIn = numerator / denominator + 1;\\n    }\\n\\n    /**\\n     * @notice Given some amount of an asset and pair reserves\\n     *         returns an equivalent amount of the other asset\\n     * @dev Used when add or remove liquidity\\n     * @param _amountA Amount of tokenA ( can be policytoken or stablecoin)\\n     * @param _reserveA Reserve of tokenA\\n     * @param _reserveB Reserve of tokenB\\n     */\\n    function _quote(\\n        uint256 _amountA,\\n        uint256 _reserveA,\\n        uint256 _reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(_amountA > 0, \\\"insufficient amount\\\");\\n        require(_reserveA > 0 && _reserveB > 0, \\\"insufficient liquidity\\\");\\n\\n        amountB = (_amountA * _reserveB) / _reserveA;\\n    }\\n}\\n\"\n    },\n    \"contracts/tokens/interfaces/IBuyerToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IBuyerToken is IERC20 {\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Functions ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Mint buyer tokens\\n     * @param  _account Receiver's address\\n     * @param  _amount Amount to be minted\\n     */\\n    function mintBuyerToken(address _account, uint256 _amount) external;\\n\\n    /**\\n     * @notice Burn buyer tokens\\n     * @param  _account Receiver's address\\n     * @param  _amount Amount to be burned\\n     */\\n    function burnBuyerToken(address _account, uint256 _amount) external;\\n}\\n\"\n    },\n    \"contracts/miserable-flight/InsurancePool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"../libraries/SafePRBMath.sol\\\";\\nimport \\\"../lucky-box/interfaces/IDegisLottery.sol\\\";\\nimport \\\"../utils/OwnableWithoutContext.sol\\\";\\nimport \\\"./abstracts/InsurancePoolStore.sol\\\";\\n\\n/**\\n * @title  Insurance Pool\\n * @notice Insurance pool is the reserved risk pool for flight delay product.\\n *         For simplicity, some state variables are in the InsurancePoolStore contract.\\n */\\ncontract InsurancePool is\\n    ERC20(\\\"Degis FlightDelay LPToken\\\", \\\"DLP\\\"),\\n    InsurancePoolStore,\\n    OwnableWithoutContext,\\n    ReentrancyGuard\\n{\\n    using SafeERC20 for IERC20;\\n    using SafePRBMath for uint256;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Other Contracts ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    IERC20 public USDToken;\\n    IDegisLottery public degisLottery;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Constructor function\\n     * @param _emergencyPool Emergency pool address\\n     * @param _degisLottery Lottery address\\n     * @param _usdAddress USDToken address\\n     */\\n    constructor(\\n        address _emergencyPool,\\n        address _degisLottery,\\n        address _usdAddress\\n    ) OwnableWithoutContext(msg.sender) {\\n        // Initialize some factors\\n        collateralFactor = 1e18;\\n        lockedRatio = 1e18;\\n        LPValue = 1e18;\\n\\n        emergencyPool = _emergencyPool;\\n\\n        USDToken = IERC20(_usdAddress);\\n\\n        degisLottery = IDegisLottery(_degisLottery);\\n\\n        // Initial distribution, 0: LP 1: Lottery 2: Emergency\\n        rewardDistribution[0] = 50;\\n        rewardDistribution[1] = 40;\\n        rewardDistribution[2] = 10;\\n\\n        frozenTime = 7 days;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Only the policyFlow contract can call some functions\\n     */\\n    modifier onlyPolicyFlow() {\\n        require(\\n            _msgSender() == policyFlow,\\n            \\\"Only the policyFlow contract can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice The address can not be zero\\n     */\\n    modifier notZeroAddress(address _address) {\\n        assert(_address != address(0));\\n        _;\\n    }\\n\\n    /**\\n     * @notice There is a frozen time for unstaking\\n     */\\n    modifier afterFrozenTime(address _user) {\\n        require(\\n            block.timestamp >= userInfo[_user].depositTime + frozenTime,\\n            \\\"Can not withdraw until the fronzen time\\\"\\n        );\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Get the real balance: LPValue * LP_Num\\n     * @dev Used in many places so give it a seperate function\\n     * @param _user User's address\\n     * @return _userBalance Real balance of this user\\n     */\\n    function getUserBalance(address _user)\\n        public\\n        view\\n        returns (uint256 _userBalance)\\n    {\\n        uint256 lp_num = balanceOf(_user);\\n        _userBalance = lp_num.mul(LPValue);\\n    }\\n\\n    /**\\n     * @notice Get the balance that one user(LP) can unlock\\n     * @param _user User's address\\n     * @return _unlockedAmount Unlocked amount of the user\\n     */\\n    function getUnlockedFor(address _user)\\n        public\\n        view\\n        returns (uint256 _unlockedAmount)\\n    {\\n        uint256 userBalance = getUserBalance(_user);\\n        _unlockedAmount = availableCapacity >= userBalance\\n            ? userBalance\\n            : availableCapacity;\\n    }\\n\\n    /**\\n     * @notice Check the conditions when receive new buying request\\n     * @param _payoff Payoff of the policy to be bought\\n     * @return Whether there is enough capacity in the pool for this payoff\\n     */\\n    function checkCapacity(uint256 _payoff) external view returns (bool) {\\n        return availableCapacity >= _payoff;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Owner Functions *********************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Set a new frozen time\\n     * @param _newFrozenTime New frozen time, in timestamp(s)\\n     */\\n    function setFrozenTime(uint256 _newFrozenTime) external onlyOwner {\\n        frozenTime = _newFrozenTime;\\n        emit FrozenTimeChanged(_newFrozenTime);\\n    }\\n\\n    /**\\n     * @notice Set the address of policyFlow\\n     */\\n    function setPolicyFlow(address _policyFlowAddress)\\n        public\\n        onlyOwner\\n        notZeroAddress(_policyFlowAddress)\\n    {\\n        policyFlow = _policyFlowAddress;\\n        emit PolicyFlowChanged(_policyFlowAddress);\\n    }\\n\\n    /**\\n     * @notice Set the premium reward distribution\\n     * @param _newDistribution New distribution [LP, Lottery, Emergency]\\n     */\\n    function setRewardDistribution(uint256[3] memory _newDistribution)\\n        public\\n        onlyOwner\\n    {\\n        uint256 sum = _newDistribution[0] +\\n            _newDistribution[1] +\\n            _newDistribution[2];\\n        require(sum == 100, \\\"Reward distribution must sum to 100\\\");\\n\\n        for (uint256 i = 0; i < 3; i++) {\\n            rewardDistribution[i] = _newDistribution[i];\\n        }\\n        emit RewardDistributionChanged(\\n            _newDistribution[0],\\n            _newDistribution[1],\\n            _newDistribution[2]\\n        );\\n    }\\n\\n    /**\\n     * @notice Change the collateral factor\\n     * @param _factor The new collateral factor\\n     */\\n    function setCollateralFactor(uint256 _factor) public onlyOwner {\\n        require(_factor > 0, \\\"Collateral Factor should be larger than 0\\\");\\n        uint256 oldFactor = collateralFactor;\\n        collateralFactor = _factor.div(100);\\n        emit CollateralFactorChanged(oldFactor, _factor);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice LPs stake assets into the pool\\n     * @param _amount The amount that the user want to stake\\n     */\\n    function stake(uint256 _amount) external nonReentrant {\\n        require(_amount > 0, \\\"Zero Amount\\\");\\n        require(\\n            IERC20(USDToken).balanceOf(_msgSender()) >= _amount,\\n            \\\"Not enough USD\\\"\\n        );\\n\\n        _updateLPValue();\\n\\n        _deposit(_msgSender(), _amount);\\n    }\\n\\n    /**\\n     * @notice Unstake from the pool (May fail if a claim happens before this operation)\\n     * @dev Only unstake by yourself\\n     * @param _amount The amount that the user want to unstake\\n     */\\n    function unstake(uint256 _amount)\\n        external\\n        afterFrozenTime(_msgSender())\\n        nonReentrant\\n    {\\n        require(totalStakingBalance - lockedBalance > 0, \\\"All locked\\\");\\n\\n        address _user = _msgSender();\\n\\n        _updateLPValue();\\n\\n        uint256 userBalance = getUserBalance(_user);\\n        require(\\n            _amount <= userBalance && _amount > 0,\\n            \\\"Not enough balance to be unlocked or your withdraw amount is 0\\\"\\n        );\\n\\n        uint256 unlocked = totalStakingBalance - lockedBalance;\\n        uint256 unstakeAmount = _amount;\\n\\n        // Will jump this part when the pool has enough liquidity\\n        if (_amount > unlocked) unstakeAmount = unlocked; // only withdraw the unlocked value\\n\\n        if (unstakeAmount > 0) _withdraw(_user, unstakeAmount);\\n    }\\n\\n    /**\\n     * @notice Unstake the max amount of a user\\n     */\\n    function unstakeMax() external afterFrozenTime(_msgSender()) nonReentrant {\\n        require(totalStakingBalance - lockedBalance > 0, \\\"All locked\\\");\\n\\n        address _user = _msgSender();\\n\\n        _updateLPValue();\\n\\n        uint256 userBalance = getUserBalance(_user);\\n\\n        uint256 unlocked = totalStakingBalance - lockedBalance;\\n        uint256 unstakeAmount = userBalance;\\n\\n        // Will jump this part when the pool has enough liquidity\\n        if (userBalance > unlocked) unstakeAmount = unlocked; // only withdraw the unlocked value\\n\\n        _withdraw(_user, unstakeAmount);\\n    }\\n\\n    /**\\n     * @notice Update the pool variables when buying policies\\n     * @dev Capacity check is done before calling this function\\n     * @param _premium Policy's premium\\n     * @param _payoff Policy's payoff (max payoff)\\n     * @param _user Address of the buyer\\n     */\\n    function updateWhenBuy(\\n        uint256 _premium,\\n        uint256 _payoff,\\n        address _user\\n    ) external onlyPolicyFlow {\\n        // Update pool status\\n        lockedBalance += _payoff;\\n        activePremiums += _premium;\\n        availableCapacity -= _payoff;\\n\\n        // Update lockedRatio\\n        _updateLockedRatio();\\n\\n        // Remember approval\\n        USDToken.safeTransferFrom(_user, address(this), _premium);\\n\\n        emit NewPolicyBought(_user, _premium, _payoff);\\n    }\\n\\n    /**\\n     * @notice Update the status when a policy expires\\n     * @param _premium Policy's premium\\n     * @param _payoff Policy's payoff (max payoff)\\n     */\\n    function updateWhenExpire(uint256 _premium, uint256 _payoff)\\n        external\\n        onlyPolicyFlow\\n    {\\n        // Distribute the premium\\n        uint256 remainingPremium = _distributePremium(_premium);\\n\\n        // Update pool status\\n        activePremiums -= _premium;\\n        lockedBalance -= _payoff;\\n\\n        availableCapacity += _payoff + remainingPremium;\\n        totalStakingBalance += remainingPremium;\\n\\n        _updateLPValue();\\n    }\\n\\n    /**\\n     * @notice Pay a claim\\n     * @param _premium Premium of the policy\\n     * @param _payoff Max payoff of the policy\\n     * @param _realPayoff Real payoff of the policy\\n     * @param _user Address of the policy claimer\\n     */\\n    function payClaim(\\n        uint256 _premium,\\n        uint256 _payoff,\\n        uint256 _realPayoff,\\n        address _user\\n    ) external onlyPolicyFlow notZeroAddress(_user) {\\n        // Distribute the premium\\n        uint256 remainingPremium = _distributePremium(_premium);\\n\\n        // Update the pool status\\n        lockedBalance -= _payoff;\\n\\n        totalStakingBalance =\\n            totalStakingBalance -\\n            _realPayoff +\\n            remainingPremium;\\n\\n        availableCapacity += (_payoff - _realPayoff + remainingPremium);\\n\\n        activePremiums -= _premium;\\n\\n        // Pay the claim\\n        USDToken.safeTransfer(_user, _realPayoff);\\n\\n        _updateLPValue();\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ********************************** Internal Functions ********************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Finish the deposit process\\n     * @dev LPValue will not change during deposit\\n     * @param _user Address of the user who deposits\\n     * @param _amount Amount he deposits\\n     */\\n    function _deposit(address _user, uint256 _amount) internal {\\n        uint256 amountWithFactor = _amount.mul(collateralFactor);\\n\\n        // Update the pool's status\\n        totalStakingBalance += _amount;\\n        availableCapacity += amountWithFactor;\\n\\n        _updateLockedRatio();\\n\\n        // msg.sender always pays\\n        USDToken.safeTransferFrom(_user, address(this), _amount);\\n\\n        // LP Token number need to be newly minted\\n        uint256 lp_num = _amount.div(LPValue);\\n        _mint(_user, lp_num);\\n\\n        userInfo[_user].depositTime = block.timestamp;\\n\\n        emit Stake(_user, _amount);\\n    }\\n\\n    /**\\n     * @notice _withdraw: finish the withdraw action, only when meeting the conditions\\n     * @dev LPValue will not change during withdraw\\n     * @param _user address of the user who withdraws\\n     * @param _amount the amount he withdraws\\n     */\\n    function _withdraw(address _user, uint256 _amount) internal {\\n        uint256 amountWithFactor = _amount.mul(collateralFactor);\\n        // Update the pool's status\\n        totalStakingBalance -= _amount;\\n        availableCapacity -= amountWithFactor;\\n\\n        _updateLockedRatio();\\n\\n        USDToken.safeTransfer(_user, _amount);\\n\\n        uint256 lp_num = _amount.div(LPValue);\\n        _burn(_user, lp_num);\\n\\n        emit Unstake(_user, _amount);\\n    }\\n\\n    /**\\n     * @notice Distribute the premium to lottery and emergency pool\\n     * @param _premium Premium amount to be distributed\\n     */\\n    function _distributePremium(uint256 _premium) internal returns (uint256) {\\n        uint256 premiumToLottery = _premium.mul(rewardDistribution[1].div(100));\\n\\n        uint256 premiumToEmergency = _premium.mul(\\n            rewardDistribution[2].div(100)\\n        );\\n\\n        // Transfer some reward to emergency pool\\n        USDToken.safeTransfer(emergencyPool, premiumToEmergency);\\n\\n        // Transfer some reward to lottery\\n        // Check the allowance first\\n        if (\\n            USDToken.allowance(address(this), address(degisLottery)) <\\n            10000000 ether\\n        ) {\\n            USDToken.approve(address(degisLottery), type(uint256).max);\\n        }\\n\\n        degisLottery.injectFunds(premiumToLottery);\\n\\n        emit PremiumDistributed(premiumToEmergency, premiumToLottery);\\n\\n        return _premium - premiumToEmergency - premiumToLottery;\\n    }\\n\\n    /**\\n     * @notice Update the value of each lp token\\n     * @dev Normally it will update when claim or expire\\n     */\\n    function _updateLPValue() internal {\\n        uint256 totalLP = totalSupply();\\n\\n        if (totalLP == 0) return;\\n        else {\\n            uint256 totalBalance = IERC20(USDToken).balanceOf(address(this));\\n\\n            LPValue = (totalBalance - activePremiums).div(totalLP);\\n        }\\n    }\\n\\n    /**\\n     * @notice Update the pool's locked ratio\\n     */\\n    function _updateLockedRatio() internal {\\n        if (lockedBalance == 0) lockedRatio = 0;\\n        else lockedRatio = lockedBalance.div(totalStakingBalance);\\n    }\\n}\\n\"\n    },\n    \"contracts/lucky-box/interfaces/IDegisLottery.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface IDegisLottery {\\n    /**\\n     * @notice Inject funds\\n     * @param _amount amount to inject in USD\\n     * @dev Callable by operator\\n     */\\n    function injectFunds(uint256 _amount) external;\\n\\n    /**\\n     * @notice View current lottery id\\n     */\\n    function currentLotteryId() external view returns (uint256);\\n}\\n\"\n    },\n    \"contracts/miserable-flight/abstracts/InsurancePoolStore.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nabstract contract InsurancePoolStore {\\n    address public policyFlow;\\n    address public emergencyPool;\\n\\n    uint256 public frozenTime; // default as 7 days\\n\\n    struct UserInfo {\\n        uint256 depositTime;\\n        uint256 pendingBalance; // the amount in the unstake queue\\n    }\\n    mapping(address => UserInfo) public userInfo;\\n\\n    // 1 LP = LPValue(USD)\\n    uint256 public LPValue;\\n\\n    // Total staking balance of the pool\\n    uint256 public totalStakingBalance;\\n\\n    // Locked balance is for potiential payoff\\n    uint256 public lockedBalance;\\n\\n    // locked relation = locked balance / totalStakingBalance\\n    uint256 public lockedRatio; //  1e18 = 1  1e17 = 0.1  1e19 = 10\\n    uint256 public collateralFactor; //  1e18 = 1  1e17 = 0.1  1e19 = 10\\n\\n    // Available capacity for taking new\\n    uint256 public availableCapacity;\\n\\n    // Premiums have been paid but the policies haven't expired\\n    uint256 public activePremiums;\\n\\n    // [0]: LP, [1]: Lottery, [2]: Emergency\\n    uint256[3] public rewardDistribution;\\n\\n    // events\\n    event Stake(address indexed userAddress, uint256 amount);\\n    event Unstake(address indexed userAddress, uint256 amount);\\n\\n    event CollateralFactorChanged(uint256 oldFactor, uint256 newFactor);\\n\\n    event PolicyFlowChanged(address policyFlowAddress);\\n\\n    event NewPolicyBought(\\n        address indexed userAddress,\\n        uint256 premium,\\n        uint256 payout\\n    );\\n    event RewardDistributionChanged(\\n        uint256 toLP,\\n        uint256 toLottery,\\n        uint256 toEmergency\\n    );\\n\\n    event FrozenTimeChanged(uint256 _newFrozenTime);\\n\\n    event PremiumDistributed(\\n        uint256 _premiumToEmergency,\\n        uint256 _premiumToLottery\\n    );\\n}\\n\"\n    },\n    \"contracts/lucky-box/RandomNumberGenerator.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../libraries/StringsUtils.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\\\";\\n\\nimport \\\"./interfaces/IDegisLottery.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract RandomNumberGenerator is VRFConsumerBase, Ownable {\\n    using StringsUtils for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    IDegisLottery public DegisLottery;\\n\\n    bytes32 public keyHash;\\n    bytes32 public latestRequestId;\\n    uint256 public randomResult;\\n    uint256 public fee;\\n\\n    uint256 public latestLotteryId;\\n\\n    /**\\n     * @notice Constructor\\n     * @dev RandomNumberGenerator must be deployed before the lottery.\\n     * Once the lottery contract is deployed, setLotteryAddress must be called.\\n     * https://docs.chain.link/docs/vrf-contracts/\\n     * @param _vrfCoordinator address of the VRF coordinator\\n     * @param _linkToken address of the LINK token\\n     */\\n    constructor(\\n        address _vrfCoordinator,\\n        address _linkToken,\\n        bytes32 _keyHash\\n    ) Ownable(msg.sender) VRFConsumerBase(_vrfCoordinator, _linkToken) {\\n        keyHash = _keyHash;\\n        fee = 0.1 * 10e18;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Change the fee\\n     * @param _fee new fee (in LINK)\\n     */\\n    function setFee(uint256 _fee) external onlyOwner {\\n        fee = _fee;\\n    }\\n\\n    /**\\n     * @notice Change the keyHash\\n     * @param _keyHash new keyHash\\n     */\\n    function setKeyHash(bytes32 _keyHash) external onlyOwner {\\n        keyHash = _keyHash;\\n    }\\n\\n    /**\\n     * @notice Set the address for the DegisLottery\\n     * @param _degisLottery address of the PancakeSwap lottery\\n     */\\n    function setLotteryAddress(address _degisLottery) external onlyOwner {\\n        DegisLottery = IDegisLottery(_degisLottery);\\n    }\\n\\n    /**\\n     * @notice It allows the admin to withdraw tokens sent to the contract\\n     * @param _tokenAddress the address of the token to withdraw\\n     * @param _tokenAmount the number of token amount to withdraw\\n     * @dev Only callable by owner.\\n     */\\n    function withdrawTokens(address _tokenAddress, uint256 _tokenAmount)\\n        external\\n        onlyOwner\\n    {\\n        IERC20(_tokenAddress).safeTransfer(_msgSender(), _tokenAmount);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Request randomness from Chainlink VRF\\n     */\\n    function getRandomNumber() external {\\n        require(_msgSender() == address(DegisLottery), \\\"Only DegisLottery\\\");\\n\\n        require(keyHash != bytes32(0), \\\"Must have valid key hash\\\");\\n        // require(LINK.balanceOf(address(this)) >= fee, \\\"Not enough LINK tokens\\\");\\n\\n        //*********************************//\\n        // TODO: This part is only for test on Fuji Testnet because there is no VRF currently\\n        string memory randInput = string(\\n            abi.encodePacked(\\n                block.timestamp.uintToString(),\\n                blockhash(block.number - (block.timestamp % 64)),\\n                address(this)\\n            )\\n        );\\n        randomResult = _rand(randInput) % 10000;\\n\\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\\n        //*********************************//\\n\\n        // latestRequestId = requestRandomness(keyHash, fee);\\n    }\\n\\n    /**\\n     * @notice Get the random number\\n     * @return randomNumber the random result\\n     */\\n    function _rand(string memory input) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(input)));\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Internal Functions ********************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Callback function used by ChainLink's VRF Coordinator\\n     */\\n    // TODO: On Fuji testnet, we use fake random numbers\\n    function fulfillRandomness(bytes32 requestId, uint256 randomness)\\n        internal\\n        override\\n    {\\n        require(latestRequestId == requestId, \\\"Wrong requestId\\\");\\n        randomResult = randomness % 10000;\\n\\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\\n    }\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\n\\nimport \\\"./VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\\n\\n  /**\\n   * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\\n\\n  /**\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n    // the hash of the block containing this request to obtain the seed/input\\n    // which is finally passed to the VRF cryptographic machinery.\\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n    // nonces[_keyHash] must stay in sync with\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n    // This provides protection against the user repeating their input seed,\\n    // which would result in a predictable/duplicate output, if multiple such\\n    // requests appeared in the same block.\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface internal immutable LINK;\\n  address private immutable vrfCoordinator;\\n\\n  // Nonces for each VRF key from which randomness has been requested.\\n  //\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\\n    private nonces;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n  constructor(address _vrfCoordinator, address _link) {\\n    vrfCoordinator = _vrfCoordinator;\\n    LINK = LinkTokenInterface(_link);\\n  }\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract VRFRequestIDBase {\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  ) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Chainlink.sol\\\";\\nimport \\\"./interfaces/ENSInterface.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/ChainlinkRequestInterface.sol\\\";\\nimport \\\"./interfaces/OperatorInterface.sol\\\";\\nimport \\\"./interfaces/PointerInterface.sol\\\";\\nimport {ENSResolver as ENSResolver_Chainlink} from \\\"./vendor/ENSResolver.sol\\\";\\n\\n/**\\n * @title The ChainlinkClient contract\\n * @notice Contract writers can inherit this contract in order to create requests for the\\n * Chainlink network\\n */\\nabstract contract ChainlinkClient {\\n  using Chainlink for Chainlink.Request;\\n\\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\\n  uint256 private constant AMOUNT_OVERRIDE = 0;\\n  address private constant SENDER_OVERRIDE = address(0);\\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\\\"link\\\");\\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\\\"oracle\\\");\\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\\n\\n  ENSInterface private s_ens;\\n  bytes32 private s_ensNode;\\n  LinkTokenInterface private s_link;\\n  OperatorInterface private s_oracle;\\n  uint256 private s_requestCount = 1;\\n  mapping(bytes32 => address) private s_pendingRequests;\\n\\n  event ChainlinkRequested(bytes32 indexed id);\\n  event ChainlinkFulfilled(bytes32 indexed id);\\n  event ChainlinkCancelled(bytes32 indexed id);\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackAddr address to operate the callback on\\n   * @param callbackFunctionSignature function signature to use for the callback\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildChainlinkRequest(\\n    bytes32 specId,\\n    address callbackAddr,\\n    bytes4 callbackFunctionSignature\\n  ) internal pure returns (Chainlink.Request memory) {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackFunctionSignature function signature to use for the callback\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\\n    internal\\n    view\\n    returns (Chainlink.Request memory)\\n  {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, address(this), callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  ) internal returns (bytes32 requestId) {\\n    uint256 nonce = s_requestCount;\\n    s_requestCount = nonce + 1;\\n    bytes memory encodedRequest = abi.encodeWithSelector(\\n      ChainlinkRequestInterface.oracleRequest.selector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      address(this),\\n      req.callbackFunctionId,\\n      nonce,\\n      ORACLE_ARGS_VERSION,\\n      req.buf.buf\\n    );\\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendOperatorRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  ) internal returns (bytes32 requestId) {\\n    uint256 nonce = s_requestCount;\\n    s_requestCount = nonce + 1;\\n    bytes memory encodedRequest = abi.encodeWithSelector(\\n      OperatorInterface.operatorRequest.selector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      req.callbackFunctionId,\\n      nonce,\\n      OPERATOR_ARGS_VERSION,\\n      req.buf.buf\\n    );\\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\\n  }\\n\\n  /**\\n   * @notice Make a request to an oracle\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param nonce used to generate the request ID\\n   * @param payment The amount of LINK to send for the request\\n   * @param encodedRequest data encoded for request type specific format\\n   * @return requestId The request ID\\n   */\\n  function _rawRequest(\\n    address oracleAddress,\\n    uint256 nonce,\\n    uint256 payment,\\n    bytes memory encodedRequest\\n  ) private returns (bytes32 requestId) {\\n    requestId = keccak256(abi.encodePacked(this, nonce));\\n    s_pendingRequests[requestId] = oracleAddress;\\n    emit ChainlinkRequested(requestId);\\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \\\"unable to transferAndCall to oracle\\\");\\n  }\\n\\n  /**\\n   * @notice Allows a request to be cancelled if it has not been fulfilled\\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\\n   * Deletes the request from the `pendingRequests` mapping.\\n   * Emits ChainlinkCancelled event.\\n   * @param requestId The request ID\\n   * @param payment The amount of LINK sent for the request\\n   * @param callbackFunc The callback function specified for the request\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelChainlinkRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  ) internal {\\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\\n    delete s_pendingRequests[requestId];\\n    emit ChainlinkCancelled(requestId);\\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\\n  }\\n\\n  /**\\n   * @notice the next request count to be used in generating a nonce\\n   * @dev starts at 1 in order to ensure consistent gas cost\\n   * @return returns the next request count to be used in a nonce\\n   */\\n  function getNextRequestCount() internal view returns (uint256) {\\n    return s_requestCount;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle address\\n   * @param oracleAddress The address of the oracle contract\\n   */\\n  function setChainlinkOracle(address oracleAddress) internal {\\n    s_oracle = OperatorInterface(oracleAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the LINK token address\\n   * @param linkAddress The address of the LINK token contract\\n   */\\n  function setChainlinkToken(address linkAddress) internal {\\n    s_link = LinkTokenInterface(linkAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the Chainlink token address for the public\\n   * network as given by the Pointer contract\\n   */\\n  function setPublicChainlinkToken() internal {\\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the LINK token\\n   * @return The address of the LINK token\\n   */\\n  function chainlinkTokenAddress() internal view returns (address) {\\n    return address(s_link);\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the oracle contract\\n   * @return The address of the oracle contract\\n   */\\n  function chainlinkOracleAddress() internal view returns (address) {\\n    return address(s_oracle);\\n  }\\n\\n  /**\\n   * @notice Allows for a request which was created on another contract to be fulfilled\\n   * on this contract\\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\\n   * @param requestId The request ID used for the response\\n   */\\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\\n    s_pendingRequests[requestId] = oracleAddress;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\\n   * @dev Accounts for subnodes having different resolvers\\n   * @param ensAddress The address of the ENS contract\\n   * @param node The ENS node hash\\n   */\\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\\n    s_ens = ENSInterface(ensAddress);\\n    s_ensNode = node;\\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\\n    setChainlinkToken(resolver.addr(linkSubnode));\\n    updateChainlinkOracleWithENS();\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle contract with the address resolved by ENS\\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\\n   */\\n  function updateChainlinkOracleWithENS() internal {\\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\\n    setChainlinkOracle(resolver.addr(oracleSubnode));\\n  }\\n\\n  /**\\n   * @notice Ensures that the fulfillment is valid for this contract\\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\\n   * @param requestId The request ID for fulfillment\\n   */\\n  function validateChainlinkCallback(bytes32 requestId)\\n    internal\\n    recordChainlinkFulfillment(requestId)\\n  // solhint-disable-next-line no-empty-blocks\\n  {\\n\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the oracle of the request.\\n   * Emits ChainlinkFulfilled event.\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\\n    require(msg.sender == s_pendingRequests[requestId], \\\"Source must be the oracle of the request\\\");\\n    delete s_pendingRequests[requestId];\\n    emit ChainlinkFulfilled(requestId);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the request is already pending\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier notPendingRequest(bytes32 requestId) {\\n    require(s_pendingRequests[requestId] == address(0), \\\"Request is already pending\\\");\\n    _;\\n  }\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/Chainlink.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {CBORChainlink} from \\\"./vendor/CBORChainlink.sol\\\";\\nimport {BufferChainlink} from \\\"./vendor/BufferChainlink.sol\\\";\\n\\n/**\\n * @title Library for common Chainlink functions\\n * @dev Uses imported CBOR library for encoding to buffer\\n */\\nlibrary Chainlink {\\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\\n\\n  using CBORChainlink for BufferChainlink.buffer;\\n\\n  struct Request {\\n    bytes32 id;\\n    address callbackAddress;\\n    bytes4 callbackFunctionId;\\n    uint256 nonce;\\n    BufferChainlink.buffer buf;\\n  }\\n\\n  /**\\n   * @notice Initializes a Chainlink request\\n   * @dev Sets the ID, callback address, and callback function signature on the request\\n   * @param self The uninitialized request\\n   * @param jobId The Job Specification ID\\n   * @param callbackAddr The callback address\\n   * @param callbackFunc The callback function signature\\n   * @return The initialized request\\n   */\\n  function initialize(\\n    Request memory self,\\n    bytes32 jobId,\\n    address callbackAddr,\\n    bytes4 callbackFunc\\n  ) internal pure returns (Chainlink.Request memory) {\\n    BufferChainlink.init(self.buf, defaultBufferSize);\\n    self.id = jobId;\\n    self.callbackAddress = callbackAddr;\\n    self.callbackFunctionId = callbackFunc;\\n    return self;\\n  }\\n\\n  /**\\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\\n   * @param self The initialized request\\n   * @param data The CBOR data\\n   */\\n  function setBuffer(Request memory self, bytes memory data) internal pure {\\n    BufferChainlink.init(self.buf, data.length);\\n    BufferChainlink.append(self.buf, data);\\n  }\\n\\n  /**\\n   * @notice Adds a string value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The string value to add\\n   */\\n  function add(\\n    Request memory self,\\n    string memory key,\\n    string memory value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeString(value);\\n  }\\n\\n  /**\\n   * @notice Adds a bytes value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The bytes value to add\\n   */\\n  function addBytes(\\n    Request memory self,\\n    string memory key,\\n    bytes memory value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeBytes(value);\\n  }\\n\\n  /**\\n   * @notice Adds a int256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The int256 value to add\\n   */\\n  function addInt(\\n    Request memory self,\\n    string memory key,\\n    int256 value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds a uint256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The uint256 value to add\\n   */\\n  function addUint(\\n    Request memory self,\\n    string memory key,\\n    uint256 value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeUInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds an array of strings to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param values The array of string values to add\\n   */\\n  function addStringArray(\\n    Request memory self,\\n    string memory key,\\n    string[] memory values\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.startArray();\\n    for (uint256 i = 0; i < values.length; i++) {\\n      self.buf.encodeString(values[i]);\\n    }\\n    self.buf.endSequence();\\n  }\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ENSInterface {\\n  // Logged when the owner of a node assigns a new owner to a subnode.\\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n  // Logged when the owner of a node transfers ownership to a new account.\\n  event Transfer(bytes32 indexed node, address owner);\\n\\n  // Logged when the resolver for a node changes.\\n  event NewResolver(bytes32 indexed node, address resolver);\\n\\n  // Logged when the TTL of a node changes\\n  event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n  function setSubnodeOwner(\\n    bytes32 node,\\n    bytes32 label,\\n    address owner\\n  ) external;\\n\\n  function setResolver(bytes32 node, address resolver) external;\\n\\n  function setOwner(bytes32 node, address owner) external;\\n\\n  function setTTL(bytes32 node, uint64 ttl) external;\\n\\n  function owner(bytes32 node) external view returns (address);\\n\\n  function resolver(bytes32 node) external view returns (address);\\n\\n  function ttl(bytes32 node) external view returns (uint64);\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ChainlinkRequestInterface {\\n  function oracleRequest(\\n    address sender,\\n    uint256 requestPrice,\\n    bytes32 serviceAgreementID,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function cancelOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration\\n  ) external;\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OracleInterface.sol\\\";\\nimport \\\"./ChainlinkRequestInterface.sol\\\";\\n\\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\\n  function operatorRequest(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function fulfillOracleRequest2(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes calldata data\\n  ) external returns (bool);\\n\\n  function ownerTransferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\\n\\n  function getAuthorizedSenders() external returns (address[] memory);\\n\\n  function setAuthorizedSenders(address[] calldata senders) external;\\n\\n  function getForwarder() external returns (address);\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface PointerInterface {\\n  function getAddress() external view returns (address);\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ENSResolver {\\n  function addr(bytes32 node) public view virtual returns (address);\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.19;\\n\\nimport {BufferChainlink} from \\\"./BufferChainlink.sol\\\";\\n\\nlibrary CBORChainlink {\\n  using BufferChainlink for BufferChainlink.buffer;\\n\\n  uint8 private constant MAJOR_TYPE_INT = 0;\\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\\n  uint8 private constant MAJOR_TYPE_STRING = 3;\\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n  uint8 private constant MAJOR_TYPE_MAP = 5;\\n  uint8 private constant MAJOR_TYPE_TAG = 6;\\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\\n    if(value <= 23) {\\n      buf.appendUint8(uint8((major << 5) | value));\\n    } else if (value <= 0xFF) {\\n      buf.appendUint8(uint8((major << 5) | 24));\\n      buf.appendInt(value, 1);\\n    } else if (value <= 0xFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 25));\\n      buf.appendInt(value, 2);\\n    } else if (value <= 0xFFFFFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 26));\\n      buf.appendInt(value, 4);\\n    } else {\\n      buf.appendUint8(uint8((major << 5) | 27));\\n      buf.appendInt(value, 8);\\n    }\\n  }\\n\\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\\n    buf.appendUint8(uint8((major << 5) | 31));\\n  }\\n\\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\\n    if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, value);\\n    } else {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\\n    }\\n  }\\n\\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\\n    if(value < -0x10000000000000000) {\\n      encodeSignedBigNum(buf, value);\\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, uint(value));\\n    } else if(value >= 0) {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\\n    } else {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\\n    }\\n  }\\n\\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\\n    buf.append(value);\\n  }\\n\\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n    encodeBytes(buf, abi.encode(value));\\n  }\\n\\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\\n  }\\n\\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\\n    buf.append(bytes(value));\\n  }\\n\\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n  }\\n\\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n  }\\n\\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n  }\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev A library for working with mutable byte buffers in Solidity.\\n *\\n * Byte buffers are mutable and expandable, and provide a variety of primitives\\n * for writing to them. At any time you can fetch a bytes object containing the\\n * current contents of the buffer. The bytes object should not be stored between\\n * operations, as it may change due to resizing of the buffer.\\n */\\nlibrary BufferChainlink {\\n  /**\\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n   *      a capacity. The capacity may be longer than the current value, in\\n   *      which case it can be extended without the need to allocate more memory.\\n   */\\n  struct buffer {\\n    bytes buf;\\n    uint256 capacity;\\n  }\\n\\n  /**\\n   * @dev Initializes a buffer with an initial capacity.\\n   * @param buf The buffer to initialize.\\n   * @param capacity The number of bytes of space to allocate the buffer.\\n   * @return The buffer, for chaining.\\n   */\\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\\n    if (capacity % 32 != 0) {\\n      capacity += 32 - (capacity % 32);\\n    }\\n    // Allocate space for the buffer data\\n    buf.capacity = capacity;\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(buf, ptr)\\n      mstore(ptr, 0)\\n      mstore(0x40, add(32, add(ptr, capacity)))\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Initializes a new buffer from an existing bytes object.\\n   *      Changes to the buffer may mutate the original value.\\n   * @param b The bytes object to initialize the buffer with.\\n   * @return A new buffer.\\n   */\\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\\n    buffer memory buf;\\n    buf.buf = b;\\n    buf.capacity = b.length;\\n    return buf;\\n  }\\n\\n  function resize(buffer memory buf, uint256 capacity) private pure {\\n    bytes memory oldbuf = buf.buf;\\n    init(buf, capacity);\\n    append(buf, oldbuf);\\n  }\\n\\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\\n    if (a > b) {\\n      return a;\\n    }\\n    return b;\\n  }\\n\\n  /**\\n   * @dev Sets buffer length to 0.\\n   * @param buf The buffer to truncate.\\n   * @return The original buffer, for chaining..\\n   */\\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n    assembly {\\n      let bufptr := mload(buf)\\n      mstore(bufptr, 0)\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The start offset to write to.\\n   * @param data The data to append.\\n   * @param len The number of bytes to copy.\\n   * @return The original buffer, for chaining.\\n   */\\n  function write(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes memory data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    require(len <= data.length);\\n\\n    if (off + len > buf.capacity) {\\n      resize(buf, max(buf.capacity, len + off) * 2);\\n    }\\n\\n    uint256 dest;\\n    uint256 src;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Start address = buffer address + offset + sizeof(buffer length)\\n      dest := add(add(bufptr, 32), off)\\n      // Update buffer length if we're extending it\\n      if gt(add(len, off), buflen) {\\n        mstore(bufptr, add(len, off))\\n      }\\n      src := add(data, 32)\\n    }\\n\\n    // Copy word-length chunks while possible\\n    for (; len >= 32; len -= 32) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n      dest += 32;\\n      src += 32;\\n    }\\n\\n    // Copy remaining bytes\\n    unchecked {\\n      uint256 mask = (256**(32 - len)) - 1;\\n      assembly {\\n        let srcpart := and(mload(src), not(mask))\\n        let destpart := and(mload(dest), mask)\\n        mstore(dest, or(destpart, srcpart))\\n      }\\n    }\\n\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @param len The number of bytes to copy.\\n   * @return The original buffer, for chaining.\\n   */\\n  function append(\\n    buffer memory buf,\\n    bytes memory data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, len);\\n  }\\n\\n  /**\\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, data.length);\\n  }\\n\\n  /**\\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write the byte at.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeUint8(\\n    buffer memory buf,\\n    uint256 off,\\n    uint8 data\\n  ) internal pure returns (buffer memory) {\\n    if (off >= buf.capacity) {\\n      resize(buf, buf.capacity * 2);\\n    }\\n\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Address = buffer address + sizeof(buffer length) + off\\n      let dest := add(add(bufptr, off), 32)\\n      mstore8(dest, data)\\n      // Update buffer length if we extended it\\n      if eq(off, buflen) {\\n        mstore(bufptr, add(buflen, 1))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\\n    return writeUint8(buf, buf.buf.length, data);\\n  }\\n\\n  /**\\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n   *      exceed the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @param len The number of bytes to write (left-aligned).\\n   * @return The original buffer, for chaining.\\n   */\\n  function write(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes32 data,\\n    uint256 len\\n  ) private pure returns (buffer memory) {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    unchecked {\\n      uint256 mask = (256**len) - 1;\\n      // Right-align data\\n      data = data >> (8 * (32 - len));\\n      assembly {\\n        // Memory address of the buffer data\\n        let bufptr := mload(buf)\\n        // Address = buffer address + sizeof(buffer length) + off + len\\n        let dest := add(add(bufptr, off), len)\\n        mstore(dest, or(and(mload(dest), not(mask)), data))\\n        // Update buffer length if we extended it\\n        if gt(add(off, len), mload(bufptr)) {\\n          mstore(bufptr, add(off, len))\\n        }\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeBytes20(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes20 data\\n  ) internal pure returns (buffer memory) {\\n    return write(buf, off, bytes32(data), 20);\\n  }\\n\\n  /**\\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chhaining.\\n   */\\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, bytes32(data), 20);\\n  }\\n\\n  /**\\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, 32);\\n  }\\n\\n  /**\\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @param len The number of bytes to write (right-aligned).\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeInt(\\n    buffer memory buf,\\n    uint256 off,\\n    uint256 data,\\n    uint256 len\\n  ) private pure returns (buffer memory) {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    uint256 mask = (256**len) - 1;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Address = buffer address + off + sizeof(buffer length) + len\\n      let dest := add(add(bufptr, off), len)\\n      mstore(dest, or(and(mload(dest), not(mask)), data))\\n      // Update buffer length if we extended it\\n      if gt(add(off, len), mload(bufptr)) {\\n        mstore(bufptr, add(off, len))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n   * exceed the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer.\\n   */\\n  function appendInt(\\n    buffer memory buf,\\n    uint256 data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    return writeInt(buf, buf.buf.length, data, len);\\n  }\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OracleInterface {\\n  function fulfillOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes32 data\\n  ) external returns (bool);\\n\\n  function isAuthorizedSender(address node) external view returns (bool);\\n\\n  function withdraw(address recipient, uint256 amount) external;\\n\\n  function withdrawable() external view returns (uint256);\\n}\\n\"\n    },\n    \"contracts/miserable-flight/FlightOracle.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\\\";\\nimport \\\"./interfaces/IPolicyFlow.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/**\\n * @title  Flight Oracle\\n * @notice This is the flight oracle contract.\\n *         Called by policyFlow contract and send the request to chainlink node.\\n *         After receiving the result, call the policyFlow contract to do the settlement.\\n * @dev    Remember to set the url, oracleAddress and jobId\\n *         If there are multiple oracle providers in the future, this contract may need to be updated.\\n */\\ncontract FlightOracle is ChainlinkClient, Ownable {\\n    using Chainlink for Chainlink.Request;\\n\\n    IPolicyFlow public policyFlow;\\n\\n    address public oracleAddress;\\n    bytes32 public jobId;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event OracleAddressChanged(address newOracle);\\n    event JobIdChanged(bytes32 newJobId);\\n    event PolicyFlowChanged(address newPolicyFlow);\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Need the address of LINK token on specific network\\n     */\\n    constructor(address _policyFlow, address _link) Ownable(msg.sender) {\\n        policyFlow = IPolicyFlow(_policyFlow);\\n\\n        setChainlinkToken(_link);\\n\\n        oracleAddress = 0x7D9398979267a6E050FbFDFff953Fc612A5aD4C9;\\n        jobId = \\\"bcc0a699531940479bc93cf9fa5afb3f\\\";\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // Only the policyFlow can call some functions\\n    modifier onlyPolicyFlow() {\\n        require(\\n            msg.sender == address(policyFlow),\\n            \\\"Only the policyflow can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Returns the address of the LINK token\\n     * @dev This is the public implementation for chainlinkTokenAddress, which is\\n     *      an internal method of the ChainlinkClient contract\\n     */\\n    function getChainlinkTokenAddress() external view returns (address) {\\n        return chainlinkTokenAddress();\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Set the oracle address\\n     */\\n    function setOracleAddress(address _newOracle) external onlyOwner {\\n        oracleAddress = _newOracle;\\n        emit OracleAddressChanged(_newOracle);\\n    }\\n\\n    /**\\n     * @notice Set a new job id\\n     */\\n    function setJobId(bytes32 _newJobId) external onlyOwner {\\n        jobId = _newJobId;\\n        emit JobIdChanged(_newJobId);\\n    }\\n\\n    /**\\n     * @notice Change the policy flow contract address\\n     */\\n    function setPolicyFlow(address _policyFlow) external onlyOwner {\\n        policyFlow = IPolicyFlow(_policyFlow);\\n        emit PolicyFlowChanged(_policyFlow);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Creates a request to the specified Oracle contract address\\n     * @dev This function ignores the stored Oracle contract address and\\n     *      will instead send the request to the address specified\\n     * @param _payment Payment to the oracle\\n     * @param _url The URL to fetch data from\\n     * @param _path The dot-delimited path to parse of the response\\n     * @param _times The number to multiply the result by\\n     */\\n    function newOracleRequest(\\n        uint256 _payment,\\n        string memory _url,\\n        string memory _path,\\n        int256 _times\\n    ) public onlyPolicyFlow returns (bytes32) {\\n        require(\\n            oracleAddress != address(0) && jobId != 0,\\n            \\\"Set the oracle address & jobId\\\"\\n        );\\n\\n        // Enough LINK token for payment\\n        require(\\n            LinkTokenInterface(chainlinkTokenAddress()).balanceOf(\\n                address(this)\\n            ) >= _payment,\\n            \\\"Insufficient LINK balance\\\"\\n        );\\n\\n        Chainlink.Request memory req = buildChainlinkRequest(\\n            jobId,\\n            address(this),\\n            this.fulfill.selector\\n        );\\n        req.add(\\\"url\\\", _url);\\n        req.add(\\\"path\\\", _path);\\n        req.addInt(\\\"times\\\", _times);\\n        return sendChainlinkRequestTo(oracleAddress, req, _payment);\\n    }\\n\\n    /**\\n     * @notice The fulfill method from requests created by this contract\\n     * @dev The recordChainlinkFulfillment protects this function from being called\\n     *      by anyone other than the oracle address that the request was sent to\\n     * @param _requestId The ID that was generated for the request\\n     * @param _data The answer provided by the oracle\\n     */\\n    function fulfill(bytes32 _requestId, uint256 _data)\\n        public\\n        recordChainlinkFulfillment(_requestId)\\n    {\\n        policyFlow.finalSettlement(_requestId, _data);\\n    }\\n}\\n\"\n    },\n    \"contracts/miserable-flight/FDPolicyToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\";\\nimport \\\"../utils/OwnableWithoutContext.sol\\\";\\nimport \\\"../libraries/StringsUtils.sol\\\";\\nimport \\\"./interfaces/IPolicyFlow.sol\\\";\\nimport \\\"./interfaces/IPolicyStruct.sol\\\";\\n\\n/**\\n * @title  Policy Token for flight delay\\n * @notice ERC721 policy token\\n *         Can get a long string form of the tokenURI\\n *         When the ownership is transferred, it will update the status in policyFlow\\n */\\ncontract FDPolicyToken is\\n    ERC721Enumerable,\\n    IPolicyStruct,\\n    OwnableWithoutContext\\n{\\n    using StringsUtils for uint256;\\n    using StringsUtils for address;\\n\\n    // PolicyFlow contract interface\\n    IPolicyFlow public policyFlow;\\n\\n    uint256 public _nextId;\\n\\n    struct PolicyTokenURIParam {\\n        string flightNumber;\\n        address owner;\\n        uint256 premium;\\n        uint256 payoff;\\n        uint256 purchaseTimestamp;\\n        uint256 departureTimestamp;\\n        uint256 landingTimestamp;\\n        uint256 status;\\n    }\\n\\n    event PolicyFlowUpdated(address newPolicyFlow);\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    constructor()\\n        ERC721(\\\"Degis FlightDelay PolicyToken\\\", \\\"DEGIS_FD_PT\\\")\\n        OwnableWithoutContext(msg.sender)\\n    {\\n        _nextId = 1;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Get the tokenURI of a policy\\n     * @param _tokenId Token Id of the policy token\\n     * @return The tokenURI in string form\\n     */\\n    function tokenURI(uint256 _tokenId)\\n        public\\n        view\\n        override(ERC721)\\n        returns (string memory)\\n    {\\n        require(_tokenId < _nextId, \\\"TokenId is too large!\\\");\\n        return _getTokenURI(_tokenId);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Set Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n       @notice Update the policyFlow address if it has been updated\\n       @param _policyFlow New policyFlow contract address\\n     */\\n    function updatePolicyFlow(address _policyFlow) external onlyOwner {\\n        policyFlow = IPolicyFlow(_policyFlow);\\n        emit PolicyFlowUpdated(_policyFlow);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Main Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Mint a new policy token to an address\\n     * @param _to The receiver address\\n     */\\n    function mintPolicyToken(address _to) public {\\n        require(\\n            _msgSender() == address(policyFlow),\\n            \\\"Only the policyflow contract can mint fd policy token\\\"\\n        );\\n        uint256 tokenId = _nextId++;\\n        _safeMint(_to, tokenId);\\n    }\\n\\n    /**\\n     * @notice Transfer the owner of a policy token and update the information in policyFlow\\n     * @dev Need approval and is prepared for secondary market\\n     * @dev If you just transfer the policy token, you will not transfer the right for claiming payoff\\n     * @param _from The original owner of the policy\\n     * @param _to The new owner of the policy\\n     * @param _tokenId Token id of the policy\\n     */\\n    function transferOwner(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) public {\\n        safeTransferFrom(_from, _to, _tokenId);\\n        policyFlow.policyOwnerTransfer(_tokenId, _from, _to);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Internal Functions ********************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Get the tokenURI, the metadata is from policyFlow contract\\n     * @param _tokenId Token Id of the policy token\\n     */\\n    function _getTokenURI(uint256 _tokenId)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        PolicyInfo memory info = policyFlow.getPolicyInfoById(_tokenId);\\n\\n        return\\n            _constructTokenURI(\\n                PolicyTokenURIParam(\\n                    info.flightNumber,\\n                    info.buyerAddress,\\n                    info.premium,\\n                    info.payoff,\\n                    info.purchaseTimestamp,\\n                    info.departureTimestamp,\\n                    info.landingTimestamp,\\n                    uint256(info.status)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Construct the metadata of a specific policy token\\n     * @param _params The parameters of the policy token\\n     */\\n    function _constructTokenURI(PolicyTokenURIParam memory _params)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        string[9] memory parts;\\n\\n        parts[0] = \\\"ProductId: 0, \\\";\\n        parts[1] = string(\\n            abi.encodePacked(\\\"FlightNumber: \\\", _params.flightNumber, \\\", \\\")\\n        );\\n        parts[2] = string(\\n            abi.encodePacked(\\n                \\\"BuyerAddress: \\\",\\n                (_params.owner).addressToString(),\\n                \\\", \\\"\\n            )\\n        );\\n\\n        parts[3] = string(\\n            abi.encodePacked(\\n                \\\"Premium: \\\",\\n                (_params.premium / 1e18).uintToString(),\\n                \\\", \\\"\\n            )\\n        );\\n\\n        parts[4] = string(\\n            abi.encodePacked(\\n                \\\"Payoff: \\\",\\n                (_params.payoff / 1e18).uintToString(),\\n                \\\", \\\"\\n            )\\n        );\\n\\n        parts[5] = string(\\n            abi.encodePacked(\\n                \\\"PurchaseTimestamp: \\\",\\n                _params.purchaseTimestamp.uintToString(),\\n                \\\", \\\"\\n            )\\n        );\\n\\n        parts[6] = string(\\n            abi.encodePacked(\\n                \\\"DepartureTimestamp:\\\",\\n                _params.departureTimestamp.uintToString(),\\n                \\\", \\\"\\n            )\\n        );\\n\\n        parts[7] = string(\\n            abi.encodePacked(\\n                \\\"LandingTimestamp: \\\",\\n                (_params.landingTimestamp).uintToString(),\\n                \\\", \\\"\\n            )\\n        );\\n\\n        parts[8] = string(\\n            abi.encodePacked(\\n                \\\"PolicyStatus: \\\",\\n                _params.status.uintToString(),\\n                \\\".\\\"\\n            )\\n        );\\n\\n        string memory output = string(\\n            abi.encodePacked(\\n                parts[0],\\n                parts[1],\\n                parts[2],\\n                parts[3],\\n                parts[4],\\n                parts[5],\\n                parts[6],\\n                parts[7],\\n                parts[8]\\n            )\\n        );\\n        return output;\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\n    },\n    \"contracts/miserable-flight/PolicyFlow.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\nimport \\\"../proxy/OwnableUpgradeable.sol\\\";\\nimport \\\"../tokens/interfaces/IBuyerToken.sol\\\";\\nimport \\\"./interfaces/ISigManager.sol\\\";\\nimport \\\"./interfaces/IFDPolicyToken.sol\\\";\\nimport \\\"./interfaces/IFlightOracle.sol\\\";\\nimport \\\"./interfaces/IInsurancePool.sol\\\";\\nimport \\\"./interfaces/IPolicyStruct.sol\\\";\\nimport \\\"./abstracts/PolicyParameters.sol\\\";\\nimport \\\"../libraries/StringsUtils.sol\\\";\\nimport \\\"../libraries/StablecoinDecimal.sol\\\";\\n\\ncontract PolicyFlow is IPolicyStruct, PolicyParameters, OwnableUpgradeable {\\n    using StringsUtils for uint256;\\n    using StablecoinDecimal for uint256;\\n\\n    // Other contracts\\n    IBuyerToken public buyerToken;\\n    ISigManager public sigManager;\\n    IFDPolicyToken public policyToken;\\n    IFlightOracle public flightOracle;\\n    IInsurancePool public insurancePool;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    string public FLIGHT_STATUS_URL = \\\"https://degis.io:3207/flight_status?\\\";\\n\\n    uint256 public totalPolicies;\\n\\n    uint256 public fee;\\n\\n    mapping(uint256 => PolicyInfo) public policyList;\\n\\n    mapping(address => uint256[]) userPolicyList;\\n\\n    mapping(bytes32 => uint256) requestList;\\n\\n    mapping(uint256 => uint256) delayResultList;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n    event FeeChanged(uint256 newFee);\\n    event MaxPayoffChanged(uint256 newMaxPayoff);\\n    event MinTimeBeforeDepartureChanged(uint256 newMinTime);\\n    event FlightOracleChanged(address newOracle);\\n    event OracleUrlChanged(string newUrl);\\n    event DelayThresholdChanged(uint256 thresholdMin, uint256 thresholdMax);\\n\\n    event NewPolicyApplication(uint256 policyId, address indexed user);\\n    event NewClaimRequest(\\n        uint256 policyId,\\n        string flightNumber,\\n        bytes32 requestId\\n    );\\n    event PolicySold(uint256 policyId, address indexed user);\\n    event PolicyDeclined(uint256 policyId, address indexed user);\\n    event PolicyClaimed(uint256 policyId, address indexed user);\\n    event PolicyExpired(uint256 policyId, address indexed user);\\n    event FulfilledOracleRequest(uint256 policyId, bytes32 requestId);\\n    event PolicyOwnerTransfer(uint256 indexed tokenId, address newOwner);\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Initializer ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Initializer of the PolicyFlow contract\\n     * @dev Upgradeable contracts do not have a constrcutor\\n     * @param _insurancePool The InsurancePool contract address\\n     * @param _policyToken The PolicyToken contract address\\n     * @param _sigManager The SigManager contract address\\n     * @param _buyerToken The BuyerToken contract address\\n     */\\n    function initialize(\\n        address _insurancePool,\\n        address _policyToken,\\n        address _sigManager,\\n        address _buyerToken\\n    ) public initializer {\\n        __Ownable_init(msg.sender);\\n        __PolicyFlow_init(\\n            _insurancePool,\\n            _policyToken,\\n            _sigManager,\\n            _buyerToken\\n        );\\n    }\\n\\n    function __PolicyFlow_init(\\n        address _insurancePool,\\n        address _policyToken,\\n        address _sigManager,\\n        address _buyerToken\\n    ) internal onlyInitializing {\\n        insurancePool = IInsurancePool(_insurancePool);\\n        policyToken = IFDPolicyToken(_policyToken);\\n        sigManager = ISigManager(_sigManager);\\n        buyerToken = IBuyerToken(_buyerToken);\\n\\n        // Set the oracle fee\\n        fee = 0.1 * 10**18;\\n    }\\n\\n    // ----------------------------------------------------------------------------------- //\\n    // ********************************* View Functions ********************************** //\\n    // ----------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Show a user's policies (all)\\n     * @dev Should only be checked for frontend\\n     * @param _user User's address\\n     * @return userPolicies User's all policy details\\n     */\\n    function viewUserPolicy(address _user)\\n        external\\n        view\\n        returns (PolicyInfo[] memory)\\n    {\\n        uint256 userPolicyAmount = userPolicyList[_user].length;\\n        require(userPolicyAmount > 0, \\\"No policy for this user\\\");\\n\\n        PolicyInfo[] memory result = new PolicyInfo[](userPolicyAmount);\\n\\n        for (uint256 i = 0; i < userPolicyAmount; i++) {\\n            uint256 policyId = userPolicyList[_user][i];\\n\\n            result[i] = policyList[policyId];\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @notice Get the policyInfo from its count/order\\n     * @param _policyId Total count/order of the policy = NFT tokenId\\n     * @return policy A struct of information about this policy\\n     */\\n    // TODO: If still need this function\\n    function getPolicyInfoById(uint256 _policyId)\\n        public\\n        view\\n        returns (PolicyInfo memory policy)\\n    {\\n        policy = policyList[_policyId];\\n    }\\n\\n    /**\\n     * @notice Get the policy buyer by policyId\\n     * @param _policyId Unique policy Id (uint256)\\n     * @return buyerAddress The buyer of this policy\\n     */\\n    // TODO: If still need this function\\n    function findPolicyBuyerById(uint256 _policyId)\\n        public\\n        view\\n        returns (address buyerAddress)\\n    {\\n        buyerAddress = policyList[_policyId].buyerAddress;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Change the oracle fee\\n     * @param _fee New oracle fee\\n     */\\n    function setFee(uint256 _fee) external onlyOwner {\\n        fee = _fee;\\n        emit FeeChanged(_fee);\\n    }\\n\\n    /**\\n     * @notice Change the max payoff\\n     * @param _newMaxPayoff New maxpayoff amount\\n     */\\n    function setMaxPayoff(uint256 _newMaxPayoff) external onlyOwner {\\n        MAX_PAYOFF = _newMaxPayoff;\\n        emit MaxPayoffChanged(_newMaxPayoff);\\n    }\\n\\n    /**\\n     * @notice How long before departure when users can not buy new policies\\n     * @param _newMinTime New time set\\n     */\\n    function setMinTimeBeforeDeparture(uint256 _newMinTime) external onlyOwner {\\n        MIN_TIME_BEFORE_DEPARTURE = _newMinTime;\\n        emit MinTimeBeforeDepartureChanged(_newMinTime);\\n    }\\n\\n    /**\\n     * @notice Change the oracle address\\n     * @param _oracleAddress New oracle address\\n     */\\n    function setFlightOracle(address _oracleAddress) external onlyOwner {\\n        flightOracle = IFlightOracle(_oracleAddress);\\n        emit FlightOracleChanged(_oracleAddress);\\n    }\\n\\n    /**\\n     * @notice Set a new url\\n     */\\n    function setURL(string memory _url) external onlyOwner {\\n        FLIGHT_STATUS_URL = _url;\\n        emit OracleUrlChanged(_url);\\n    }\\n\\n    /**\\n     * @notice Set the new delay threshold used for calculating payoff\\n     * @param _thresholdMin New minimum threshold\\n     * @param _thresholdMax New maximum threshold\\n     */\\n    function setDelayThreshold(uint256 _thresholdMin, uint256 _thresholdMax)\\n        external\\n        onlyOwner\\n    {\\n        DELAY_THRESHOLD_MIN = _thresholdMin;\\n        DELAY_THRESHOLD_MAX = _thresholdMax;\\n        emit DelayThresholdChanged(_thresholdMin, _thresholdMax);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Buy a new flight delay policy\\n     * @dev The transaction should have the signature from the backend server\\n     * @dev Premium is in stablecoin, so it is 6 decimals\\n     * @param _productId ID of the purchased product (0: flightdelay; 1,2,3...: others)\\n     * @param _flightNumber Flight number in string (e.g. \\\"AQ1299\\\")\\n     * @param _premium Premium of this policy (decimals: 6)\\n     * @param _departureTimestamp Departure date of this flight (unix timestamp in s, not ms!)\\n     * @param _landingDate Landing date of this flight (uinx timestamp in s, not ms!)\\n     * @param _deadline Deadline for this purchase request\\n     * @param signature Use web3.eth.sign(hash(data), account) to generate the signature\\n     */\\n    function newApplication(\\n        uint256 _productId,\\n        string memory _flightNumber,\\n        uint256 _premium,\\n        uint256 _departureTimestamp,\\n        uint256 _landingDate,\\n        uint256 _deadline,\\n        bytes calldata signature\\n    ) public returns (uint256 _policyId) {\\n        uint256 currentTimestamp = block.timestamp;\\n        require(\\n            currentTimestamp <= _deadline,\\n            \\\"Expired deadline, please resubmit a transaction\\\"\\n        );\\n\\n        require(\\n            _productId == PRODUCT_ID,\\n            \\\"You are calling the wrong product contract\\\"\\n        );\\n\\n        require(\\n            _departureTimestamp >= currentTimestamp + MIN_TIME_BEFORE_DEPARTURE,\\n            \\\"It's too close to the departure time, you cannot buy this policy\\\"\\n        );\\n\\n        // Should be signed by operators\\n        _checkSignature(\\n            signature,\\n            _flightNumber,\\n            _departureTimestamp,\\n            _landingDate,\\n            _msgSender(),\\n            _premium,\\n            _deadline\\n        );\\n\\n        // Generate the policy\\n        // Use ++totalPolicies to keep the policyId the same as ERC721 tokenId\\n        // Policy Id starts from 1\\n        uint256 currentPolicyId = ++totalPolicies;\\n\\n        policyList[currentPolicyId] = PolicyInfo(\\n            PRODUCT_ID,\\n            _msgSender(),\\n            currentPolicyId,\\n            _flightNumber,\\n            _premium,\\n            MAX_PAYOFF,\\n            currentTimestamp,\\n            _departureTimestamp,\\n            _landingDate,\\n            PolicyStatus.INI,\\n            false,\\n            404\\n        );\\n\\n        // Check the policy with the insurance pool status\\n        // May be accepted or rejected, if accepted then update the status of insurancePool\\n        _policyCheck(_premium, MAX_PAYOFF, msg.sender, currentPolicyId);\\n\\n        // Give buyer tokens depending on the usd value they spent\\n        buyerToken.mintBuyerToken(msg.sender, _premium.toNormal());\\n\\n        // Store the policy's total order with userAddress\\n        userPolicyList[msg.sender].push(totalPolicies);\\n\\n        emit NewPolicyApplication(currentPolicyId, msg.sender);\\n\\n        return currentPolicyId;\\n    }\\n\\n    /**\\n     * @notice Make a claim request\\n     * @dev Anyone can make a new claim\\n     * @param _policyId The total order/id of the policy\\n     * @param _flightNumber The flight number\\n     * @param _timestamp The flight departure timestamp\\n     * @param _path Which data in json needs to get\\n     * @param _forceUpdate Owner can force to update\\n     */\\n    function newClaimRequest(\\n        uint256 _policyId,\\n        string memory _flightNumber,\\n        string memory _timestamp,\\n        string memory _path,\\n        bool _forceUpdate\\n    ) public {\\n        PolicyInfo memory policy = policyList[_policyId];\\n\\n        // Can not get the result before landing date\\n        // Landing date may not be true, may be a fixed interval (4hours)\\n        require(\\n            block.timestamp >= policy.landingTimestamp,\\n            \\\"Can only claim a policy after its expected landing timestamp\\\"\\n        );\\n\\n        // Check if the policy has been settled\\n        require(\\n            (!policy.alreadySettled) ||\\n                (_forceUpdate && (_msgSender() == owner())),\\n            \\\"Already settled\\\"\\n        );\\n\\n        // Check if the flight number is correct\\n        require(\\n            keccak256(abi.encodePacked(_flightNumber)) ==\\n                keccak256(abi.encodePacked(policy.flightNumber)),\\n            \\\"Wrong flight number provided\\\"\\n        );\\n\\n        // Check if the departure date is correct\\n        require(\\n            keccak256(abi.encodePacked(_timestamp)) ==\\n                keccak256(\\n                    abi.encodePacked(policy.departureTimestamp.uintToString())\\n                ),\\n            \\\"Wrong departure timestamp provided\\\"\\n        );\\n\\n        // Construct the url for oracle\\n        string memory _url = string(\\n            abi.encodePacked(\\n                FLIGHT_STATUS_URL,\\n                \\\"flight_no=\\\",\\n                _flightNumber,\\n                \\\"&timestamp=\\\",\\n                _timestamp\\n            )\\n        );\\n\\n        // Start a new oracle request\\n        bytes32 requestId = flightOracle.newOracleRequest(fee, _url, _path, 1);\\n\\n        // Record this request\\n        requestList[requestId] = _policyId;\\n        policyList[_policyId].alreadySettled = true;\\n\\n        emit NewClaimRequest(_policyId, _flightNumber, requestId);\\n    }\\n\\n    /**\\n     * @notice Update information when a policy token's ownership has been transferred\\n     * @dev This function is called by the ERC721 contract of PolicyToken\\n     * @param _tokenId Token Id of the policy token\\n     * @param _oldOwner The initial owner\\n     * @param _newOwner The new owner\\n     */\\n    function policyOwnerTransfer(\\n        uint256 _tokenId,\\n        address _oldOwner,\\n        address _newOwner\\n    ) external {\\n        // Check the call is from policy token contract\\n        require(\\n            _msgSender() == address(policyToken),\\n            \\\"only called from the flight delay policy token contract\\\"\\n        );\\n\\n        // Check the previous owner record\\n        uint256 policyId = _tokenId;\\n        require(\\n            _oldOwner == policyList[policyId].buyerAddress,\\n            \\\"The previous owner is wrong\\\"\\n        );\\n\\n        // Update the new buyer address\\n        policyList[policyId].buyerAddress = _newOwner;\\n        emit PolicyOwnerTransfer(_tokenId, _newOwner);\\n    }\\n\\n    // ----------------------------------------------------------------------------------- //\\n    // ********************************* Oracle Functions ******************************** //\\n    // ----------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Do the final settlement, called by FlightOracle contract\\n     * @param _requestId Chainlink request id\\n     * @param _result Delay result (minutes) given by oracle\\n     */\\n    function finalSettlement(bytes32 _requestId, uint256 _result) public {\\n        // Check if the call is from flight oracle\\n        require(\\n            msg.sender == address(flightOracle),\\n            \\\"this function should be called by FlightOracle contract\\\"\\n        );\\n\\n        uint256 policyId = requestList[_requestId];\\n\\n        PolicyInfo storage policy = policyList[policyId];\\n        policy.delayResult = _result;\\n\\n        uint256 premium = policy.premium;\\n        address buyerAddress = policy.buyerAddress;\\n\\n        require(\\n            _result <= DELAY_THRESHOLD_MAX || _result == 400,\\n            \\\"Abnormal oracle result, result should be [0 - 240] or 400\\\"\\n        );\\n\\n        if (_result == 0) {\\n            // 0: on time\\n            _policyExpired(premium, MAX_PAYOFF, buyerAddress, policyId);\\n        } else if (_result <= DELAY_THRESHOLD_MAX) {\\n            uint256 real_payoff = calcPayoff(_result);\\n            _policyClaimed(premium, real_payoff, buyerAddress, policyId);\\n        } else if (_result == 400) {\\n            // 400: cancelled\\n            _policyClaimed(premium, MAX_PAYOFF, buyerAddress, policyId);\\n        }\\n\\n        emit FulfilledOracleRequest(policyId, _requestId);\\n    }\\n\\n    // ----------------------------------------------------------------------------------- //\\n    // ******************************** Internal Functions ******************************* //\\n    // ----------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice check the policy and then determine whether we can afford it\\n     * @param _payoff the payoff of the policy sold\\n     * @param _user user's address\\n     * @param _policyId the unique policy ID\\n     */\\n    function _policyCheck(\\n        uint256 _premium,\\n        uint256 _payoff,\\n        address _user,\\n        uint256 _policyId\\n    ) internal {\\n        // Whether there are enough capacity in the pool\\n        bool _isAccepted = insurancePool.checkCapacity(_payoff);\\n\\n        if (_isAccepted) {\\n            insurancePool.updateWhenBuy(_premium, _payoff, _user);\\n            policyList[_policyId].status = PolicyStatus.SOLD;\\n            emit PolicySold(_policyId, _user);\\n\\n            policyToken.mintPolicyToken(_user);\\n        } else {\\n            emit PolicyDeclined(_policyId, _user);\\n            revert(\\\"not sufficient capacity in the insurance pool\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice update the policy when it is expired\\n     * @param _premium the premium of the policy sold\\n     * @param _payoff the payoff of the policy sold\\n     * @param _user user's address\\n     * @param _policyId the unique policy ID\\n     */\\n    function _policyExpired(\\n        uint256 _premium,\\n        uint256 _payoff,\\n        address _user,\\n        uint256 _policyId\\n    ) internal {\\n        insurancePool.updateWhenExpire(_premium, _payoff);\\n        policyList[_policyId].status = PolicyStatus.EXPIRED;\\n        emit PolicyExpired(_policyId, _user);\\n    }\\n\\n    /**\\n     * @notice Update the policy when it is claimed\\n     * @param _premium Premium of the policy sold\\n     * @param _payoff Payoff of the policy sold\\n     * @param _user User's address\\n     * @param _policyId The unique policy ID\\n     */\\n    function _policyClaimed(\\n        uint256 _premium,\\n        uint256 _payoff,\\n        address _user,\\n        uint256 _policyId\\n    ) internal {\\n        insurancePool.payClaim(_premium, MAX_PAYOFF, _payoff, _user);\\n        policyList[_policyId].status = PolicyStatus.CLAIMED;\\n        emit PolicyClaimed(_policyId, _user);\\n    }\\n\\n    /**\\n     * @notice The payoff formula\\n     * @param _delay Delay in minutes\\n     * @return the final payoff volume\\n     */\\n    function calcPayoff(uint256 _delay) internal view returns (uint256) {\\n        uint256 payoff = 0;\\n\\n        // payoff model 1 - linear\\n        if (_delay <= DELAY_THRESHOLD_MIN) {\\n            payoff = 0;\\n        } else if (\\n            _delay > DELAY_THRESHOLD_MIN && _delay <= DELAY_THRESHOLD_MAX\\n        ) {\\n            payoff = (_delay * _delay) / 480;\\n        } else if (_delay > DELAY_THRESHOLD_MAX) {\\n            payoff = MAX_PAYOFF;\\n        }\\n\\n        payoff = payoff * 1e6;\\n        return payoff;\\n    }\\n\\n    /**\\n     * @notice Check whether the signature is valid\\n     * @param signature 65 byte array: [[v (1)], [r (32)], [s (32)]]\\n     * @param _flightNumber Flight number\\n     * @param _address userAddress\\n     * @param _premium Premium of the policy\\n     * @param _deadline Deadline of the application\\n     */\\n    function _checkSignature(\\n        bytes calldata signature,\\n        string memory _flightNumber,\\n        uint256 _departureTimestamp,\\n        uint256 _landingDate,\\n        address _address,\\n        uint256 _premium,\\n        uint256 _deadline\\n    ) internal view {\\n        sigManager.checkSignature(\\n            signature,\\n            _flightNumber,\\n            _departureTimestamp,\\n            _landingDate,\\n            _address,\\n            _premium,\\n            _deadline\\n        );\\n    }\\n}\\n\"\n    },\n    \"contracts/proxy/OwnableUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address _initialOwner) internal onlyInitializing {\\n        __Ownable_init_unchained(_initialOwner);\\n    }\\n\\n    function __Ownable_init_unchained(address _initialOwner) internal onlyInitializing {\\n        _transferOwnership( _initialOwner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\n    },\n    \"contracts/miserable-flight/interfaces/ISigManager.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface ISigManager {\\n    event SignerAdded(address indexed _newSigner);\\n    event SignerRemoved(address indexed _oldSigner);\\n\\n    function addSigner(address) external;\\n\\n    function removeSigner(address) external;\\n\\n    function isValidSigner(address) external view returns (bool);\\n\\n    function checkSignature(\\n        bytes calldata signature,\\n        string memory _flightNumber,\\n        uint256 _departureTimestamp,\\n        uint256 _landingDate,\\n        address _address,\\n        uint256 _premium,\\n        uint256 _deadline\\n    ) external view;\\n}\\n\"\n    },\n    \"contracts/miserable-flight/interfaces/IFDPolicyToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IFDPolicyToken is IERC721Enumerable {\\n    function mintPolicyToken(address _receiver) external;\\n\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n\\n    function getTokenURI(uint256 _tokenId)\\n        external\\n        view\\n        returns (string memory);\\n}\\n\"\n    },\n    \"contracts/miserable-flight/interfaces/IFlightOracle.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface IFlightOracle {\\n    function newOracleRequest(\\n        uint256 _payment,\\n        string memory _url,\\n        string memory _path,\\n        int256 times\\n    ) external returns (bytes32);\\n\\n    // Set a new url\\n    function setURL(string memory _url) external;\\n\\n    // Set the oracle address\\n    function setOracleAddress(address _newOracle) external;\\n\\n    // Set a new job id\\n    function setJobId(bytes32 _newJobId) external;\\n\\n    // Set a new policy flow\\n    function setPolicyFlow(address _policyFlow) external;\\n\\n    function getChainlinkTokenAddress() external view returns (address);\\n}\\n\"\n    },\n    \"contracts/miserable-flight/interfaces/IInsurancePool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface IInsurancePool {\\n    // view functions\\n\\n    function getUserBalance(address) external view returns (uint256);\\n\\n    function getPoolUnlocked() external view returns (uint256);\\n\\n    function getUnlockedFor(address _user) external view returns (uint256);\\n\\n    function getLockedFor(address _user) external view returns (uint256);\\n\\n    function checkCapacity(uint256 _payoff) external view returns (bool);\\n\\n    // set functions\\n\\n    function setPurchaseIncentive(uint256 _newIncentive) external;\\n\\n    function setFrozenTime(uint256 _newFrozenTime) external;\\n\\n    function setPolicyFlow(address _policyFlowAddress) external;\\n\\n    function setIncomeDistribution(uint256[3] memory _newDistribution) external;\\n\\n    function setCollateralFactor(uint256 _factor) external;\\n\\n    function transferOwnership(address _newOwner) external;\\n\\n    // main functions\\n\\n    function stake(address _user, uint256 _amount) external;\\n\\n    function unstake(uint256 _amount) external;\\n\\n    function unstakeMax() external;\\n\\n    function updateWhenBuy(\\n        uint256 _premium,\\n        uint256 _payoff,\\n        address _user\\n    ) external;\\n\\n    function updateWhenExpire(uint256 _premium, uint256 _payoff) external;\\n\\n    function payClaim(\\n        uint256 _premium,\\n        uint256 _payoff,\\n        uint256 _realPayoff,\\n        address _user\\n    ) external;\\n\\n    function revertUnstakeRequest(address _user) external;\\n\\n    function revertAllUnstakeRequest(address _user) external;\\n}\\n\"\n    },\n    \"contracts/miserable-flight/abstracts/PolicyParameters.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nabstract contract PolicyParameters {\\n    // Product parameter\\n    uint256 public constant PRODUCT_ID = 0;\\n\\n    // Parameters about the claim curve\\n    uint256 public MAX_PAYOFF = 180 * 10**6;\\n    uint256 public DELAY_THRESHOLD_MIN = 30;\\n    uint256 public DELAY_THRESHOLD_MAX = 240;\\n\\n    // Minimum time before departure for applying\\n    uint256 public MIN_TIME_BEFORE_DEPARTURE = 24 hours;\\n}\\n\"\n    },\n    \"contracts/libraries/StablecoinDecimal.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nlibrary StablecoinDecimal {\\n    function toNormal(uint256 _value) internal pure returns (uint256) {\\n        uint256 decimal_difference = 1e12;\\n        return _value / decimal_difference;\\n    }\\n\\n    function toStablecoin(uint256 _value) internal pure returns (uint256) {\\n        uint256 decimal_difference = 1e12;\\n        return _value * decimal_difference;\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\n    },\n    \"contracts/miserable-flight/SigManager.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/**\\n * @title  Signature Manager\\n * @notice Signature is used when submitting new applications.\\n *         The premium should be decided by the pricing model and be signed by a private key.\\n *         Other submissions will not be accepted.\\n *         Please keep the signer key safe.\\n */\\ncontract SigManager is Ownable {\\n    using ECDSA for bytes32;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Variables *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    mapping(address => bool) public isValidSigner;\\n\\n    bytes32 public _SUBMIT_APPLICATION_TYPEHASH;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event SignerAdded(address _newSigner);\\n    event SignerRemoved(address _oldSigner);\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    constructor() Ownable(msg.sender) {\\n        _SUBMIT_APPLICATION_TYPEHASH = keccak256(\\n            \\\"5G is great, physical lab is difficult to find\\\"\\n        );\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @dev This modifier uses assert which means this error should never happens\\n     */\\n    modifier validAddress(address _address) {\\n        assert(_address != address(0));\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Add a signer into valid signer list\\n     * @param _newSigner The new signer address\\n     */\\n    function addSigner(address _newSigner)\\n        external\\n        validAddress(_newSigner)\\n        onlyOwner\\n    {\\n        require(!isValidSigner[_newSigner], \\\"Already a signer\\\");\\n\\n        isValidSigner[_newSigner] = true;\\n\\n        emit SignerAdded(_newSigner);\\n    }\\n\\n    /**\\n     * @notice Remove a signer from the valid signer list\\n     * @param _oldSigner The old signer address to be removed\\n     */\\n    function removeSigner(address _oldSigner)\\n        external\\n        validAddress(_oldSigner)\\n        onlyOwner\\n    {\\n        require(isValidSigner[_oldSigner], \\\"Not a signer\\\");\\n\\n        isValidSigner[_oldSigner] = false;\\n\\n        emit SignerRemoved(_oldSigner);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Check signature when buying a new policy (avoid arbitrary premium amount)\\n     * @param signature 65 bytes array: [[v (1)], [r (32)], [s (32)]]\\n     * @param _flightNumber Flight number\\n     * @param _departureTimestamp Flight departure timestamp\\n     * @param _landingDate Flight landing date\\n     * @param _user User address\\n     * @param _premium Policy premium\\n     * @param _deadline Deadline of a this signature\\n     */\\n    function checkSignature(\\n        bytes calldata signature,\\n        string memory _flightNumber,\\n        uint256 _departureTimestamp,\\n        uint256 _landingDate,\\n        address _user,\\n        uint256 _premium,\\n        uint256 _deadline\\n    ) external view {\\n        bytes32 hashedFlightNumber = keccak256(bytes(_flightNumber));\\n\\n        bytes32 hashData = keccak256(\\n            abi.encodePacked(\\n                _SUBMIT_APPLICATION_TYPEHASH,\\n                hashedFlightNumber,\\n                _departureTimestamp,\\n                _landingDate,\\n                _user,\\n                _premium,\\n                _deadline\\n            )\\n        );\\n        address signer = hashData.toEthSignedMessageHash().recover(signature);\\n\\n        require(isValidSigner[signer], \\\"Only submitted by authorized signers\\\");\\n    }\\n}\\n\"\n    },\n    \"contracts/mocks/MockUSD.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/**\\n * @notice This is the MockUSD used in testnet\\n *         Maximum mint amount is 500k for each user.\\n *         Maximum mint amount for every single tx is 100k.\\n */\\ncontract MockUSD is ERC20 {\\n    uint256 public constant INITIAL_SUPPLY = 100000 * 1e6;\\n\\n    constructor() ERC20(\\\"MOCKUSD\\\", \\\"USDC\\\") {\\n        // When first deployed, give the owner some coins\\n        _mint(msg.sender, INITIAL_SUPPLY);\\n    }\\n\\n    // Everyone can mint, have fun for test\\n    function mint(address _account, uint256 _amount) public {\\n        _mint(_account, _amount);\\n    }\\n\\n    // 6 decimals to mock stablecoins\\n    function decimals() public pure override returns (uint8) {\\n        return 6;\\n    }\\n}\\n\"\n    },\n    \"contracts/mocks/MockERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/**\\n * @notice MockERC20 for test\\n * @dev MockUSD has 6 decimals, this contract is 18 decimals\\n */\\ncontract MockERC20 is ERC20 {\\n    constructor() ERC20(\\\"MockERC20\\\", \\\"ERC20\\\") {}\\n\\n    // Everyone can mint, have fun for test\\n    function mint(address _account, uint256 _amount) public {\\n        _mint(_account, _amount);\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\n    },\n    \"contracts/governance/Whitelist.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title Whitelist\\n/// @notice contains a list of wallets allowed to perform a certain operation\\ncontract Whitelist is Ownable {\\n    mapping(address => bool) internal wallets;\\n\\n    /// @notice events of approval and revoking wallets\\n    event ApproveWallet(address);\\n    event RevokeWallet(address);\\n\\n    /// @notice approves wallet\\n    /// @param _wallet the wallet to approve\\n    function approveWallet(address _wallet) external onlyOwner {\\n        if (!wallets[_wallet]) {\\n            wallets[_wallet] = true;\\n            emit ApproveWallet(_wallet);\\n        }\\n    }\\n\\n    /// @notice revokes wallet\\n    /// @param _wallet the wallet to revoke\\n    function revokeWallet(address _wallet) external onlyOwner {\\n        if (wallets[_wallet]) {\\n            wallets[_wallet] = false;\\n            emit RevokeWallet(_wallet);\\n        }\\n    }\\n\\n    /// @notice checks if _wallet is whitelisted\\n    /// @param _wallet the wallet to check\\n    /// @return true if wallet is whitelisted\\n    function check(address _wallet) external view returns (bool) {\\n        return wallets[_wallet];\\n    }\\n}\\n\"\n    },\n    \"contracts/governance/VoteEscrowedDegis.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./VeERC20Upgradeable.sol\\\";\\nimport \\\"./Whitelist.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\n\\n/**\\n * @title Vote Escrowed Degis\\n * @notice The staking contract for DEG -> veDEG, also the token used for governance.\\n * If you stake degis, you generate veDEG at the current `generationRate` until you reach `maxCap`\\n * If you unstake any amount of degis, you loose all of your veDEG.\\n * ERC721 staking does not affect generation nor cap for the moment, but it will in a future upgrade.\\n * Note that it's ownable and the owner wields tremendous power. The ownership\\n * will be transferred to a governance smart contract once Platypus is sufficiently\\n * distributed and the community can show to govern itself.\\n */\\ncontract VoteEscrowedDegis is\\n    Initializable,\\n    OwnableUpgradeable,\\n    ReentrancyGuardUpgradeable,\\n    PausableUpgradeable,\\n    VeERC20Upgradeable\\n{\\n    using SafeERC20 for IERC20;\\n\\n    struct UserInfo {\\n        // degis staked by user\\n        uint256 amount;\\n        // time of last veDEG claim or first deposit if user has not claimed yet\\n        uint256 lastRelease;\\n    }\\n\\n    // Degis token\\n    IERC20 public degis;\\n\\n    /// @notice max veDEG to staked degis ratio\\n    /// Note if user has 10 degis staked, they can only have a max of 10 * maxCap veDEG in balance\\n    uint256 public maxCap;\\n\\n    /// @notice the rate of veDEG generated per second, per degis staked\\n    uint256 public generationRate;\\n\\n    /// @notice invVvoteThreshold threshold.\\n    /// @notice voteThreshold is the tercentage of cap from which votes starts to count for governance proposals.\\n    /// @dev inverse of the threshold to apply.\\n    /// Example: th = 5% => (1/5) * 100 => invVoteThreshold = 20\\n    /// Example 2: th = 3.03% => (1/3.03) * 100 => invVoteThreshold = 33\\n    /// Formula is invVoteThreshold = (1 / th) * 100\\n    uint256 public invVoteThreshold;\\n\\n    /// @notice whitelist wallet checker\\n    /// @dev contract addresses are by default unable to stake degis, they must be previously whitelisted to stake degis\\n    Whitelist public whitelist;\\n\\n    /// @notice user info mapping\\n    mapping(address => UserInfo) public users;\\n\\n    /// @notice events describing staking, unstaking and claiming\\n    event Staked(address indexed user, uint256 indexed amount);\\n    event Unstaked(address indexed user, uint256 indexed amount);\\n    event Claimed(address indexed user, uint256 indexed amount);\\n\\n    /// @notice events describing NFT staking and unstaking\\n    event StakedNft(address indexed user, uint256 indexed nftId);\\n    event UnstakedNft(address indexed user, uint256 indexed nftId);\\n\\n    function initialize(IERC20 _degis) public initializer {\\n        require(address(_degis) != address(0), \\\"zero address\\\");\\n\\n        // Initialize veDEG\\n        __ERC20_init(\\\"Platypus Venom\\\", \\\"veDEG\\\");\\n        __Ownable_init();\\n        __ReentrancyGuard_init_unchained();\\n        __Pausable_init_unchained();\\n\\n        // set generationRate (veDEG per sec per degis staked)\\n        generationRate = 3888888888888;\\n\\n        // set maxCap\\n        maxCap = 100;\\n\\n        // set inv vote threshold\\n        // invVoteThreshold = 20 => th = 5\\n        invVoteThreshold = 20;\\n\\n        // set degis\\n        degis = _degis;\\n    }\\n\\n    /**\\n     * @dev pause pool, restricting certain operations\\n     */\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev unpause pool, enabling certain operations\\n     */\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @notice sets whitelist address\\n    /// @param _whitelist the new whitelist address\\n    function setWhitelist(Whitelist _whitelist) external onlyOwner {\\n        require(address(_whitelist) != address(0), \\\"zero address\\\");\\n        whitelist = _whitelist;\\n    }\\n\\n    /// @notice sets maxCap\\n    /// @param _maxCap the new max ratio\\n    function setMaxCap(uint256 _maxCap) external onlyOwner {\\n        require(_maxCap != 0, \\\"max cap cannot be zero\\\");\\n        maxCap = _maxCap;\\n    }\\n\\n    /// @notice sets generation rate\\n    /// @param _generationRate the new max ratio\\n    function setGenerationRate(uint256 _generationRate) external onlyOwner {\\n        require(_generationRate != 0, \\\"generation rate cannot be zero\\\");\\n        generationRate = _generationRate;\\n    }\\n\\n    /// @notice sets invVoteThreshold\\n    /// @param _invVoteThreshold the new var\\n    /// Formula is invVoteThreshold = (1 / th) * 100\\n    function setInvVoteThreshold(uint256 _invVoteThreshold) external onlyOwner {\\n        // onwner should set a high value if we do not want to implement an important threshold\\n        require(_invVoteThreshold != 0, \\\"invVoteThreshold cannot be zero\\\");\\n        invVoteThreshold = _invVoteThreshold;\\n    }\\n\\n    /// @notice checks wether user _addr has degis staked\\n    /// @param _addr the user address to check\\n    /// @return true if the user has degis in stake, false otherwise\\n    function isUser(address _addr) public view returns (bool) {\\n        return users[_addr].amount > 0;\\n    }\\n\\n    /// @notice returns staked amount of degis for user\\n    /// @param _addr the user address to check\\n    /// @return staked amount of degis\\n    function getStakeddegis(address _addr) external view returns (uint256) {\\n        return users[_addr].amount;\\n    }\\n\\n    /// @dev explicity override multiple inheritance\\n    function totalSupply()\\n        public\\n        view\\n        override(VeERC20Upgradeable)\\n        returns (uint256)\\n    {\\n        return super.totalSupply();\\n    }\\n\\n    /// @dev explicity override multiple inheritance\\n    function balanceOf(address account)\\n        public\\n        view\\n        override(VeERC20Upgradeable)\\n        returns (uint256)\\n    {\\n        return super.balanceOf(account);\\n    }\\n\\n    /// @notice deposits degis into contract\\n    /// @param _amount the amount of degis to deposit\\n    function deposit(uint256 _amount) external nonReentrant whenNotPaused {\\n        require(_amount > 0, \\\"amount to deposit cannot be zero\\\");\\n\\n        // assert call is not coming from a smart contract\\n        // unless it is whitelisted\\n        _assertNotContract(msg.sender);\\n\\n        if (isUser(msg.sender)) {\\n            // if user exists, first, claim his veDEG\\n            _claim(msg.sender);\\n            // then, increment his holdings\\n            users[msg.sender].amount += _amount;\\n        } else {\\n            // add new user to mapping\\n            users[msg.sender].lastRelease = block.timestamp;\\n            users[msg.sender].amount = _amount;\\n        }\\n\\n        // Request degis from user\\n        degis.safeTransferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    /// @notice asserts addres in param is not a smart contract.\\n    /// @notice if it is a smart contract, check that it is whitelisted\\n    /// @param _addr the address to check\\n    function _assertNotContract(address _addr) private view {\\n        if (_addr != tx.origin) {\\n            require(\\n                address(whitelist) != address(0) && whitelist.check(_addr),\\n                \\\"Smart contract depositors not allowed\\\"\\n            );\\n        }\\n    }\\n\\n    /// @notice claims accumulated veDEG\\n    function claim() external nonReentrant whenNotPaused {\\n        require(isUser(msg.sender), \\\"user has no stake\\\");\\n        _claim(msg.sender);\\n    }\\n\\n    /// @dev private claim function\\n    /// @param _addr the address of the user to claim from\\n    function _claim(address _addr) private {\\n        uint256 amount = _claimable(_addr);\\n\\n        // update last release time\\n        users[_addr].lastRelease = block.timestamp;\\n\\n        if (amount > 0) {\\n            emit Claimed(_addr, amount);\\n            _mint(_addr, amount);\\n        }\\n    }\\n\\n    /// @notice Calculate the amount of veDEG that can be claimed by user\\n    /// @param _addr the address to check\\n    /// @return amount of veDEG that can be claimed by user\\n    function claimable(address _addr) external view returns (uint256) {\\n        require(_addr != address(0), \\\"zero address\\\");\\n        return _claimable(_addr);\\n    }\\n\\n    /// @dev private claim function\\n    /// @param _addr the address of the user to claim from\\n    function _claimable(address _addr) private view returns (uint256) {\\n        UserInfo storage user = users[_addr];\\n\\n        // get seconds elapsed since last claim\\n        uint256 secondsElapsed = block.timestamp - user.lastRelease;\\n\\n        // calculate pending amount\\n        // Math.mwmul used to multiply wad numbers\\n        uint256 pending = Math.wmul(\\n            user.amount,\\n            secondsElapsed * generationRate\\n        );\\n\\n        // get user's veDEG balance\\n        uint256 userVeDEGBalance = balanceOf(_addr);\\n\\n        // user veDEG balance cannot go above user.amount * maxCap\\n        uint256 maxVeDEGCap = user.amount * maxCap;\\n\\n        // first, check that user hasn't reached the max limit yet\\n        if (userVeDEGBalance < maxVeDEGCap) {\\n            // then, check if pending amount will make user balance overpass maximum amount\\n            if ((userVeDEGBalance + pending) > maxVeDEGCap) {\\n                return maxVeDEGCap - userVeDEGBalance;\\n            } else {\\n                return pending;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    /// @notice withdraws staked degis\\n    /// @param _amount the amount of degis to unstake\\n    /// Note Beware! you will loose all of your veDEG if you unstake any amount of degis!\\n    function withdraw(uint256 _amount) external nonReentrant whenNotPaused {\\n        require(_amount > 0, \\\"amount to withdraw cannot be zero\\\");\\n        require(users[msg.sender].amount >= _amount, \\\"not enough balance\\\");\\n\\n        // reset last Release timestamp\\n        users[msg.sender].lastRelease = block.timestamp;\\n\\n        // update his balance before burning or sending back degis\\n        users[msg.sender].amount -= _amount;\\n\\n        // get user veDEG balance that must be burned\\n        uint256 userVeDEGBalance = balanceOf(msg.sender);\\n\\n        _burn(msg.sender, userVeDEGBalance);\\n\\n        // send back the staked degis\\n        degis.safeTransfer(msg.sender, _amount);\\n    }\\n\\n    /// @notice get votes for veDEG\\n    /// @dev votes should only count if account has > threshold% of current cap reached\\n    /// @dev invVoteThreshold = (1/threshold%)*100\\n    /// @return the valid votes\\n    function getVotes(address _account)\\n        external\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        uint256 veDEGBalance = balanceOf(_account);\\n\\n        // check that user has more than voting treshold of maxCap and has degis in stake\\n        if (\\n            veDEGBalance * invVoteThreshold > users[_account].amount * maxCap &&\\n            isUser(_account)\\n        ) {\\n            return veDEGBalance;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\n    },\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\n    },\n    \"contracts/governance/VeERC20Upgradeable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"./interfaces/IVeERC20.sol\\\";\\n\\n/// @title VeERC20Upgradeable\\n/// @notice Modified version of ERC20Upgradeable where transfers and allowances are disabled.\\n/// @dev only minting and burning are allowed. The hook _afterTokenOperation is called after Minting and Burning.\\ncontract VeERC20Upgradeable is Initializable, ContextUpgradeable, IVeERC20 {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    /**\\n     * @dev Emitted when `value` tokens are burned and minted\\n     */\\n    event Burn(address indexed account, uint256 value);\\n    event Mint(address indexed beneficiary, uint256 value);\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_)\\n        internal\\n        initializer\\n    {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_)\\n        internal\\n        initializer\\n    {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Mint(account, amount);\\n\\n        _afterTokenOperation(account, _balances[account]);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Burn(account, amount);\\n\\n        _afterTokenOperation(account, _balances[account]);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any minting and burning.\\n     * @param account the account being affected\\n     * @param newBalance newBalance after operation\\n     */\\n    function _afterTokenOperation(address account, uint256 newBalance)\\n        internal\\n        virtual\\n    {}\\n\\n    uint256[45] private __gap;\\n}\\n\"\n    },\n    \"contracts/governance/libraries/Math.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    uint256 public constant WAD = 10**18;\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) public pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint256 x, uint256 y) public pure returns (uint256) {\\n        return ((x * y) + (WAD / 2)) / WAD;\\n    }\\n}\\n\"\n    },\n    \"contracts/governance/interfaces/IVeERC20.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IVeERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\"\n    },\n    \"contracts/governance/interfaces/IVeDEG.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./IVeERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the VePtp\\n */\\ninterface IVePtp is IVeERC20 {\\n    function isUser(address _addr) external view returns (bool);\\n\\n    function deposit(uint256 _amount) external;\\n\\n    function claim() external;\\n\\n    function withdraw(uint256 _amount) external;\\n\\n\\n    function getStakedPtp(address _addr) external view returns (uint256);\\n\\n    function getVotes(address _account) external view returns (uint256);\\n}\\n\"\n    },\n    \"contracts/utils/interfaces/IERC20PermitWithMultipleMinters.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\n\\ninterface IERC20PermitWithMultipleMinters is IERC20, IERC20Permit {\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Functions ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n    /**\\n     * @notice Add a new minter into the minterList\\n     * @param _newMinter Address of the new minter\\n     */\\n    function addMinter(address _newMinter) external;\\n\\n    /**\\n     * @notice Remove a minter from the minterList\\n     * @param _oldMinter Address of the minter to be removed\\n     */\\n    function removeMinter(address _oldMinter) external;\\n\\n    /**\\n     * @notice Add a new burner into the burnerList\\n     * @param _newBurner Address of the new burner\\n     */\\n    function addBurner(address _newBurner) external;\\n\\n    /**\\n     * @notice Remove a minter from the minterList\\n     * @param _oldBurner Address of the minter to be removed\\n     */\\n    function removeBurner(address _oldBurner) external;\\n}\\n\"\n    },\n    \"contracts/lucky-box/DegisLottery.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./interfaces/IRandomNumberGenerator.sol\\\";\\n\\ncontract DegisLottery is ReentrancyGuard, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    IERC20 public DEGToken;\\n    IERC20 public USDToken;\\n    IRandomNumberGenerator public randomGenerator;\\n\\n    address public operatorAddress;\\n\\n    uint256 public constant TICKET_PRICE = 10 ether;\\n\\n    struct Tickets {\\n        mapping(uint256 => uint256) ticketsWeight;\\n        mapping(uint256 => uint256) ticketsAmount;\\n    }\\n    Tickets poolTickets;\\n    mapping(address => Tickets) usersTickets;\\n\\n    enum Status {\\n        Pending,\\n        Open,\\n        Close,\\n        Claimable\\n    }\\n    struct LotteryInfo {\\n        Status status;\\n        uint256 startTime;\\n        uint256 endTime;\\n        uint256[4] stageProportion;\\n        uint256[4] stageReward;\\n        uint256[4] stageAmount;\\n        uint256[4] stageWeight;\\n        uint256 totalRewards;\\n        uint256 pendingRewards;\\n        uint256 finalNumber;\\n    }\\n    mapping(uint256 => LotteryInfo) public lotteries;\\n\\n    uint256 public RewardsToNextLottery;\\n\\n    uint256 public allPendingRewards;\\n\\n    uint256 public currentLotteryId; // Total Rounds\\n\\n    mapping(address => uint256) public userCheckPoint;\\n    mapping(address => uint256) public usersTotalRewards;\\n\\n    mapping(address => mapping(uint256 => uint256)) public usersRewards;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event TicketsPurchase(\\n        address indexed buyer,\\n        uint256 indexed lotteryId,\\n        uint256 totalAmount\\n    );\\n    event TicketsRedeem(\\n        address indexed redeemer,\\n        uint256 indexed lotteryId,\\n        uint256 totalAmount\\n    );\\n    event LotteryOpen(\\n        uint256 indexed lotteryId,\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256 totalRewards\\n    );\\n    event LotteryNumberDrawn(\\n        uint256 indexed lotteryId,\\n        uint256 finalNumber,\\n        uint256 pendingRewards\\n    );\\n\\n    event ReceiveRewards(\\n        address indexed claimer,\\n        uint256 amount,\\n        uint256 indexed lotteryId\\n    );\\n\\n    event LotteryClose(uint256 indexed lotteryId);\\n\\n    event LotteryFundInjection(\\n        uint256 indexed lotteryId,\\n        uint256 injectedAmount\\n    );\\n    event RandomNumberGeneratorChanged(address randomGenerator);\\n    event OperatorAddressChanged(address operator);\\n    event AdminTokenRecovery(address indexed token, uint256 amount);\\n\\n    /**\\n     * @notice Constructor function\\n     * @dev RandomNumberGenerator must be deployed prior to this contract\\n     * @param _DEGTokenAddress Address of the DEG token (for buying tickets)\\n     * @param _USDTokenAddress Address of the USD token (for prize distribution)\\n     * @param _randomGeneratorAddress Address of the RandomGenerator contract used to work with ChainLink VRF\\n     */\\n    constructor(\\n        address _DEGTokenAddress,\\n        address _USDTokenAddress,\\n        address _randomGeneratorAddress\\n    ) Ownable(msg.sender) {\\n        DEGToken = IERC20(_DEGTokenAddress);\\n        USDToken = IERC20(_USDTokenAddress);\\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    modifier notContract() {\\n        require(!_isContract(_msgSender()), \\\"Contract not allowed\\\");\\n        require(_msgSender() == tx.origin, \\\"Proxy contract not allowed\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            _msgSender() == operatorAddress || _msgSender() == owner(),\\n            \\\"Not operator\\\"\\n        );\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    function getCurrentRoundWeight() public view returns (uint256) {\\n        return ((currentLotteryId + 24) * 1000000) / (currentLotteryId + 12);\\n    }\\n\\n    /**\\n     * @notice Get pool tickets info\\n     * @dev May be a huge number, avoid reading this frequently\\n     * @param _startIndex Start number\\n     * @param _stopIndex Stop number\\n     * @param _position Which level to check (0, 1, 2, 3), use 0 to check the 4-digit number\\n     */\\n    function getPoolTicketsInfo(\\n        uint256 _startIndex,\\n        uint256 _stopIndex,\\n        uint256 _position\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256[] memory\\n        )\\n    {\\n        uint256[] memory ticketsNumber = new uint256[](\\n            _stopIndex - _startIndex + 1\\n        );\\n        uint256[] memory ticketsAmount = new uint256[](\\n            _stopIndex - _startIndex + 1\\n        );\\n        uint256[] memory ticketsWeight = new uint256[](\\n            _stopIndex - _startIndex + 1\\n        );\\n\\n        for (uint256 i = _startIndex; i <= _stopIndex; i++) {\\n            uint256 encodedNumber = _encodedNumber(i, _position);\\n\\n            ticketsNumber[i - _startIndex] = i;\\n            ticketsAmount[i - _startIndex] = poolTickets.ticketsAmount[\\n                encodedNumber\\n            ];\\n            ticketsWeight[i - _startIndex] = poolTickets.ticketsWeight[\\n                encodedNumber\\n            ];\\n        }\\n        return (ticketsNumber, ticketsAmount, ticketsWeight);\\n    }\\n\\n    /**\\n     * @notice Get user tickets info\\n     */\\n    function getUserTicketsInfo(\\n        address user,\\n        uint256 _startIndex,\\n        uint256 _stopIndex,\\n        uint256 position\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256[] memory\\n        )\\n    {\\n        uint256 length = _stopIndex - _startIndex + 1;\\n\\n        uint256[] memory ticketsNumber = new uint256[](length);\\n        uint256[] memory ticketsAmount = new uint256[](length);\\n        uint256[] memory ticketsWeight = new uint256[](length);\\n\\n        for (uint256 i = _startIndex; i <= _stopIndex; i++) {\\n            uint256 encodedNumber = _encodedNumber(i, position);\\n            ticketsNumber[i - _startIndex] = i;\\n            ticketsAmount[i - _startIndex] = usersTickets[user].ticketsAmount[\\n                encodedNumber\\n            ];\\n            ticketsWeight[i - _startIndex] = usersTickets[user].ticketsWeight[\\n                encodedNumber\\n            ];\\n        }\\n        return (ticketsNumber, ticketsAmount, ticketsWeight);\\n    }\\n\\n    /**\\n     * @notice Get lottery stage info\\n     */\\n    function getLotteriesStageInfo(uint256 _lotteryId)\\n        external\\n        view\\n        returns (\\n            uint256[] memory stageProportion,\\n            uint256[] memory stageReward,\\n            uint256[] memory stageAmount,\\n            uint256[] memory stageWeight\\n        )\\n    {\\n        stageProportion = new uint256[](4);\\n        stageReward = new uint256[](4);\\n        stageAmount = new uint256[](4);\\n        stageWeight = new uint256[](4);\\n\\n        for (uint256 i = 0; i < 4; i++) {\\n            stageProportion[i] = lotteries[_lotteryId].stageProportion[i];\\n            stageReward[i] = lotteries[_lotteryId].stageReward[i];\\n            stageAmount[i] = lotteries[_lotteryId].stageAmount[i];\\n            stageWeight[i] = lotteries[_lotteryId].stageWeight[i];\\n        }\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Set operator, treasury, and injector addresses\\n     * @dev Only callable by the owner\\n     * @param _operatorAddress address of the operator\\n     */\\n    function setOperatorAddress(address _operatorAddress) external onlyOwner {\\n        require(_operatorAddress != address(0), \\\"Cannot be zero address\\\");\\n\\n        operatorAddress = _operatorAddress;\\n\\n        emit OperatorAddressChanged(_operatorAddress);\\n    }\\n\\n    /**\\n     * @notice Set the contract address for the RandomGenerator contract\\n     * @dev Only callable by the owner\\n     * @param _randomNumberGenerator Address of the RandomGenerator contract\\n     */\\n    function setRandomNumberGenerator(address _randomNumberGenerator)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _randomNumberGenerator != address(0),\\n            \\\"Can not be zero address\\\"\\n        );\\n\\n        randomGenerator = IRandomNumberGenerator(_randomNumberGenerator);\\n\\n        emit RandomNumberGeneratorChanged(_randomNumberGenerator);\\n    }\\n\\n    /**\\n     * @notice Change the end time of current round (only if it was set a wrong number)\\n     * @dev Normally this function is not needed\\n     * @param _endTime New end time\\n     */\\n    function setEndTime(uint256 _endTime) external onlyOwner {\\n        require(\\n            lotteries[currentLotteryId].status == Status.Open,\\n            \\\"Only change endtime when Lottery open\\\"\\n        );\\n\\n        lotteries[currentLotteryId].endTime = _endTime;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Start the lottery\\n     * @dev Callable only by operator\\n     * @param _endTime EndTime of the lottery (UNIX timestamp in s)\\n     * @param _stageProportion Breakdown of rewards per bracket\\n     * @dev Stage proportion must sum to 10,000(100 <=> 1)\\n     */\\n    function startLottery(\\n        uint256 _endTime,\\n        uint256[4] calldata _stageProportion\\n    ) external onlyOperator {\\n        require(\\n            (currentLotteryId == 0) ||\\n                (lotteries[currentLotteryId].status == Status.Claimable),\\n            \\\"Not time to start lottery\\\"\\n        );\\n\\n        require(\\n            (_stageProportion[0] +\\n                _stageProportion[1] +\\n                _stageProportion[2] +\\n                _stageProportion[3]) <= 10000,\\n            \\\"Total rewards of each bracket should <= 10000\\\"\\n        );\\n\\n        currentLotteryId++;\\n\\n        lotteries[currentLotteryId] = LotteryInfo({\\n            status: Status.Open,\\n            startTime: block.timestamp,\\n            endTime: _endTime,\\n            stageProportion: _stageProportion,\\n            stageReward: [uint256(0), uint256(0), uint256(0), uint256(0)],\\n            stageAmount: [uint256(0), uint256(0), uint256(0), uint256(0)],\\n            stageWeight: [uint256(0), uint256(0), uint256(0), uint256(0)],\\n            totalRewards: RewardsToNextLottery,\\n            pendingRewards: 0,\\n            finalNumber: 0\\n        });\\n        RewardsToNextLottery = 0;\\n\\n        emit LotteryOpen(\\n            currentLotteryId,\\n            lotteries[currentLotteryId].startTime,\\n            lotteries[currentLotteryId].endTime,\\n            lotteries[currentLotteryId].totalRewards\\n        );\\n    }\\n\\n    /**\\n     * @notice Close a lottery\\n     * @dev Callable by any address and need to meet the endtime condition\\n     * @dev Normally it's automatically called by our contract\\n     */\\n    function closeLottery() external nonReentrant {\\n        require(\\n            lotteries[currentLotteryId].status == Status.Open,\\n            \\\"Current lottery is not open\\\"\\n        );\\n\\n        require(\\n            block.timestamp >= lotteries[currentLotteryId].endTime,\\n            \\\"Not time to close lottery\\\"\\n        );\\n\\n        lotteries[currentLotteryId].endTime = block.timestamp;\\n\\n        // Request a random number from the generator\\n        randomGenerator.getRandomNumber();\\n\\n        // Update the lottery status\\n        lotteries[currentLotteryId].status = Status.Close;\\n\\n        emit LotteryClose(currentLotteryId);\\n    }\\n\\n    /**\\n     * @notice Buy tickets for the current lottery round\\n     * @dev Can not be called by a smart contract\\n     * @param _ticketNumbers array of ticket numbers between 0 and 9999\\n     * @param _ticketAmounts array of ticket amount\\n     */\\n    function buyTickets(\\n        uint256[] calldata _ticketNumbers,\\n        uint256[] calldata _ticketAmounts\\n    ) external notContract nonReentrant {\\n        require(_ticketNumbers.length != 0, \\\"No tickets are being bought\\\");\\n        require(\\n            _ticketNumbers.length == _ticketAmounts.length,\\n            \\\"Different lengths\\\"\\n        );\\n\\n        require(\\n            lotteries[currentLotteryId].status == Status.Open,\\n            \\\"Current lottery is not open\\\"\\n        );\\n\\n        if (userCheckPoint[_msgSender()] == 0) {\\n            userCheckPoint[_msgSender()] = currentLotteryId;\\n        }\\n\\n        if (userCheckPoint[_msgSender()] < currentLotteryId) {\\n            receiveRewards(currentLotteryId - 1);\\n        }\\n\\n        // Get the weight of current round (round is a global content)\\n        uint256 roundWeight = getCurrentRoundWeight();\\n\\n        // Total amount of tickets will be bought\\n        uint256 totalAmount = 0;\\n\\n        for (uint256 i = 0; i < _ticketNumbers.length; i++) {\\n            _buyTicket(\\n                poolTickets,\\n                _ticketNumbers[i],\\n                _ticketAmounts[i],\\n                roundWeight * _ticketAmounts[i]\\n            );\\n            _buyTicket(\\n                usersTickets[_msgSender()],\\n                _ticketNumbers[i],\\n                _ticketAmounts[i],\\n                roundWeight * _ticketAmounts[i]\\n            );\\n            totalAmount += _ticketAmounts[i];\\n        }\\n\\n        DEGToken.safeTransferFrom(\\n            address(_msgSender()),\\n            address(this),\\n            totalAmount * TICKET_PRICE\\n        );\\n\\n        emit TicketsPurchase(_msgSender(), currentLotteryId, totalAmount);\\n    }\\n\\n    /**\\n     * @notice Redeem tickets for all lottery\\n     * @param _ticketNumbers Array of ticket numbers\\n     * @dev Callable by users\\n     */\\n    function redeemTickets(uint256[] calldata _ticketNumbers)\\n        external\\n        notContract\\n        nonReentrant\\n    {\\n        require(_ticketNumbers.length != 0, \\\"No tickets are being redeem\\\");\\n\\n        require(\\n            lotteries[currentLotteryId].status == Status.Open,\\n            \\\"Sorry, current lottery is not open\\\"\\n        );\\n\\n        if (userCheckPoint[msg.sender] < currentLotteryId) {\\n            receiveRewards(currentLotteryId - 1);\\n        }\\n\\n        uint256 totalAmount = 0;\\n        for (uint256 i = 0; i < _ticketNumbers.length; i++) {\\n            uint256 encodedNumber = _encodedNumber(_ticketNumbers[i], 3);\\n\\n            uint256 ticketAmount = usersTickets[msg.sender].ticketsAmount[\\n                encodedNumber\\n            ];\\n            uint256 ticketWeight = usersTickets[msg.sender].ticketsWeight[\\n                encodedNumber\\n            ];\\n            _redeemTicket(\\n                poolTickets,\\n                _ticketNumbers[i],\\n                ticketAmount,\\n                ticketWeight\\n            );\\n            _redeemTicket(\\n                usersTickets[_msgSender()],\\n                _ticketNumbers[i],\\n                ticketAmount,\\n                ticketWeight\\n            );\\n            totalAmount += ticketAmount;\\n        }\\n\\n        require(totalAmount != 0, \\\"No tickets are being redeemed\\\");\\n\\n        DEGToken.safeTransfer(_msgSender(), totalAmount * TICKET_PRICE);\\n\\n        emit TicketsRedeem(_msgSender(), currentLotteryId, totalAmount);\\n    }\\n\\n    /**\\n     * @notice Inject funds\\n     * @param _amount amount to inject\\n     * @dev Callable by owner(incentive) or injector address(insurancePool income)\\n     * @dev Transfer without calling this function will not be recorded\\n     */\\n    function injectFunds(uint256 _amount) external onlyOperator nonReentrant {\\n        USDToken.safeTransferFrom(_msgSender(), address(this), _amount);\\n\\n        if (lotteries[currentLotteryId].status == Status.Open) {\\n            lotteries[currentLotteryId].totalRewards += _amount;\\n        } else RewardsToNextLottery += _amount;\\n\\n        // tag: This place may need change\\n        require(\\n            allPendingRewards + lotteries[currentLotteryId].totalRewards <=\\n                USDToken.balanceOf(address(this)),\\n            \\\"Wrong USD amount\\\"\\n        );\\n\\n        emit LotteryFundInjection(currentLotteryId, _amount);\\n    }\\n\\n    /**\\n     * @notice Draw the final number, calculate reward in DEG for each group,\\n     *         and make this lottery claimable (need to wait for the random generator)\\n     * @dev Callable by any address\\n     */\\n    function drawLottery() external nonReentrant {\\n        require(\\n            lotteries[currentLotteryId].status == Status.Close,\\n            \\\"this lottery has not closed, you should first close it\\\"\\n        );\\n        require(\\n            currentLotteryId == randomGenerator.latestLotteryId(),\\n            \\\"the final number has not been drawn\\\"\\n        );\\n\\n        // Get the final lucky numbers from randomGenerator\\n        uint256 finalNumber = randomGenerator.randomResult();\\n\\n        uint256 lastAmount = 0;\\n        uint256 lastWeight = 0;\\n\\n        LotteryInfo storage currentLottery = lotteries[currentLotteryId];\\n\\n        uint256 tempPendingRewards = 0;\\n\\n        for (uint256 j = 0; j < 4; j++) {\\n            uint256 i = 3 - j;\\n\\n            uint256 encodedNumber = _encodedNumber(finalNumber, i);\\n\\n            currentLottery.stageAmount[i] =\\n                poolTickets.ticketsAmount[encodedNumber] -\\n                lastAmount;\\n            lastAmount = poolTickets.ticketsAmount[encodedNumber];\\n\\n            currentLottery.stageWeight[i] =\\n                poolTickets.ticketsWeight[encodedNumber] -\\n                lastWeight;\\n            lastWeight = poolTickets.ticketsWeight[encodedNumber];\\n\\n            if (currentLottery.stageAmount[i] == 0)\\n                currentLottery.stageReward[i] = 0;\\n            else\\n                currentLottery.stageReward[i] =\\n                    (currentLottery.stageProportion[i] *\\n                        currentLottery.totalRewards) /\\n                    10000;\\n\\n            tempPendingRewards += currentLottery.stageReward[i];\\n        }\\n        currentLottery.pendingRewards += tempPendingRewards;\\n\\n        RewardsToNextLottery =\\n            currentLottery.totalRewards -\\n            currentLottery.pendingRewards;\\n\\n        require(\\n            allPendingRewards + currentLottery.totalRewards <=\\n                USDToken.balanceOf(address(this)),\\n            \\\"Wrong USD amount\\\"\\n        );\\n\\n        // Update internal statuses for this lottery round\\n        currentLottery.finalNumber = finalNumber;\\n        currentLottery.status = Status.Claimable;\\n\\n        // Update all pending rewards\\n        allPendingRewards += currentLottery.pendingRewards;\\n\\n        emit LotteryNumberDrawn(\\n            currentLotteryId,\\n            finalNumber, // final result for this round\\n            lotteries[currentLotteryId].pendingRewards\\n        );\\n    }\\n\\n    /**\\n     * @notice Receive award from a lottery\\n     * @param _lotteryId lottery id\\n     * @param user user address\\n     */\\n    function receiveReward(uint256 _lotteryId, address user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 award = 0;\\n        uint256 lastWeight = 0;\\n        uint256 finalNumber = lotteries[_lotteryId].finalNumber;\\n        for (uint256 j = 0; j < 4; j++) {\\n            uint256 i = 3 - j;\\n            uint256 encodedNumber = _encodedNumber(finalNumber, i);\\n            uint256 weight = usersTickets[user].ticketsWeight[encodedNumber] -\\n                lastWeight;\\n            lastWeight = usersTickets[user].ticketsWeight[encodedNumber];\\n            if (lotteries[_lotteryId].stageWeight[i] != 0) {\\n                award +=\\n                    (lotteries[_lotteryId].stageReward[i] * weight) /\\n                    lotteries[_lotteryId].stageWeight[i];\\n            }\\n        }\\n\\n        return award;\\n    }\\n\\n    /**\\n     * @notice Receive all awards from lottery before lottery id\\n     * @param _lotteryId lottery id\\n     * @dev Callable by users only, not contract!\\n     */\\n    function receiveRewards(uint256 _lotteryId) public notContract {\\n        require(\\n            lotteries[_lotteryId].status == Status.Claimable,\\n            \\\"this round of lottery are not ready for claiming\\\"\\n        );\\n\\n        require(\\n            userCheckPoint[msg.sender] <= _lotteryId,\\n            \\\"all awards have been received\\\"\\n        );\\n\\n        uint256 awards = 0;\\n\\n        for (uint256 i = userCheckPoint[msg.sender]; i <= _lotteryId; i++) {\\n            uint256 award = receiveReward(i, msg.sender);\\n            awards += award;\\n            lotteries[i].pendingRewards -= award;\\n\\n            usersRewards[msg.sender][i] = award;\\n            usersTotalRewards[msg.sender] += award;\\n        }\\n        userCheckPoint[msg.sender] = _lotteryId + 1;\\n\\n        allPendingRewards -= awards;\\n\\n        // require(awards != 0, \\\"no awards\\\");\\n\\n        // Transfer the prize to winner\\n        if (awards != 0) {\\n            USDToken.safeTransfer(msg.sender, awards);\\n        }\\n        emit ReceiveRewards(msg.sender, awards, _lotteryId);\\n    }\\n\\n    /**\\n     * @notice Recover wrong tokens sent to the contract\\n     * @dev    Only callable by the owner\\n     * @dev    All tokens except DEG and USD are wrong tokens\\n     * @param _tokenAddress the address of the token to withdraw\\n     * @param _tokenAmount token amount to withdraw\\n     */\\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount)\\n        external\\n        onlyOwner\\n    {\\n        require(_tokenAddress != address(DEGToken), \\\"Cannot recover DEG token\\\");\\n\\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\\n\\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Internal Functions ********************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Update the status to finish buying a ticket\\n     * @param tickets Tickets to update\\n     * @param _ticketNumber Original number of the ticket\\n     * @param _ticketAmount Amount of this number are being bought\\n     * @param _ticketWeight Weight of this ticket, depends on round\\n     */\\n    function _buyTicket(\\n        Tickets storage tickets,\\n        uint256 _ticketNumber,\\n        uint256 _ticketAmount,\\n        uint256 _ticketWeight\\n    ) internal {\\n        for (uint256 i = 0; i < 4; i++) {\\n            uint256 encodedNumber = _encodedNumber(_ticketNumber, i);\\n            tickets.ticketsWeight[encodedNumber] += _ticketWeight;\\n            tickets.ticketsAmount[encodedNumber] += _ticketAmount;\\n        }\\n    }\\n\\n    /**\\n     * @notice Update the status to finish redeeming a ticket\\n     * @param tickets Tickets to update\\n     * @param _ticketNumber Original number of the ticket\\n     * @param _ticketAmount Amount of this number are being redeemed\\n     * @param _ticketWeight Weight of this ticket, depends on round\\n     */\\n    function _redeemTicket(\\n        Tickets storage tickets,\\n        uint256 _ticketNumber,\\n        uint256 _ticketAmount,\\n        uint256 _ticketWeight\\n    ) internal {\\n        for (uint256 i = 0; i < 4; i++) {\\n            uint256 encodedNumber = _encodedNumber(_ticketNumber, i);\\n            tickets.ticketsWeight[encodedNumber] -= _ticketWeight;\\n            tickets.ticketsAmount[encodedNumber] -= _ticketAmount;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the encoded number form\\n     * @param _number The original number\\n     * @param _position The number's position/level (0, 1, 2, 3)\\n     */\\n    function _encodedNumber(uint256 _number, uint256 _position)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (_number % (10**(_position + 1))) + _position * 10000;\\n    }\\n\\n    /**\\n     * @notice Check if an address is a contract\\n     */\\n    function _isContract(address _addr) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    function _viewUserTicetAmount(address user, uint256 encodedNumber)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return usersTickets[user].ticketsAmount[encodedNumber];\\n    }\\n\\n    function _viewUserTicetWeight(address user, uint256 encodedNumber)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return usersTickets[user].ticketsWeight[encodedNumber];\\n    }\\n\\n    function viewUserAllTicketsInfo(address user, uint256 maxAmount)\\n        external\\n        view\\n        returns (\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256\\n        )\\n    {\\n        uint256[] memory ticketsNumber = new uint256[](maxAmount);\\n        uint256[] memory ticketsAmount = new uint256[](maxAmount);\\n        uint256[] memory ticketsWeight = new uint256[](maxAmount);\\n\\n        uint256 amount = 0;\\n        uint256 number = 0;\\n        uint256 i0 = 0;\\n        uint256 i1 = 0;\\n        uint256 i2 = 0;\\n        uint256 i3 = 0;\\n\\n        for (i0 = 0; i0 <= 9; i0++) {\\n            number = i0;\\n            if (_viewUserTicetAmount(user, _encodedNumber(number, 0)) == 0)\\n                continue;\\n            for (i1 = 0; i1 <= 9; i1++) {\\n                number = i0 + i1 * 10;\\n                if (_viewUserTicetAmount(user, _encodedNumber(number, 1)) == 0)\\n                    continue;\\n                for (i2 = 0; i2 <= 9; i2++) {\\n                    number = i0 + i1 * 10 + i2 * 100;\\n                    if (\\n                        _viewUserTicetAmount(user, _encodedNumber(number, 2)) ==\\n                        0\\n                    ) continue;\\n                    for (i3 = 0; i3 <= 9; i3++) {\\n                        number = i0 + i1 * 10 + i2 * 100 + i3 * 1000;\\n                        if (\\n                            _viewUserTicetAmount(\\n                                user,\\n                                _encodedNumber(number, 3)\\n                            ) == 0\\n                        ) continue;\\n                        ticketsNumber[amount] = number;\\n                        ticketsAmount[amount] = _viewUserTicetAmount(\\n                            user,\\n                            _encodedNumber(number, 3)\\n                        );\\n                        ticketsWeight[amount] = _viewUserTicetWeight(\\n                            user,\\n                            _encodedNumber(number, 3)\\n                        );\\n                        amount++;\\n                        if (amount >= maxAmount)\\n                            return (\\n                                ticketsNumber,\\n                                ticketsAmount,\\n                                ticketsWeight,\\n                                amount\\n                            );\\n                    }\\n                }\\n            }\\n        }\\n        return (ticketsNumber, ticketsAmount, ticketsWeight, amount);\\n    }\\n\\n    function viewUserRewardsInfo(\\n        address user,\\n        uint256 _startRound,\\n        uint256 _endRound\\n    )\\n        external\\n        view\\n        returns (\\n            uint256[] memory,\\n            uint256[] memory,\\n            uint256[] memory\\n        )\\n    {\\n        require(\\n            _startRound <= _endRound,\\n            \\\"End lottery smaller than start lottery\\\"\\n        );\\n        require(_endRound <= currentLotteryId, \\\"End lottery round not open\\\");\\n\\n        require(\\n            lotteries[_endRound].status == Status.Claimable,\\n            \\\"this round of lottery are not ready for claiming\\\"\\n        );\\n\\n        uint256[] memory lotteryIds = new uint256[](\\n            _endRound - _startRound + 1\\n        );\\n        uint256[] memory userRewards = new uint256[](\\n            _endRound - _startRound + 1\\n        );\\n        uint256[] memory userDrawed = new uint256[](\\n            _endRound - _startRound + 1\\n        );\\n        uint256 userStartLotteryId = userCheckPoint[user];\\n        for (uint256 i = _startRound; i <= _endRound; i++) {\\n            lotteryIds[i - _startRound] = i;\\n            if (i < userStartLotteryId) {\\n                userDrawed[i - _startRound] = 1;\\n                userRewards[i - _startRound] = usersRewards[user][i];\\n            } else {\\n                userDrawed[i - _startRound] = 0;\\n                userRewards[i - _startRound] = receiveReward(i, user);\\n            }\\n        }\\n        return (lotteryIds, userRewards, userDrawed);\\n    }\\n}\\n\"\n    },\n    \"contracts/lucky-box/interfaces/IRandomNumberGenerator.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\ninterface IRandomNumberGenerator {\\n    /**\\n     * @notice Views random result\\n     */\\n    function getRandomNumber() external;\\n\\n    function randomResult() external view returns (uint32);\\n\\n    function latestLotteryId() external view returns (uint256);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            Address.functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _upgradeTo(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\n    },\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/TransparentUpgradeableProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\n     */\\n    constructor(\\n        address _logic,\\n        address admin_,\\n        bytes memory _data\\n    ) payable ERC1967Proxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _changeAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        _changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeToAndCall(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _getAdmin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\n    },\n    \"contracts/proxy/ProxyAdmin.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/ProxyAdmin.sol)\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/**\\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\\n */\\ncontract ProxyAdmin is Ownable {\\n    constructor() Ownable(msg.sender) {}\\n\\n    /**\\n     * @dev Returns the current implementation of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyImplementation(TransparentUpgradeableProxy proxy)\\n        public\\n        view\\n        virtual\\n        returns (address)\\n    {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\\n            hex\\\"5c60da1b\\\"\\n        );\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the current admin of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyAdmin(TransparentUpgradeableProxy proxy)\\n        public\\n        view\\n        virtual\\n        returns (address)\\n    {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\\n            hex\\\"f851a440\\\"\\n        );\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of `proxy` to `newAdmin`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the current admin of `proxy`.\\n     */\\n    function changeProxyAdmin(\\n        TransparentUpgradeableProxy proxy,\\n        address newAdmin\\n    ) public virtual onlyOwner {\\n        proxy.changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        proxy.upgradeTo(implementation);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgradeAndCall(\\n        TransparentUpgradeableProxy proxy,\\n        address implementation,\\n        bytes memory data\\n    ) public payable virtual onlyOwner {\\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n    }\\n}\\n\"\n    },\n    \"contracts/farming/PurchaseIncentiveVault.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"../tokens/interfaces/IBuyerToken.sol\\\";\\nimport \\\"../tokens/interfaces/IDegisToken.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\nimport \\\"../utils/Pausable.sol\\\";\\n\\nimport \\\"../libraries/SafePRBMath.sol\\\";\\n\\n/**\\n * @title  Purchase Incentive Vault\\n * @notice This is the purchase incentive vault for staking buyer tokens.\\n *         Users first stake their buyer tokens and wait for distribution.\\n *         About every 24 hours, the reward will be calculated to users' account.\\n *         After disrtribution, users' reward balance will update but they still need to manually claim the reward.\\n */\\ncontract PurchaseIncentiveVault is Ownable, Pausable, ReentrancyGuard {\\n    using SafeERC20 for IBuyerToken;\\n    using SafePRBMath for uint256;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // Other contracts\\n    IBuyerToken buyerToken;\\n    IDegisToken degis;\\n\\n    // Current round number\\n    uint256 public currentRound;\\n\\n    // Degis reward per round\\n    uint256 public degisPerRound;\\n\\n    // The interval will only limit the distribution (not the staking)\\n    uint256 public distributionInterval;\\n\\n    // Last distribution block\\n    uint256 public lastDistribution;\\n\\n    uint256 public MAX_ROUND = 50;\\n\\n    struct RoundInfo {\\n        uint256 shares;\\n        address[] users;\\n        bool hasDistributed;\\n        uint256 degisPerShare;\\n    }\\n    mapping(uint256 => RoundInfo) public roundInfo;\\n\\n    struct UserInfo {\\n        uint256 lastRewardRoundIndex;\\n        uint256[] pendingRounds;\\n    }\\n    mapping(address => UserInfo) public userInfo;\\n\\n    // User address => Round number => User shares\\n    mapping(address => mapping(uint256 => uint256)) public userSharesInRound;\\n\\n    // User address => Pending rewards\\n    mapping(address => uint256) public userRewards;\\n\\n    mapping(address => uint256) public userLastRewardRound;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event DegisRewardChanged(uint256 oldPerRound, uint256 newPerRound);\\n    event DistributionIntervalChanged(uint256 oldInterval, uint256 newInterval);\\n    event MaxRoundChanged(uint256 oldMaxRound, uint256 newMaxRound);\\n    event Stake(\\n        address userAddress,\\n        uint256 currentRound,\\n        uint256 actualAmount\\n    );\\n    event Redeem(address userAddress, uint256 currentRound, uint256 amount);\\n    event RewardClaimed(address userAddress, uint256 userReward);\\n    event RoundSettled(uint256 currentRound, uint256 blockNumber);\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    constructor(address _buyerToken, address _degisToken) Ownable(msg.sender) {\\n        // Initialize two tokens\\n        buyerToken = IBuyerToken(_buyerToken);\\n        degis = IDegisToken(_degisToken);\\n\\n        // Initialize the last distribution time\\n        lastDistribution = block.timestamp;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Check if admins can distribute now\\n     * @dev Should pass the distribution interval\\n     */\\n    modifier hasPassedInterval() {\\n        require(\\n            block.timestamp - lastDistribution > distributionInterval,\\n            \\\"Two distributions should have an interval\\\"\\n        );\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Get the amount of users in _round, used for distribution\\n     * @param _round Round number to check\\n     * @return totalUsers Total amount of users in _round\\n     */\\n    function getTotalUsersInRound(uint256 _round)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return roundInfo[_round].users.length;\\n    }\\n\\n    /**\\n     * @notice Get the user addresses in _round\\n     * @param _round Round number to check\\n     * @return users All user addresses in this round\\n     */\\n    function getUsersInRound(uint256 _round)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return roundInfo[_round].users;\\n    }\\n\\n    /**\\n     * @notice Get user's pending rounds\\n     * @param _user User address to check\\n     * @return pendingRounds User's pending rounds\\n     */\\n    function getUserPendingRounds(address _user)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return userInfo[_user].pendingRounds;\\n    }\\n\\n    /**\\n     * @notice Get your shares in the current round\\n     * @param _user Address of the user\\n     */\\n    function getUserShares(address _user) public view returns (uint256) {\\n        return userSharesInRound[_user][currentRound];\\n    }\\n\\n    /**\\n     * @notice Get a user's pending reward\\n     * @return userPendingReward User's pending reward\\n     */\\n    function pendingReward() public view returns (uint256 userPendingReward) {\\n        UserInfo memory user = userInfo[_msgSender()];\\n\\n        uint256 length = user.pendingRounds.length - user.lastRewardRoundIndex;\\n        uint256 startIndex = user.lastRewardRoundIndex;\\n\\n        for (uint256 i = startIndex; i < startIndex + length; i++) {\\n            uint256 round = user.pendingRounds[i];\\n\\n            userPendingReward += roundInfo[round].degisPerShare.mul(\\n                userSharesInRound[_msgSender()][round]\\n            );\\n        }\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    function pause() external onlyOwner {\\n        super._pause();\\n    }\\n\\n    function unpause() external onlyOwner {\\n        super._unpause();\\n    }\\n\\n    /**\\n     * @notice Set degis distribution per round\\n     * @param _degisPerRound Degis distribution per round to be set\\n     */\\n    function setDegisPerRound(uint256 _degisPerRound) external onlyOwner {\\n        emit DegisRewardChanged(degisPerRound, _degisPerRound);\\n\\n        degisPerRound = _degisPerRound;\\n    }\\n\\n    /**\\n     * @notice Set a new distribution interval\\n     * @param _newInterval The new interval\\n     */\\n    function setDistributionInterval(uint256 _newInterval) external onlyOwner {\\n        emit DistributionIntervalChanged(distributionInterval, _newInterval);\\n\\n        distributionInterval = _newInterval;\\n    }\\n\\n    /**\\n     * @notice Set the max rounds to claim rewards\\n     */\\n    function setMaxRound(uint256 _maxRound) external onlyOwner {\\n        emit MaxRoundChanged(MAX_ROUND, _maxRound);\\n\\n        MAX_ROUND = _maxRound;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Stake buyer tokens into this contract\\n     * @param _amount Amount of buyer tokens to stake\\n     */\\n    function stake(uint256 _amount) external nonReentrant whenNotPaused {\\n        require(_amount > 0, \\\"Amount must be greater than 0\\\");\\n\\n        uint256 vaultBalanceBefore = buyerToken.balanceOf(address(this));\\n        buyerToken.safeTransferFrom(_msgSender(), address(this), _amount);\\n        uint256 vaultBalanceAfter = buyerToken.balanceOf(address(this));\\n\\n        uint256 actualAmount = vaultBalanceAfter - vaultBalanceBefore;\\n\\n        // If the user has not staked in this round, record this new user\\n        if (userSharesInRound[_msgSender()][currentRound] == 0) {\\n            roundInfo[currentRound].users.push(_msgSender());\\n        }\\n\\n        userSharesInRound[_msgSender()][currentRound] += actualAmount;\\n\\n        uint256 length = userInfo[_msgSender()].pendingRounds.length;\\n\\n        // Initialize the last reward round\\n        if (length == 0) userInfo[_msgSender()].lastRewardRoundIndex = 0;\\n\\n        // Only add the round if it's not in the array\\n        if (\\n            length == 0 ||\\n            (length != 0 &&\\n                userInfo[_msgSender()].pendingRounds[length - 1] !=\\n                currentRound)\\n        ) userInfo[_msgSender()].pendingRounds.push(currentRound);\\n\\n        // Update the total shares\\n        roundInfo[currentRound].shares += actualAmount;\\n\\n        emit Stake(_msgSender(), currentRound, actualAmount);\\n    }\\n\\n    /**\\n     * @notice Redeem buyer token from the vault\\n     * @param _amount Amount to redeem\\n     */\\n    function redeem(uint256 _amount) external nonReentrant whenNotPaused {\\n        require(_amount > 0, \\\"Amount must be greater than 0\\\");\\n\\n        uint256 userBalance = userSharesInRound[_msgSender()][currentRound];\\n        require(\\n            userBalance >= _amount,\\n            \\\"Not enough buyer tokens for you to redeem\\\"\\n        );\\n\\n        buyerToken.safeTransfer(_msgSender(), _amount);\\n\\n        userSharesInRound[_msgSender()][currentRound] -= _amount;\\n\\n        if (userSharesInRound[_msgSender()][currentRound] == 0) {\\n            userInfo[_msgSender()].pendingRounds.pop();\\n        }\\n\\n        roundInfo[currentRound].shares -= _amount;\\n\\n        emit Redeem(_msgSender(), currentRound, _amount);\\n    }\\n\\n    /**\\n     * @notice Setttle the current round\\n     * @dev Callable by any address, must pass the distribution interval\\n     */\\n    function settleCurrentRound() external hasPassedInterval whenNotPaused {\\n        RoundInfo storage info = roundInfo[currentRound];\\n        require(!info.hasDistributed, \\\"Already distributed\\\");\\n\\n        uint256 totalShares = info.shares;\\n\\n        // If no one staked, no reward\\n        if (totalShares == 0) info.degisPerShare = 0;\\n        else info.degisPerShare = degisPerRound.div(totalShares);\\n\\n        info.hasDistributed = true;\\n\\n        emit RoundSettled(currentRound, block.timestamp);\\n\\n        currentRound += 1;\\n        lastDistribution = block.timestamp;\\n    }\\n\\n    /**\\n     * @notice User can claim his own reward\\n     */\\n    function claimOwnReward() external nonReentrant whenNotPaused {\\n        UserInfo memory user = userInfo[_msgSender()];\\n\\n        require(user.pendingRounds.length != 0, \\\"You have no shares ever\\\");\\n\\n        uint256 roundsToClaim = user.pendingRounds.length -\\n            user.lastRewardRoundIndex;\\n\\n        require(roundsToClaim > 0, \\\"Have claimed all\\\");\\n\\n        if (user.pendingRounds[user.pendingRounds.length - 1] == currentRound) {\\n            roundsToClaim -= 1;\\n        }\\n\\n        if (roundsToClaim > MAX_ROUND) {\\n            roundsToClaim = MAX_ROUND;\\n\\n            userInfo[_msgSender()].lastRewardRoundIndex += MAX_ROUND;\\n        } else userInfo[_msgSender()].lastRewardRoundIndex += roundsToClaim;\\n\\n        uint256 userPendingReward;\\n        uint256 startIndex = user.lastRewardRoundIndex;\\n\\n        for (uint256 i = startIndex; i < startIndex + roundsToClaim; i++) {\\n            uint256 round = user.pendingRounds[i];\\n\\n            userPendingReward += roundInfo[round].degisPerShare.mul(\\n                userSharesInRound[_msgSender()][round]\\n            );\\n        }\\n\\n        degis.mintDegis(_msgSender(), userPendingReward);\\n    }\\n}\\n\"\n    },\n    \"contracts/utils/Pausable.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _isPaused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {}\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _isPaused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _isPaused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _isPaused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\n    },\n    \"contracts/farming/FarmingPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"../libraries/SafePRBMath.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"../tokens/interfaces/IDegisToken.sol\\\";\\n\\n/**\\n * @title  Farming Pool\\n * @notice This contract is for LPToken mining on Degis\\n * @dev    The pool id starts from 1 not 0\\n */\\ncontract FarmingPool is Ownable, ReentrancyGuard {\\n    using SafePRBMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IDegisToken;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // The reward token is degis\\n    IDegisToken public degis;\\n\\n    // PoolId starts from 1\\n    uint256 public _nextPoolId;\\n\\n    // Farming starts from a certain block number\\n    uint256 public startBlock;\\n\\n    struct PoolInfo {\\n        address lpToken;\\n        uint256 degisPerBlock;\\n        uint256 lastRewardBlock;\\n        uint256 accDegisPerShare;\\n    }\\n    PoolInfo[] public poolList;\\n\\n    // lptoken address => poolId\\n    mapping(address => uint256) public poolMapping;\\n\\n    // poolId => alreadyFarming\\n    mapping(uint256 => bool) public isFarming;\\n\\n    struct UserInfo {\\n        uint256 rewardDebt; // degis reward debt\\n        uint256 stakingBalance; // the amount of a user's staking in the pool\\n    }\\n    // poolId => userAddress => userInfo\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n    event StartBlockChanged(uint256 startBlock);\\n    event Stake(address staker, uint256 poolId, uint256 amount);\\n    event Withdraw(address staker, uint256 poolId, uint256 amount);\\n    event Harvest(\\n        address staker,\\n        address rewardReceiver,\\n        uint256 poolId,\\n        uint256 pendingReward\\n    );\\n    event HarvestAndCompound(\\n        address staker,\\n        uint256 poolId,\\n        uint256 pendingReward\\n    );\\n    event NewPoolAdded(address lpToken, uint256 degisPerBlock);\\n    event FarmingPoolRestarted(uint256 poolId, uint256 blockNumber);\\n    event FarmingPoolStopped(uint256 poolId, uint256 blockNumber);\\n    event DegisRewardChanged(uint256 poolId, uint256 degisPerBlock);\\n    event PoolUpdated(uint256 poolId);\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    constructor(address _degis) Ownable(msg.sender) {\\n        degis = IDegisToken(_degis);\\n\\n        // Start from 1\\n        _nextPoolId = 1;\\n\\n        // Manually fit the poolList[0] to avoid potential misleading\\n        poolList.push(\\n            PoolInfo({\\n                lpToken: address(0),\\n                degisPerBlock: 0,\\n                lastRewardBlock: 0,\\n                accDegisPerShare: 0\\n            })\\n        );\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************** Modifiers *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice The address can not be zero\\n     */\\n    modifier notZeroAddress(address _address) {\\n        assert(_address != address(0));\\n        _;\\n    }\\n\\n    /**\\n     * @notice The pool is still in farming\\n     */\\n    modifier stillFarming(uint256 _poolId) {\\n        require(isFarming[_poolId], \\\"Pool is not farming\\\");\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** View Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Check the amount of pending degis reward\\n     * @param _poolId PoolId of this farming pool\\n     * @param _user User address\\n     * @return pendingDegisAmount Amount of pending degis\\n     */\\n    function pendingDegis(uint256 _poolId, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        PoolInfo memory poolInfo = poolList[_poolId];\\n\\n        if (\\n            poolInfo.lastRewardBlock == 0 ||\\n            block.number < poolInfo.lastRewardBlock ||\\n            block.number < startBlock\\n        ) return 0;\\n\\n        UserInfo memory user = userInfo[_poolId][_user];\\n\\n        uint256 lp_balance = IERC20(poolInfo.lpToken).balanceOf(address(this));\\n\\n        uint256 accDegisPerShare = poolInfo.accDegisPerShare;\\n\\n        if (lp_balance == 0) return 0;\\n        else {\\n            // If the pool is still farming, update the info\\n            if (isFarming[_poolId]) {\\n                // Deigs amount given to this pool\\n                uint256 blocks = block.number - poolInfo.lastRewardBlock;\\n                uint256 degisReward = poolInfo.degisPerBlock * blocks;\\n\\n                // Update accDegisPerShare\\n                accDegisPerShare += degisReward.div(lp_balance);\\n            }\\n\\n            // If the pool has stopped, not update the info\\n            uint256 pending = user.stakingBalance.mul(accDegisPerShare) -\\n                user.rewardDebt;\\n\\n            return pending;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the total pool list\\n     * @return pooList Total pool list\\n     */\\n    function getPoolList() external view returns (PoolInfo[] memory) {\\n        return poolList;\\n    }\\n\\n    /**\\n     * @notice Get a user's balance\\n     * @param _poolId Id of the pool\\n     * @param _user User address\\n     * @return balance User's balance (lpToken)\\n     */\\n    function getUserBalance(uint256 _poolId, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return userInfo[_poolId][_user].stakingBalance;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Set Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Set the start block number\\n     * @param _startBlock New start block number\\n     */\\n    function setStartBlock(uint256 _startBlock) external onlyOwner {\\n        // Can only be set before any pool is added\\n        require(\\n            _nextPoolId == 1,\\n            \\\"Can not set start block after adding a pool\\\"\\n        );\\n\\n        startBlock = _startBlock;\\n        emit StartBlockChanged(_startBlock);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Main Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Add a new lp to the pool. Can only be called by the owner.\\n     * @param _lpToken LP token address\\n     * @param _degisPerBlock Reward distribution per block for this new pool\\n     * @param _withUpdate Whether update all pools' status\\n     */\\n    function add(\\n        address _lpToken,\\n        uint256 _degisPerBlock,\\n        bool _withUpdate\\n    ) public notZeroAddress(_lpToken) onlyOwner {\\n        // Check if already exists, if the poolId is 0, that means not in the pool\\n        require(\\n            !_alreadyInPool(_lpToken),\\n            \\\"This lptoken is already in the farming pool\\\"\\n        );\\n\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n\\n        uint256 lastRewardBlock = block.number > startBlock\\n            ? block.number\\n            : startBlock;\\n\\n        // Push this new pool into the list\\n        poolList.push(\\n            PoolInfo({\\n                lpToken: _lpToken,\\n                degisPerBlock: _degisPerBlock,\\n                lastRewardBlock: lastRewardBlock,\\n                accDegisPerShare: 0\\n            })\\n        );\\n\\n        // Store the poolId and set the farming status to true\\n        poolMapping[_lpToken] = _nextPoolId;\\n        isFarming[_nextPoolId] = true;\\n\\n        _nextPoolId += 1;\\n\\n        emit NewPoolAdded(_lpToken, _degisPerBlock);\\n    }\\n\\n    /**\\n     * @notice Update the degisPerBlock for a specific pool (set to 0 to stop farming)\\n     * @param _poolId Id of the farming pool\\n     * @param _degisPerBlock New reward amount per block\\n     * @param _withUpdate Whether update all the pool\\n     */\\n    function setDegisReward(\\n        uint256 _poolId,\\n        uint256 _degisPerBlock,\\n        bool _withUpdate\\n    ) public onlyOwner {\\n        // Ensure there already exists this pool\\n        require(poolList[_poolId].lastRewardBlock != 0, \\\"Pool not exists\\\");\\n\\n        if (_withUpdate) massUpdatePools();\\n        else updatePool(_poolId);\\n\\n        if (isFarming[_poolId] == false && _degisPerBlock > 0) {\\n            isFarming[_poolId] = true;\\n            emit FarmingPoolRestarted(_poolId, block.number);\\n        }\\n\\n        if (_degisPerBlock == 0) {\\n            isFarming[_poolId] = false;\\n            emit FarmingPoolStopped(_poolId, block.number);\\n        } else {\\n            poolList[_poolId].degisPerBlock = _degisPerBlock;\\n            emit DegisRewardChanged(_poolId, _degisPerBlock);\\n        }\\n    }\\n\\n    /**\\n     * @notice Stake LP token into the farming pool\\n     * @param _poolId Id of the farming pool\\n     * @param _amount Staking amount\\n     */\\n    function stake(uint256 _poolId, uint256 _amount)\\n        public\\n        nonReentrant\\n        stillFarming(_poolId)\\n    {\\n        require(_amount > 0, \\\"Can not stake zero\\\");\\n\\n        PoolInfo storage pool = poolList[_poolId];\\n        UserInfo storage user = userInfo[_poolId][_msgSender()];\\n\\n        // Must update first!!\\n        updatePool(_poolId);\\n\\n        if (user.stakingBalance > 0) {\\n            uint256 pending = user.stakingBalance.mul(pool.accDegisPerShare) -\\n                user.rewardDebt;\\n\\n            _safeDegisTransfer(_msgSender(), pending);\\n        }\\n\\n        // Check the difference before and after the stake\\n        uint256 poolBalanceBefore = IERC20(pool.lpToken).balanceOf(\\n            address(this)\\n        );\\n\\n        // Transfer the lptoken into farming pool\\n        IERC20(pool.lpToken).safeTransferFrom(\\n            _msgSender(),\\n            address(this),\\n            _amount\\n        );\\n\\n        // Check the difference before and after the stake\\n        uint256 poolBalanceAfter = IERC20(pool.lpToken).balanceOf(\\n            address(this)\\n        );\\n\\n        // Actual deposit amount\\n        uint256 actualAmount = poolBalanceAfter - poolBalanceBefore;\\n\\n        user.stakingBalance += actualAmount;\\n        user.rewardDebt = user.stakingBalance.mul(pool.accDegisPerShare);\\n\\n        emit Stake(_msgSender(), _poolId, _amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw lptoken from the pool\\n     * @param _poolId Id of the farming pool\\n     * @param _amount Amount of lp tokens to withdraw\\n     */\\n    function withdraw(uint256 _poolId, uint256 _amount) public nonReentrant {\\n        require(_amount > 0, \\\"Zero amount\\\");\\n\\n        PoolInfo storage pool = poolList[_poolId];\\n        UserInfo storage user = userInfo[_poolId][_msgSender()];\\n\\n        require(user.stakingBalance >= _amount, \\\"Not enough stakingBalance\\\");\\n\\n        if (isFarming[_poolId]) updatePool(_poolId);\\n\\n        uint256 pending = user.stakingBalance.mul(pool.accDegisPerShare) -\\n            user.rewardDebt;\\n\\n        _safeDegisTransfer(_msgSender(), pending);\\n\\n        user.stakingBalance -= _amount;\\n        user.rewardDebt = user.stakingBalance.mul(pool.accDegisPerShare);\\n\\n        IERC20(pool.lpToken).safeTransfer(_msgSender(), _amount);\\n\\n        emit Withdraw(_msgSender(), _poolId, _amount);\\n    }\\n\\n    /**\\n     * @notice Harvest the degis reward and can be sent to another address\\n     * @param _poolId Id of the farming pool\\n     * @param _to Receiver of degis rewards\\n     */\\n    function harvest(uint256 _poolId, address _to) public nonReentrant {\\n        // Only update the pool when it is still in farming\\n        if (isFarming[_poolId]) updatePool(_poolId);\\n\\n        PoolInfo memory pool = poolList[_poolId];\\n        UserInfo storage user = userInfo[_poolId][_msgSender()];\\n\\n        uint256 pendingReward = user.stakingBalance.mul(pool.accDegisPerShare) -\\n            user.rewardDebt;\\n\\n        // Effects\\n        user.rewardDebt = user.stakingBalance.mul(pool.accDegisPerShare);\\n\\n        // Interactions\\n        if (pendingReward != 0) {\\n            degis.safeTransfer(_to, pendingReward);\\n        }\\n\\n        emit Harvest(_msgSender(), _to, _poolId, pendingReward);\\n    }\\n\\n    /**\\n     * @notice Update the pool's reward status\\n     * @param _poolId Id of the farming pool\\n     */\\n    function updatePool(uint256 _poolId) public {\\n        PoolInfo storage pool = poolList[_poolId];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n\\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\\n\\n        if (lpSupply == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n\\n        uint256 blocks = block.number - pool.lastRewardBlock;\\n        uint256 degisReward = blocks * pool.degisPerBlock;\\n\\n        // Don't forget to set the farming pool as minter\\n        degis.mintDegis(address(this), degisReward);\\n\\n        pool.accDegisPerShare += degisReward.div(lpSupply);\\n\\n        pool.lastRewardBlock = block.number;\\n\\n        emit PoolUpdated(_poolId);\\n    }\\n\\n    /**\\n     * @notice Update all farming pools (except for those stopped ones)\\n     */\\n    function massUpdatePools() public {\\n        uint256 length = poolList.length;\\n        for (uint256 poolId = 0; poolId < length; poolId++) {\\n            if (isFarming[poolId] == false) continue;\\n            else updatePool(poolId);\\n        }\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ********************************** Internal Functions ********************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Check if a lptoken has been added into the pool before\\n     * @dev This can be written as a modifier, I just want to test the error form\\n     * @param _lpTokenAddress LP token address\\n     * @return _isInPool Wether this lp already in pool\\n     */\\n    function _alreadyInPool(address _lpTokenAddress)\\n        internal\\n        view\\n        returns (bool _isInPool)\\n    {\\n        uint256 poolId = poolMapping[_lpTokenAddress];\\n\\n        _isInPool = (poolId != 0) ? true : false;\\n    }\\n\\n    /**\\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\\n     * @param _to User's address\\n     * @param _amount Amount to transfer\\n     */\\n    function _safeDegisTransfer(address _to, uint256 _amount) internal {\\n        uint256 totalDegis = degis.balanceOf(address(this));\\n        if (_amount > totalDegis) {\\n            degis.transfer(_to, totalDegis);\\n        } else {\\n            degis.transfer(_to, _amount);\\n        }\\n    }\\n}\\n\"\n    },\n    \"contracts/governance/TimeLock.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (governance/TimelockController.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\n/**\\n * @dev Contract module which acts as a timelocked controller. When set as the\\n * owner of an `Ownable` smart contract, it enforces a timelock on all\\n * `onlyOwner` maintenance operations. This gives time for users of the\\n * controlled contract to exit before a potentially dangerous maintenance\\n * operation is applied.\\n *\\n * By default, this contract is self administered, meaning administration tasks\\n * have to go through the timelock process. The proposer (resp executor) role\\n * is in charge of proposing (resp executing) operations. A common use case is\\n * to position this {TimelockController} as the owner of a smart contract, with\\n * a multisig or a DAO as the sole proposer.\\n *\\n * _Available since v3.3._\\n */\\ncontract TimelockController is AccessControl {\\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\\\"TIMELOCK_ADMIN_ROLE\\\");\\n    bytes32 public constant PROPOSER_ROLE = keccak256(\\\"PROPOSER_ROLE\\\");\\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\\\"EXECUTOR_ROLE\\\");\\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\\n\\n    mapping(bytes32 => uint256) private _timestamps;\\n    uint256 private _minDelay;\\n\\n    /**\\n     * @dev Emitted when a call is scheduled as part of operation `id`.\\n     */\\n    event CallScheduled(\\n        bytes32 indexed id,\\n        uint256 indexed index,\\n        address target,\\n        uint256 value,\\n        bytes data,\\n        bytes32 predecessor,\\n        uint256 delay\\n    );\\n\\n    /**\\n     * @dev Emitted when a call is performed as part of operation `id`.\\n     */\\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\\n\\n    /**\\n     * @dev Emitted when operation `id` is cancelled.\\n     */\\n    event Cancelled(bytes32 indexed id);\\n\\n    /**\\n     * @dev Emitted when the minimum delay for future operations is modified.\\n     */\\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\\n\\n    /**\\n     * @dev Initializes the contract with a given `minDelay`.\\n     */\\n    constructor(\\n        uint256 minDelay,\\n        address[] memory proposers,\\n        address[] memory executors\\n    ) {\\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\\n\\n        // deployer + self administration\\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\\n\\n        // register proposers\\n        for (uint256 i = 0; i < proposers.length; ++i) {\\n            _setupRole(PROPOSER_ROLE, proposers[i]);\\n        }\\n\\n        // register executors\\n        for (uint256 i = 0; i < executors.length; ++i) {\\n            _setupRole(EXECUTOR_ROLE, executors[i]);\\n        }\\n\\n        _minDelay = minDelay;\\n        emit MinDelayChange(0, minDelay);\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only by a certain role. In\\n     * addition to checking the sender's role, `address(0)` 's role is also\\n     * considered. Granting a role to `address(0)` is equivalent to enabling\\n     * this role for everyone.\\n     */\\n    modifier onlyRoleOrOpenRole(bytes32 role) {\\n        if (!hasRole(role, address(0))) {\\n            _checkRole(role, _msgSender());\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Returns whether an id correspond to a registered operation. This\\n     * includes both Pending, Ready and Done operations.\\n     */\\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\\n        return getTimestamp(id) > 0;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is pending or not.\\n     */\\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\\n        return getTimestamp(id) > _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is ready or not.\\n     */\\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\\n        uint256 timestamp = getTimestamp(id);\\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is done or not.\\n     */\\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\\n        return getTimestamp(id) == _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\\n     * unset operations, 1 for done operations).\\n     */\\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\\n        return _timestamps[id];\\n    }\\n\\n    /**\\n     * @dev Returns the minimum delay for an operation to become valid.\\n     *\\n     * This value can be changed by executing an operation that calls `updateDelay`.\\n     */\\n    function getMinDelay() public view virtual returns (uint256 duration) {\\n        return _minDelay;\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a single\\n     * transaction.\\n     */\\n    function hashOperation(\\n        address target,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public pure virtual returns (bytes32 hash) {\\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a batch of\\n     * transactions.\\n     */\\n    function hashOperationBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata datas,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public pure virtual returns (bytes32 hash) {\\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a single transaction.\\n     *\\n     * Emits a {CallScheduled} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function schedule(\\n        address target,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes32 predecessor,\\n        bytes32 salt,\\n        uint256 delay\\n    ) public virtual onlyRole(PROPOSER_ROLE) {\\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\\n        _schedule(id, delay);\\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a batch of transactions.\\n     *\\n     * Emits one {CallScheduled} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function scheduleBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata datas,\\n        bytes32 predecessor,\\n        bytes32 salt,\\n        uint256 delay\\n    ) public virtual onlyRole(PROPOSER_ROLE) {\\n        require(targets.length == values.length, \\\"TimelockController: length mismatch\\\");\\n        require(targets.length == datas.length, \\\"TimelockController: length mismatch\\\");\\n\\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\\n        _schedule(id, delay);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\\n        }\\n    }\\n\\n    /**\\n     * @dev Schedule an operation that is to becomes valid after a given delay.\\n     */\\n    function _schedule(bytes32 id, uint256 delay) private {\\n        require(!isOperation(id), \\\"TimelockController: operation already scheduled\\\");\\n        require(delay >= getMinDelay(), \\\"TimelockController: insufficient delay\\\");\\n        _timestamps[id] = block.timestamp + delay;\\n    }\\n\\n    /**\\n     * @dev Cancel an operation.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\\n        require(isOperationPending(id), \\\"TimelockController: operation cannot be cancelled\\\");\\n        delete _timestamps[id];\\n\\n        emit Cancelled(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a single transaction.\\n     *\\n     * Emits a {CallExecuted} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    function execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata data,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\\n        _beforeCall(id, predecessor);\\n        _call(id, 0, target, value, data);\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a batch of transactions.\\n     *\\n     * Emits one {CallExecuted} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    function executeBatch(\\n        address[] calldata targets,\\n        uint256[] calldata values,\\n        bytes[] calldata datas,\\n        bytes32 predecessor,\\n        bytes32 salt\\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\\n        require(targets.length == values.length, \\\"TimelockController: length mismatch\\\");\\n        require(targets.length == datas.length, \\\"TimelockController: length mismatch\\\");\\n\\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\\n        _beforeCall(id, predecessor);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            _call(id, i, targets[i], values[i], datas[i]);\\n        }\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Checks before execution of an operation's calls.\\n     */\\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\\n        require(isOperationReady(id), \\\"TimelockController: operation is not ready\\\");\\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \\\"TimelockController: missing dependency\\\");\\n    }\\n\\n    /**\\n     * @dev Checks after execution of an operation's calls.\\n     */\\n    function _afterCall(bytes32 id) private {\\n        require(isOperationReady(id), \\\"TimelockController: operation is not ready\\\");\\n        _timestamps[id] = _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Execute an operation's call.\\n     *\\n     * Emits a {CallExecuted} event.\\n     */\\n    function _call(\\n        bytes32 id,\\n        uint256 index,\\n        address target,\\n        uint256 value,\\n        bytes calldata data\\n    ) private {\\n        (bool success, ) = target.call{value: value}(data);\\n        require(success, \\\"TimelockController: underlying transaction reverted\\\");\\n\\n        emit CallExecuted(id, index, target, value, data);\\n    }\\n\\n    /**\\n     * @dev Changes the minimum timelock duration for future operations.\\n     *\\n     * Emits a {MinDelayChange} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\\n     */\\n    function updateDelay(uint256 newDelay) external virtual {\\n        require(msg.sender == address(this), \\\"TimelockController: caller must be timelock\\\");\\n        emit MinDelayChange(_minDelay, newDelay);\\n        _minDelay = newDelay;\\n    }\\n}\\n\"\n    },\n    \"contracts/chainlinkMock/VRFMock.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"../lucky-box/interfaces/IDegisLottery.sol\\\";\\nimport \\\"../libraries/StringsUtils.sol\\\";\\n\\ncontract VRFMock is Ownable {\\n    using StringsUtils for uint256;\\n\\n    IDegisLottery public DegisLottery;\\n\\n    uint256 public randomResult;\\n\\n    uint256 public latestLotteryId;\\n\\n    constructor() Ownable(msg.sender) {}\\n\\n    /**\\n     * @notice Set the address for the DegisLottery\\n     * @param _degisLottery address of the PancakeSwap lottery\\n     */\\n    function setLotteryAddress(address _degisLottery) external onlyOwner {\\n        DegisLottery = IDegisLottery(_degisLottery);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Request randomness from Chainlink VRF\\n     */\\n    function getRandomNumber() external {\\n        require(_msgSender() == address(DegisLottery), \\\"Only DegisLottery\\\");\\n\\n        // TODO: This part is only for test on Fuji Testnet because there is no VRF currently\\n        string memory randInput = string(\\n            abi.encodePacked((block.timestamp).uintToString(), address(this))\\n        );\\n        randomResult = _rand(randInput) % 10000;\\n\\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\\n    }\\n\\n    function _rand(string memory input) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(input)));\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/SafePRBMathTester.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"./SafePRBMath.sol\\\";\\n\\ncontract SafePRBMathTester {\\n    function avg(uint256 x, uint256 y) public pure returns (uint256 result) {\\n        return SafePRBMath.avg(x, y);\\n    }\\n\\n    function ceil(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.ceil(x);\\n    }\\n\\n    function div(uint256 x, uint256 y) public pure returns (uint256 result) {\\n        return SafePRBMath.div(x, y);\\n    }\\n\\n    function e() public pure returns (uint256 result) {\\n        return SafePRBMath.e();\\n    }\\n\\n    function exp(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.exp(x);\\n    }\\n\\n    function exp2(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.exp2(x);\\n    }\\n\\n    function floor(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.floor(x);\\n    }\\n\\n    function frac(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.frac(x);\\n    }\\n\\n    function fromUint(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.fromUint(x);\\n    }\\n\\n    function gm(uint256 x, uint256 y) public pure returns (uint256 result) {\\n        return SafePRBMath.gm(x, y);\\n    }\\n\\n    function inv(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.inv(x);\\n    }\\n\\n    function ln(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.ln(x);\\n    }\\n\\n    function log10(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.log10(x);\\n    }\\n\\n    function log2(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.log2(x);\\n    }\\n\\n    function mul(uint256 x, uint256 y) public pure returns (uint256 result) {\\n        return SafePRBMath.mul(x, y);\\n    }\\n\\n    function pi() public pure returns (uint256 result) {\\n        return SafePRBMath.pi();\\n    }\\n\\n    function pow(uint256 x, uint256 y) public pure returns (uint256 result) {\\n        return SafePRBMath.pow(x, y);\\n    }\\n\\n    function powu(uint256 x, uint256 y) public pure returns (uint256 result) {\\n        return SafePRBMath.powu(x, y);\\n    }\\n\\n    function scale() public pure returns (uint256 result) {\\n        return SafePRBMath.scale();\\n    }\\n\\n    function sqrt(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.sqrt(x);\\n    }\\n\\n    function toUint(uint256 x) public pure returns (uint256 result) {\\n        return SafePRBMath.toUint(x);\\n    }\\n}\\n\"\n    },\n    \"contracts/EmergencyPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./utils/Ownable.sol\\\";\\n\\n/**\\n * @title  Emergency Pool\\n * @notice Emergency pool in degis will keep a reserve vault for emergency usage.\\n *         The asset comes from part of the product's income (currently 10%).\\n *         Users can also stake funds into this contract manually.\\n *         The owner has the right to withdraw funds from emergency pool and it would be passed to community governance.\\n */\\ncontract EmergencyPool is Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Variables **************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    string public name = \\\"Degis Emergency Pool\\\";\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    event Deposit(\\n        address indexed tokenAddress,\\n        address indexed userAddress,\\n        uint256 amount\\n    );\\n    event Withdraw(\\n        address indexed tokenAddress,\\n        address indexed userAddress,\\n        uint256 amount\\n    );\\n\\n    constructor() Ownable(msg.sender) {}\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Main Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Manually stake into the pool\\n     * @param _tokenAddress Address of the ERC20 token\\n     * @param _amount The amount that the user want to stake\\n     */\\n    function deposit(address _tokenAddress, uint256 _amount) external {\\n        require(_amount > 0, \\\"Amount must be greater than 0\\\");\\n\\n        IERC20(_tokenAddress).safeTransferFrom(\\n            _msgSender(),\\n            address(this),\\n            _amount\\n        );\\n\\n        emit Deposit(_tokenAddress, _msgSender(), _amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw the asset when emergency (only by the owner)\\n     * @dev The ownership need to be transferred to another contract in the future\\n     * @param _tokenAddress Address of the ERC20 token\\n     * @param _amount The amount that the user want to unstake\\n     */\\n    function emergencyWithdraw(address _tokenAddress, uint256 _amount)\\n        external\\n        onlyOwner\\n    {\\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\\n        require(_amount <= balance, \\\"Insufficient funds\\\");\\n\\n        IERC20(_tokenAddress).safeTransfer(owner(), _amount);\\n        emit Withdraw(_tokenAddress, owner(), _amount);\\n    }\\n}\\n\"\n    },\n    \"contracts/libraries/StringsUtilsTester.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"./StringsUtils.sol\\\";\\n\\ncontract StringsUtilsTester {\\n    function byToString(bytes32 _bytes) public pure returns (string memory) {\\n        return StringsUtils.byToString(_bytes);\\n    }\\n\\n    function addressToString(address _addr)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return StringsUtils.addressToString(_addr);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function uintToString(uint256 value) public pure returns (string memory) {\\n        return StringsUtils.uintToString(value);\\n    }\\n\\n    function uintToHexString(uint256 value)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return StringsUtils.uintToHexString(value);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function uintToHexString(uint256 value, uint256 length)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return StringsUtils.uintToHexString(value, length);\\n    }\\n}\\n\"\n    },\n    \"contracts/chainlinkMock/PriceFeedMock.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"../libraries/StringsUtils.sol\\\";\\n\\ncontract PriceFeedMock is Ownable {\\n    using StringsUtils for uint256;\\n\\n    struct PriceFeedInfo {\\n        address priceFeedAddress;\\n        uint256 decimals;\\n    }\\n    // Use token name (string) as the mapping key\\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\\n\\n    uint256 public roundId;\\n\\n    uint256 public result;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n    event PriceFeedChanged(\\n        string tokenName,\\n        address feedAddress,\\n        uint256 decimals\\n    );\\n\\n    event LatestPriceGet(uint256 roundID, uint256 price);\\n\\n    constructor() Ownable(msg.sender) {}\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Main Functions *********************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @dev For test, you can set the result you want\\n     */\\n    function setResult(uint256 _result) public {\\n        result = _result;\\n    }\\n\\n    /**\\n     * @notice Get latest price of a token\\n     * @param _tokenName Address of the token\\n     * @return price The latest price\\n     */\\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\\n        uint256 price = result;\\n\\n        // require(price > 0, \\\"Only accept price that > 0\\\");\\n        if (price < 0) price = 0;\\n\\n        emit LatestPriceGet(roundId, price);\\n\\n        roundId += 1;\\n\\n        uint256 finalPrice = uint256(price);\\n\\n        return finalPrice;\\n    }\\n}\\n\"\n    },\n    \"contracts/tokens/BuyerToken.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../utils/ERC20PermitWithMultipleMinters.sol\\\";\\n\\n/**\\n * @title  Buyer Token\\n * @notice Buyer tokens are distributed to buyers corresponding to the usd value they spend.\\n *         Users can deposit their buyer tokens into PurchaseIncentiveVault.\\n *         Periodical reward will be given to the participants in PurchaseIncentiveVault.\\n *         When distributing purchase incentive reward, the buyer tokens will be burned.\\n * @dev    Need to set the correct minters and burners when reploying this contract.\\n */\\ncontract BuyerToken is ERC20PermitWithMultipleMinters {\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Constructor *************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    constructor() ERC20PermitWithMultipleMinters(\\\"DegisBuyerToken\\\", \\\"DBT\\\") {}\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *********************************** Main Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Mint buyer tokens\\n     * @param  _account Receiver's address\\n     * @param  _amount Amount to be minted\\n     */\\n    function mintBuyerToken(address _account, uint256 _amount) external {\\n        mint(_account, _amount);\\n    }\\n\\n    /**\\n     * @notice Burn buyer tokens\\n     * @param  _account Receiver's address\\n     * @param  _amount Amount to be burned\\n     */\\n    function burnBuyerToken(address _account, uint256 _amount) external {\\n        burn(_account, _amount);\\n    }\\n}\\n\"\n    },\n    \"contracts/naughty-price/PriceGetter.sol\": {\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../utils/Ownable.sol\\\";\\n\\n/**\\n * @title  Price Getter\\n * @notice This is the contract for getting price feed from chainlink.\\n *         The contract will keep a record from tokenName => priceFeed Address.\\n *         Got the sponsorship and collaboration with Chainlink.\\n * @dev    The price from chainlink priceFeed has different decimals, be careful.\\n */\\ncontract PriceGetter is Ownable {\\n    struct PriceFeedInfo {\\n        address priceFeedAddress;\\n        uint256 decimals;\\n    }\\n    // Use token name (string) as the mapping key\\n    // Should set the correct orginal token name\\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Events ***************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n    event PriceFeedChanged(\\n        string tokenName,\\n        address feedAddress,\\n        uint256 decimals\\n    );\\n\\n    event LatestPriceGet(\\n        uint80 roundID,\\n        int256 price,\\n        uint256 startedAt,\\n        uint256 timeStamp,\\n        uint80 answeredInRound\\n    );\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Constructor ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Constructor function, initialize some price feed\\n     */\\n    constructor() Ownable(msg.sender) {\\n        // At first, launch three kind of pools\\n\\n        // Uncomment below when launched on Avalanche Fuji\\n        priceFeedInfo[\\\"AVAX\\\"] = PriceFeedInfo(\\n            0x0A77230d17318075983913bC2145DB16C7366156,\\n            8\\n        );\\n\\n        priceFeedInfo[\\\"ETH\\\"] = PriceFeedInfo(\\n            0x976B3D034E162d8bD72D6b9C989d545b839003b0,\\n            8\\n        );\\n\\n        priceFeedInfo[\\\"BTC\\\"] = PriceFeedInfo(\\n            0x2779D32d5166BAaa2B2b658333bA7e6Ec0C65743,\\n            8\\n        );\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // *************************************** Modifiers ************************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Can not give zero address\\n     */\\n    modifier notZeroAddress(address _address) {\\n        require(_address != address(0), \\\"Zero address\\\");\\n        _;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ View Functions ************************************ //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************ Set Functions ************************************* //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Set a price feed oracle address for a token\\n     * @param _tokenName Address of the token\\n     * @param _feedAddress Price feed oracle address\\n     * @param _decimals Decimals of this price feed service\\n     */\\n    function setPriceFeed(\\n        string memory _tokenName,\\n        address _feedAddress,\\n        uint256 _decimals\\n    ) public onlyOwner notZeroAddress(_feedAddress) {\\n        require(_decimals <= 18, \\\"Too many decimals\\\");\\n        priceFeedInfo[_tokenName] = PriceFeedInfo(_feedAddress, _decimals);\\n\\n        emit PriceFeedChanged(_tokenName, _feedAddress, _decimals);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------- //\\n    // ************************************* Main Functions *********************************** //\\n    // ---------------------------------------------------------------------------------------- //\\n\\n    /**\\n     * @notice Get latest price of a token\\n     * @param _tokenName Address of the token\\n     * @return price The latest price\\n     */\\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\\n        PriceFeedInfo memory priceFeed = priceFeedInfo[_tokenName];\\n\\n        (\\n            uint80 roundID,\\n            int256 price,\\n            uint256 startedAt,\\n            uint256 timeStamp,\\n            uint80 answeredInRound\\n        ) = AggregatorV3Interface(priceFeed.priceFeedAddress).latestRoundData();\\n\\n        // require(price > 0, \\\"Only accept price that > 0\\\");\\n        if (price < 0) price = 0;\\n\\n        emit LatestPriceGet(\\n            roundID,\\n            price,\\n            startedAt,\\n            timeStamp,\\n            answeredInRound\\n        );\\n        // Transfer the result decimals\\n        uint256 finalPrice = uint256(price) * (10**(18 - priceFeed.decimals));\\n\\n        return finalPrice;\\n    }\\n}\\n\"\n    },\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 200,\n      \"details\": {\n        \"yul\": true,\n        \"yulDetails\": {\n          \"stackAllocation\": true,\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\"\n        }\n      }\n    },\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"abi\",\n          \"evm.bytecode\",\n          \"evm.deployedBytecode\",\n          \"evm.methodIdentifiers\",\n          \"metadata\",\n          \"devdoc\",\n          \"userdoc\",\n          \"storageLayout\",\n          \"evm.gasEstimates\",\n          \"devdoc\",\n          \"userdoc\"\n        ],\n        \"\": [\n          \"ast\"\n        ]\n      }\n    },\n    \"metadata\": {\n      \"useLiteralContent\": true\n    }\n  }\n}",
      "solcInputHash": "4966e17ab068a2b2a0957b14e3f47845",
      "transactionHash": "0xc53d8ebb0d917eb0152f3e2ea4ca425f75fcbbc12d4d75d69e59540dc94013f9",
      "args": []
    },
    "decoded": {
      "from": "0x1Be1A151BA3D24F594ee971dc9B843F23b5bA80E",
      "gasPrice": "57026728648",
      "gasLimit": "559526",
      "to": null,
      "value": "0",
      "nonce": 12,
      "data": "0x608060405234801561001057600080fd5b503361001b81610021565b50610071565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6108b5806100806000396000f3fe60806040526004361061007b5760003560e01c80639623609d1161004e5780639623609d1461010b57806399a88ec41461011e578063f2fde38b1461013e578063f3b7dead1461015e57600080fd5b8063204e1c7a14610080578063715018a6146100b65780637eff275e146100cd5780638da5cb5b146100ed575b600080fd5b34801561008c57600080fd5b506100a061009b366004610505565b61017e565b6040516100ad9190610535565b60405180910390f35b3480156100c257600080fd5b506100cb610204565b005b3480156100d957600080fd5b506100cb6100e8366004610557565b610252565b3480156100f957600080fd5b506000546001600160a01b03166100a0565b6100cb61011936600461068f565b6102ed565b34801561012a57600080fd5b506100cb610139366004610557565b61038d565b34801561014a57600080fd5b506100cb6101593660046106fa565b6103f2565b34801561016a57600080fd5b506100a0610179366004610505565b61045d565b6000806000836001600160a01b03166040516101999061072c565b600060405180830381855afa9150503d80600081146101d4576040519150601f19603f3d011682016040523d82523d6000602084013e6101d9565b606091505b5091509150816101e857600080fd5b808060200190518101906101fc9190610740565b949350505050565b336102176000546001600160a01b031690565b6001600160a01b0316146102465760405162461bcd60e51b815260040161023d90610761565b60405180910390fd5b6102506000610478565b565b336102656000546001600160a01b031690565b6001600160a01b03161461028b5760405162461bcd60e51b815260040161023d90610761565b6040516308f2839760e41b81526001600160a01b03831690638f283970906102b7908490600401610535565b600060405180830381600087803b1580156102d157600080fd5b505af11580156102e5573d6000803e3d6000fd5b505050505050565b336103006000546001600160a01b031690565b6001600160a01b0316146103265760405162461bcd60e51b815260040161023d90610761565b60405163278f794360e11b81526001600160a01b03841690634f1ef28690349061035690869086906004016107fd565b6000604051808303818588803b15801561036f57600080fd5b505af1158015610383573d6000803e3d6000fd5b5050505050505050565b336103a06000546001600160a01b031690565b6001600160a01b0316146103c65760405162461bcd60e51b815260040161023d90610761565b604051631b2ce7f360e11b81526001600160a01b03831690633659cfe6906102b7908490600401610535565b336104056000546001600160a01b031690565b6001600160a01b03161461042b5760405162461bcd60e51b815260040161023d90610761565b6001600160a01b0381166104515760405162461bcd60e51b815260040161023d9061081d565b61045a81610478565b50565b6000806000836001600160a01b031660405161019990610876565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006001600160a01b0382165b92915050565b60006104d5826104c8565b6104ef816104db565b811461045a57600080fd5b80356104d5816104e6565b60006020828403121561051a5761051a600080fd5b60006101fc84846104fa565b61052f816104c8565b82525050565b602081016104d58284610526565b6104ef816104c8565b80356104d581610543565b6000806040838503121561056d5761056d600080fd5b600061057985856104fa565b925050602061058a8582860161054c565b9150509250929050565b634e487b7160e01b600052604160045260246000fd5b601f19601f830116810181811067ffffffffffffffff821117156105d0576105d0610594565b6040525050565b60006105e260405190565b90506105ee82826105aa565b919050565b600067ffffffffffffffff82111561060d5761060d610594565b601f19601f83011660200192915050565b82818337506000910152565b600061063d610638846105f3565b6105d7565b90508281526020810184848401111561065857610658600080fd5b61066384828561061e565b509392505050565b600082601f83011261067f5761067f600080fd5b81356101fc84826020860161062a565b6000806000606084860312156106a7576106a7600080fd5b60006106b386866104fa565b93505060206106c48682870161054c565b925050604084013567ffffffffffffffff8111156106e4576106e4600080fd5b6106f08682870161066b565b9150509250925092565b60006020828403121561070f5761070f600080fd5b60006101fc848461054c565b635c60da1b60e01b81525b60040190565b6105ee8161071b565b80516104d581610543565b60006020828403121561075557610755600080fd5b60006101fc8484610735565b60208082528181019081527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726040830152606082016104d5565b60005b838110156107b657818101518382015260200161079e565b838111156107c5576000848401525b50505050565b60006107d5825190565b8084526020840193506107ec81856020860161079b565b601f01601f19169290920192915050565b6040810161080b8285610526565b81810360208301526101fc81846107cb565b602080825281016104d581602681527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160208201526564647265737360d01b604082015260600190565b6303e1469160e61b8152610726565b6105ee8161086756fea2646970667358221220b2e73e40ff4f6664e6a342d26cbd1b6d2f85e1850495fb416ec82fd3c0054ba464736f6c634300080a0033",
      "r": "0x92da2c87be1a2391e315652cf3cdec316e463dbda9f1b548346c4db1026cd5a2",
      "s": "0x643979c4c403c54a20af4fc1d5423e2f28108c5dec65baf804cc305fab250338",
      "v": 86263,
      "chainId": 43114
    }
  }
}