{
  "language": "Solidity",
  "sources": {
    "contracts/chainlinkMock/PriceFeedMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"../libraries/StringsUtils.sol\";\n\ncontract PriceFeedMock is Ownable {\n    using StringsUtils for uint256;\n\n    struct PriceFeedInfo {\n        address priceFeedAddress;\n        uint256 decimals;\n    }\n    // Use token name (string) as the mapping key\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\n\n    uint256 public roundId;\n\n    uint256 public result;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event PriceFeedChanged(\n        string tokenName,\n        address feedAddress,\n        uint256 decimals\n    );\n\n    event LatestPriceGet(uint256 roundID, uint256 price);\n\n    constructor() Ownable(msg.sender) {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @dev For test, you can set the result you want\n     */\n    function setResult(uint256 _result) public {\n        result = _result;\n    }\n\n    /**\n     * @notice Get latest price of a token\n     * @param _tokenName Address of the token\n     * @return price The latest price\n     */\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\n        uint256 price = result;\n\n        // require(price > 0, \"Only accept price that > 0\");\n        if (price < 0) price = 0;\n\n        emit LatestPriceGet(roundId, price);\n\n        roundId += 1;\n\n        uint256 finalPrice = uint256(price);\n\n        return finalPrice;\n    }\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./Context.sol\";\n\n/**\n * @dev The owner can be set during deployment, not default to be msg.sender\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor(address _initialOwner) {\n        _transferOwnership(_initialOwner);\n    }\n\n    /**\n     * @notice Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @notice Leaves the contract without owner. It will not be possible to call\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * @dev    Renouncing ownership will leave the contract without an owner,\n     *         thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Can only be called by the current owner.\n     * @param  newOwner Address of the new owner\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Internal function without access restriction.\n     * @param  newOwner Address of the new owner\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/libraries/StringsUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUtils {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @notice Bytes to string (not human-readable form)\n     * @param _bytes Input bytes\n     * @return stringBytes String form of the bytes\n     */\n    function byToString(bytes32 _bytes) internal pure returns (string memory) {\n        return uintToHexString(uint256(_bytes), 32);\n    }\n\n    /**\n     * @notice Transfer address to string (not change the content)\n     * @param _addr Input address\n     * @return stringAddress String form of the address\n     */\n    function addressToString(address _addr)\n        internal\n        pure\n        returns (string memory)\n    {\n        return uintToHexString(uint256(uint160(_addr)), 20);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function uintToString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function uintToHexString(uint256 value)\n        internal\n        pure\n        returns (string memory)\n    {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return uintToHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function uintToHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/naughty-price/PolicyCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { StringsUtils } from \"../libraries/StringsUtils.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IERC20Decimals } from \"../utils/interfaces/IERC20Decimals.sol\";\nimport { IPriceGetter } from \"./interfaces/IPriceGetter.sol\";\nimport { INaughtyFactory } from \"./interfaces/INaughtyFactory.sol\";\nimport { INPPolicyToken } from \"./interfaces/INPPolicyToken.sol\";\n\n/**\n * @title  PolicyCore\n * @notice Core logic of Naughty Price Product\n *         Preset:\n *              (Done in the naughtyFactory contract)\n *              1. Deploy policyToken contract\n *              2. Deploy policyToken-Stablecoin pool contract\n *         User Interaction:\n *              1. Deposit Stablecoin and mint PolicyTokens\n *              2. Redeem their Stablecoin and burn the PolicyTokens (before settlement)\n *              3. Claim for payout with PolicyTokens (after settlement)\n *         PolicyTokens are minted with the ratio 1:1 to Stablecoin\n *         The PolicyTokens are traded in the pool with CFMM (xy=k)\n *         When the event happens, a PolicyToken can be burned for claiming 1 Stablecoin.\n *         When the event does not happen, the PolicyToken depositors can\n *         redeem their 1 deposited Stablecoin\n *\n * @dev    Most of the functions to be called from outside will use the name of policyToken\n *         rather than the address (easy to read).\n *         Other variables or functions still use address to index.\n *         The rule of policyToken naming is:\n *              Original Token Name(with decimals) + Strike Price + Lower or Higher + Date\n *         E.g.  AVAX_30.0_L_2101, BTC_30000.0_L_2102, ETH_8000.0_H_2109\n *         (the original name need to be the same as in the chainlink oracle)\n *         There are three decimals for a policy token:\n *              1. Name decimals: Only for generating the name of policyToken\n *              2. Token decimals: The decimals of the policyToken\n *                 (should be the same as the paired stablecoin)\n *              3. Price decimals: Always 18. The oracle result will be transferred for settlement\n */\n\ncontract PolicyCore is OwnableUpgradeable {\n    using StringsUtils for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant SCALE = 1e18;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Factory contract, responsible for deploying new contracts\n    INaughtyFactory public factory;\n\n    // Oracle contract, responsible for getting the final price\n    IPriceGetter public priceGetter;\n\n    // Lottery address\n    address public lottery;\n\n    // Income sharing contract address\n    address public incomeSharing;\n\n    // Naughty Router contract address\n    address public naughtyRouter;\n\n    // Contract for initial liquidity matching\n    // solhint-disable-next-line var-name-mixedcase\n    address public ILMContract;\n\n    // Income to lottery ratio (max 10)\n    uint256 public toLotteryPart;\n\n    struct PolicyTokenInfo {\n        address policyTokenAddress;\n        bool isCall;\n        uint256 nameDecimals; // decimals of the name generation\n        uint256 tokenDecimals; // decimals of the policy token\n        uint256 strikePrice;\n        uint256 deadline;\n        uint256 settleTimestamp;\n    }\n    // Policy token name => Policy token information\n    mapping(string => PolicyTokenInfo) public policyTokenInfoMapping;\n\n    // Policy token address => Policy token name\n    mapping(address => string) public policyTokenAddressToName;\n\n    // Policy token name list\n    string[] public allPolicyTokens;\n\n    // Stablecoin address => Supported or not\n    mapping(address => bool) public supportedStablecoin;\n\n    // Policy token address => Stablecoin address\n    mapping(address => address) public whichStablecoin;\n\n    // PolicyToken => Strike Token (e.g. AVAX30L202101 address => AVAX address)\n    mapping(address => string) internal policyTokenToOriginal;\n\n    // User Address => Token Address => User Quota Amount\n    mapping(address => mapping(address => uint256)) internal userQuota;\n\n    struct SettlementInfo {\n        uint256 price;\n        bool isHappened;\n        bool alreadySettled;\n        uint256 currentDistributionIndex;\n    }\n    // Policy token address => Settlement result information\n    mapping(address => SettlementInfo) public settleResult;\n\n    // Stalecoin address => Pending income amount\n    mapping(address => uint256) public pendingIncomeToLottery;\n    mapping(address => uint256) public pendingIncomeToSharing;\n\n    // IDO pool record and ido price getter contract\n    mapping(string => bool) public isIDOPool;\n    IPriceGetter public idoPriceGetter;\n\n    // Arbitrary pool means the oracle is from a specific contract function\n    mapping(string => bool) public isArbitraryPool;\n    IPriceGetter public arbitraryPriceGetter;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Events ******************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event LotteryChanged(address oldLotteryAddress, address newLotteryAddress);\n    event IncomeSharingChanged(\n        address oldIncomeSharing,\n        address newIncomeSharing\n    );\n    event NaughtyRouterChanged(address oldRouter, address newRouter);\n    event ILMChanged(address oldILM, address newILM);\n    event IncomeToLotteryChanged(uint256 oldToLottery, uint256 newToLottery);\n    event PolicyTokenDeployed(\n        string tokenName,\n        address tokenAddress,\n        uint256 tokenDecimals,\n        uint256 deadline,\n        uint256 settleTimestamp\n    );\n    event PoolDeployed(\n        address poolAddress,\n        address policyTokenAddress,\n        address stablecoin\n    );\n    event Deposit(\n        address indexed userAddress,\n        string indexed policyTokenName,\n        address indexed stablecoin,\n        uint256 amount\n    );\n    event DelegateDeposit(\n        address payerAddress,\n        address userAddress,\n        string policyTokenName,\n        address stablecoin,\n        uint256 amount\n    );\n    event Redeem(\n        address indexed userAddress,\n        string indexed policyTokenName,\n        address indexed stablecoin,\n        uint256 amount\n    );\n    event RedeemAfterSettlement(\n        address indexed userAddress,\n        string indexed policyTokenName,\n        address indexed stablecoin,\n        uint256 amount\n    );\n    event FinalResultSettled(\n        string _policyTokenName,\n        uint256 price,\n        bool isHappened\n    );\n    event NewStablecoinAdded(address _newStablecoin);\n    event UpdateUserQuota(\n        address user,\n        address policyTokenAddress,\n        uint256 amount\n    );\n    event IDOPriceGetterChanged(address oldPriceGetter, address newPriceGetter);\n    event ArbitraryPriceGetterChanged(\n        address oldArbitraryPriceGetter,\n        address newArbitraryPriceGetter\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor, for some addresses\n     *\n     * @param _factory     Address of naughty factory\n     * @param _priceGetter Address of the oracle contract\n     */\n    function initialize(\n        address _factory,\n        address _priceGetter\n    ) public initializer {\n        __Ownable_init();\n\n        factory = INaughtyFactory(_factory);\n        priceGetter = IPriceGetter(_priceGetter);\n\n        // 20% to lottery, 80% to income sharing\n        toLotteryPart = 2;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if this stablecoin is supported\n     * @param _stablecoin Stablecoin address\n     */\n    modifier validStablecoin(address _stablecoin) {\n        require(\n            supportedStablecoin[_stablecoin] == true,\n            \"Stablecoin not support\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Check whether the policy token is paired with this stablecoin\n     * @param _policyTokenName Policy token name\n     * @param _stablecoin      Stablecoin address\n     */\n    modifier validPolicyTokenWithStablecoin(\n        string memory _policyTokenName,\n        address _stablecoin\n    ) {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n        require(\n            whichStablecoin[policyTokenAddress] == _stablecoin,\n            \"Invalid policytoken&stablecoin\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Check if the policy token has been deployed, used when deploying pools\n     * @param _policyTokenName Name of the policy token inside the pair\n     */\n    modifier deployedPolicy(string memory _policyTokenName) {\n        require(\n            policyTokenInfoMapping[_policyTokenName].policyTokenAddress !=\n                address(0),\n            \"Policytoken not deployed\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Deposit/Redeem/Swap only before deadline\n     * @dev Each pool will also have this deadline\n     *      That needs to be set inside naughtyFactory\n     * @param _policyTokenName Name of the policy token\n     */\n    modifier beforeDeadline(string memory _policyTokenName) {\n        uint256 deadline = policyTokenInfoMapping[_policyTokenName].deadline;\n        require(block.timestamp <= deadline, \"Deadline passed\");\n        _;\n    }\n\n    /**\n     * @notice Can only settle the result after the \"_settleTimestamp\"\n     * @param _policyTokenName Name of the policy token\n     */\n    modifier afterSettlement(string memory _policyTokenName) {\n        uint256 settleTimestamp = policyTokenInfoMapping[_policyTokenName]\n            .settleTimestamp;\n        require(block.timestamp >= settleTimestamp, \"Not reach settle time\");\n        _;\n    }\n\n    /**\n     * @notice Avoid multiple settlements\n     * @param _policyTokenName Name of the policy token\n     */\n    modifier notAlreadySettled(string memory _policyTokenName) {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n        require(\n            settleResult[policyTokenAddress].alreadySettled == false,\n            \"Already settled\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Find the token address by its name\n     * @param _policyTokenName Name of the policy token (e.g. \"AVAX_30_L_2103\")\n     * @return policyTokenAddress Address of the policy token\n     */\n    function findAddressbyName(\n        string memory _policyTokenName\n    ) public view returns (address policyTokenAddress) {\n        policyTokenAddress = policyTokenInfoMapping[_policyTokenName]\n            .policyTokenAddress;\n\n        require(policyTokenAddress != address(0), \"Policy token not found\");\n    }\n\n    /**\n     * @notice Find the token name by its address\n     * @param _policyTokenAddress Address of the policy token\n     * @return policyTokenName Name of the policy token\n     */\n    function findNamebyAddress(\n        address _policyTokenAddress\n    ) public view returns (string memory policyTokenName) {\n        policyTokenName = policyTokenAddressToName[_policyTokenAddress];\n\n        require(bytes(policyTokenName).length > 0, \"Policy name not found\");\n    }\n\n    /**\n     * @notice Find the token information by its name\n     * @param _policyTokenName Name of the policy token (e.g. \"AVAX30L202103\")\n     * @return policyTokenInfo PolicyToken detail information\n     */\n    function getPolicyTokenInfo(\n        string memory _policyTokenName\n    ) public view returns (PolicyTokenInfo memory) {\n        return policyTokenInfoMapping[_policyTokenName];\n    }\n\n    /**\n     * @notice Get a user's quota for a certain policy token\n     * @param _user               Address of the user to be checked\n     * @param _policyTokenAddress Address of the policy token\n     * @return _quota User's quota result\n     */\n    function getUserQuota(\n        address _user,\n        address _policyTokenAddress\n    ) external view returns (uint256 _quota) {\n        _quota = userQuota[_user][_policyTokenAddress];\n    }\n\n    /**\n     * @notice Get the information about all the tokens\n     * @dev Include all active&expired tokens\n     * @return tokensInfo Token information list\n     */\n    function getAllTokens() external view returns (PolicyTokenInfo[] memory) {\n        uint256 length = allPolicyTokens.length;\n        PolicyTokenInfo[] memory tokensInfo = new PolicyTokenInfo[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            tokensInfo[i] = policyTokenInfoMapping[allPolicyTokens[i]];\n        }\n\n        return tokensInfo;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new supported stablecoin\n     * @param _newStablecoin Address of the new stablecoin\n     */\n    function addStablecoin(address _newStablecoin) external onlyOwner {\n        supportedStablecoin[_newStablecoin] = true;\n        emit NewStablecoinAdded(_newStablecoin);\n    }\n\n    /**\n     * @notice Change the address of lottery\n     * @param _lotteryAddress Address of the new lottery\n     */\n    function setLottery(address _lotteryAddress) external onlyOwner {\n        emit LotteryChanged(lottery, _lotteryAddress);\n        lottery = _lotteryAddress;\n    }\n\n    /**\n     * @notice Change the address of emergency pool\n     * @param _incomeSharing Address of the new incomeSharing\n     */\n    function setIncomeSharing(address _incomeSharing) external onlyOwner {\n        emit IncomeSharingChanged(incomeSharing, _incomeSharing);\n        incomeSharing = _incomeSharing;\n    }\n\n    /**\n     * @notice Change the address of naughty router\n     * @param _router Address of the new naughty router\n     */\n    function setNaughtyRouter(address _router) external onlyOwner {\n        emit NaughtyRouterChanged(naughtyRouter, _router);\n        naughtyRouter = _router;\n    }\n\n    /**\n     * @notice Change the address of ILM\n     * @param _ILM Address of the new ILM\n     */\n    function setILMContract(address _ILM) external onlyOwner {\n        emit ILMChanged(ILMContract, _ILM);\n        ILMContract = _ILM;\n    }\n\n    /**\n     * @notice Change the income part to lottery\n     * @dev The remaining part will be distributed to incomeSharing\n     * @param _toLottery Proportion to lottery\n     */\n    function setIncomeToLottery(uint256 _toLottery) external onlyOwner {\n        require(_toLottery <= 10, \"Max 10\");\n        emit IncomeToLotteryChanged(toLotteryPart, _toLottery);\n        toLotteryPart = _toLottery;\n    }\n\n    /**\n     * @notice Set IDO price getter contract\n     * @param _idoPriceGetter Address of the new IDO price getter contract\n     */\n    function setIDOPriceGetter(address _idoPriceGetter) external onlyOwner {\n        emit IDOPriceGetterChanged(address(idoPriceGetter), _idoPriceGetter);\n        idoPriceGetter = IPriceGetter(_idoPriceGetter);\n    }\n\n    function setArbitraryPriceGetter(\n        address _arbitraryPriceGetter\n    ) external onlyOwner {\n        emit ArbitraryPriceGetterChanged(\n            address(arbitraryPriceGetter),\n            _arbitraryPriceGetter\n        );\n        arbitraryPriceGetter = IPriceGetter(_arbitraryPriceGetter);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy a new policy token and return the token address.\n     * @dev Only the owner can deploy new policy tokens.\n     *      The name form is like \"Token_Price_Direction_Date\" (\"AVAX_50_L_2203\") and is built inside the contract.\n     *      Name decimals and token decimals are different here.\n     *\n     *      Token decimals = Stablecoin decimals\n     *\n     *      For normal tokens: The original token name should be the same in Chainlink PriceFeeds.\n     *                         Those tokens that are not listed on Chainlink are not supported.\n     *      For DEX tokens:    The original token should have a valid DEX pair and be manually set in IDOPriceGetter.\n     *      For arbitrary tokens: The original token's price source should be manually set in ArbitraryPriceGetter.\n     *\n     * @param _tokenName       Name of the original token (e.g. AVAX, BTC, ETH...)\n     * @param _stablecoin      Address of the stablecoin (check decimals here, should be the same stablecoin when deploying pools)\n     * @param _isCall          The policy is for higher or lower than the strike price (call / put)\n     * @param _nameDecimals    Decimals of this token's name (0~18)\n     * @param _tokenDecimals   Decimals of this token's value (0~18) (same as paired stablecoin)\n     * @param _strikePrice     Strike price of the policy (have already been transferred with 1e18)\n     * @param _round           Round of the token (e.g. 2203 -> expired at 22 March)\n     * @param _deadline        Deadline of this policy token (deposit / redeem / swap)\n     * @param _settleTimestamp Can settle after this timestamp (for oracle)\n     * @param _poolType        _poolType: 0 normal 1 IDO 2 arbitrary\n     */\n    function deployPolicyToken(\n        string memory _tokenName,\n        address _stablecoin,\n        bool _isCall,\n        uint256 _nameDecimals,\n        uint256 _tokenDecimals,\n        uint256 _strikePrice,\n        string memory _round,\n        uint256 _deadline,\n        uint256 _settleTimestamp,\n        uint256 _poolType\n    ) external onlyOwner {\n        require(\n            _nameDecimals <= 18 && _tokenDecimals <= 18,\n            \"Too many decimals\"\n        );\n        require(\n            IERC20Decimals(_stablecoin).decimals() == _tokenDecimals,\n            \"Decimals not paired\"\n        );\n\n        require(_deadline > block.timestamp, \"Wrong deadline\");\n        require(_settleTimestamp >= _deadline, \"Wrong settleTimestamp\");\n\n        // Generate the policy token name\n        string memory policyTokenName = _generateName(\n            _tokenName,\n            _nameDecimals,\n            _strikePrice,\n            _isCall,\n            _round\n        );\n        // Deploy a new policy token by the factory contract\n        address policyTokenAddress = factory.deployPolicyToken(\n            policyTokenName,\n            _tokenDecimals\n        );\n\n        // Store the policyToken information in the mapping\n        policyTokenInfoMapping[policyTokenName] = PolicyTokenInfo(\n            policyTokenAddress,\n            _isCall,\n            _nameDecimals,\n            _tokenDecimals,\n            _strikePrice,\n            _deadline,\n            _settleTimestamp\n        );\n\n        // Keep the record from policy token to original token\n        policyTokenToOriginal[policyTokenAddress] = _tokenName;\n\n        // Record the address to name mapping\n        policyTokenAddressToName[policyTokenAddress] = policyTokenName;\n\n        // Push the policytokenName into the list\n        allPolicyTokens.push(policyTokenName);\n\n        emit PolicyTokenDeployed(\n            policyTokenName,\n            policyTokenAddress,\n            _tokenDecimals,\n            _deadline,\n            _settleTimestamp\n        );\n\n        // Record if it is a IDO pool or arbitrary pool\n        if (_poolType == 1) {\n            isIDOPool[policyTokenName] = true;\n        } else if (_poolType == 2) {\n            isArbitraryPool[policyTokenName] = true;\n        }\n    }\n\n    /**\n     * @notice Deploy a new pair (pool).\n     *         The policy token should be already deployed.\n     *         Caller can be the owner or ILM contract.\n     *\n     * @param _policyTokenName Name of the policy token.\n     * @param _stablecoin      Address of the stable coin.\n     * @param _poolDeadline    Swapping deadline of the pool (normally the same as the token's deadline).\n     * @param _feeRate         Fee rate given to LP holders.\n     */\n    function deployPool(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _poolDeadline,\n        uint256 _feeRate\n    )\n        external\n        validStablecoin(_stablecoin)\n        deployedPolicy(_policyTokenName)\n        returns (address)\n    {\n        require(\n            msg.sender == owner() || msg.sender == ILMContract,\n            \"Only owner or ILM\"\n        );\n\n        require(_poolDeadline > block.timestamp, \"Wrong deadline\");\n        require(\n            _poolDeadline == policyTokenInfoMapping[_policyTokenName].deadline,\n            \"Different deadline\"\n        );\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        address poolAddress = _deployPool(\n            policyTokenAddress,\n            _stablecoin,\n            _poolDeadline,\n            _feeRate\n        );\n\n        emit PoolDeployed(poolAddress, policyTokenAddress, _stablecoin);\n\n        return poolAddress;\n    }\n\n    /**\n     * @notice Deposit stablecoins and get policy tokens\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin      Address of the stable coin\n     * @param _amount          Amount of stablecoin\n     */\n    function deposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    )\n        public\n        beforeDeadline(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        require(_amount > 0, \"Zero Amount\");\n        _deposit(_policyTokenName, _stablecoin, _amount, msg.sender);\n    }\n\n    /**\n     * @notice Delegate deposit (deposit and mint for other addresses)\n     * @dev Only called by the router contract\n     *\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin      Address of the sable coin\n     * @param _amount          Amount of stablecoin\n     * @param _user            Address to receive the policy tokens\n     */\n    function delegateDeposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    )\n        external\n        beforeDeadline(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        require(msg.sender == naughtyRouter, \"Only router can delegate\");\n        require(_amount > 0, \"Zero Amount\");\n\n        _deposit(_policyTokenName, _stablecoin, _amount, _user);\n\n        emit DelegateDeposit(\n            msg.sender,\n            _user,\n            _policyTokenName,\n            _stablecoin,\n            _amount\n        );\n    }\n\n    /**\n     * @notice Burn policy tokens and redeem stablecoins\n     * @dev Redeem happens before the deadline and is different from claim/settle\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin      Address of the stablecoin\n     * @param _amount          Amount to redeem\n     */\n    function redeem(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    )\n        public\n        beforeDeadline(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Check if the user has enough quota (quota is only for those who mint policy tokens)\n        require(\n            userQuota[msg.sender][policyTokenAddress] >= _amount,\n            \"User's quota not sufficient\"\n        );\n\n        // Update quota\n        userQuota[msg.sender][policyTokenAddress] -= _amount;\n\n        // Charge 1% Fee when redeem / claim\n        uint256 amountWithFee = _chargeFee(_stablecoin, _amount);\n\n        // Transfer back the stablecoin\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\n\n        // Burn the policy tokens\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\n        policyToken.burn(msg.sender, _amount);\n\n        emit Redeem(msg.sender, _policyTokenName, _stablecoin, _amount);\n    }\n\n    /**\n     * @notice Redeem policy tokens and get stablecoins by the user himeself\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin      Address of the stablecoin\n     */\n    function redeemAfterSettlement(\n        string memory _policyTokenName,\n        address _stablecoin\n    )\n        public\n        afterSettlement(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Copy to memory (will not change the result)\n        SettlementInfo memory result = settleResult[policyTokenAddress];\n\n        // Must have got the final price\n        require(\n            result.price != 0 && result.alreadySettled,\n            \"Have not got the oracle result\"\n        );\n\n        require(result.isHappened == false, \"Event must not happen\");\n\n        uint256 quota = userQuota[msg.sender][policyTokenAddress];\n        // User must have quota because this is for depositors when event not happens\n        require(quota > 0, \"No quota\");\n\n        // Charge 1% Fee when redeem / claim\n        uint256 amountWithFee = _chargeFee(_stablecoin, quota);\n\n        // Send back stablecoins directly\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\n\n        // Delete the userQuota storage\n        delete userQuota[msg.sender][policyTokenAddress];\n\n        emit RedeemAfterSettlement(\n            msg.sender,\n            _policyTokenName,\n            _stablecoin,\n            amountWithFee\n        );\n    }\n\n    /**\n     * @notice Claim a payoff based on policy tokens\n     * @dev It is done after result settlement and only if the result is true\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin      Address of the stable coin\n     * @param _amount          Amount of stablecoin\n     */\n    function claim(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    )\n        public\n        afterSettlement(_policyTokenName)\n        validPolicyTokenWithStablecoin(_policyTokenName, _stablecoin)\n    {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Copy to memory (will not change the result)\n        SettlementInfo memory result = settleResult[policyTokenAddress];\n\n        // Check if we have already settle the final price\n        require(\n            result.price != 0 && result.alreadySettled,\n            \"Have not got the oracle result\"\n        );\n\n        // Check if the event happens\n        require(result.isHappened, \"Event must happen\");\n\n        // Charge 1% fee\n        uint256 amountWithFee = _chargeFee(_stablecoin, _amount);\n\n        IERC20(_stablecoin).safeTransfer(msg.sender, amountWithFee);\n\n        // Users must have enough policy tokens to claim\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\n\n        // Burn the policy tokens\n        policyToken.burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Get the final price from the PriceGetter contract\n     * @param _policyTokenName Name of the policy token\n     */\n    function settleFinalResult(\n        string memory _policyTokenName\n    )\n        public\n        afterSettlement(_policyTokenName)\n        notAlreadySettled(_policyTokenName)\n    {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        SettlementInfo storage result = settleResult[policyTokenAddress];\n\n        // Get the strike token name\n        string memory originalTokenName = policyTokenToOriginal[\n            policyTokenAddress\n        ];\n\n        uint256 finalPrice;\n        // Get the final price from oracle\n        if (isIDOPool[_policyTokenName]) {\n            finalPrice = idoPriceGetter.getLatestPrice(_policyTokenName);\n        } else if (isArbitraryPool[_policyTokenName]) {\n            finalPrice = arbitraryPriceGetter.getLatestPrice(_policyTokenName);\n        } else {\n            finalPrice = priceGetter.getLatestPrice(originalTokenName);\n        }\n\n        // Record the price\n        result.alreadySettled = true;\n        result.price = finalPrice;\n\n        PolicyTokenInfo memory policyTokenInfo = policyTokenInfoMapping[\n            _policyTokenName\n        ];\n\n        // Get the final result\n        bool situationT1 = (finalPrice >= policyTokenInfo.strikePrice) &&\n            policyTokenInfo.isCall;\n        bool situationT2 = (finalPrice <= policyTokenInfo.strikePrice) &&\n            !policyTokenInfo.isCall;\n\n        bool isHappened = (situationT1 || situationT2) ? true : false;\n\n        // Record the result\n        result.isHappened = isHappened;\n\n        emit FinalResultSettled(_policyTokenName, finalPrice, isHappened);\n    }\n\n    /**\n     * @notice Collect the income\n     * @dev Can be done by anyone, only when there is some income to be distributed\n     *      For each stablecoin, this function need to called separately\n     *\n     * @param _stablecoin Address of stablecoin\n     */\n    function collectIncome(address _stablecoin) public {\n        require(\n            lottery != address(0) && incomeSharing != address(0),\n            \"Not set lottery/incomeSharing\"\n        );\n\n        uint256 amountToLottery = pendingIncomeToLottery[_stablecoin];\n        uint256 amountToSharing = pendingIncomeToSharing[_stablecoin];\n        require(\n            amountToLottery > 0 || amountToSharing > 0,\n            \"No pending income\"\n        );\n\n        IERC20(_stablecoin).safeTransfer(lottery, amountToLottery);\n        IERC20(_stablecoin).safeTransfer(incomeSharing, amountToSharing);\n\n        pendingIncomeToLottery[_stablecoin] = 0;\n        pendingIncomeToSharing[_stablecoin] = 0;\n    }\n\n    /**\n     * @notice Update user quota from ILM when claim\n     *\n     * @dev When you claim your liquidity from ILM, you will get normal quota as you are using policyCore\n     * @param _user        User address\n     * @param _policyToken PolicyToken address\n     * @param _amount      Quota amount\n     */\n    function updateUserQuota(\n        address _user,\n        address _policyToken,\n        uint256 _amount\n    ) external {\n        require(msg.sender == ILMContract, \"Only ILM\");\n\n        userQuota[_user][_policyToken] += _amount;\n\n        emit UpdateUserQuota(_user, _policyToken, _amount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Finish deploying a pool\n     *\n     * @param _policyTokenAddress Address of the policy token\n     * @param _stablecoin         Address of the stable coin\n     * @param _poolDeadline       Swapping deadline of the pool (normally the same as the token's deadline)\n     * @param _feeRate            Fee rate given to LP holders\n     *\n     * @return poolAddress Address of the pool\n     */\n    function _deployPool(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _poolDeadline,\n        uint256 _feeRate\n    ) internal returns (address) {\n        // Deploy a new pool (policyToken <=> stablecoin)\n        address poolAddress = factory.deployPool(\n            _policyTokenAddress,\n            _stablecoin,\n            _poolDeadline,\n            _feeRate\n        );\n\n        // Record the mapping\n        whichStablecoin[_policyTokenAddress] = _stablecoin;\n\n        return poolAddress;\n    }\n\n    /**\n     * @notice Finish Deposit\n     *\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the sable coin\n     * @param _amount Amount of stablecoin\n     * @param _user Address to receive the policy tokens\n     */\n    function _deposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    ) internal {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Update the user quota\n        userQuota[_user][policyTokenAddress] += _amount;\n\n        // Transfer stablecoins to this contract\n        IERC20(_stablecoin).safeTransferFrom(_user, address(this), _amount);\n\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\n\n        // Mint new policy tokens\n        policyToken.mint(_user, _amount);\n\n        emit Deposit(_user, _policyTokenName, _stablecoin, _amount);\n    }\n\n    /**\n     * @notice Charge fee when redeem / claim\n     *\n     * @param _stablecoin Stablecoin address\n     * @param _amount     Amount to redeem / claim\n     *\n     * @return amountWithFee Amount with fee\n     */\n    function _chargeFee(\n        address _stablecoin,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 amountWithFee = (_amount * 990) / 1000;\n        uint256 amountToCollect = _amount - amountWithFee;\n\n        uint256 amountToLottery = (amountToCollect * toLotteryPart) / 10;\n\n        pendingIncomeToLottery[_stablecoin] += amountToLottery;\n        pendingIncomeToSharing[_stablecoin] +=\n            amountToCollect -\n            amountToLottery;\n\n        return amountWithFee;\n    }\n\n    /**\n     * @notice Generate the policy token name\n     *\n     * @param _tokenName   Name of the stike token (BTC, ETH, AVAX...)\n     * @param _decimals    Decimals of the name generation (0,1=>1, 2=>2)\n     * @param _strikePrice Strike price of the policy (18 decimals)\n     * @param _isCall      The policy's payoff is triggered when higher(true) or lower(false)\n     * @param _round       Round of the policy, named by <month><day> (e.g. 0320, 1215)\n     */\n    function _generateName(\n        string memory _tokenName,\n        uint256 _decimals,\n        uint256 _strikePrice,\n        bool _isCall,\n        string memory _round\n    ) public pure returns (string memory) {\n        // The direction is \"H\"(Call) or \"L\"(Put)\n        string memory direction = _isCall ? \"H\" : \"L\";\n\n        // Integer part of the strike price (12e18 => 12)\n        uint256 intPart = _strikePrice / 1e18;\n        // require(intPart > 0, \"Invalid int part\");\n\n        uint256 decimalPart;\n        string memory decimalPartString;\n\n        // Decimal part of the strike price (1234e16 => 34)\n        // Can not start with 0 (e.g. 1204e16 => 0 this is incorrect, will revert in next step)\n        uint256 modRemaining = _frac(_strikePrice);\n\n        decimalPart = modRemaining / (10 ** (18 - _decimals));\n\n        if (decimalPart < 10 ** (_decimals - 1)) {\n            decimalPartString = string(\n                abi.encodePacked(\n                    _returnZeroes(_findZeroes(modRemaining, _decimals)),\n                    decimalPart.uintToString()\n                )\n            );\n        } else {\n            decimalPartString = decimalPart.uintToString();\n        }\n\n        // if (_decimals >= 2)\n        //     require(decimalPart > 10**(_decimals - 1), \"Invalid decimal part\");\n\n        // Combine the string\n        string memory name = string(\n            abi.encodePacked(\n                _tokenName,\n                \"_\",\n                intPart.uintToString(),\n                \".\",\n                decimalPartString,\n                \"_\",\n                direction,\n                \"_\",\n                _round\n            )\n        );\n        return name;\n    }\n\n    /**\n     * @notice Calculate the fraction part of a number\n     *\n     * @dev The scale is fixed as 1e18 (decimal fraction)\n     *\n     * @param x Number to calculate\n     *\n     * @return result Fraction result\n     */\n    function _frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    // E.g. number = 12.0456 e18 = 1204 e16\n    //      x = modRemaining = 456 e14\n    //      decimals = 4\n    //      Should return: 1\n    function _findZeroes(\n        uint256 x,\n        uint256 decimals\n    ) internal pure returns (uint256 numOfZero) {\n        assert(decimals <= 16);\n        numOfZero = 1;\n\n        uint256 fracRes;\n\n        for (uint256 i; i < decimals; ) {\n            fracRes = x / 10 ** (16 - i);\n            if (fracRes == 0) {\n                numOfZero++;\n            } else {\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _returnZeroes(\n        uint256 num\n    ) public pure returns (string memory zeroString) {\n        for (uint256 i; i < num; ) {\n            zeroString = string(abi.encodePacked(zeroString, \"0\"));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/utils/interfaces/IERC20Decimals.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.10;\n\ninterface IERC20Decimals {\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/naughty-price/interfaces/IPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IPriceGetter {\n    function getPriceFeedAddress(string memory _tokenName)\n        external\n        view\n        returns (address);\n\n    function setPriceFeed(string memory _tokenName, address _feedAddress)\n        external;\n\n    function getLatestPrice(string memory _tokenName)\n        external\n        returns (uint256 _price);\n}\n"
    },
    "contracts/naughty-price/interfaces/INaughtyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface INaughtyFactory {\n    function getPairAddress(address _tokenAddress1, address _tokenAddress2)\n        external\n        view\n        returns (address);\n\n    function deployPolicyToken(\n        string memory _policyTokenName,\n        uint256 _decimals\n    ) external returns (address);\n\n    function deployPool(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external returns (address);\n\n    function incomeMaker() external view returns (address);\n\n    function incomeMakerProportion() external view returns (uint256);\n}\n"
    },
    "contracts/naughty-price/interfaces/INPPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface INPPolicyToken is IERC20 {\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/interfaces/IERC20PermitWithMultipleMinters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\ninterface IERC20PermitWithMultipleMinters is IERC20, IERC20Permit {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Functions ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    /**\n     * @notice Add a new minter into the minterList\n     * @param _newMinter Address of the new minter\n     */\n    function addMinter(address _newMinter) external;\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldMinter Address of the minter to be removed\n     */\n    function removeMinter(address _oldMinter) external;\n\n    /**\n     * @notice Add a new burner into the burnerList\n     * @param _newBurner Address of the new burner\n     */\n    function addBurner(address _newBurner) external;\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldBurner Address of the minter to be removed\n     */\n    function removeBurner(address _oldBurner) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/naughty-price/NaughtyPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport { Math } from \"../libraries/Math.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"../utils/ReentrancyGuard.sol\";\nimport { INaughtyFactory } from \"./interfaces/INaughtyFactory.sol\";\n\n/**\n * @title  Naughty Pair\n * @notice This is the contract for the naughtyPrice swapping pair.\n *         Every time a new naughtyPrice product is online you need to deploy this contract.\n *         The contract will be initialized with two tokens and a deadline.\n *         Token0 will be policy tokens and token1 will be stablecoins.\n *         The swaps are only availale before the deadline.\n */\ncontract NaughtyPair is ERC20(\"Naughty Pool LP\", \"NLP\"), ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Minimum liquidity locked\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n\n    // naughtyFactory contract address\n    address public factory;\n\n    // Token addresses in the pool\n    address public token0; // Insurance Token\n    address public token1; // USDT\n\n    uint112 private reserve0; // Amount of Insurance Token\n    uint112 private reserve1; // Amount of USDT\n\n    // Used for modifiers\n    bool public unlocked = true;\n\n    // Every pool will have a deadline\n    uint256 public deadline;\n\n    // Fee Rate, given to LP holders (0 ~ 1000)\n    uint256 public feeRate;\n\n    // reserve0 * reserve1\n    uint256 public kLast;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event ReserveUpdated(uint256 reserve0, uint256 reserve1);\n    event Swap(\n        address indexed sender,\n        uint256 amountAIn,\n        uint256 amountBIn,\n        uint256 amountAOut,\n        uint256 amountBOut,\n        address indexed to\n    );\n\n    event Mint(address indexed sender, uint256 amountA, uint256 amountB);\n    event Burn(\n        address indexed sender,\n        uint256 amountA,\n        uint256 amountB,\n        address indexed to\n    );\n\n    constructor() {\n        factory = msg.sender; // deployed by factory contract\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Can not swap after the deadline\n     * @dev Each pool will have a deadline and it was set when deployed\n     *      Does not apply to income maker contract\n     */\n    modifier beforeDeadline() {\n        if (msg.sender != INaughtyFactory(factory).incomeMaker()) {\n            require(block.timestamp <= deadline, \"Can not swap after deadline\");\n        }\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Init Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Initialize the contract status after the deployment by factory\n     *\n     * @param _token0   Token0 address (policy token address)\n     * @param _token1   Token1 address (stablecoin address)\n     * @param _deadline Deadline for this pool\n     * @param _feeRate  Fee rate to LP holders (1000 <=> 100%)\n     */\n    function initialize(\n        address _token0,\n        address _token1,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external {\n        require(\n            msg.sender == factory,\n            \"can only be initialized by the factory contract\"\n        );\n        require(_feeRate <= 1000, \"feeRate over 1.0\");\n\n        token0 = _token0;\n        token1 = _token1;\n\n        // deadline for the whole pool after which no swap will be allowed\n        deadline = _deadline;\n\n        feeRate = _feeRate;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get reserve0 (Policy token) and reserve1 (stablecoin).\n     * @dev This function always put policy token at the first place!\n     * @return _reserve0 Reserve of token0\n     * @return _reserve1 Reserve of token1\n     */\n    function getReserves()\n        public\n        view\n        returns (uint112 _reserve0, uint112 _reserve1)\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint LP Token to liquidity providers\n     *         Called when adding liquidity.\n     * @param to The user address\n     * @return liquidity The LP token amount\n     */\n    function mint(\n        address to\n    ) external nonReentrant returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n\n        uint256 balance0 = IERC20(token0).balanceOf(address(this)); // policy token balance after deposit\n        uint256 balance1 = IERC20(token1).balanceOf(address(this)); // stablecoin balance after deposit\n\n        uint256 amount0 = balance0 - _reserve0; // just deposit\n        uint256 amount1 = balance1 - _reserve1;\n\n        // Distribute part of the fee to income maker\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n\n        uint256 _totalSupply = totalSupply(); // gas savings\n        if (_totalSupply == 0) {\n            // No liquidity = First add liquidity\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n            // Keep minimum liquidity to this contract\n            _mint(factory, MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = min(\n                (amount0 * _totalSupply) / _reserve0,\n                (amount1 * _totalSupply) / _reserve1\n            );\n        }\n\n        require(liquidity > 0, \"insufficient liquidity minted\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1);\n\n        if (feeOn) kLast = reserve0 * reserve1;\n\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    /**\n     * @notice Burn LP tokens give back the original tokens\n     * @param _to User address\n     * @return amount0 Amount of token0 to be sent back\n     * @return amount1 Amount of token1 to be sent back\n     */\n    function burn(\n        address _to\n    ) external nonReentrant returns (uint256 amount0, uint256 amount1) {\n        // gas savings\n        (uint112 _reserve0, uint112 _reserve1) = getReserves();\n        address _token0 = token0;\n        address _token1 = token1;\n\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this)); // policy token balance\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this)); // stablecoin balance\n\n        uint256 liquidity = balanceOf(address(this));\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n\n        uint256 _totalSupply = totalSupply(); // gas savings\n\n        // How many tokens to be sent back\n        amount0 = (liquidity * balance0) / _totalSupply;\n        amount1 = (liquidity * balance1) / _totalSupply;\n\n        require(amount0 > 0 && amount1 > 0, \"Insufficient liquidity burned\");\n\n        // Currently all the liquidity in the pool was just sent by the user, so burn all\n        _burn(address(this), liquidity);\n\n        // Transfer tokens out and update the balance\n        IERC20(_token0).safeTransfer(_to, amount0);\n        IERC20(_token1).safeTransfer(_to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1);\n\n        if (feeOn) kLast = reserve0 * reserve1;\n\n        emit Burn(msg.sender, amount0, amount1, _to);\n    }\n\n    /**\n     * @notice Finish the swap process\n     * @param _amount0Out Amount of token0 to be given out (may be 0)\n     * @param _amount1Out Amount of token1 to be given out (may be 0)\n     * @param _to Address to receive the swap result\n     */\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to\n    ) external beforeDeadline nonReentrant {\n        require(\n            _amount0Out > 0 || _amount1Out > 0,\n            \"Output amount need to be > 0\"\n        );\n\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n        require(\n            _amount0Out < _reserve0 && _amount1Out < _reserve1,\n            \"Not enough liquidity\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(_to != _token0 && _to != _token1, \"INVALID_TO\");\n\n            if (_amount0Out > 0) IERC20(_token0).safeTransfer(_to, _amount0Out);\n            if (_amount1Out > 0) IERC20(_token1).safeTransfer(_to, _amount1Out);\n\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - _amount0Out\n            ? balance0 - (_reserve0 - _amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - _amount1Out\n            ? balance1 - (_reserve1 - _amount1Out)\n            : 0;\n\n        require(amount0In > 0 || amount1In > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\n        {\n            uint256 balance0Adjusted = balance0 * 1000 - amount0In * feeRate;\n            uint256 balance1Adjusted = balance1 * 1000 - amount1In * feeRate;\n\n            require(\n                balance0Adjusted * balance1Adjusted >=\n                    _reserve0 * _reserve1 * (1000 ** 2),\n                \"The remaining x*y is less than K\"\n            );\n        }\n\n        _update(balance0, balance1);\n\n        emit Swap(\n            msg.sender,\n            amount0In,\n            amount1In,\n            _amount0Out,\n            _amount1Out,\n            _to\n        );\n    }\n\n    /**\n     * @notice Syncrinize the status of this pool\n     */\n    function sync() external nonReentrant {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this))\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ********************************** Internal Functions ********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update the reserves of the pool\n     * @param balance0 Balance of token0\n     * @param balance1 Balance of token1\n     */\n    function _update(uint256 balance0, uint256 balance1) private {\n        uint112 MAX_NUM = type(uint112).max;\n        require(balance0 <= MAX_NUM && balance1 <= MAX_NUM, \"Uint112 OVERFLOW\");\n\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n\n        emit ReserveUpdated(reserve0, reserve1);\n    }\n\n    /**\n     * @notice Get the smaller one of two numbers\n     * @param x The first number\n     * @param y The second number\n     * @return z The smaller one\n     */\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    function _mintFee(\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private returns (bool feeOn) {\n        address incomeMaker = INaughtyFactory(factory).incomeMaker();\n\n        // If incomeMaker is not zero address, fee is on\n        feeOn = incomeMaker != address(0);\n\n        uint256 _k = kLast;\n\n        if (feeOn) {\n            if (_k != 0) {\n                uint256 rootK = Math.sqrt(_reserve0 * _reserve1);\n                uint256 rootKLast = Math.sqrt(_k);\n\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply() *\n                        (rootK - rootKLast) *\n                        10;\n\n                    // (1 / φ) - 1\n                    // Proportion got from factory is based on 100\n                    // Use 1000/proportion to make it divided (donominator and numerator both * 10)\n                    // p = 40 (2/5) => 1000/40 = 25\n                    uint256 incomeMakerProportion = INaughtyFactory(factory)\n                        .incomeMakerProportion();\n                    uint256 denominator = rootK *\n                        (1000 / incomeMakerProportion - 10) +\n                        rootKLast *\n                        10;\n\n                    uint256 liquidity = numerator / denominator;\n\n                    // Mint the liquidity to income maker contract\n                    if (liquidity > 0) _mint(incomeMaker, liquidity);\n                }\n            }\n        } else if (_k != 0) {\n            kLast = 0;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary Math {\n    uint256 internal constant WAD = 10**18;\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return ((x * y) + (WAD / 2)) / WAD;\n    }\n}\n"
    },
    "contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/naughty-price/NaughtyRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IBuyerToken} from \"../tokens/interfaces/IBuyerToken.sol\";\nimport {INaughtyPair} from \"./interfaces/INaughtyPair.sol\";\nimport {INaughtyFactory} from \"./interfaces/INaughtyFactory.sol\";\nimport {IPolicyCore} from \"./interfaces/IPolicyCore.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IERC20Decimals} from \"../utils/interfaces/IERC20Decimals.sol\";\n\n/**\n * @title  NaughtyRouter\n * @notice Router for the pool, you can add/remove liquidity or swap A for B.\n *         Swapping fee rate is 2% and all of them are given to LP.\n *         Very similar logic with Uniswap V2.\n *\n */\ncontract NaughtyRouter is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for INaughtyPair;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Some other contracts\n    address public factory;\n    address public policyCore;\n    address public buyerToken;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PolicyCoreChanged(address oldPolicyCore, address newPolicyCore);\n\n    event BuyerTokenChanged(address oldBuyerToken, address newBuyerToken);\n\n    event LiquidityAdded(\n        address indexed pairAddress,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n\n    event LiquidityRemoved(\n        address indexed pairAddress,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _factory, address _buyerToken)\n        public\n        initializer\n    {\n        __Ownable_init();\n\n        factory = _factory;\n        buyerToken = _buyerToken;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Transactions are available only before the deadline\n     * @param _deadLine Deadline of the pool\n     */\n    modifier beforeDeadline(uint256 _deadLine) {\n        if (msg.sender != INaughtyFactory(factory).incomeMaker()) {\n            require(block.timestamp < _deadLine, \"expired transaction\");\n        }\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set the address of policyCore\n     * @param _coreAddress Address of new policyCore\n     */\n    function setPolicyCore(address _coreAddress) external onlyOwner {\n        emit PolicyCoreChanged(policyCore, _coreAddress);\n        policyCore = _coreAddress;\n    }\n\n    /**\n     * @notice Set the address of buyer token\n     * @param _buyerToken Address of new buyer token\n     */\n    function setBuyerToken(address _buyerToken) external onlyOwner {\n        emit BuyerTokenChanged(buyerToken, _buyerToken);\n        buyerToken = _buyerToken;\n    }\n\n    /**\n     * @notice Set the address of factory\n     * @param _naughtyFactory Address of new naughty factory\n     */\n    function setNaughtyFactory(address _naughtyFactory) external onlyOwner {\n        emit BuyerTokenChanged(factory, _naughtyFactory);\n        factory = _naughtyFactory;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Helper Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add liquidity but only provide stablecoins\n     * @dev Only difference with addLiquidity is that mintPolicyTokenForUser\n     * @param _tokenA Address of policyToken\n     * @param _tokenB Address of stablecoin\n     * @param _amountADesired Amount of policyToken desired\n     * @param _amountBDesired Amount of stablecoin desired\n     * @param _amountAMin Minimum amount of policy token\n     * @param _amountBMin Minimum amount of stablecoin\n     * @param _to Address that receive the lp token, normally the user himself\n     * @param _deadline Transaction will revert after this deadline\n     */\n    function addLiquidityWithUSD(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        beforeDeadline(_deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        require(_checkStablecoin(_tokenB), \"Token B should be stablecoin\");\n\n        // Mint _amountADesired policy tokens for users\n        _mintPolicyTokensForUser(\n            _tokenA,\n            _tokenB,\n            _amountADesired,\n            _msgSender()\n        );\n\n        // Add liquidity\n        {\n            (amountA, amountB, liquidity) = addLiquidity(\n                _tokenA,\n                _tokenB,\n                _amountADesired,\n                _amountBDesired,\n                _amountAMin,\n                _amountBMin,\n                _to,\n                _deadline\n            );\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add liquidity function\n     * @param _tokenA Address of policyToken\n     * @param _tokenB Address of stablecoin\n     * @param _amountADesired Amount of policyToken desired\n     * @param _amountBDesired Amount of stablecoin desired\n     * @param _amountAMin Minimum amoutn of policy token\n     * @param _amountBMin Minimum amount of stablecoin\n     * @param _to Address that receive the lp token, normally the user himself\n     * @param _deadline Transaction will revert after this deadline\n     * @return amountA Amount of tokenA to be input\n     * @return amountB Amount of tokenB to be input\n     * @return liquidity LP token to be mint\n     */\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        beforeDeadline(_deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        {\n            (amountA, amountB) = _addLiquidity(\n                _tokenA,\n                _tokenB,\n                _amountADesired,\n                _amountBDesired,\n                _amountAMin,\n                _amountBMin\n            );\n        }\n\n        address pair = INaughtyFactory(factory).getPairAddress(\n            _tokenA,\n            _tokenB\n        );\n\n        _transferHelper(_tokenA, _msgSender(), pair, amountA);\n        _transferHelper(_tokenB, _msgSender(), pair, amountB);\n\n        liquidity = INaughtyPair(pair).mint(_to);\n\n        emit LiquidityAdded(pair, amountA, amountB, liquidity);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool\n     * @param _tokenA Address of policy token\n     * @param _tokenB Address of stablecoin\n     * @param _liquidity The lptoken amount to be removed\n     * @param _amountAMin Minimum amount of tokenA given out\n     * @param _amountBMin Minimum amount of tokenB given out\n     * @param _to User address\n     * @param _deadline Deadline of this transaction\n     * @return amountA Amount of token0 given out\n     * @return amountB Amount of token1 given out\n     */\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        beforeDeadline(_deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        address pair = INaughtyFactory(factory).getPairAddress(\n            _tokenA,\n            _tokenB\n        );\n\n        INaughtyPair(pair).safeTransferFrom(_msgSender(), pair, _liquidity); // send liquidity to pair\n\n        // Amount0: insurance token\n        (amountA, amountB) = INaughtyPair(pair).burn(_to);\n\n        require(amountA >= _amountAMin, \"Insufficient insurance token amount\");\n        require(amountB >= _amountBMin, \"Insufficient USDT token\");\n\n        emit LiquidityRemoved(pair, amountA, amountB, _liquidity);\n    }\n\n    /**\n     * @notice Amount out is fixed\n     * @param _amountInMax Maximum token input\n     * @param _amountOut Fixed token output\n     * @param _tokenIn Address of input token\n     * @param _tokenOut Address of output token\n     * @param _to User address\n     * @param _deadline Deadline for this specific swap\n     * @return amountIn Amounts to be really put in\n     */\n    function swapTokensforExactTokens(\n        uint256 _amountInMax,\n        uint256 _amountOut,\n        address _tokenIn,\n        address _tokenOut,\n        address _to,\n        uint256 _deadline\n    ) external beforeDeadline(_deadline) returns (uint256 amountIn) {\n        address pair = INaughtyFactory(factory).getPairAddress(\n            _tokenIn,\n            _tokenOut\n        );\n        require(\n            block.timestamp <= INaughtyPair(pair).deadline(),\n            \"This pool has been frozen for swapping\"\n        );\n\n        bool isBuying = _checkStablecoin(_tokenIn);\n\n        uint256 feeRate = INaughtyPair(pair).feeRate();\n\n        // Get how many tokens should be put in (the order depends on isBuying)\n        amountIn = _getAmountIn(\n            isBuying,\n            _amountOut,\n            _tokenIn,\n            _tokenOut,\n            feeRate\n        );\n\n        require(amountIn <= _amountInMax, \"excessive input amount\");\n\n        _transferHelper(_tokenIn, _msgSender(), pair, amountIn);\n\n        _swap(pair, _tokenIn, amountIn, _amountOut, isBuying, _to);\n    }\n\n    /**\n     * @notice Amount in is fixed\n     * @param _amountIn Fixed token input\n     * @param _amountOutMin Minimum token output\n     * @param _tokenIn Address of input token\n     * @param _tokenOut Address of output token\n     * @param _to User address\n     * @param _deadline Deadline for this specific swap\n     * @return amountOut Amounts to be really given out\n     */\n    function swapExactTokensforTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _tokenIn,\n        address _tokenOut,\n        address _to,\n        uint256 _deadline\n    ) external beforeDeadline(_deadline) returns (uint256 amountOut) {\n        address pair = INaughtyFactory(factory).getPairAddress(\n            _tokenIn,\n            _tokenOut\n        );\n        require(\n            block.timestamp <= INaughtyPair(pair).deadline(),\n            \"This pool has been frozen for swapping\"\n        );\n\n        // Check if the tokenIn is stablecoin\n        bool isBuying = _checkStablecoin(_tokenIn);\n\n        uint256 feeRate = INaughtyPair(pair).feeRate();\n\n        // Get how many tokens should be given out (the order depends on isBuying)\n        amountOut = _getAmountOut(\n            isBuying,\n            _amountIn,\n            _tokenIn,\n            _tokenOut,\n            feeRate\n        );\n        require(amountOut >= _amountOutMin, \"excessive output amount\");\n\n        _transferHelper(_tokenIn, _msgSender(), pair, _amountIn);\n\n        _swap(pair, _tokenIn, _amountIn, amountOut, isBuying, _to);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Internal function to finish adding liquidity\n     * @param _tokenA Address of tokenA\n     * @param _tokenB Address of tokenB\n     * @param _amountADesired Amount of tokenA to be added\n     * @param _amountBDesired Amount of tokenB to be added\n     * @param _amountAMin Minimum amount of tokenA\n     * @param _amountBMin Minimum amount of tokenB\n     * @return amountA Real amount of tokenA\n     * @return amountB Real amount of tokenB\n     */\n    function _addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) private view returns (uint256 amountA, uint256 amountB) {\n        require(_checkStablecoin(_tokenB), \"Please put stablecoin as tokenB\");\n\n        (uint256 reserveA, uint256 reserveB) = _getReserves(_tokenA, _tokenB);\n\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (_amountADesired, _amountBDesired);\n        } else {\n            uint256 amountBOptimal = _quote(\n                _amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= _amountBDesired) {\n                require(amountBOptimal >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (_amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = _quote(\n                    _amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                require(amountAOptimal <= _amountADesired, \"nonono\");\n                require(amountAOptimal >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, _amountBDesired);\n            }\n        }\n    }\n\n    /**\n     * @notice Finish the erc20 transfer operation\n     * @param _token ERC20 token address\n     * @param _from Address to give out the token\n     * @param _to Pair address to receive the token\n     * @param _amount Transfer amount\n     */\n    function _transferHelper(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        IERC20(_token).safeTransferFrom(_from, _to, _amount);\n    }\n\n    /**\n     * @notice Finish swap process\n     * @param _pair Address of the pair\n     * @param _tokenIn Address of the input token\n     * @param _amountIn Amount of tokens put in\n     * @param _amountOut Amount of tokens get out\n     * @param _isBuying Whether this is a purchase or a sell\n     * @param _to Address of the user\n     */\n    function _swap(\n        address _pair,\n        address _tokenIn,\n        uint256 _amountIn,\n        uint256 _amountOut,\n        bool _isBuying,\n        address _to\n    ) internal {\n        // Only give buyer tokens when this is a purchase\n        if (_isBuying) {\n            // Check the decimals\n            uint256 decimals = IERC20Decimals(_tokenIn).decimals();\n            uint256 buyerTokenAmount = _amountIn * 10**(18 - decimals);\n            IBuyerToken(buyerToken).mintBuyerToken(\n                _msgSender(),\n                buyerTokenAmount\n            );\n        }\n\n        // If the user is buying policies => amount1Out = 0\n        // One of these two variables will be 0\n        uint256 amountAOut = _isBuying ? _amountOut : 0;\n        uint256 amountBOut = _isBuying ? 0 : _amountOut;\n\n        INaughtyPair(_pair).swap(amountAOut, amountBOut, _to);\n    }\n\n    /**\n     * @notice Used when users only provide stablecoins and want to mint & add liquidity in one step\n     * @dev Need have approval before (done by the user himself)\n     * @param _policyTokenAddress Address of the policy token\n     * @param _stablecoin Address of the stablecoin\n     * @param _amount Amount to be used for minting policy tokens\n     * @param _user The user's address\n     */\n    function _mintPolicyTokensForUser(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    ) internal {\n        // Find the policy token name\n        string memory policyTokenName = IPolicyCore(policyCore)\n            .findNamebyAddress(_policyTokenAddress);\n\n        IPolicyCore(policyCore).delegateDeposit(\n            policyTokenName,\n            _stablecoin,\n            _amount,\n            _user\n        );\n    }\n\n    function _checkStablecoin(address _tokenAddress)\n        internal\n        view\n        returns (bool)\n    {\n        return IPolicyCore(policyCore).supportedStablecoin(_tokenAddress);\n    }\n\n    /**\n     * @notice Fetche the reserves for a pair\n     * @dev You need to sort the token order by yourself!\n     *      No matter your input order, the return value will always start with policy token reserve.\n     */\n    function _getReserves(address tokenA, address tokenB)\n        internal\n        view\n        returns (uint112 reserveA, uint112 reserveB)\n    {\n        address pairAddress = INaughtyFactory(factory).getPairAddress(\n            tokenA,\n            tokenB\n        );\n\n        // (Policy token reserve, stablecoin reserve)\n        (reserveA, reserveB) = INaughtyPair(pairAddress).getReserves();\n    }\n\n    /**\n     * @notice Used when swap exact tokens for tokens (in is fixed)\n     * @param isBuying Whether the user is buying policy tokens\n     * @param _amountIn Amount of tokens put in\n     * @param _tokenIn Address of the input token\n     * @param _tokenOut Address of the output token\n     */\n    function _getAmountOut(\n        bool isBuying,\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _feeRate\n    ) internal view returns (uint256 amountOut) {\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\n            _tokenIn,\n            _tokenOut\n        );\n\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\n        // Get the right order\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\n            ? (reserveB, reserveA)\n            : (reserveA, reserveB);\n\n        require(_amountIn > 0, \"insufficient input amount\");\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient liquidity\");\n\n        uint256 amountInWithFee = _amountIn * (1000 - _feeRate);\n        uint256 numerator = amountInWithFee * (reserveOut);\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n\n        amountOut = numerator / denominator;\n    }\n\n    /**\n     * @notice Used when swap tokens for exact tokens (out is fixed)\n     * @param isBuying Whether the user is buying policy tokens\n     * @param _amountOut Amount of tokens given out\n     * @param _tokenIn Address of the input token\n     * @param _tokenOut Address of the output token\n     */\n    function _getAmountIn(\n        bool isBuying,\n        uint256 _amountOut,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _feeRate\n    ) internal view returns (uint256 amountIn) {\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\n            _tokenIn,\n            _tokenOut\n        );\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\n        // Get the right order\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\n            ? (reserveB, reserveA)\n            : (reserveA, reserveB);\n\n        require(_amountOut > 0, \"insufficient output amount\");\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient liquidity\");\n\n        uint256 numerator = reserveIn * (_amountOut) * 1000;\n        uint256 denominator = (reserveOut - _amountOut) * (1000 - _feeRate);\n\n        amountIn = numerator / denominator + 1;\n    }\n\n    /**\n     * @notice Given some amount of an asset and pair reserves\n     *         returns an equivalent amount of the other asset\n     * @dev Used when add or remove liquidity\n     * @param _amountA Amount of tokenA ( can be policytoken or stablecoin)\n     * @param _reserveA Reserve of tokenA\n     * @param _reserveB Reserve of tokenB\n     */\n    function _quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(_amountA > 0, \"insufficient amount\");\n        require(_reserveA > 0 && _reserveB > 0, \"insufficient liquidity\");\n\n        amountB = (_amountA * _reserveB) / _reserveA;\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IBuyerToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBuyerToken is IERC20 {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Functions ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintBuyerToken(address _account, uint256 _amount) external;\n\n    /**\n     * @notice Burn buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnBuyerToken(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/naughty-price/interfaces/INaughtyPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface INaughtyPair is IERC20 {\n    function initialize(\n        address _token0,\n        address _token1,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external;\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function feeRate() external view returns (uint256);\n\n    function deadline() external view returns (uint256);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 _reserve0, uint112 _reserve1);\n\n    function swap(\n        uint256,\n        uint256,\n        address\n    ) external;\n\n    function burn(address) external returns (uint256, uint256);\n\n    function mint(address) external returns (uint256);\n\n    function sync() external;\n}\n"
    },
    "contracts/naughty-price/interfaces/IPolicyCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IPolicyCore {\n    struct PolicyTokenInfo {\n        address policyTokenAddress;\n        bool isCall;\n        uint256 nameDecimals; // decimals of the name generation\n        uint256 tokenDecimals; // decimals of the policy token\n        uint256 strikePrice;\n        uint256 deadline;\n        uint256 settleTimestamp;\n    }\n\n    /**\n     * @notice Find the address by its name\n     */\n    function findAddressbyName(string memory _policyTokenName)\n        external\n        view\n        returns (address _policyTokenAddress);\n\n    /**\n     * @notice Find the name by address\n     */\n    function findNamebyAddress(address _policyTokenAddress)\n        external\n        view\n        returns (string memory);\n\n    /**\n     * @notice Check whether the stablecoin is supported\n     */\n    function supportedStablecoin(address _coinAddress)\n        external\n        view\n        returns (bool);\n\n    function delegateDeposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    ) external;\n\n    function deployPool(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _poolDeadline,\n        uint256 _feeRate\n    ) external returns (address);\n\n    function getPolicyTokenInfo(string memory _policyTokenName)\n        external\n        view\n        returns (PolicyTokenInfo memory);\n\n    function updateUserQuota(\n        address _user,\n        address _policyToken,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/ILM/NaughtyPriceILM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Decimals } from \"../utils/interfaces/IERC20Decimals.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IPolicyCore } from \"../naughty-price/interfaces/IPolicyCore.sol\";\nimport { INaughtyRouter } from \"../naughty-price/interfaces/INaughtyRouter.sol\";\nimport { INaughtyPair } from \"../naughty-price/interfaces/INaughtyPair.sol\";\nimport { ILMToken as LPToken } from \"./ILMToken.sol\";\n\n/**\n * @title Naughty Price Initial Liquidity Matching\n * @notice Naughty Price timeline: 1 -- 14 -- 5\n *         The first day of each round would be the time for liquidity matching\n *         User\n *           - Select the naughty token\n *           - Provide stablecoins into this contract & Select your price choice\n *           - Change the amountA and amountB of this pair\n *         When reach deadline\n *           - Final price of ILM = Initial price of naughty price pair = amountA/amountB\n */\ncontract NaughtyPriceILM is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Scale when calculating fee\n    uint256 public constant SCALE = 1e12;\n\n    // Degis entrance fee = 1 / 100 deposit amount\n    uint256 public constant FEE_DENOMINATOR = 100;\n\n    // Minimum deposit amount\n    uint256 public constant MINIMUM_AMOUNT = 1e6;\n\n    // Uint256 maximum value\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Degis token address\n    address public degis;\n\n    // PolicyCore, Router and EmergencyPool contract address\n    address public policyCore;\n    address public router;\n    address public emergencyPool;\n\n    struct UserInfo {\n        uint256 amountA;\n        uint256 amountB;\n        uint256 degisDebt;\n    }\n    // user address => policy token address => user info\n    mapping(address => mapping(address => UserInfo)) public users;\n\n    // Status of an ILM round\n    enum Status {\n        BeforeStart,\n        Active,\n        Finished,\n        Stopped\n    }\n\n    struct PairInfo {\n        Status status; // 0: before start 1: active 2: finished 3: stopped\n        address lptoken; // lptoken address\n        uint256 ILMDeadline; // deadline for initial liquidity matching\n        address stablecoin; // stablecoin address\n        uint256 amountA; // Amount of policy tokens\n        uint256 amountB; // Amount of stablecoins\n        address naughtyPairAddress; // Naughty pair address deployed when finished ILM\n        // degis paid as fee\n        uint256 degisAmount;\n        uint256 accDegisPerShare;\n    }\n    // Policy Token Address => Pair Info\n    mapping(address => PairInfo) public pairs;\n\n    mapping(address => uint256) public endPrice;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Deposit(\n        address indexed policyToken,\n        address indexed stablecoin,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event Withdraw(\n        address indexed policyToken,\n        address indexed stablecoin,\n        address indexed user,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event EmergencyWithdraw(address owner, uint256 amount);\n    event ILMFinish(\n        address policyToken,\n        address stablecoin,\n        address poolAddress,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event ILMStart(\n        address policyToken,\n        address stablecoin,\n        uint256 deadline,\n        address lptokenAddress\n    );\n    event Harvest(address user, uint256 reward);\n    event Claim(address user, uint256 amountA, uint256 amountB);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error ILM__WrongILMDeadline();\n    error ILM__ZeroAddress();\n    error ILM__RoundOver();\n    error ILM__PairNotActive();\n    error ILM__RoundNotOver();\n    error ILM__ZeroAmount();\n    error ILM__NotActiveILM();\n    error ILM__StablecoinNotPaired();\n    error ILM__StablecoinNotSupport();\n    error ILM__NoDeposit();\n    error ILM__NotEnoughDeposit();\n    error ILM__AlreadyStarted();\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Initialze function for proxy\n     * @dev Called only when deploying proxy contract\n     * @param _degis Degis token address\n     * @param _policyCore PolicyCore contract address\n     * @param _router NaughtyRouter contract address\n     * @param _emergencyPool EmergencyPool contract address\n     */\n    function initialize(\n        address _degis,\n        address _policyCore,\n        address _router,\n        address _emergencyPool\n    ) public initializer {\n        if (_policyCore == address(0) || _router == address(0))\n            revert ILM__ZeroAddress();\n\n        __Ownable_init();\n\n        degis = _degis;\n        policyCore = _policyCore;\n        router = _router;\n\n        emergencyPool = _emergencyPool;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check whether a pair is active\n     * @param _policyToken Policy token address\n     */\n    modifier activePair(address _policyToken) {\n        if (pairs[_policyToken].status != Status.Active)\n            revert ILM__PairNotActive();\n        _;\n    }\n\n    /**\n     * @notice Check whether is during ILM\n     * @param _policyToken Policy token address\n     */\n    modifier duringILM(address _policyToken) {\n        if (block.timestamp > pairs[_policyToken].ILMDeadline)\n            revert ILM__RoundOver();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the current price\n     * @dev Price has a scale of 1e12\n     * @param _policyToken Policy token address\n     * @return price Price of the token pair\n     */\n    function getPrice(address _policyToken) external view returns (uint256) {\n        uint256 amountA = pairs[_policyToken].amountA;\n        uint256 amountB = pairs[_policyToken].amountB;\n        return (amountB * SCALE) / amountA;\n    }\n\n    /**\n     * @notice Get the total amount of a pair\n     * @param _policyToken Policy token address\n     * @return totalAmount Total amount of a pair\n     */\n    function getPairTotalAmount(address _policyToken)\n        external\n        view\n        returns (uint256 totalAmount)\n    {\n        totalAmount = pairs[_policyToken].amountA + pairs[_policyToken].amountB;\n    }\n\n    /**\n     * @notice Get the amount of user's deposit\n     * @param _user User address\n     * @param _policyToken Policy token address\n     */\n    function getUserDeposit(address _user, address _policyToken)\n        external\n        view\n        returns (uint256 amountA, uint256 amountB)\n    {\n        amountA = users[_user][_policyToken].amountA;\n        amountB = users[_user][_policyToken].amountB;\n    }\n\n    /**\n     * @notice Emergency stop ILM\n     * @param _policyToken Policy token address to be stopped\n     */\n    function emergencyStop(address _policyToken) external onlyOwner {\n        pairs[_policyToken].status = Status.Stopped;\n    }\n\n    /**\n     * @notice Emergency restart ILM\n     * @param _policyToken Policy token address to be restarted\n     */\n    function emergencyRestart(address _policyToken) external onlyOwner {\n        pairs[_policyToken].status = Status.Active;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start a new ILM round\n     * @dev A new lp token will be deployed when starting a new ILM round\n     *      It will have a special farming reward pool\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     * @param _ILMDeadline Deadline of ILM period\n     */\n    function startILM(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _ILMDeadline\n    ) external onlyOwner {\n        // Get policy token name & Check if this policy token exists\n        // The check is inside policy core contract\n        string memory policyTokenName = IPolicyCore(policyCore)\n            .findNamebyAddress(_policyToken);\n\n        // Check if the stablecoin is supported\n        bool isSupported = IPolicyCore(policyCore).supportedStablecoin(\n            _stablecoin\n        );\n        if (!isSupported) revert ILM__StablecoinNotSupport();\n\n        // The deadline for ILM can not be later than the policy token deadline\n        uint256 policyTokenDeadline = (\n            IPolicyCore(policyCore).getPolicyTokenInfo(policyTokenName)\n        ).deadline;\n        if (_ILMDeadline >= policyTokenDeadline) revert ILM__WrongILMDeadline();\n\n        PairInfo storage pair = pairs[_policyToken];\n\n        if(pair.lptoken != address(0)) revert ILM__AlreadyStarted();\n\n        // Update the status\n        pair.status = Status.Active;\n        pair.stablecoin = _stablecoin;\n        pair.ILMDeadline = _ILMDeadline;\n\n        // Deploy a new ERC20 LP Token\n        string memory LPTokenName = string(\n            abi.encodePacked(\"ILM-\", policyTokenName)\n        );\n        address lpTokenAddress = _deployLPToken(LPTokenName);\n\n        // Record the lptoken address\n        pair.lptoken = lpTokenAddress;\n\n        // Pre-approve the stablecoin for later deposit\n        IERC20(_policyToken).approve(router, MAX_UINT256);\n\n        emit ILMStart(_policyToken, _stablecoin, _ILMDeadline, lpTokenAddress);\n    }\n\n    /**\n     * @notice Finish a round of ILM\n     * @dev The swap pool for the protection token will be deployed with inital liquidity\\\n     *      The amount of initial liquidity will be the total amount of the pair\n     *      Can be called by any address\n     * @param _policyToken Policy token address\n     * @param _deadlineForSwap Pool deadline\n     * @param _feeRate Fee rate of the swap pool\n     */\n    function finishILM(\n        address _policyToken,\n        uint256 _deadlineForSwap,\n        uint256 _feeRate\n    ) external activePair(_policyToken) {\n        PairInfo memory pair = pairs[_policyToken];\n\n        // Pair status is 1 and passed deadline => can finish ILM\n        if (block.timestamp <= pair.ILMDeadline) revert ILM__RoundNotOver();\n        if (pair.amountA + pair.amountB == 0) revert ILM__NoDeposit();\n\n        // Update the status of this pair\n        pairs[_policyToken].status = Status.Finished;\n\n        // Get policy token name\n        string memory policyTokenName = IPolicyCore(policyCore)\n            .findNamebyAddress(_policyToken);\n\n        // Deploy a new pool and return the pool address\n        address poolAddress = IPolicyCore(policyCore).deployPool(\n            policyTokenName,\n            pair.stablecoin,\n            _deadlineForSwap,\n            _feeRate // maximum = 1000 = 100%\n        );\n        pairs[_policyToken].naughtyPairAddress = poolAddress;\n\n        // Approval prepration for withdraw liquidity\n        INaughtyPair(poolAddress).approve(router, MAX_UINT256);\n\n        // Add initial liquidity to the pool\n        // Zero slippage\n        INaughtyRouter(router).addLiquidityWithUSD(\n            _policyToken,\n            pair.stablecoin,\n            pair.amountA,\n            pair.amountB,\n            pair.amountA,\n            pair.amountB,\n            address(this),\n            block.timestamp + 60\n        );\n\n        emit ILMFinish(\n            _policyToken,\n            pair.stablecoin,\n            poolAddress,\n            pair.amountA,\n            pair.amountB\n        );\n    }\n\n    /**\n     * @notice Deposit stablecoin and choose the price\n     * @dev Deposit only check the pair status not the deadline\n     *      There may be a zero ILM and we still need to deposit some asset to make it start\n     *      Anyone wants to enter ILM need to pay some DEG as entrance fee\n     *      The ratio is 100:1(usd:deg) and your fee is distributed to the users prior to you\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     * @param _amountA Amount of policy token (virtual)\n     * @param _amountB Amount of stablecoin (virtual)\n     */\n    function deposit(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _amountA,\n        uint256 _amountB\n    ) external activePair(_policyToken) {\n        if (_amountA + _amountB < MINIMUM_AMOUNT) revert ILM__ZeroAmount();\n        if (_stablecoin != pairs[_policyToken].stablecoin)\n            revert ILM__StablecoinNotPaired();\n\n        uint256 amountToDeposit = _amountA + _amountB;\n\n        // Every 100usd pay 1 degis\n        uint256 decimalDiff = 18 - IERC20Decimals(_stablecoin).decimals();\n        uint256 degisToPay = (amountToDeposit * 10**decimalDiff) /\n            FEE_DENOMINATOR;\n\n        // Update the info about deg entrance fee when deposit\n        _updateWhenDeposit(\n            _policyToken,\n            amountToDeposit,\n            degisToPay,\n            decimalDiff\n        );\n\n        PairInfo storage pair = pairs[_policyToken];\n        UserInfo storage user = users[msg.sender][_policyToken];\n\n        // Update deg record and transfer degis token\n        pair.degisAmount += degisToPay;\n        IERC20(degis).safeTransferFrom(msg.sender, address(this), degisToPay);\n\n        // Update the status\n        pair.amountA += _amountA;\n        pair.amountB += _amountB;\n        user.amountA += _amountA;\n        user.amountB += _amountB;\n\n        // Transfer tokens\n        IERC20(_stablecoin).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountToDeposit\n        );\n\n        // Distribute the lptoken\n        address lpToken = pairs[_policyToken].lptoken;\n        LPToken(lpToken).mint(msg.sender, amountToDeposit);\n\n        emit Deposit(_policyToken, _stablecoin, _amountA, _amountB);\n    }\n\n    /**\n     * @notice Withdraw stablecoins\n     * @dev Only checks the status not the deadline\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     * @param _amountA Amount of policy token (virtual)\n     * @param _amountB Amount of stablecoin (virtual)\n     */\n    function withdraw(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _amountA,\n        uint256 _amountB\n    ) public activePair(_policyToken) {\n        UserInfo memory currentUserInfo = users[msg.sender][_policyToken];\n\n        // Check if the user has enough tokens to withdraw\n        if (currentUserInfo.amountA + currentUserInfo.amountB == 0)\n            revert ILM__NoDeposit();\n        if (\n            _amountA > currentUserInfo.amountA ||\n            _amountB > currentUserInfo.amountB\n        ) revert ILM__NotEnoughDeposit();\n\n        PairInfo storage pair = pairs[_policyToken];\n        UserInfo storage user = users[msg.sender][_policyToken];\n\n        // Update status when withdraw\n        uint256 degisToWithdraw = (pair.accDegisPerShare *\n            (currentUserInfo.amountA + currentUserInfo.amountB)) /\n            SCALE -\n            currentUserInfo.degisDebt;\n\n        if (degisToWithdraw > 0) {\n            // Degis will be withdrawed to emergency pool, not the user\n            uint256 reward = _safeTokenTransfer(\n                degis,\n                emergencyPool,\n                degisToWithdraw\n            );\n            emit Harvest(emergencyPool, reward);\n        }\n\n        // Update the user's amount and pool's amount\n        pair.amountA -= _amountA;\n        pair.amountB -= _amountB;\n        user.amountA -= _amountA;\n        user.amountB -= _amountB;\n\n        uint256 amountToWithdraw = _amountA + _amountB;\n\n        // Withdraw stablecoins to the user\n        _safeTokenTransfer(_stablecoin, msg.sender, amountToWithdraw);\n\n        // Burn the lptokens\n        LPToken(pair.lptoken).burn(msg.sender, amountToWithdraw);\n\n        // Update the user debt\n        user.degisDebt =\n            ((user.amountA + user.amountB) * pair.accDegisPerShare) /\n            SCALE;\n\n        emit Withdraw(\n            _policyToken,\n            _stablecoin,\n            msg.sender,\n            _amountA,\n            _amountB\n        );\n    }\n\n    /**\n     * @notice Withdraw all stablecoins of a certain policy token\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     */\n    function withdrawAll(address _policyToken, address _stablecoin) external {\n        uint256 amounAMax = users[msg.sender][_policyToken].amountA;\n        uint256 amounBMax = users[msg.sender][_policyToken].amountB;\n\n        withdraw(_policyToken, _stablecoin, amounAMax, amounBMax);\n    }\n\n    /**\n     * @notice Claim liquidity back\n     * @dev You will get back some DEG (depending on how many users deposit after you)\n     *      The claim amount is determined by the LP Token balance of you (you can buy from others)\n     *      But the DEG reward would only be got once\n     *      Your LP token will be burnt and you can not join ILM farming pool again\n     * @param _policyToken Policy token address\n     * @param _stablecoin Stablecoin address\n     * @param _amountAMin Minimum amount of policy token (slippage)\n     * @param _amountBMin Minimum amount of stablecoin (slippage)\n     */\n    function claim(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _amount,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) external {\n        if (_amount == 0) revert ILM__ZeroAmount();\n\n        PairInfo storage pair = pairs[_policyToken];\n\n        address lptoken = pair.lptoken;\n\n        uint256 lpBalance = LPToken(lptoken).balanceOf(msg.sender);\n        uint256 lpToClaim = _amount > lpBalance ? lpBalance : _amount;\n\n        // Total liquidity owned by the pool\n        uint256 totalLiquidity = INaughtyPair(pair.naughtyPairAddress)\n            .balanceOf(address(this));\n\n        uint256 lpTotalSupply = LPToken(lptoken).totalSupply();\n\n        // User's liquidity amount\n        uint256 userLiquidity = (lpToClaim * totalLiquidity) / lpTotalSupply;\n\n        _updateWhenClaim(_policyToken);\n\n        {\n            // Remove liquidity\n            (\n                uint256 policyTokenAmount,\n                uint256 stablecoinAmount\n            ) = INaughtyRouter(router).removeLiquidity(\n                    _policyToken,\n                    _stablecoin,\n                    userLiquidity,\n                    _amountAMin,\n                    _amountBMin,\n                    msg.sender,\n                    block.timestamp + 60\n                );\n\n            emit Claim(msg.sender, policyTokenAmount, stablecoinAmount);\n        }\n\n        IPolicyCore(policyCore).updateUserQuota(\n            msg.sender,\n            _policyToken,\n            (pair.amountA * lpToClaim) / (pair.amountA + pair.amountB)\n        );\n\n        // Burn the user's lp tokens\n        LPToken(lptoken).burn(msg.sender, lpToClaim);\n    }\n\n    /**\n     * @notice Emergency withdraw a certain token\n     * @param _token Token address\n     * @param _amount Token amount\n     */\n    function emergencyWithdraw(address _token, uint256 _amount) external {\n        IERC20(_token).safeTransfer(owner(), _amount);\n\n        emit EmergencyWithdraw(owner(), _amount);\n    }\n\n    /**\n     * @notice Approve stablecoins for naughty price contracts\n     * @param _stablecoin Stablecoin address\n     */\n    function approveStablecoin(address _stablecoin) external {\n        IERC20(_stablecoin).approve(router, MAX_UINT256);\n        IERC20(_stablecoin).approve(policyCore, MAX_UINT256);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy the new lp token for a round\n     * @param _name Name of the lp token\n     * @return lpTokenAddress Address of the lp token\n     */\n    function _deployLPToken(string memory _name) internal returns (address) {\n        address lpTokenAddress = address(\n            new LPToken(address(this), _name, _name)\n        );\n        return lpTokenAddress;\n    }\n\n    /**\n     * @notice Safely transfer tokens\n     * @param _token Token address\n     * @param _receiver Receiver address\n     * @param _amount Amount of tokens\n     * @return realAmount Real amount that is transferred\n     */\n    function _safeTokenTransfer(\n        address _token,\n        address _receiver,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        if (_amount > balance) {\n            IERC20(_token).safeTransfer(_receiver, balance);\n            return balance;\n        } else {\n            IERC20(_token).safeTransfer(_receiver, _amount);\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice Update debt & fee distribution\n     * @param _policyToken Policy token address\n     * @param _usdAmount Amount of stablecoins input\n     * @param _degAmount Amount of degis input\n     */\n    function _updateWhenDeposit(\n        address _policyToken,\n        uint256 _usdAmount,\n        uint256 _degAmount,\n        uint256 _decimalDiff\n    ) internal {\n        PairInfo storage pair = pairs[_policyToken];\n\n        // If this is the first user, accDegisPerShare = 1e16\n        // No debt\n        if (pair.degisAmount == 0) {\n            pair.accDegisPerShare =\n                (SCALE * 10**_decimalDiff) /\n                FEE_DENOMINATOR;\n            return;\n        }\n\n        UserInfo storage user = users[msg.sender][_policyToken];\n\n        // Update accDegisPerShare first\n        pair.accDegisPerShare +=\n            (_degAmount * SCALE) /\n            ((pair.amountA + pair.amountB));\n\n        uint256 currentUserDeposit = user.amountA + user.amountB;\n        // If user has deposited before, distribute the deg reward first\n        // Pending reward is calculated with the new degisPerShare value\n        if (currentUserDeposit > 0) {\n            uint256 pendingReward = (currentUserDeposit *\n                pair.accDegisPerShare) /\n                SCALE -\n                user.degisDebt;\n\n            uint256 reward = _safeTokenTransfer(\n                degis,\n                msg.sender,\n                pendingReward\n            );\n            emit Harvest(msg.sender, reward);\n        }\n\n        // Update user debt\n        user.degisDebt =\n            (pair.accDegisPerShare * (currentUserDeposit + _usdAmount)) /\n            SCALE;\n    }\n\n    /**\n     * @notice Update degis reward when claim\n     * @param _policyToken Policy token address\n     */\n    function _updateWhenClaim(address _policyToken) internal {\n        uint256 accDegisPerShare = pairs[_policyToken].accDegisPerShare;\n\n        UserInfo storage user = users[msg.sender][_policyToken];\n\n        uint256 userTotalDeposit = user.amountA + user.amountB;\n\n        uint256 pendingReward = (userTotalDeposit * accDegisPerShare) /\n            SCALE -\n            user.degisDebt;\n\n        if (pendingReward > 0) {\n            // Update debt\n            // Only get deg back when first time claim\n            user.degisDebt = (userTotalDeposit * accDegisPerShare) / SCALE;\n\n            uint256 reward = _safeTokenTransfer(\n                degis,\n                msg.sender,\n                pendingReward\n            );\n            emit Harvest(msg.sender, reward);\n        }\n    }\n}\n"
    },
    "contracts/naughty-price/interfaces/INaughtyRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\ninterface INaughtyRouter {\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityWithUSD(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function swapExactTokensforTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _tokenIn,\n        address _tokenOut,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 amountOut);\n}\n"
    },
    "contracts/ILM/ILMToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ILMToken is ERC20 {\n    address public ILMContract;\n\n    constructor(\n        address _ILM,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        ILMContract = _ILM;\n    }\n\n    modifier onlyILM() {\n        require(msg.sender == ILMContract, \"Only ILM\");\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) public onlyILM {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _to, uint256 _amount) public onlyILM {\n        _burn(_to, _amount);\n    }\n}\n"
    },
    "contracts/naughty-price/NaughtyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\nimport \"./NPPolicyToken.sol\";\nimport \"./NaughtyPair.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { INaughtyPair } from \"./interfaces/INaughtyPair.sol\";\nimport { IPolicyCore } from \"./interfaces/IPolicyCore.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title Naughty Factory\n * @notice Factory contract to deploy new price proteciton pools.\n *\n *         Each pool(product) will have a unique naughtyId\n *         Each pool will have its pool token\n *         PolicyToken - Stablecoin\n *         Token 0 may change but Token 1 is always stablecoin.\n */\n\ncontract NaughtyFactory is OwnableUpgradeable {\n    // INIT_CODE_HASH for NaughtyPair, may be used in frontend\n    bytes32 public constant PAIR_INIT_CODE_HASH =\n        keccak256(abi.encodePacked(type(NaughtyPair).creationCode));\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // PolicyToken Address => StableCoin Address => Pool Address\n    mapping(address => mapping(address => address)) internal getPair;\n\n    // Store all the pairs' addresses\n    address[] public allPairs;\n\n    // Store all policy tokens' addresses\n    address[] public allTokens;\n\n    // Next pool id to be deployed\n    uint256 public _nextId;\n\n    // Address of policyCore\n    address public policyCore;\n\n    // Address of income maker, part of the transaction fee will be distributed to this address\n    address public incomeMaker;\n\n    // Swap fee proportion to income maker\n    uint256 public incomeMakerProportion;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PolicyCoreAddressChanged(\n        address oldPolicyCore,\n        address newPolicyCore\n    );\n    event IncomeMakerProportionChanged(\n        uint256 oldProportion,\n        uint256 newProportion\n    );\n    event IncomeMakerAddressChanged(\n        address oldIncomeMaker,\n        address newIncomeMaker\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize() public initializer {\n        __Ownable_init();\n        // 40% of swap fee is distributed to income maker contract\n        // Can be set later\n        incomeMakerProportion = 40;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Modifiers ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only called by policyCore contract\n     */\n    modifier onlyPolicyCore() {\n        require(msg.sender == policyCore, \"Only called by policyCore\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the all tokens that have been deployed\n     * @return tokens All tokens\n     */\n    function getAllTokens() external view returns (address[] memory) {\n        return allTokens;\n    }\n\n    /**\n     * @notice Get the INIT_CODE_HASH for policy tokens with parameters\n     * @dev For test/task convinience, pre-compute the address\n     *      Ethers.js:\n     *      Address = ethers.utils.getCreate2Address(factory address, salt, INIT_CODE_HASH)\n     *      salt = keccak256(abi.encodePacked(_policyTokenName))\n     * @param _tokenName Name of the policy token to be deployed\n     * @param _decimals Token decimals of this policy token\n     */\n    function getInitCodeHashForPolicyToken(\n        string memory _tokenName,\n        uint256 _decimals\n    ) public view returns (bytes32) {\n        bytes memory bytecode = _getPolicyTokenBytecode(_tokenName, _decimals);\n        return keccak256(bytecode);\n    }\n\n    /**\n     * @notice Get the pair address deployed by the factory\n     *         PolicyToken address first, and then stablecoin address\n     *         The order of the tokens will be sorted inside the function\n     * @param _tokenAddress1 Address of token1\n     * @param _tokenAddress2 Address of toekn2\n     * @return Pool address of the two tokens\n     */\n    function getPairAddress(\n        address _tokenAddress1,\n        address _tokenAddress2\n    ) public view returns (address) {\n        // Policy token address at the first place\n        (address token0, address token1) = IPolicyCore(policyCore)\n            .supportedStablecoin(_tokenAddress2)\n            ? (_tokenAddress1, _tokenAddress2)\n            : (_tokenAddress2, _tokenAddress1);\n\n        address _pairAddress = getPair[token0][token1];\n\n        return _pairAddress;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Set Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Remember to call this function to set the policyCore address\n     * @dev    Only callable by the owner\n     *         < PolicyCore should be the minter of policyToken >\n     *         < This process is done inside constructor >\n     * @param _policyCore Address of policyCore contract\n     */\n    function setPolicyCoreAddress(address _policyCore) external onlyOwner {\n        emit PolicyCoreAddressChanged(policyCore, _policyCore);\n        policyCore = _policyCore;\n    }\n\n    /**\n     * @notice Set income maker proportion\n     * @dev    Only callable by the owner\n     * @param _proportion New proportion to income maker contract\n     */\n    function setIncomeMakerProportion(uint256 _proportion) external onlyOwner {\n        emit IncomeMakerProportionChanged(incomeMakerProportion, _proportion);\n        incomeMakerProportion = _proportion;\n    }\n\n    /**\n     * @notice Set income maker address\n     * @dev Only callable by the owner\n     * @param _incomeMaker New income maker address\n     */\n    function setIncomeMakerAddress(address _incomeMaker) external onlyOwner {\n        emit IncomeMakerAddressChanged(incomeMaker, _incomeMaker);\n        incomeMaker = _incomeMaker;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy a new policy token.\n     *         Detail info is included inside the token name and handled inside policyCore.       \n     * \n     * @param _policyTokenName Name of the policyToken\n     * @param _decimals        Decimals of the policyToken\n     * \n     * @return tokenAddress PolicyToken address\n     */\n    function deployPolicyToken(\n        string memory _policyTokenName,\n        uint256 _decimals\n    ) external onlyPolicyCore returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(_policyTokenName));\n\n        bytes memory bytecode = _getPolicyTokenBytecode(\n            _policyTokenName,\n            _decimals\n        );\n\n        address _policTokenAddress = _deploy(bytecode, salt);\n\n        allTokens.push(_policTokenAddress);\n\n        _nextId++;\n\n        return _policTokenAddress;\n    }\n\n    /**\n     * @notice After deploy the policytoken and get the address,\n     *         we deploy the policyToken - stablecoin pool contract.\n     * \n     * @param _policyTokenAddress Address of policy token\n     * @param _stablecoin         Address of the stable coin\n     * @param _deadline           Deadline of the pool\n     * @param _feeRate            Fee rate given to LP holders\n     * \n     * @return poolAddress Address of the pool\n     */\n    function deployPool(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) public onlyPolicyCore returns (address) {\n        bytes memory bytecode = type(NaughtyPair).creationCode;\n\n        bytes32 salt = keccak256(\n            abi.encodePacked(_policyTokenAddress, _stablecoin)\n        );\n\n        address _poolAddress = _deploy(bytecode, salt);\n\n        INaughtyPair(_poolAddress).initialize(\n            _policyTokenAddress,\n            _stablecoin,\n            _deadline,\n            _feeRate\n        );\n\n        getPair[_policyTokenAddress][_stablecoin] = _poolAddress;\n\n        allPairs.push(_poolAddress);\n\n        return _poolAddress;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy function with create2\n     * @param code Byte code of the contract (creation code)\n     * @param salt Salt for the deployment\n     * @return addr The deployed contract address\n     */\n    function _deploy(\n        bytes memory code,\n        bytes32 salt\n    ) internal returns (address addr) {\n        assembly {\n            addr := create2(0, add(code, 0x20), mload(code), salt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Get the policyToken bytecode (with constructor parameters)\n     * @param _tokenName Name of policyToken\n     * @param _decimals Decimals of policyToken\n     */\n    function _getPolicyTokenBytecode(\n        string memory _tokenName,\n        uint256 _decimals\n    ) internal view returns (bytes memory) {\n        bytes memory bytecode = type(NPPolicyToken).creationCode;\n\n        // Encodepacked the parameters\n        // The minter is set to be the policyCore address\n        return\n            abi.encodePacked(\n                bytecode,\n                abi.encode(_tokenName, _tokenName, policyCore, _decimals)\n            );\n    }\n}\n"
    },
    "contracts/naughty-price/NPPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title  Policy Token for Naughty Price\n * @notice This is the contract for token price policy token.\n *         It is a ERC20 token with an owner and a minter.\n *         The owner should be the deployer at first.\n *         The minter should be the policyCore contract.\n * @dev    It is different from the flight delay token.\n *         That is an ERC721 NFT and this is an ERC20 token.\n */\ncontract NPPolicyToken is ERC20 {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    address public minter;\n\n    uint256 private tokenDecimals;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Mint(address account, uint256 amount);\n    event Burn(address account, uint256 amount);\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _minter,\n        uint256 _decimals\n    ) ERC20(_name, _symbol) {\n        minter = _minter;\n        tokenDecimals = _decimals;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Modifiers **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only the minter can mint\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"Only minter\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint some policy tokens\n     * @param _account Address to receive the tokens\n     * @param _amount Amount to be minted\n     */\n    function mint(address _account, uint256 _amount) public onlyMinter {\n        _mint(_account, _amount);\n        emit Mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn some policy tokens\n     * @param _account Address to burn tokens\n     * @param _amount Amount to be burned\n     */\n    function burn(address _account, uint256 _amount) public onlyMinter {\n        _burn(_account, _amount);\n        emit Burn(_account, _amount);\n    }\n\n    /**\n     * @notice Get the decimals of this token\n     * @dev It should be the same as its paired stablecoin\n     */\n    function decimals() public view override returns (uint8) {\n        return uint8(tokenDecimals);\n    }\n}\n"
    },
    "contracts/tokens/ShieldSwap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { ICurvePool } from \"./interfaces/ICurvePool.sol\";\nimport { IPlatypusPool } from \"./interfaces/IPlatypusPool.sol\";\n\n/**\n * @title  Shield Swap\n * @author Eric Lee (ylikp.ust@gmail.com)\n * @dev    Users can swap other stablecoins to USDC without going to PTP or Curve\n *         USDC can be used in NaughtyPrice and future products\n *\n *         Currently, the swap is done inside Platypus & Curve\n *\n *         The stablecoin and its swapping pool should be supported\n *\n *         When deposit, the toToken is USDC, which pool to use depends on tokenToPoolForDeposit(token)\n *         When withdraw, the fromToken is USDC, which pool to use depends on tokenToPoolForWithdraw(token)\n */\ncontract ShieldSwap is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // USDC address (base token)\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n\n    // Other stablecoin addresses\n    address public constant USDCe = 0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664;\n    address public constant USDT = 0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7;\n    address public constant USDTe = 0xc7198437980c041c805A1EDcbA50c1Ce5db95118;\n    address public constant DAIe = 0xd586E7F844cEa2F87f50152665BCbc2C279D8d70;\n    address public constant YUSD = 0x111111111111ed1D73f860F57b2798b683f2d325;\n\n    uint256 public constant PLATYPUS_SWAP = 1;\n    uint256 public constant CURVE_SWAP = 2;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // PTP Main Pool: USDC + USDT + USDC.e + USDT.e + DAI.e\n    address public constant PTP_MAIN =\n        0x66357dCaCe80431aee0A7507e2E361B7e2402370;\n\n    // Curve YUSD pool: YUSD + USDT + USDC\n    address public constant CURVE_YUSD =\n        0x1da20Ac34187b2d9c74F729B85acB225D3341b25;\n\n    // Stablecoin => whether supported\n    mapping(address => bool) public supportedStablecoin;\n\n    // All supporting swap pools\n    mapping(string => address) public pools;\n\n    // Token address => swap pool address\n    // If fromToken is x, then use mapping(x) to swap\n    mapping(address => address) public tokenToPoolForDeposit;\n    // If toToken is x, then use mapping(x) to swap\n    mapping(address => address) public tokenToPoolForWithdraw;\n\n    // Curve pool address => Token address => Token index\n    mapping(address => mapping(address => int128)) public curvePoolTokenIndex;\n\n    // ------------------------------------------------------------------------- --------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event AddStablecoin(address stablecoin);\n    event Deposit(\n        address indexed user,\n        address indexed stablecoin,\n        uint256 inAmount,\n        uint256 outAmount\n    );\n    event Withdraw(address indexed user, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize() public initializer {\n        __Ownable_init();\n\n        // USDT.e\n        supportedStablecoin[USDTe] = true;\n        // USDT\n        supportedStablecoin[USDT] = true;\n        // USDC.e\n        supportedStablecoin[USDCe] = true;\n        // USDC\n        supportedStablecoin[USDC] = true;\n        // DAI.e\n        supportedStablecoin[DAIe] = true;\n        // YUSD\n        supportedStablecoin[YUSD] = true;\n\n        IERC20(USDC).approve(PTP_MAIN, type(uint256).max);\n        IERC20(USDT).approve(PTP_MAIN, type(uint256).max);\n        IERC20(USDTe).approve(PTP_MAIN, type(uint256).max);\n        IERC20(USDCe).approve(PTP_MAIN, type(uint256).max);\n        IERC20(DAIe).approve(PTP_MAIN, type(uint256).max);\n\n        IERC20(YUSD).approve(CURVE_YUSD, type(uint256).max);\n        IERC20(USDC).approve(CURVE_YUSD, type(uint256).max);\n\n        // YUSD pool indexes\n        curvePoolTokenIndex[CURVE_YUSD][YUSD] = 0;\n        curvePoolTokenIndex[CURVE_YUSD][USDC] = 1;\n        curvePoolTokenIndex[CURVE_YUSD][USDT] = 2;\n\n        // Token to pool\n        tokenToPoolForDeposit[YUSD] = CURVE_YUSD;\n        tokenToPoolForWithdraw[YUSD] = CURVE_YUSD;\n\n        tokenToPoolForDeposit[USDT] = PTP_MAIN;\n        tokenToPoolForWithdraw[USDT] = PTP_MAIN;\n\n        tokenToPoolForDeposit[USDTe] = PTP_MAIN;\n        tokenToPoolForWithdraw[USDTe] = PTP_MAIN;\n\n        tokenToPoolForDeposit[USDCe] = PTP_MAIN;\n        tokenToPoolForWithdraw[USDCe] = PTP_MAIN;\n\n        tokenToPoolForDeposit[DAIe] = PTP_MAIN;\n        tokenToPoolForWithdraw[DAIe] = PTP_MAIN;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add new supported stablecoin\n     *\n     * @dev Set a new supported token address\n     *      Only callable by the owner\n     *\n     * @param _stablecoin Stablecoin address\n     */\n    function addSupportedStablecoin(address _stablecoin) external onlyOwner {\n        supportedStablecoin[_stablecoin] = true;\n\n        emit AddStablecoin(_stablecoin);\n    }\n\n    /**\n     * @notice Add new curve pool\n     *\n     * @param _pool   Curve pool address\n     * @param _tokens Tokens inside this pool\n     */\n    function addCurvePool(address _pool, address[] calldata _tokens)\n        external\n        onlyOwner\n    {\n        uint256 length = _tokens.length;\n        for (uint256 i; i < length; ) {\n            curvePoolTokenIndex[_pool][_tokens[i]] = int128(int256(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Set the swap pool for a new token\n     *\n     * @param _isDeposit Whether for deposit or withdraw\n     * @param _token     Token address\n     * @param _pool      Pool address to swap\n     */\n    function setTokenToPool(\n        bool _isDeposit,\n        address _token,\n        address _pool\n    ) external onlyOwner {\n        if (_isDeposit) {\n            tokenToPoolForDeposit[_token] = _pool;\n        } else {\n            tokenToPoolForWithdraw[_token] = _pool;\n        }\n    }\n\n    /**\n     * @notice Approve a stablecoin for swapping\n     *         Call once for each stablecoin\n     *\n     * @param _token    Stablecoin address\n     * @param _contract Contract address to give allowance\n     */\n    function approveStablecoin(address _token, address _contract) external {\n        IERC20(_token).approve(_contract, type(uint256).max);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deposit tokens and swap to USDC\n     *         If the input is USDC, no swap needed, otherwise, swap to USDC\n     *\n     * @param _type       Swap type (1 for PTP, 2 for Curve)\n     * @param _stablecoin Stablecoin address\n     * @param _amount     Input stablecoin amount\n     * @param _minAmount  Minimum amount output (if need swap)\n     */\n    function deposit(\n        uint256 _type,\n        address _stablecoin,\n        uint256 _amount,\n        uint256 _minAmount\n    ) external {\n        require(supportedStablecoin[_stablecoin], \"Stablecoin not supported\");\n\n        // Transfer stablecoin to this contract\n        IERC20(_stablecoin).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        // Actual shield amount\n        uint256 outAmount;\n\n        if (_stablecoin != USDC) {\n            // Swap stablecoin to USDC and directly goes to this contract\n            if (_type == PLATYPUS_SWAP) {\n                outAmount = _ptpSwap(\n                    tokenToPoolForDeposit[_stablecoin],\n                    _stablecoin,\n                    USDC,\n                    _amount,\n                    _minAmount,\n                    address(this)\n                );\n            }\n            // Curve YUSD swap\n            else if (_type == CURVE_SWAP) {\n                outAmount = _curveSwap(\n                    tokenToPoolForDeposit[_stablecoin],\n                    _stablecoin,\n                    USDC,\n                    _amount,\n                    _minAmount\n                );\n            } else revert(\"No swap pair\");\n        } else {\n            outAmount = _amount;\n        }\n\n        _safeTokenTransfer(USDC, outAmount);\n\n        emit Deposit(msg.sender, _stablecoin, _amount, outAmount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Swap stablecoins in Platypus\n     *\n     * @param _pool        Platypus pool address\n     * @param _fromToken   From token address\n     * @param _toToken     To token address\n     * @param _fromAmount  Amount of from token\n     * @param _minToAmount Minimun output amount\n     * @param _to          Address that will receive the output token\n     */\n    function _ptpSwap(\n        address _pool,\n        address _fromToken,\n        address _toToken,\n        uint256 _fromAmount,\n        uint256 _minToAmount,\n        address _to\n    ) internal returns (uint256 actualAmount) {\n        (actualAmount, ) = IPlatypusPool(_pool).swap(\n            _fromToken,\n            _toToken,\n            _fromAmount,\n            _minToAmount,\n            _to,\n            block.timestamp + 10\n        );\n    }\n\n    /**\n     * @notice Swap stablecoins in Curve\n     *\n     * @param _pool         Curve pool address\n     * @param _fromToken    From token address\n     * @param _toToken      To token address\n     * @param _amountIn     Amount of from token\n     * @param _minAmountOut Minimum output amount\n     *\n     * @return actualAmountOut Actual output amount after swap\n     */\n    function _curveSwap(\n        address _pool,\n        address _fromToken,\n        address _toToken,\n        uint256 _amountIn,\n        uint256 _minAmountOut\n    ) internal returns (uint256 actualAmountOut) {\n        int128 indexFromToken = curvePoolTokenIndex[_pool][_fromToken];\n        int128 indexToToken = curvePoolTokenIndex[_pool][_toToken];\n\n        actualAmountOut = ICurvePool(_pool).exchange(\n            indexFromToken,\n            indexToToken,\n            _amountIn,\n            _minAmountOut\n        );\n    }\n\n    /**\n     * @notice Safe token transfer\n     *\n     * @param _token  Token address to be transferred\n     * @param _amount Amount of token to be transferred\n     *\n     * @return realAmount Real amount that has been transferred\n     */\n    function _safeTokenTransfer(address _token, uint256 _amount)\n        internal\n        returns (uint256 realAmount)\n    {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        if (balance > _amount) {\n            realAmount = _amount;\n        } else {\n            realAmount = balance;\n        }\n        IERC20(_token).safeTransfer(msg.sender, realAmount);\n    }\n}\n"
    },
    "contracts/tokens/interfaces/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface ICurvePool {\n    // Get the token address inside a curve stableswap pool\n    function coins(uint256 _index) external view returns (address);\n\n    // Get coin amount for the curve pool\n    function N_COINS() external view returns (int128);\n\n    // Do the exchange\n    function exchange(\n        int128 _indexForInToken,\n        int128 _indexForOutToken,\n        uint256 _amountIn,\n        uint256 _minAmountOut\n    ) external returns (uint256 actualAmount);\n}\n"
    },
    "contracts/tokens/interfaces/IPlatypusPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IPlatypusPool {\n    function swap(\n        address _fromToken,\n        address _toToken,\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 actualAmount, uint256 haircut);\n}\n"
    },
    "contracts/tokens/Shield.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { ICurvePool } from \"./interfaces/ICurvePool.sol\";\nimport { IPlatypusPool } from \"./interfaces/IPlatypusPool.sol\";\n\n/**\n * @title  Shield Token (Derived Stablecoin on Degis)\n * @author Eric Lee (ylikp.ust@gmail.com)\n * @dev    Users can swap other stablecoins to Shield (actually backed by USDC only)\n *         Shield can be used in NaughtyPrice and future products\n *\n *         When users want to withdraw, their shield tokens will be burned\n *         and USDC will be sent back to them (if no sepecific choice)\n *             other stablecoins will be sent back to them (if have sepecific choice)\n *\n *         Currently, the swap is done inside Platypus & Curve\n *\n *         The stablecoin and its swapping pool should be supported\n *\n *         When deposit, the toToken is USDC, which pool to use depends on tokenToPoolForDeposit(token)\n *         When withdraw, the fromToken is USDC, which pool to use depends on tokenToPoolForWithdraw(token)\n */\ncontract Shield is ERC20Upgradeable, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // USDC address (base token)\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n\n    // Other stablecoin addresses\n    address public constant USDCe = 0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664;\n    address public constant USDT = 0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7;\n    address public constant USDTe = 0xc7198437980c041c805A1EDcbA50c1Ce5db95118;\n    address public constant DAIe = 0xd586E7F844cEa2F87f50152665BCbc2C279D8d70;\n    address public constant YUSD = 0x111111111111ed1D73f860F57b2798b683f2d325;\n\n    uint256 public constant PLATYPUS_SWAP = 1;\n    uint256 public constant CURVE_SWAP = 2;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // PTP Main Pool: USDC + USDT + USDC.e + USDT.e + DAI.e\n    address public constant PTP_MAIN =\n        0x66357dCaCe80431aee0A7507e2E361B7e2402370;\n\n    // Curve YUSD pool: YUSD + USDT + USDC\n    address public constant CURVE_YUSD =\n        0x1da20Ac34187b2d9c74F729B85acB225D3341b25;\n\n    // Stablecoin => whether supported\n    mapping(address => bool) public supportedStablecoin;\n\n    // All supporting swap pools\n    mapping(string => address) public pools;\n\n    // Token address => swap pool address\n    // If fromToken is x, then use mapping(x) to swap\n    mapping(address => address) public tokenToPoolForDeposit;\n    // If toToken is x, then use mapping(x) to swap\n    mapping(address => address) public tokenToPoolForWithdraw;\n\n    // Curve pool address => Token address => Token index\n    mapping(address => mapping(address => int128)) public curvePoolTokenIndex;\n\n    // ------------------------------------------------------------------------- --------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event AddStablecoin(address stablecoin);\n    event Deposit(\n        address indexed user,\n        address indexed stablecoin,\n        uint256 inAmount,\n        uint256 outAmount\n    );\n    event Withdraw(address indexed user, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize() public initializer {\n        __ERC20_init(\"Shield Token\", \"SHD\");\n        __Ownable_init();\n\n        // USDT.e\n        supportedStablecoin[USDTe] = true;\n        // USDT\n        supportedStablecoin[USDT] = true;\n        // USDC.e\n        supportedStablecoin[USDCe] = true;\n        // USDC\n        supportedStablecoin[USDC] = true;\n        // DAI.e\n        supportedStablecoin[DAIe] = true;\n        // YUSD\n        supportedStablecoin[YUSD] = true;\n\n        IERC20(USDC).approve(PTP_MAIN, type(uint256).max);\n        IERC20(USDT).approve(PTP_MAIN, type(uint256).max);\n        IERC20(USDTe).approve(PTP_MAIN, type(uint256).max);\n        IERC20(USDCe).approve(PTP_MAIN, type(uint256).max);\n        IERC20(DAIe).approve(PTP_MAIN, type(uint256).max);\n\n        IERC20(YUSD).approve(CURVE_YUSD, type(uint256).max);\n        IERC20(USDC).approve(CURVE_YUSD, type(uint256).max);\n\n        // YUSD pool indexes\n        curvePoolTokenIndex[CURVE_YUSD][YUSD] = 0;\n        curvePoolTokenIndex[CURVE_YUSD][USDC] = 1;\n        curvePoolTokenIndex[CURVE_YUSD][USDT] = 2;\n\n        // Token to pool\n        tokenToPoolForDeposit[YUSD] = CURVE_YUSD;\n        tokenToPoolForWithdraw[YUSD] = CURVE_YUSD;\n\n        tokenToPoolForDeposit[USDT] = PTP_MAIN;\n        tokenToPoolForWithdraw[USDT] = PTP_MAIN;\n\n        tokenToPoolForDeposit[USDTe] = PTP_MAIN;\n        tokenToPoolForWithdraw[USDTe] = PTP_MAIN;\n\n        tokenToPoolForDeposit[USDCe] = PTP_MAIN;\n        tokenToPoolForWithdraw[USDCe] = PTP_MAIN;\n\n        tokenToPoolForDeposit[DAIe] = PTP_MAIN;\n        tokenToPoolForWithdraw[DAIe] = PTP_MAIN;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add new supported stablecoin\n     *\n     * @dev Set a new supported token address\n     *      Only callable by the owner\n     *\n     * @param _stablecoin Stablecoin address\n     */\n    function addSupportedStablecoin(address _stablecoin) external onlyOwner {\n        supportedStablecoin[_stablecoin] = true;\n\n        emit AddStablecoin(_stablecoin);\n    }\n\n    /**\n     * @notice Add new curve pool\n     *\n     * @param _pool   Curve pool address\n     * @param _tokens Tokens inside this pool\n     */\n    function addCurvePool(address _pool, address[] calldata _tokens)\n        external\n        onlyOwner\n    {\n        uint256 length = _tokens.length;\n        for (uint256 i; i < length; ) {\n            curvePoolTokenIndex[_pool][_tokens[i]] = int128(int256(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function setTokenToPool(\n        bool _isDeposit,\n        address _token,\n        address _pool\n    ) external onlyOwner {\n        if (_isDeposit) {\n            tokenToPoolForDeposit[_token] = _pool;\n        } else {\n            tokenToPoolForWithdraw[_token] = _pool;\n        }\n    }\n\n    /**\n     * @notice Approve a stablecoin for swapping\n     *         Call once for each stablecoin\n     *\n     * @param _token    Stablecoin address\n     * @param _contract Contract address to give allowance\n     */\n    function approveStablecoin(address _token, address _contract) external onlyOwner {\n        IERC20(_token).approve(_contract, type(uint256).max);\n    }\n\n    function unapprove(address _token, address _contract) external onlyOwner {\n        IERC20(_token).approve(_contract, 0);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deposit tokens and mint Shield\n     *         If the input is USDC, no swap needed, otherwise, swap to USDC\n     *\n     * @param _type       Swap type (1 for PTP, 2 for Curve)\n     * @param _stablecoin Stablecoin address\n     * @param _amount     Input stablecoin amount\n     * @param _minAmount  Minimum amount output (if need swap)\n     */\n    function deposit(\n        uint256 _type,\n        address _stablecoin,\n        uint256 _amount,\n        uint256 _minAmount\n    ) external {\n        require(supportedStablecoin[_stablecoin], \"Stablecoin not supported\");\n\n        // Transfer stablecoin to this contract\n        IERC20(_stablecoin).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        // Actual shield amount\n        uint256 outAmount;\n\n        if (_stablecoin != USDC) {\n            // Swap stablecoin to USDC and directly goes to this contract\n            if (_type == PLATYPUS_SWAP) {\n                outAmount = _ptpSwap(\n                    tokenToPoolForDeposit[_stablecoin],\n                    _stablecoin,\n                    USDC,\n                    _amount,\n                    _minAmount,\n                    address(this)\n                );\n            }\n            // Curve YUSD swap\n            else if (_type == CURVE_SWAP) {\n                outAmount = _curveSwap(\n                    tokenToPoolForDeposit[_stablecoin],\n                    _stablecoin,\n                    USDC,\n                    _amount,\n                    _minAmount\n                );\n            } else revert(\"No swap pair\");\n        } else {\n            outAmount = _amount;\n        }\n\n        // Mint shield\n        _mint(msg.sender, outAmount);\n\n        emit Deposit(msg.sender, _stablecoin, _amount, outAmount);\n    }\n\n    /**\n     * @notice Withdraw stablecoins and burn shield\n     *\n     * @param _type       Swap type (use PTP/Curve, which pool)\n     * @param _stablecoin Stablecoin address\n     * @param _amount     Amount of shield to burn\n     * @param _minAmount  Minimum amount of stablecoin to withdraw (if need swap)\n     */\n    function withdraw(\n        uint256 _type,\n        address _stablecoin,\n        uint256 _amount,\n        uint256 _minAmount\n    ) external {\n        require(supportedStablecoin[_stablecoin], \"Stablecoin not supported\");\n\n        uint256 actualAmount;\n\n        if (_stablecoin == USDC) withdraw(_stablecoin, _amount, _amount);\n        else {\n            if (_type == PLATYPUS_SWAP) {\n                // Swap USDC to stablecoin and directly\n                actualAmount = _ptpSwap(\n                    tokenToPoolForWithdraw[_stablecoin],\n                    USDC,\n                    _stablecoin,\n                    _amount,\n                    _minAmount,\n                    address(this)\n                );\n            } else if (_type == CURVE_SWAP) {\n                actualAmount = _curveSwap(\n                    tokenToPoolForWithdraw[_stablecoin],\n                    USDC,\n                    _stablecoin,\n                    _amount,\n                    _minAmount\n                );\n            }\n\n            // Actual amount may have different decimals\n            withdraw(_stablecoin, actualAmount, _amount);\n        }\n    }\n\n    /**\n     * @notice Withdraw stablecoin and burn shield\n     *\n     * @param _stablecoin       Stablecoin address\n     * @param _stablecoinAmount Stablecoin amount to be transferred back\n     * @param _shieldAmount     Shield amount to be burned\n     */\n    function withdraw(\n        address _stablecoin,\n        uint256 _stablecoinAmount,\n        uint256 _shieldAmount\n    ) internal {\n        // Transfer stablecoin back\n        uint256 realAmount = _safeTokenTransfer(_stablecoin, _stablecoinAmount);\n\n        // Burn shield token\n        _burn(msg.sender, _shieldAmount);\n\n        emit Withdraw(msg.sender, realAmount);\n    }\n\n    /**\n     * @notice Withdraw all of a user's balance\n     *         This function only returns USDC back\n     *         If you want other tokens back, use withdraw()\n     */\n    function withdrawAll() external {\n        uint256 userBalance = balanceOf(msg.sender);\n        withdraw(USDC, userBalance, userBalance);\n    }\n\n    /**\n     * @notice Shield has 6 decimals\n     */\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Swap stablecoins in Platypus\n     *\n     * @param _pool        Platypus pool address\n     * @param _fromToken   From token address\n     * @param _toToken     To token address\n     * @param _fromAmount  Amount of from token\n     * @param _minToAmount Minimun output amount\n     * @param _to          Address that will receive the output token\n     */\n    function _ptpSwap(\n        address _pool,\n        address _fromToken,\n        address _toToken,\n        uint256 _fromAmount,\n        uint256 _minToAmount,\n        address _to\n    ) internal returns (uint256 actualAmount) {\n        (actualAmount, ) = IPlatypusPool(_pool).swap(\n            _fromToken,\n            _toToken,\n            _fromAmount,\n            _minToAmount,\n            _to,\n            block.timestamp + 10\n        );\n    }\n\n    /**\n     * @notice Swap stablecoins in Curve\n     *\n     * @param _pool         Curve pool address\n     * @param _fromToken    From token address\n     * @param _toToken      To token address\n     * @param _amountIn     Amount of from token\n     * @param _minAmountOut Minimum output amount\n     *\n     * @return actualAmountOut Actual output amount after swap\n     */\n    function _curveSwap(\n        address _pool,\n        address _fromToken,\n        address _toToken,\n        uint256 _amountIn,\n        uint256 _minAmountOut\n    ) internal returns (uint256 actualAmountOut) {\n        int128 indexFromToken = curvePoolTokenIndex[_pool][_fromToken];\n        int128 indexToToken = curvePoolTokenIndex[_pool][_toToken];\n\n        actualAmountOut = ICurvePool(_pool).exchange(\n            indexFromToken,\n            indexToToken,\n            _amountIn,\n            _minAmountOut\n        );\n    }\n\n    /**\n     * @notice Safe token transfer\n     *\n     * @param _token  Token address to be transferred\n     * @param _amount Amount of token to be transferred\n     *\n     * @return realAmount Real amount that has been transferred\n     */\n    function _safeTokenTransfer(address _token, uint256 _amount)\n        internal\n        returns (uint256 realAmount)\n    {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        if (balance > _amount) {\n            realAmount = _amount;\n        } else {\n            realAmount = balance;\n        }\n        IERC20(_token).safeTransfer(msg.sender, realAmount);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/staking/abstracts/BasePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/IStakingPoolFactory.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nabstract contract BasePool is IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    struct UserInfo {\n        uint256 tokenAmount;\n        uint256 totalWeight;\n        uint256 rewardDebt;\n        // An array of holder's deposits\n        Deposit[] deposits;\n    }\n    mapping(address => UserInfo) public users;\n\n    // Token address staked in this pool\n    address public poolToken;\n\n    // Reward token: degis\n    address public degisToken;\n\n    // Reward start timestamp\n    uint256 public startTimestamp;\n\n    // Degis reward speed\n    uint256 public degisPerSecond;\n\n    // Last check point\n    uint256 public lastRewardTimestamp;\n\n    // Accumulated degis per weight till now\n    uint256 public accDegisPerWeight;\n\n    // Total weight in the pool\n    uint256 public totalWeight;\n\n    // Factory contract address\n    address public factory;\n\n    // Fees are paid to the previous stakers\n    uint256 public constant FEE_RATE = 2;\n\n    // Weight multiplier constants\n    uint256 internal constant WEIGHT_MULTIPLIER = 1e6;\n\n    uint256 internal constant YEAR_STAKE_WEIGHT_MULTIPLIER =\n        2 * WEIGHT_MULTIPLIER;\n\n    uint256 internal constant REWARD_PER_WEIGHT_MULTIPLIER = 1e12;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Stake(address user, uint256 amount, uint256 lockUntil);\n\n    event Unstake(address user, uint256 amount);\n\n    event Harvest(address user, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor\n     */\n    constructor(\n        address _degisToken,\n        address _poolToken,\n        address _factory,\n        uint256 _startTimestamp,\n        uint256 _degisPerSecond\n    ) {\n        degisToken = _degisToken;\n        poolToken = _poolToken;\n        factory = _factory;\n\n        degisPerSecond = _degisPerSecond;\n\n        startTimestamp = _startTimestamp;\n\n        lastRewardTimestamp = block.timestamp > _startTimestamp\n            ? block.timestamp\n            : _startTimestamp;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only the factory can call some functions\n     */\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Only factory\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get a user's deposit info\n     * @param _user User address\n     * @return deposits[] User's deposit info\n     */\n    function getUserDeposits(\n        address _user\n    ) external view returns (Deposit[] memory) {\n        return users[_user].deposits;\n    }\n\n    /**\n     * @notice Get pending rewards\n     * @param _user User address\n     * @return pendingReward User's pending rewards\n     */\n    function pendingReward(address _user) external view returns (uint256) {\n        if (\n            block.timestamp < lastRewardTimestamp ||\n            block.timestamp < startTimestamp ||\n            totalWeight == 0\n        ) return 0;\n\n        uint256 blocks = block.timestamp - lastRewardTimestamp;\n        uint256 degisReward = blocks * degisPerSecond;\n\n        // recalculated value for `yieldRewardsPerWeight`\n        uint256 newDegisPerWeight = rewardToWeight(degisReward, totalWeight) +\n            accDegisPerWeight;\n\n        // based on the rewards per weight value, calculate pending rewards;\n        UserInfo memory user = users[_user];\n\n        uint256 pending = weightToReward(user.totalWeight, newDegisPerWeight) -\n            user.rewardDebt;\n\n        return pending;\n    }\n\n    function rewardToWeight(\n        uint256 reward,\n        uint256 rewardPerWeight\n    ) public pure returns (uint256) {\n        return (reward * REWARD_PER_WEIGHT_MULTIPLIER) / rewardPerWeight;\n    }\n\n    function weightToReward(\n        uint256 weight,\n        uint256 rewardPerWeight\n    ) public pure returns (uint256) {\n        return (weight * rewardPerWeight) / REWARD_PER_WEIGHT_MULTIPLIER;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n    function setDegisPerSecond(uint256 _degisPerSecond) external onlyFactory {\n        degisPerSecond = _degisPerSecond;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Stake tokens\n     * @param _amount Amount of tokens to stake\n     * @param _lockUntil Lock until timestamp\n     */\n    function stake(uint256 _amount, uint256 _lockUntil) external {\n        _stake(msg.sender, _amount, _lockUntil);\n    }\n\n    /**\n     * @notice Unstake tokens\n     * @param _depositId Deposit id to be unstaked\n     * @param _amount Amount of tokens to unstake\n     */\n    function unstake(uint256 _depositId, uint256 _amount) external {\n        _unstake(msg.sender, _depositId, _amount);\n    }\n\n    /**\n     * @notice Harvest your staking rewards\n     */\n    function harvest() external {\n        // First update the pool\n        updatePool();\n\n        UserInfo storage user = users[msg.sender];\n\n        // calculate pending yield rewards, this value will be returned\n        uint256 pending = _pendingReward(msg.sender);\n\n        if (pending == 0) return;\n\n        _safeDegisTransfer(msg.sender, pending);\n\n        user.rewardDebt = weightToReward(user.totalWeight, accDegisPerWeight);\n\n        emit Harvest(msg.sender, pending);\n    }\n\n    /**\n     * @notice Update the pool without fee\n     */\n    function updatePool() public {\n        _updatePoolWithFee(0);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update pool status with fee (if any)\n     * @param _fee Fee to be distributed\n     */\n    function _updatePoolWithFee(uint256 _fee) internal {\n        if (block.timestamp <= lastRewardTimestamp) return;\n\n        uint256 balance = IERC20(poolToken).balanceOf(address(this));\n\n        if (balance == 0) {\n            lastRewardTimestamp = block.timestamp;\n            return;\n        }\n\n        uint256 timePassed = block.timestamp - lastRewardTimestamp;\n\n        // There is _fee when staking\n        uint256 degisReward = timePassed * degisPerSecond + _fee;\n\n        // Mint reward to this staking pool\n        IStakingPoolFactory(factory).mintReward(address(this), degisReward);\n\n        accDegisPerWeight += rewardToWeight(degisReward, totalWeight);\n\n        lastRewardTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Finish stake process.\n     *         Two types of staking: normal and lock.\n     *           - Normal: can unlock any time\n     *           - Lock: can only unlock after lockUntil timestamp, each stake action will create a different entity\n     *\n     * @param _user      User address\n     * @param _amount    Amount of tokens to stake\n     * @param _lockUntil Lock until timestamp (0 for normal staking)\n     */\n    function _stake(\n        address _user,\n        uint256 _amount,\n        uint256 _lockUntil\n    ) internal virtual nonReentrant {\n        require(block.timestamp > startTimestamp, \"Pool not started\");\n        require(_amount > 0, \"Zero amount\");\n        require(\n            _lockUntil == 0 || (_lockUntil > block.timestamp),\n            \"Invalid lock interval\"\n        );\n        if (_lockUntil >= block.timestamp + 365 days)\n            _lockUntil = block.timestamp + 365 days;\n\n        uint256 depositFee;\n        if (IERC20(poolToken).balanceOf(address(this)) > 0) {\n            // Charge deposit fee and distribute to previous stakers\n            depositFee = (_amount * FEE_RATE) / 100;\n            _updatePoolWithFee(depositFee);\n        } else updatePool();\n\n        UserInfo storage user = users[_user];\n\n        if (user.tokenAmount > 0) {\n            _distributeReward(_user);\n        }\n\n        uint256 previousBalance = IERC20(poolToken).balanceOf(address(this));\n        transferPoolTokenFrom(msg.sender, address(this), _amount);\n        uint256 newBalance = IERC20(poolToken).balanceOf(address(this));\n\n        // Actual amount is without the fee\n        uint256 addedAmount = newBalance - previousBalance - depositFee;\n\n        // For normal staking, lockFrom = 0, lockUntil = 0\n        uint256 lockFrom = _lockUntil > 0 ? block.timestamp : 0;\n        uint256 lockUntil = _lockUntil;\n\n        uint256 stakeWeight = timeToWeight(lockUntil - lockFrom) * addedAmount;\n        assert(stakeWeight > 0);\n\n        Deposit memory newDeposit = Deposit({\n            tokenAmount: addedAmount,\n            weight: stakeWeight,\n            lockedFrom: lockFrom,\n            lockedUntil: lockUntil\n        });\n        // deposit ID is an index of the deposit in `deposits` array\n        user.deposits.push(newDeposit);\n\n        user.tokenAmount += addedAmount;\n        user.totalWeight += stakeWeight;\n        user.rewardDebt = weightToReward(user.totalWeight, accDegisPerWeight);\n\n        totalWeight += stakeWeight;\n\n        emit Stake(msg.sender, _amount, _lockUntil);\n    }\n\n    /**\n     * @notice Finish unstake process\n     * @param _user User address\n     * @param _depositId deposit ID to unstake from, zero-indexed\n     * @param _amount amount of tokens to unstake\n     */\n    function _unstake(\n        address _user,\n        uint256 _depositId,\n        uint256 _amount\n    ) internal virtual nonReentrant {\n        // verify an amount is set\n        require(_amount > 0, \"zero amount\");\n\n        UserInfo storage user = users[_user];\n\n        Deposit storage stakeDeposit = user.deposits[_depositId];\n\n        // verify available balance\n        // if staker address ot deposit doesn't exist this check will fail as well\n        require(stakeDeposit.tokenAmount >= _amount, \"amount exceeds stake\");\n\n        // update smart contract state\n        updatePool();\n        // and process current pending rewards if any\n        _distributeReward(_user);\n\n        // recalculate deposit weight\n        uint256 previousWeight = stakeDeposit.weight;\n\n        uint256 newWeight = timeToWeight(\n            stakeDeposit.lockedUntil - stakeDeposit.lockedFrom\n        ) * (stakeDeposit.tokenAmount - _amount);\n\n        // update the deposit, or delete it if its depleted\n        if (stakeDeposit.tokenAmount - _amount == 0) {\n            delete user.deposits[_depositId];\n        } else {\n            stakeDeposit.tokenAmount -= _amount;\n            stakeDeposit.weight = newWeight;\n        }\n\n        // update user record\n        user.tokenAmount -= _amount;\n        user.totalWeight = user.totalWeight - previousWeight + newWeight;\n        user.rewardDebt = weightToReward(user.totalWeight, accDegisPerWeight);\n\n        // update global variable\n        totalWeight -= (previousWeight - newWeight);\n\n        // otherwise just return tokens back to holder\n        transferPoolToken(msg.sender, _amount);\n\n        // emit an event\n        emit Unstake(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Lock time => Lock weight\n     * @dev 1 year = 2e6\n     *      1 week = 1e6\n     *      2 weeks = 1e6 * ( 1 + 1 / 365)\n     */\n    function timeToWeight(\n        uint256 _length\n    ) public pure returns (uint256 _weight) {\n        _weight =\n            ((_length * WEIGHT_MULTIPLIER) / 365 days) +\n            WEIGHT_MULTIPLIER;\n    }\n\n    /**\n     * @notice Check pending reward after update\n     * @param _user User address\n     */\n    function _pendingReward(\n        address _user\n    ) internal view returns (uint256 pending) {\n        // read user data structure into memory\n        UserInfo memory user = users[_user];\n\n        // and perform the calculation using the values read\n        return\n            weightToReward(user.totalWeight, accDegisPerWeight) -\n            user.rewardDebt;\n    }\n\n    /**\n     * @notice Distribute reward to staker\n     * @param _user User address\n     */\n    function _distributeReward(address _user) internal {\n        uint256 pending = _pendingReward(_user);\n\n        if (pending == 0) return;\n        else {\n            _safeDegisTransfer(_user, pending);\n        }\n    }\n\n    /**\n     * @notice Transfer pool token from pool to user\n     */\n    function transferPoolToken(address _to, uint256 _value) internal {\n        // just delegate call to the target\n        IERC20(poolToken).safeTransfer(_to, _value);\n    }\n\n    /**\n     * @notice Transfer pool token from user to pool\n     * @param _from User address\n     * @param _to Pool address\n     * @param _value Amount of tokens to transfer\n     */\n    function transferPoolTokenFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        IERC20(poolToken).safeTransferFrom(_from, _to, _value);\n    }\n\n    /**\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\n     * @param _to User's address\n     * @param _amount Amount to transfer\n     */\n    function _safeDegisTransfer(address _to, uint256 _amount) internal {\n        uint256 totalDegis = IERC20(degisToken).balanceOf(address(this));\n        if (_amount > totalDegis) {\n            IERC20(degisToken).safeTransfer(_to, totalDegis);\n        } else {\n            IERC20(degisToken).safeTransfer(_to, _amount);\n        }\n    }\n}\n"
    },
    "contracts/staking/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n/**\n * @title Illuvium Pool\n *\n * @notice An abstraction representing a pool, see IlluviumPoolBase for details\n *\n * @author Pedro Bergamini, reviewed by Basil Gorin\n */\ninterface IPool {\n    /**\n     * @dev Deposit is a key data structure used in staking,\n     *      it represents a unit of stake with its amount, weight and term (time interval)\n     */\n    struct Deposit {\n        // @dev token amount staked\n        uint256 tokenAmount;\n        // @dev stake weight\n        uint256 weight;\n        // @dev locking period - from\n        uint256 lockedFrom;\n        // @dev locking period - until\n        uint256 lockedUntil;\n    }\n\n    // for the rest of the functions see Soldoc in IlluviumPoolBase\n\n    function degisToken() external view returns (address);\n\n    function poolToken() external view returns (address);\n\n    function startTimestamp() external view returns (uint256);\n\n    function degisPerSecond() external view returns (uint256);\n\n    function totalWeight() external view returns (uint256);\n\n    function accDegisPerWeight() external view returns (uint256);\n\n    function pendingReward(address _user) external view returns (uint256);\n\n    function setDegisPerSecond(uint256 _degisPerSecond) external;\n}\n"
    },
    "contracts/staking/interfaces/IStakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IStakingPoolFactory {\n    function createPool(\n        address _poolToken,\n        uint256 _startBlock,\n        uint256 _degisPerBlock\n    ) external;\n\n    function mintReward(address _to, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/staking/CoreStakingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport {Ownable} from \"../utils/Ownable.sol\";\nimport {BasePool} from \"./abstracts/BasePool.sol\";\n\ncontract CoreStakingPool is Ownable, BasePool {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _degisToken,\n        address _poolToken,\n        address _factory,\n        uint256 _startTimestamp,\n        uint256 _degisPerSecond\n    )\n        Ownable(msg.sender)\n        BasePool(\n            _degisToken,\n            _poolToken,\n            _factory,\n            _startTimestamp,\n            _degisPerSecond\n        )\n    {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Stake function, will call the stake in BasePool\n     * @param _user User address\n     * @param _amount Amount to stake\n     * @param _lockUntil Lock until timestamp (0 means flexible staking)\n     */\n    function _stake(\n        address _user,\n        uint256 _amount,\n        uint256 _lockUntil\n    ) internal override {\n        super._stake(_user, _amount, _lockUntil);\n    }\n\n    /**\n     * @notice Unstake function, will check some conditions and call the unstake in BasePool\n     * @param _user User address\n     * @param _depositId Deposit id\n     * @param _amount Amount to unstake\n     */\n    function _unstake(\n        address _user,\n        uint256 _depositId,\n        uint256 _amount\n    ) internal override {\n        UserInfo storage user = users[_msgSender()];\n        Deposit memory stakeDeposit = user.deposits[_depositId];\n        require(\n            stakeDeposit.lockedFrom == 0 ||\n                block.timestamp >= stakeDeposit.lockedUntil,\n            \"Deposit not yet unlocked\"\n        );\n\n        super._unstake(_user, _depositId, _amount);\n    }\n}\n"
    },
    "contracts/staking/StakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport {Ownable} from \"../utils/Ownable.sol\";\nimport {IPool} from \"./interfaces/IPool.sol\";\nimport {BasePool, CoreStakingPool} from \"./CoreStakingPool.sol\";\nimport {IDegisToken} from \"../tokens/interfaces/IDegisToken.sol\";\n\ncontract StakingPoolFactory is Ownable {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Pool data info\n    struct PoolData {\n        address poolToken; // pool token address (Degis / Degis LP Token)\n        address poolAddress; // pool address (deployed by factory)\n        uint256 startTimestamp; // pool start timestamp\n        uint256 degisPerSecond; // reward speed\n    }\n\n    address public degisToken;\n\n    // Pool token address  => pool address\n    mapping(address => address) public pools;\n\n    // Pool address => whether exists\n    mapping(address => bool) public poolExists;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event PoolRegistered(\n        address indexed by,\n        address indexed poolToken,\n        address indexed poolAddress,\n        uint256 degisPerSecond\n    );\n\n    event DegisPerSecondChanged(address pool, uint256 degisPerSecond);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(address _degisToken) Ownable(msg.sender) {\n        degisToken = _degisToken;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the pool address from pool token address\n     * @param _poolToken Pool token address\n     */\n    function getPoolAddress(address _poolToken)\n        external\n        view\n        returns (address)\n    {\n        return pools[_poolToken];\n    }\n\n    /**\n     * @notice Get pool data from pool token address\n     * @param _poolToken Pool token address\n     * @return poolData Pool data struct\n     */\n    function getPoolData(address _poolToken)\n        public\n        view\n        returns (PoolData memory)\n    {\n        // get the pool address from the mapping\n        address poolAddr = pools[_poolToken];\n\n        // throw if there is no pool registered for the token specified\n        require(poolAddr != address(0), \"pool not found\");\n\n        // read pool information from the pool smart contract\n        // via the pool interface (IPool)\n        address poolToken = IPool(poolAddr).poolToken();\n        uint256 startTimestamp = IPool(poolAddr).startTimestamp();\n        uint256 degisPerSecond = IPool(poolAddr).degisPerSecond();\n\n        // create the in-memory structure and return it\n        return\n            PoolData({\n                poolToken: poolToken,\n                poolAddress: poolAddr,\n                startTimestamp: startTimestamp,\n                degisPerSecond: degisPerSecond\n            });\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set degis per second for a pool\n     * @param _pool Address of the staking pool\n     * @param _degisPerSecond Degis reward per second\n     */\n    function setDegisPerSecond(address _pool, uint256 _degisPerSecond)\n        external\n        onlyOwner\n    {\n        BasePool(_pool).setDegisPerSecond(_degisPerSecond);\n\n        emit DegisPerSecondChanged(_pool, _degisPerSecond);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Creates a staking pool and registers it within the factory\n     * @dev Only called by the owner\n     * @param _poolToken Pool token address\n     * @param _startTimestamp Start timestamp for reward\n     * @param _degisPerSecond Reward speed\n     */\n    function createPool(\n        address _poolToken,\n        uint256 _startTimestamp,\n        uint256 _degisPerSecond\n    ) external onlyOwner {\n        // create/deploy new core pool instance\n        IPool pool = new CoreStakingPool(\n            degisToken,\n            _poolToken,\n            address(this),\n            _startTimestamp,\n            _degisPerSecond\n        );\n\n        // register it within a factory\n        _registerPool(address(pool));\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Register a deployed pool instance within the factory\n     * @param _poolAddr Address of the already deployed pool instance\n     */\n    function _registerPool(address _poolAddr) internal {\n        // Read pool information from the pool smart contract\n        // via the pool interface (IPool)\n        address poolToken = IPool(_poolAddr).poolToken();\n        uint256 degisPerSecond = IPool(_poolAddr).degisPerSecond();\n\n        // Ensure that the pool is not already registered within the factory\n        require(\n            pools[poolToken] == address(0),\n            \"This pool is already registered\"\n        );\n\n        // Record\n        pools[poolToken] = _poolAddr;\n        poolExists[_poolAddr] = true;\n\n        emit PoolRegistered(\n            msg.sender,\n            poolToken,\n            _poolAddr,\n            degisPerSecond\n        );\n    }\n\n    /**\n     * @notice Mint degis tokens as reward\n     * @dev With this function, we only need to add factory contract into minterList\n     * @param _to The address to mint tokens to\n     * @param _amount Amount of degis tokens to mint\n     */\n    function mintReward(address _to, uint256 _amount) external {\n        // Verify that sender is a pool registered withing the factory\n        require(poolExists[msg.sender], \"Only called from pool\");\n\n        // Mint degis tokens as required\n        IDegisToken(degisToken).mintDegis(_to, _amount);\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IDegisToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDegisToken is IERC20, IERC20Permit {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Functions ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    function CAP() external view returns (uint256);\n\n    /**\n     * @notice Mint degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintDegis(address _account, uint256 _amount) external;\n\n    /**\n     * @notice Burn degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnDegis(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/tokens/DegisToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IDegisToken.sol\";\nimport \"../utils/ERC20PermitWithMultipleMinters.sol\";\n\n/**@title  Degis Token\n * @notice DegisToken inherits from ERC20 Permit which contains the basic ERC20 implementation.\n *         DegisToken can use the permit function rather than approve + transferFrom.\n *\n *         DegisToken has an owner, a minterList and a burnerList.\n *         When lauched on mainnet, the owner may be removed or tranferred to a multisig.\n *         By default, the owner & the first minter will be the one that deploys the contract.\n *         The minterList should contain FarmingPool and PurchaseIncentiveVault.\n *         The burnerList should contain EmergencyPool.\n */\ncontract DegisToken is ERC20PermitWithMultipleMinters {\n    // Degis has a total supply of 100 million\n    uint256 public constant CAP = 1e8 ether;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Constructor *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() ERC20PermitWithMultipleMinters(\"DegisToken\", \"DEG\") {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Modifiers **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Degis token has a hard cap of 100 million\n    modifier notExceedCap(uint256 _amount) {\n        require(\n            totalSupply() + _amount <= CAP,\n            \"Exceeds the DEG cap (100 million)\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount  Amount to be minted\n     */\n    function mintDegis(address _account, uint256 _amount)\n        external\n        notExceedCap(_amount)\n    {\n        mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount  Amount to be burned\n     */\n    function burnDegis(address _account, uint256 _amount) external {\n        burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/utils/ERC20PermitWithMultipleMinters.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"./OwnableWithoutContext.sol\";\n\n/**\n * @title  ERC20 with Multiple Minters and Burners\n * @notice This is contract used for ERC20 tokens that has multiple minters and burners.\n * @dev    The minters and burners are some contracts in Degis that need to issue DEG.\n *         It has basic implementations for ERC20 and also the owner control.\n *         Even if the owner is renounced to zero address, the token can still be minted/burned.\n *         DegisToken and BuyerToken are both this kind ERC20 token.\n */\ncontract ERC20PermitWithMultipleMinters is ERC20Permit, OwnableWithoutContext {\n    // List of all minters\n    mapping(address => bool) public isMinter;\n\n    // List of all burners\n    mapping(address => bool) public isBurner;\n\n    event MinterAdded(address newMinter);\n    event MinterRemoved(address oldMinter);\n\n    event BurnerAdded(address newBurner);\n    event BurnerRemoved(address oldBurner);\n\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    constructor(string memory name, string memory symbol)\n        ERC20(name, symbol)\n        ERC20Permit(name)\n        OwnableWithoutContext(msg.sender)\n    {\n        // After the owner is transferred to multisig governance\n        // This initial minter should be removed\n        isMinter[_msgSender()] = true;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Modifiers ****************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     *@notice Check if the msg.sender is in the minter list\n     */\n    modifier validMinter(address _sender) {\n        require(isMinter[_sender], \"Invalid minter\");\n        _;\n    }\n\n    /**\n     * @notice Check if the msg.sender is in the burner list\n     */\n    modifier validBurner(address _sender) {\n        require(isBurner[_sender], \"Invalid burner\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Admin Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new minter into the minterList\n     * @param _newMinter Address of the new minter\n     */\n    function addMinter(address _newMinter) external onlyOwner {\n        require(!isMinter[_newMinter], \"Already a minter\");\n\n        isMinter[_newMinter] = true;\n\n        emit MinterAdded(_newMinter);\n    }\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldMinter Address of the minter to be removed\n     */\n    function removeMinter(address _oldMinter) external onlyOwner {\n        require(isMinter[_oldMinter], \"Not a minter\");\n\n        isMinter[_oldMinter] = false;\n\n        emit MinterRemoved(_oldMinter);\n    }\n\n    /**\n     * @notice Add a new burner into the burnerList\n     * @param _newBurner Address of the new burner\n     */\n    function addBurner(address _newBurner) external onlyOwner {\n        require(!isBurner[_newBurner], \"Already a burner\");\n\n        isBurner[_newBurner] = true;\n\n        emit BurnerAdded(_newBurner);\n    }\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldBurner Address of the minter to be removed\n     */\n    function removeBurner(address _oldBurner) external onlyOwner {\n        require(isMinter[_oldBurner], \"Not a burner\");\n\n        isBurner[_oldBurner] = false;\n\n        emit BurnerRemoved(_oldBurner);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint tokens\n     * @param _account Receiver's address\n     * @param _amount Amount to be minted\n     */\n    function mint(address _account, uint256 _amount)\n        internal\n        validMinter(_msgSender())\n    {\n        _mint(_account, _amount); // ERC20 method with an event\n        emit Mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn tokens\n     * @param _account address\n     * @param _amount amount to be burned\n     */\n    function burn(address _account, uint256 _amount)\n        internal\n        validBurner(_msgSender())\n    {\n        _burn(_account, _amount);\n        emit Burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/utils/OwnableWithoutContext.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n/**\n * @dev The owner can be set during deployment, not default to be msg.sender\n */\nabstract contract OwnableWithoutContext {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor(address _initialOwner) {\n        _transferOwnership(_initialOwner);\n    }\n\n    /**\n     * @notice Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @notice Leaves the contract without owner. It will not be possible to call\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * @dev    Renouncing ownership will leave the contract without an owner,\n     *         thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Can only be called by the current owner.\n     * @param  newOwner Address of the new owner\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Internal function without access restriction.\n     * @param  newOwner Address of the new owner\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/tokens/BuyerToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../utils/ERC20PermitWithMultipleMinters.sol\";\n\n/**\n * @title  Buyer Token\n * @notice Buyer tokens are distributed to buyers corresponding to the usd value they spend.\n *         Users can deposit their buyer tokens into PurchaseIncentiveVault.\n *         Periodical reward will be given to the participants in PurchaseIncentiveVault.\n *         When distributing purchase incentive reward, the buyer tokens will be burned.\n * @dev    Need to set the correct minters and burners when reploying this contract.\n */\ncontract BuyerToken is ERC20PermitWithMultipleMinters {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Constructor *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() ERC20PermitWithMultipleMinters(\"DegisBuyerToken\", \"DBT\") {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount  Amount to be minted\n     */\n    function mintBuyerToken(address _account, uint256 _amount) external {\n        mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount  Amount to be burned\n     */\n    function burnBuyerToken(address _account, uint256 _amount) external {\n        burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/farming/PurchaseIncentiveVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\npragma solidity ^0.8.10;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../tokens/interfaces/IDegisToken.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/**\n * @title  Purchase Incentive Vault\n * @notice This is the purchase incentive vault for staking buyer tokens\n *         Users first stake their buyer tokens and wait for distribution\n *         About every 24 hours, the reward will be calculated to users' account\n *         After disrtribution, reward will be updated\n *              but it still need to be manually claimed.\n *\n *         Buyer tokens can only be used once\n *         You can withdraw your buyer token within the same round (current round)\n *         They can not be withdrawed if the round was settled\n */\ncontract PurchaseIncentiveVault is\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    string public constant name = \"Degis Purchase Incentive Vault\";\n\n    // Buyer Token & Degis Token SCALE = 1e18\n    uint256 public constant SCALE = 1e18;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Other contracts\n    IERC20 buyerToken;\n    IDegisToken degis;\n\n    // Current round number\n    uint256 public currentRound;\n\n    // Degis reward per round\n    uint256 public degisPerRound;\n\n    // The interval will only limit the distribution (not the staking)\n    uint256 public distributionInterval;\n\n    // Last distribution block\n    uint256 public lastDistribution;\n\n    // Max round for one claim\n    // When upgrade this parameter, redeploy the contract\n    uint256 public constant MAX_ROUND = 50;\n\n    struct RoundInfo {\n        uint256 shares;\n        address[] users;\n        bool hasDistributed;\n        uint256 degisPerShare;\n    }\n    mapping(uint256 => RoundInfo) public rounds;\n\n    struct UserInfo {\n        uint256 lastRewardRoundIndex;\n        uint256[] pendingRounds;\n    }\n    mapping(address => UserInfo) public users;\n\n    // User address => Round number => User shares\n    mapping(address => mapping(uint256 => uint256)) public userSharesInRound;\n\n    uint256[] internal threshold;\n    uint256[] internal piecewise;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event DegisRewardChanged(\n        uint256 oldRewardPerRound,\n        uint256 newRewardPerRound\n    );\n    event DistributionIntervalChanged(uint256 oldInterval, uint256 newInterval);\n    event Stake(\n        address userAddress,\n        uint256 currentRound,\n        uint256 actualAmount\n    );\n    event Redeem(address userAddress, uint256 currentRound, uint256 amount);\n    event RewardClaimed(address userAddress, uint256 userReward);\n    event RoundSettled(uint256 currentRound, uint256 blockNumber);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error PIV__NotPassedInterval();\n    error PIV__ZeroAmount();\n    error PIV__NotEnoughBuyerTokens();\n    error PIV__AlreadyDistributed();\n    error PIV__NoPendingRound();\n    error PIV__ClaimedAll();\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(\n        address _buyerToken,\n        address _degisToken\n    ) public initializer {\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        // Initialize two tokens\n        buyerToken = IERC20(_buyerToken);\n        degis = IDegisToken(_degisToken);\n\n        // Initialize the last distribution time\n        lastDistribution = block.timestamp;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if admins can distribute now\n     * @dev Should pass the distribution interval\n     */\n    modifier hasPassedInterval() {\n        if (block.timestamp - lastDistribution <= distributionInterval)\n            revert PIV__NotPassedInterval();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the amount of users in _round, used for distribution\n     * @param _round Round number to check\n     * @return totalUsers Total amount of users in _round\n     */\n    function getTotalUsersInRound(\n        uint256 _round\n    ) external view returns (uint256) {\n        return rounds[_round].users.length;\n    }\n\n    /**\n     * @notice Get the user addresses in _round\n     * @param _round Round number to check\n     * @return users All user addresses in this round\n     */\n    function getUsersInRound(\n        uint256 _round\n    ) external view returns (address[] memory) {\n        return rounds[_round].users;\n    }\n\n    /**\n     * @notice Get user's pending rounds\n     * @param _user User address to check\n     * @return pendingRounds User's pending rounds\n     */\n    function getUserPendingRounds(\n        address _user\n    ) external view returns (uint256[] memory) {\n        return users[_user].pendingRounds;\n    }\n\n    /**\n     * @notice Get your shares in the current round\n     * @param _user Address of the user\n     * @param _round Round number\n     * @return userShares User's shares in the current round\n     */\n    function getUserShares(\n        address _user,\n        uint256 _round\n    ) external view returns (uint256) {\n        return userSharesInRound[_user][_round];\n    }\n\n    /**\n     * @notice Get a user's pending reward\n     * @param _user User address\n     * @return userPendingReward User's pending reward\n     */\n    function pendingReward(\n        address _user\n    ) external view returns (uint256 userPendingReward) {\n        UserInfo memory user = users[_user];\n\n        // Total rounds that need to be distributed\n        uint256 length = user.pendingRounds.length - user.lastRewardRoundIndex;\n\n        // Start from last reward round index\n        uint256 startIndex = user.lastRewardRoundIndex;\n\n        for (uint256 i = startIndex; i < startIndex + length; ) {\n            uint256 round = user.pendingRounds[i];\n\n            userPendingReward +=\n                (rounds[round].degisPerShare *\n                    userSharesInRound[_user][round]) /\n                SCALE;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Get degis reward per round\n     * @dev Depends on the total shares in this round\n     * @return rewardPerRound Degis reward per round\n     */\n    function getRewardPerRound() public view returns (uint256 rewardPerRound) {\n        uint256 buyerBalance = rounds[currentRound].shares;\n\n        uint256[] memory thresholdM = threshold;\n\n        // If no piecewise is set, use the default degisPerRound\n        if (thresholdM.length == 0) rewardPerRound = degisPerRound;\n        else {\n            for (uint256 i = thresholdM.length - 1; i >= 0; ) {\n                if (buyerBalance >= thresholdM[i]) {\n                    rewardPerRound = piecewise[i];\n                    break;\n                }\n                unchecked {\n                    --i;\n                }\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function pause() external onlyOwner {\n        super._pause();\n    }\n\n    function unpause() external onlyOwner {\n        super._unpause();\n    }\n\n    /**\n     * @notice Set degis distribution per round\n     * @param _degisPerRound Degis distribution per round\n     */\n    function setDegisPerRound(uint256 _degisPerRound) external onlyOwner {\n        emit DegisRewardChanged(degisPerRound, _degisPerRound);\n        degisPerRound = _degisPerRound;\n    }\n\n    /**\n     * @notice Set a new distribution interval\n     * @param _newInterval The new interval\n     */\n    function setDistributionInterval(uint256 _newInterval) external onlyOwner {\n        emit DistributionIntervalChanged(distributionInterval, _newInterval);\n        distributionInterval = _newInterval;\n    }\n\n    /**\n     * @notice Set the threshold and piecewise reward\n     * @param _threshold The threshold\n     * @param _reward The piecewise reward\n     */\n    function setPiecewise(\n        uint256[] calldata _threshold,\n        uint256[] calldata _reward\n    ) external onlyOwner {\n        threshold = _threshold;\n        piecewise = _reward;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Stake buyer tokens into this contract\n     * @param _amount Amount of buyer tokens to stake\n     */\n    function stake(uint256 _amount) external nonReentrant whenNotPaused {\n        if (_amount == 0) revert PIV__ZeroAmount();\n\n        // Save gas\n        uint256 round = currentRound;\n\n        // User info of msg.sender\n        UserInfo storage user = users[msg.sender];\n\n        // If the user has not staked in this round, record this new user to the users array\n        if (userSharesInRound[msg.sender][round] == 0) {\n            rounds[round].users.push(msg.sender);\n        }\n\n        userSharesInRound[msg.sender][round] += _amount;\n\n        uint256 length = user.pendingRounds.length;\n        // Only add the round if it's not in the array\n        // Condition 1: length == 0 => no pending rounds => add this round\n        // Condition 2: length != 0 && last pending round is not the current round => add this round\n        if (\n            length == 0 ||\n            (length != 0 && user.pendingRounds[length - 1] != round)\n        ) user.pendingRounds.push(round);\n\n        // Update the total shares\n        rounds[round].shares += _amount;\n\n        // Finish the token transfer (need approval)\n        buyerToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Stake(msg.sender, round, _amount);\n    }\n\n    /**\n     * @notice Redeem buyer token from the vault\n     * @param _amount Amount to redeem\n     */\n    function redeem(uint256 _amount) external nonReentrant whenNotPaused {\n        if (_amount == 0) revert PIV__ZeroAmount();\n\n        uint256 round = currentRound;\n\n        uint256 userBalance = userSharesInRound[msg.sender][round];\n        if (userBalance < _amount) revert PIV__NotEnoughBuyerTokens();\n\n        userSharesInRound[msg.sender][round] -= _amount;\n\n        // If redeem all buyer tokens, remove this round from the user's pending rounds\n        if (userSharesInRound[msg.sender][round] == 0) {\n            users[msg.sender].pendingRounds.pop();\n        }\n\n        rounds[round].shares -= _amount;\n\n        // Finish the buyer token transfer\n        buyerToken.safeTransfer(msg.sender, _amount);\n\n        emit Redeem(msg.sender, round, _amount);\n    }\n\n    /**\n     * @notice Settle the current round\n     * @dev Callable by any address, must pass the distribution interval\n     */\n    function settleCurrentRound() external hasPassedInterval whenNotPaused {\n        RoundInfo storage info = rounds[currentRound];\n        if (info.hasDistributed) revert PIV__AlreadyDistributed();\n\n        uint256 totalShares = info.shares;\n        uint256 totalReward = getRewardPerRound();\n\n        // If no one staked, no reward\n        if (totalShares == 0) info.degisPerShare = 0;\n        else info.degisPerShare = (totalReward * SCALE) / totalShares;\n\n        info.hasDistributed = true;\n\n        emit RoundSettled(currentRound, block.timestamp);\n\n        // Update current round, ++ save little gas\n        ++currentRound;\n\n        // Update last distribution time\n        lastDistribution = block.timestamp;\n    }\n\n    /**\n     * @notice User can claim his own reward\n     */\n    function claim() external nonReentrant whenNotPaused {\n        UserInfo memory user = users[msg.sender];\n\n        if (user.pendingRounds.length == 0) revert PIV__NoPendingRound();\n\n        uint256 roundsToClaim = user.pendingRounds.length -\n            user.lastRewardRoundIndex;\n\n        if (roundsToClaim == 0) revert PIV__ClaimedAll();\n\n        if (user.pendingRounds[user.pendingRounds.length - 1] == currentRound) {\n            roundsToClaim -= 1;\n        }\n\n        uint256 startIndex = user.lastRewardRoundIndex;\n\n        // MAX_ROUND to claim each time\n        if (roundsToClaim > MAX_ROUND) {\n            roundsToClaim = MAX_ROUND;\n            users[msg.sender].lastRewardRoundIndex += MAX_ROUND;\n        } else users[msg.sender].lastRewardRoundIndex += roundsToClaim;\n\n        uint256 userPendingReward;\n\n        for (uint256 i = startIndex; i < startIndex + roundsToClaim; ) {\n            uint256 round = user.pendingRounds[i];\n\n            userPendingReward +=\n                (rounds[round].degisPerShare *\n                    userSharesInRound[msg.sender][round]) /\n                SCALE;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Mint reward to user\n        degis.mintDegis(msg.sender, userPendingReward);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/income/IncomeSharingVaultV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { IVeDEG } from \"../governance/interfaces/IVeDEG.sol\";\n\n/**\n * @title Degis Income Sharing Contract\n * @notice This contract will receive part of the income from Degis products\n *         And the income will be shared by DEG holders (in the form of veDEG)\n *\n *         It is designed to be an ever-lasting reward\n *\n *         This contract will have several pools: one pool for each reward token (e.g. USDC, USDT, etc.)\n *         To enter the income sharing vault, you need to lock some veDEG\n *             - When your veDEG is locked, it can not be withdrawed\n *\n *         The reward is updated each time there is an interaction with the contract.\n *         But the reward amount depends on the token already came to the contract.\n *         It is not a fixed amount of reward per second.\n * \n *         The income will come from (to be updated)\n *             - IncomeMaker: Collect swap fee in naughty price pool\n *             - PolicyCore: Collect deposit/redeem fee in policy core\n */\ncontract IncomeSharingVaultV2 is\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    uint256 public constant SCALE = 1e30;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    IVeDEG public veDEG;\n\n    struct PoolInfo {\n        bool available;\n        address rewardToken;\n        uint256 totalAmount;\n        uint256 accRewardPerShare;\n        uint256 lastRewardBalance;\n    }\n    // Pool Id\n    // 1: USDC.e as reward\n    // 2: Shield as reward\n    mapping(uint256 => PoolInfo) public pools;\n\n    struct UserInfo {\n        uint256 totalAmount;\n        uint256 rewardDebt;\n    }\n    mapping(uint256 => mapping(address => UserInfo)) public users;\n\n    uint256 public nextPool;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event NewRewardPoolStart(uint256 poolId, address rewardToken);\n    event RewardSpeedSet(uint256 poolId, uint256 rewardPerSecond);\n    event PoolUpdated(uint256 poolId, uint256 accRewardPerSecond);\n    event Harvest(address user, uint256 poolId, uint256 amount);\n    event Deposit(address user, uint256 poolId, uint256 amount);\n    event Withdraw(address user, uint256 poolId, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Errors start with DIS(Degis Income Sharing)\n    error DIS__PoolNotAvailable();\n    error DIS__ZeroAmount();\n    error DIS__NotEnoughVeDEG();\n    error DIS__WrongSpeed();\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _veDEG) public initializer {\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        veDEG = IVeDEG(_veDEG);\n\n        nextPool = 1;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Pending reward\n     * @param _poolId Pool Id\n     * @param _user   User address\n     * @return pendingReward Amount of pending reward\n     */\n    function pendingReward(\n        uint256 _poolId,\n        address _user\n    ) external view returns (uint256) {\n        PoolInfo memory pool = pools[_poolId];\n\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n\n        if (pool.totalAmount == 0) return 0;\n        else {\n            UserInfo memory user = users[_poolId][_user];\n\n            uint256 currentRewardBalance = IERC20(pool.rewardToken).balanceOf(\n                address(this)\n            );\n\n            if (currentRewardBalance != pool.lastRewardBalance) {\n                uint256 newReward = currentRewardBalance -\n                    pool.lastRewardBalance;\n\n                accRewardPerShare += (newReward * SCALE) / pool.totalAmount;\n            }\n\n            uint256 pending = (user.totalAmount * accRewardPerShare) /\n                SCALE -\n                user.rewardDebt;\n\n            return pending;\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start a new income sharing pool with its reward token\n     * @param _rewardToken Reward token address\n     */\n    function startPool(address _rewardToken) external onlyOwner {\n        PoolInfo storage pool = pools[nextPool++];\n\n        pool.available = true;\n        pool.rewardToken = _rewardToken;\n\n        emit NewRewardPoolStart(nextPool - 1, _rewardToken);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deposit\n     *         Will: update pool, lock veDEG, claim pending reward, update user info\n     * \n     * @param _poolId Pool Id\n     * @param _amount Amount of tokens to deposit\n     */\n    function deposit(uint256 _poolId, uint256 _amount) external nonReentrant {\n        if (!pools[_poolId].available) revert DIS__PoolNotAvailable();\n        if (_amount == 0) revert DIS__ZeroAmount();\n        if (veDEG.balanceOf(msg.sender) < _amount) revert DIS__NotEnoughVeDEG();\n\n        updatePool(_poolId);\n\n        // Lock some veDEG to participate\n        veDEG.lockVeDEG(msg.sender, _amount);\n\n        PoolInfo storage pool = pools[_poolId];\n        UserInfo storage user = users[_poolId][msg.sender];\n\n        if (user.totalAmount > 0) {\n            uint256 pending = (pool.accRewardPerShare * user.totalAmount) /\n                SCALE -\n                user.rewardDebt;\n\n            uint256 reward = _safeRewardTransfer(\n                pool.rewardToken,\n                msg.sender,\n                pending\n            );\n            pool.lastRewardBalance -= reward;\n\n            emit Harvest(msg.sender, _poolId, reward);\n        }\n\n        pool.totalAmount += _amount;\n        user.totalAmount += _amount;\n        user.rewardDebt = (pool.accRewardPerShare * user.totalAmount) / SCALE;\n\n        emit Deposit(msg.sender, _poolId, _amount);\n    }\n\n    /**\n     * @notice Withdraw all veDEG from a pool\n     * \n     * @param _poolId Pool Id\n     */\n    function withdrawAll(uint256 _poolId) external {\n        withdraw(_poolId, users[_poolId][msg.sender].totalAmount);\n    }\n\n    /**\n     * @notice Withdraw veDEG from a pool\n     *         Will: update pool, unlock veDEG, harvest reward, update user info\n     * \n     * @param _poolId Pool Id\n     * @param _amount Amount to withdraw\n     */\n    function withdraw(uint256 _poolId, uint256 _amount) public nonReentrant {\n        if (_amount == 0) revert DIS__ZeroAmount();\n\n        PoolInfo storage pool = pools[_poolId];\n        UserInfo storage user = users[_poolId][msg.sender];\n\n        if (user.totalAmount < _amount) revert DIS__NotEnoughVeDEG();\n\n        updatePool(_poolId);\n\n        uint256 pending = (pool.accRewardPerShare * user.totalAmount) /\n            SCALE -\n            user.rewardDebt;\n\n        uint256 reward = _safeRewardTransfer(\n            pool.rewardToken,\n            msg.sender,\n            pending\n        );\n        pool.lastRewardBalance -= reward;\n\n        emit Harvest(msg.sender, _poolId, reward);\n\n        // Update user info\n        pool.totalAmount -= _amount;\n\n        user.totalAmount -= _amount;\n        user.rewardDebt = (user.totalAmount * pool.accRewardPerShare) / SCALE;\n\n        // Unlock veDEG\n        veDEG.unlockVeDEG(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _poolId, _amount);\n    }\n\n    /**\n     * @notice Harvest income reward\n     * \n     * @param _poolId Pool Id\n     * @param _to     Reward receiver address\n     */\n    function harvest(\n        uint256 _poolId,\n        address _to\n    ) public nonReentrant whenNotPaused {\n        updatePool(_poolId);\n\n        PoolInfo memory pool = pools[_poolId];\n        UserInfo storage user = users[_poolId][msg.sender];\n\n        // pending reward\n        uint256 pending = (user.totalAmount * pool.accRewardPerShare) /\n            SCALE -\n            user.rewardDebt;\n\n        user.rewardDebt = (user.totalAmount * pool.accRewardPerShare) / SCALE;\n\n        uint256 reward = _safeRewardTransfer(pool.rewardToken, _to, pending);\n        pool.lastRewardBalance -= reward;\n\n        emit Harvest(msg.sender, _poolId, reward);\n    }\n\n    /**\n     * @notice Update pool\n     * @param _poolId Pool id\n     */\n    function updatePool(uint256 _poolId) public {\n        PoolInfo storage pool = pools[_poolId];\n\n        uint256 totalAmount = pool.totalAmount;\n\n        // Current reward balance\n        uint256 currentRewardBalance = IERC20(pool.rewardToken).balanceOf(\n            address(this)\n        );\n\n        if (currentRewardBalance == pool.lastRewardBalance || totalAmount == 0)\n            return;\n\n        // New reward received\n        uint256 newReward = currentRewardBalance - pool.lastRewardBalance;\n\n        pool.accRewardPerShare += (newReward * SCALE) / totalAmount;\n\n        pool.lastRewardBalance = currentRewardBalance;\n\n        emit PoolUpdated(_poolId, pool.accRewardPerShare);\n    }\n\n    function updateLastRewardBalance(uint256 _poolId) external onlyOwner {\n        uint256 currentRewardBalance = IERC20(pools[_poolId].rewardToken)\n            .balanceOf(address(this));\n        pools[_poolId].lastRewardBalance = currentRewardBalance;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Finish the reward token transfer\n     * @dev Safe means not transfer exceeds the balance of contract\n     * @param _to Address to transfer\n     * @param _amount Amount to transfer\n     * @return realAmount Real amount transferred\n     */\n    function _safeRewardTransfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        if (_amount > balance) {\n            revert(\"Insufficient balance for reward\");\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n            return _amount;\n        }\n    }\n}\n"
    },
    "contracts/governance/interfaces/IVeDEG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./IVeERC20.sol\";\n\n/**\n * @dev Interface of the VeDEG\n */\ninterface IVeDEG is IVeERC20 {\n    function deposit(uint256 _amount) external;\n\n    function depositMaxTime(uint256 _amount) external;\n\n    function claim() external;\n\n    function withdraw(uint256 _amount) external;\n\n    function lockVeDEG(address _to, uint256 _amount) external;\n\n    function unlockVeDEG(address _to, uint256 _amount) external;\n}\n"
    },
    "contracts/governance/interfaces/IVeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IVeERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/governance/VeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IVeERC20.sol\";\n\n/// @title VeERC20Upgradeable\n/// @notice Modified version of ERC20Upgradeable where transfers and allowances are disabled.\n/// @dev only minting and burning are allowed. The hook _afterTokenOperation is called after Minting and Burning.\ncontract VeERC20Upgradeable is Initializable, ContextUpgradeable, IVeERC20 {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Emitted when `value` tokens are burned and minted\n     */\n    event Burn(address indexed account, uint256 value);\n    event Mint(address indexed beneficiary, uint256 value);\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Mint(account, amount);\n\n        _afterTokenOperation(account, _balances[account]);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Burn(account, amount);\n\n        _afterTokenOperation(account, _balances[account]);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any minting and burning.\n     * @param account the account being affected\n     * @param newBalance newBalance after operation\n     */\n    function _afterTokenOperation(address account, uint256 newBalance)\n        internal\n        virtual\n    {}\n\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/governance/VoteEscrowedDegis.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { VeERC20Upgradeable } from \"./VeERC20Upgradeable.sol\";\nimport { Math } from \"../libraries/Math.sol\";\n\nimport { IFarmingPool } from \"../farming/interfaces/IFarmingPool.sol\";\n\n/**\n * @title Vote Escrowed Degis\n * @notice The staking contract for DEG -> veDEG\n *         veDEG:\n *            - Boosting the farming reward\n *            - Governance\n *            - Participate in Initial Liquidity Matching (naughty price)\n *            - etc.\n *         If you stake degis, you generate veDEG at the current `generationRate` until you reach `maxCap`\n *         If you unstake any amount of degis, you will lose all of your veDEG tokens\n *\n *         There is also an option that you lock your DEG for the max time\n *         and get the maximum veDEG balance immediately.\n *         !! Attention !!\n *         If you stake DEG for the max time for more than once, the lockUntil timestamp will\n *         be updated to the latest one.\n */\ncontract VoteEscrowedDegis is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    VeERC20Upgradeable\n{\n    using SafeERC20 for IERC20;\n\n    struct UserInfo {\n        // degis staked by user\n        uint256 amount;\n        // time of last veDEG claim or first deposit if user has not claimed yet\n        uint256 lastRelease;\n        // Amount locked for max time\n        uint256 amountLocked;\n        // Lock until timestamp\n        uint256 lockUntil;\n    }\n\n    // User info\n    mapping(address => UserInfo) public users;\n\n    // Degis token\n    // IERC20 public constant degis =\n    //     IERC20(0x9f285507Ea5B4F33822CA7aBb5EC8953ce37A645);\n    IERC20 public degis;\n\n    // Farming pool\n    IFarmingPool public farmingPool;\n\n    // Max veDEG to staked degis ratio\n    // Max veDEG amount = maxCap * degis staked\n    uint256 public maxCapRatio;\n\n    // Rate of veDEG generated per second, per degis staked\n    uint256 public generationRate;\n\n    // Calculation scale\n    uint256 public constant SCALE = 1e18;\n\n    // Whitelist contract checker\n    // Contract addresses are by default unable to stake degis, they must be whitelisted\n    mapping(address => bool) whitelist;\n\n    // Locked amount\n    mapping(address => uint256) public locked;\n\n    // NFT Staking contract\n    address public nftStaking;\n\n    mapping(address => uint256) public boosted;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event GenerationRateChanged(uint256 oldRate, uint256 newRate);\n    event MaxCapRatioChanged(uint256 oldMaxCapRatio, uint256 newMaxCapRatio);\n    event WhiteListAdded(address newWhiteList);\n    event WhiteListRemoved(address oldWhiteList);\n\n    event Deposit(address indexed user, uint256 amount);\n    event DepositMaxTime(\n        address indexed user,\n        uint256 amount,\n        uint256 lockUntil\n    );\n    event Withdraw(address indexed user, uint256 amount);\n\n    event Claimed(address indexed user, uint256 amount);\n\n    event BurnVeDEG(\n        address indexed caller,\n        address indexed user,\n        uint256 amount\n    );\n\n    event LockVeDEG(\n        address indexed caller,\n        address indexed user,\n        uint256 amount\n    );\n\n    event UnlockVeDEG(\n        address indexed caller,\n        address indexed user,\n        uint256 amount\n    );\n\n    event NFTStakingChanged(address oldNFTStaking, address newNFTStaking);\n    event BoostVeDEG(address user, uint256 boostType);\n    event UnBoostVeDEG(address user);\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Errors ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    error VED__NotWhiteListed();\n    error VED__StillLocked();\n    error VED__ZeroAddress();\n    error VED__ZeroAmount();\n    error VED__NotEnoughBalance();\n\n    error VED__TimeNotPassed();\n    error VED__OverLocked();\n\n    error VED__NotNftStaking();\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _degis, address _farmingPool)\n        public\n        initializer\n    {\n        if (_degis == address(0) || _farmingPool == address(0))\n            revert VED__ZeroAddress();\n\n        // Initialize veDEG\n        __ERC20_init(\"Vote Escrowed Degis\", \"veDEG\");\n        __Ownable_init();\n        __ReentrancyGuard_init_unchained();\n        __Pausable_init_unchained();\n\n        // Set generationRate (veDEG per sec per degis staked)\n        generationRate = 10**18;\n\n        // Set maxCap ratio\n        maxCapRatio = 100;\n\n        // Set degis\n        degis = IERC20(_degis);\n\n        // Set farming pool\n        farmingPool = IFarmingPool(_farmingPool);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Not callable by smart contract\n     * @dev Checked first by msg.sender == tx.origin\n     *      Then if the contract is whitelisted, it will still pass the check\n     */\n    modifier notContract(address _addr) {\n        if (_addr != tx.origin) {\n            if (!whitelist[_addr]) revert VED__NotWhiteListed();\n        }\n        _;\n    }\n\n    /**\n     * @notice No locked veDEG\n     * @dev Check the locked balance of a user\n     */\n    modifier noLocked(address _user) {\n        if (locked[_user] > 0) revert VED__StillLocked();\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Calculate the amount of veDEG that can be claimed by user\n     * @param _user User address\n     * @return claimableAmount Claimable amount of the user\n     */\n    function claimable(address _user) public view returns (uint256) {\n        if (_user == address(0)) revert VED__ZeroAddress();\n\n        UserInfo memory user = users[_user];\n\n        // Seconds passed since last claim\n        uint256 timePassed = block.timestamp - user.lastRelease;\n\n        uint256 realCapRatio = _getCapRatio(_user);\n\n        uint256 pending;\n        // Calculate pending amount\n        uint256 boostType = boosted[_user];\n        // If no boost\n        if (boostType == 0) {\n            pending = Math.wmul(user.amount, timePassed * generationRate);\n        }\n        // Normal nft boost\n        else if (boostType == 1) {\n            pending = Math.wmul(\n                user.amount,\n                (timePassed * generationRate * 120) / 100\n            );\n        }\n        // Rare nft boost\n        else if (boostType == 2) {\n            pending = Math.wmul(\n                user.amount,\n                (timePassed * generationRate * 150) / 100\n            );\n        }\n\n        // get user's veDEG balance\n        uint256 userVeDEGBalance = balanceOf(_user) -\n            user.amountLocked *\n            realCapRatio;\n\n        // user veDEG balance cannot go above user.amount * maxCap\n        uint256 veDEGCap = user.amount * realCapRatio;\n\n        // first, check that user hasn't reached the max limit yet\n        if (userVeDEGBalance < veDEGCap) {\n            // then, check if pending amount will make user balance overpass maximum amount\n            if (userVeDEGBalance + pending > veDEGCap) {\n                return veDEGCap - userVeDEGBalance;\n            } else {\n                return pending;\n            }\n        }\n        return 0;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Add a new whitelist address\n     * @dev Only callable by the owner\n     * @param _account Address to add\n     */\n    function addWhitelist(address _account) external onlyOwner {\n        whitelist[_account] = true;\n        emit WhiteListAdded(_account);\n    }\n\n    /**\n     * @notice Remove a new whitelist address\n     * @dev Only callable by the owner\n     * @param _account Address to remove\n     */\n    function removeWhitelist(address _account) external onlyOwner {\n        whitelist[_account] = false;\n        emit WhiteListRemoved(_account);\n    }\n\n    /**\n     * @notice Set maxCap ratio\n     * @param _maxCapRatio the new max ratio\n     */\n    function setMaxCapRatio(uint256 _maxCapRatio) external onlyOwner {\n        if (_maxCapRatio == 0) revert VED__ZeroAmount();\n        emit MaxCapRatioChanged(maxCapRatio, _maxCapRatio);\n        maxCapRatio = _maxCapRatio;\n    }\n\n    /**\n     * @notice Set generationRate\n     * @param _generationRate New generation rate\n     */\n    function setGenerationRate(uint256 _generationRate) external onlyOwner {\n        if (_generationRate == 0) revert VED__ZeroAmount();\n        emit GenerationRateChanged(generationRate, _generationRate);\n        generationRate = _generationRate;\n    }\n\n    function setNFTStaking(address _nftStaking) external onlyOwner {\n        emit NFTStakingChanged(nftStaking, _nftStaking);\n        nftStaking = _nftStaking;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Depisit degis for veDEG\n     * @dev Only EOA or whitelisted contract address\n     * @param _amount Amount to deposit\n     */\n    function deposit(uint256 _amount)\n        external\n        nonReentrant\n        whenNotPaused\n        notContract(msg.sender)\n    {\n        if (_amount == 0) revert VED__ZeroAmount();\n\n        if (users[msg.sender].amount > 0) {\n            // If the user has amount deposited, claim veDEG\n            _claim(msg.sender);\n\n            // Update the amount\n            users[msg.sender].amount += _amount;\n        } else {\n            // add new user to mapping\n            users[msg.sender].lastRelease = block.timestamp;\n            users[msg.sender].amount = _amount;\n        }\n\n        // Request degis from user\n        degis.safeTransferFrom(msg.sender, address(this), _amount);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Deposit for the max time\n     * @dev Release the max amount one time\n     */\n    function depositMaxTime(uint256 _amount)\n        external\n        nonReentrant\n        whenNotPaused\n    {\n        if (_amount == 0) revert VED__ZeroAmount();\n\n        uint256 currentMaxTime = (maxCapRatio * SCALE) / generationRate;\n        uint256 lockUntil = block.timestamp + currentMaxTime * 2;\n\n        users[msg.sender].amountLocked += _amount;\n        users[msg.sender].lockUntil = lockUntil;\n\n        // Request degis from user\n        degis.safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 realCapRatio = _getCapRatio(msg.sender);\n\n        _mint(msg.sender, realCapRatio * _amount);\n\n        emit DepositMaxTime(msg.sender, _amount, lockUntil);\n    }\n\n    /**\n     * @notice Claims accumulated veDEG for flex deposit\n     */\n    function claim() public nonReentrant whenNotPaused {\n        if (users[msg.sender].amount == 0) revert VED__ZeroAmount();\n\n        _claim(msg.sender);\n    }\n\n    /**\n     * @notice Withdraw degis token\n     * @dev User will lose all veDEG once he withdrawed\n     * @param _amount Amount to withdraw\n     */\n    function withdraw(uint256 _amount)\n        external\n        nonReentrant\n        whenNotPaused\n        noLocked(msg.sender)\n    {\n        if (_amount == 0) revert VED__ZeroAmount();\n\n        UserInfo storage user = users[msg.sender];\n        if (user.amount < _amount) revert VED__NotEnoughBalance();\n\n        // reset last Release timestamp\n        user.lastRelease = block.timestamp;\n\n        // update his balance before burning or sending back degis\n        user.amount -= _amount;\n\n        // get user veDEG balance that must be burned\n        // those locked amount will not be calculated\n\n        uint256 realCapRatio = _getCapRatio(msg.sender);\n\n        uint256 userVeDEGBalance = balanceOf(msg.sender) -\n            user.amountLocked *\n            realCapRatio;\n\n        _burn(msg.sender, userVeDEGBalance);\n\n        // send back the staked degis\n        degis.safeTransfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw all the locked veDEG\n     */\n    function withdrawLocked()\n        external\n        nonReentrant\n        whenNotPaused\n        noLocked(msg.sender)\n    {\n        UserInfo memory user = users[msg.sender];\n\n        if (user.amountLocked == 0) revert VED__ZeroAmount();\n        if (block.timestamp < user.lockUntil) revert VED__TimeNotPassed();\n\n        uint256 realCapRatio = _getCapRatio(msg.sender);\n\n        _burn(msg.sender, user.amountLocked * realCapRatio);\n\n        // update his balance before burning or sending back degis\n        users[msg.sender].amountLocked = 0;\n        users[msg.sender].lockUntil = 0;\n\n        // send back the staked degis\n        degis.safeTransfer(msg.sender, user.amountLocked);\n    }\n\n    /**\n     * @notice Lock veDEG token\n     * @dev Only whitelisted contract\n     *      Income sharing contract will lock veDEG as entrance\n     * @param _to User address\n     * @param _amount Amount to lock\n     */\n    function lockVeDEG(address _to, uint256 _amount) external {\n        // Only whitelisted contract can lock veDEG\n        if (!whitelist[msg.sender]) revert VED__NotWhiteListed();\n\n        if (locked[_to] + _amount > balanceOf(_to)) revert VED__OverLocked();\n\n        _lock(_to, _amount);\n        emit LockVeDEG(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice Unlock veDEG token\n     * @param _to User address\n     * @param _amount Amount to unlock\n     */\n    function unlockVeDEG(address _to, uint256 _amount) external {\n        // Only whitelisted contract can unlock veDEG\n        if (!whitelist[msg.sender]) revert VED__NotWhiteListed();\n\n        if (locked[_to] < _amount) revert VED__OverLocked();\n\n        _unlock(_to, _amount);\n        emit UnlockVeDEG(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice Burn veDEG\n     * @dev Only whitelisted contract\n     *      For future use, some contracts may need veDEG for entrance\n     * @param _to Address to burn\n     * @param _amount Amount to burn\n     */\n    function burnVeDEG(address _to, uint256 _amount) public {\n        // Only whitelisted contract can burn veDEG\n        if (!whitelist[msg.sender]) revert VED__NotWhiteListed();\n\n        _burn(_to, _amount);\n        emit BurnVeDEG(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @notice Boost veDEG\n     *\n     * @dev Only called by nftStaking contract\n     *\n     * @param _user User address\n     * @param _type Boost type (1 = 120%, 2 = 150%)\n     */\n    function boostVeDEG(address _user, uint256 _type) external {\n        if (msg.sender != nftStaking) revert VED__NotNftStaking();\n\n        require(_type == 1 || _type == 2);\n\n        boosted[_user] = _type;\n\n        uint256 boostRatio;\n\n        if (_type == 1) boostRatio = 20;\n        else if (_type == 2) boostRatio = 50;\n\n        uint256 userBalance = balanceOf(_user);\n\n        if (userBalance > 0) {\n            _mint(_user, (userBalance * boostRatio) / 100);\n        }\n\n        emit BoostVeDEG(_user, _type);\n    }\n\n    /**\n     * @notice UnBoost veDEG\n     *\n     * @dev Only called by nftStaking contract\n     *\n     * @param _user User address\n     */\n    function unBoostVeDEG(address _user) external {\n        if (msg.sender != nftStaking) revert VED__NotNftStaking();\n\n        uint256 currentBoostStatus = boosted[_user];\n\n        if (currentBoostStatus == 0) return;\n\n        uint256 userBalance = balanceOf(_user);\n        uint256 userLocked = locked[_user];\n\n        if (currentBoostStatus == 1) {\n            if (userLocked > 0) revert VED__StillLocked();\n            _burn(_user, (userBalance * 20) / 120);\n        } else if (currentBoostStatus == 2) {\n            if (userLocked > 0) revert VED__StillLocked();\n            _burn(_user, (userBalance * 50) / 150);\n        }\n\n        boosted[_user] = 0;\n\n        emit UnBoostVeDEG(_user);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Finish claiming veDEG\n     * @param _user User address\n     */\n    function _claim(address _user) internal {\n        uint256 amount = claimable(_user);\n\n        // update last release time\n        users[_user].lastRelease = block.timestamp;\n\n        if (amount > 0) {\n            emit Claimed(_user, amount);\n            _mint(_user, amount);\n        }\n    }\n\n    /**\n     * @notice Update the bonus in farming pool\n     * @dev Every time when token is transferred (balance change)\n     * @param _user User address\n     * @param _newBalance New veDEG balance\n     */\n    function _afterTokenOperation(address _user, uint256 _newBalance)\n        internal\n        override\n    {\n        farmingPool.updateBonus(_user, _newBalance);\n    }\n\n    /**\n     * @notice Lock veDEG token\n     * @param _to User address\n     * @param _amount Amount to lock\n     */\n    function _lock(address _to, uint256 _amount) internal {\n        locked[_to] += _amount;\n    }\n\n    /**\n     * @notice Unlock veDEG token\n     * @param _to User address\n     * @param _amount Amount to unlock\n     */\n    function _unlock(address _to, uint256 _amount) internal {\n        if (locked[_to] < _amount) revert VED__NotEnoughBalance();\n        locked[_to] -= _amount;\n    }\n\n    /**\n     * @notice Get real cap ratio for a user\n     *         The ratio depends on the boost type\n     *\n     * @param _user User address\n     *\n     * @return realCapRatio Real cap ratio\n     */\n    function _getCapRatio(address _user)\n        internal\n        view\n        returns (uint256 realCapRatio)\n    {\n        uint256 boostType = boosted[_user];\n        if (boostType == 0) {\n            realCapRatio = maxCapRatio;\n        } else if (boostType == 1) {\n            realCapRatio = (maxCapRatio * 120) / 100;\n        } else if (boostType == 2) {\n            realCapRatio = (maxCapRatio * 150) / 100;\n        }\n    }\n}\n"
    },
    "contracts/farming/interfaces/IFarmingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IFarmingPool {\n    function pendingDegis(uint256 _poolId, address _user)\n        external\n        returns (uint256);\n\n    function setStartBlock(uint256 _startBlock) external;\n\n    function add(\n        address _lpToken,\n        uint256 _poolId,\n        bool _withUpdate\n    ) external;\n\n    function setDegisReward(\n        uint256 _poolId,\n        uint256 _basicDegisPerBlock,\n        uint256 _bonusDegisPerBlock,\n        bool _withUpdate\n    ) external;\n\n    function stake(uint256 _poolId, uint256 _amount) external;\n\n    function withdraw(uint256 _poolId, uint256 _amount) external;\n\n    function updatePool(uint256 _poolId) external;\n\n    function massUpdatePools() external;\n\n    function harvest(uint256 _poolId, address _to) external;\n\n    function updateBonus(address _user, uint256 _newBalance) external;\n}\n"
    },
    "contracts/farming/DoubleRewarder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IFarmingPool.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title Degis Double Rewarder Contract\n *\n * @notice This contract is used to distribute double reward tokens (from other projects)\n *\n *         PoolInfo is stored with the reward token address as the key\n *         E.g. Double reward for TraderJoe\n *         JoeAddress => PoolInfo\n *\n *         Except the \"rewardToken\" this is also \"realRewardToken\" for the pool\n *         - RewardToken is used for storing the info\n *         - RealRewardToken is used for transfering the reward\n *\n *         If realRewardToken is set as ZeroAddress, then rewardToken is used for transfering the reward\n *\n *         Reward claiming is only available when that pool is set to be “claimable\"\n *         Before claimable, the reward is only calculated but not transfered\n *\n *         Typically, if multiple lp tokens are used for farming the same token reward,\n *         We need a mock address to represent the reward token\n *         E.g.\n *         - IM_CAI_10.0_L_1610 => CLY\n *             Reward token is CLY\n *             Real reward token is ZeroAddress\n *         - CAI_10.0_L_1610 => CLY\n *             Reward token is address(keccak256(abi.encodePacked(\"IM_CAI_10.0_L_1610\", \"CLY\")))\n *             Real reward token is CLY\n *         - CAI_10.0_L_1612 => CLY\n *             Reward token is address(keccak256(abi.encodePacked(\"IM_CAI_10.0_L_1610\", \"CLY\")))\n *             Real reward token is CLY\n */\n\ncontract DoubleRewarder is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 private constant SCALE = 1e12;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    IFarmingPool public farmingPool;\n\n    mapping(address => bool) public supportedRewardToken;\n\n    struct PoolInfo {\n        address lpToken;\n        uint256 rewardPerSecond;\n        uint256 accTokenPerShare;\n        uint256 lastRewardTimestamp;\n    }\n    // Reward token address => pool info\n    mapping(address => PoolInfo) public pools;\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n    }\n    // User address => user info\n    mapping(address => UserInfo) public userInfo;\n\n    // User address => reward token address => pending reward\n    mapping(address => mapping(address => uint256)) public userPendingReward;\n\n    // Reward token address => claimable\n    mapping(address => bool) public claimable;\n\n    // Reward token address => Real reward token address\n    // Some double reward farming start before the real reward token is deployed\n    // So user get pending reward for the reward token address but they get real reward token when they claim the reward\n    mapping(address => address) public realRewardToken;\n\n    // User address\n    mapping(address => mapping(address => UserInfo)) public newUserInfo;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event DistributeReward(address user, uint256 amount);\n\n    event NewRewardTokenAdded(address rewardToken);\n\n    event RewardRateUpdated(uint256 oldRate, uint256 newRate);\n\n    event RewardClaimable(address rewardToken);\n\n    event ClaimReward(address rewardToken, address user, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier onlyFarmingPool() {\n        require(msg.sender == address(farmingPool), \"Only farmingPool\");\n        _;\n    }\n\n    modifier supported(address _token) {\n        require(supportedRewardToken[_token], \"Token not supported\");\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     *         Only need to set farming pool address\n     */\n    function initialize(address _farmingPool) public initializer {\n        __Ownable_init();\n        farmingPool = IFarmingPool(_farmingPool);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get pending reward\n     *\n     * @param _token Reward token address\n     * @param _user  User address\n     *\n     * @return pending Pending reward\n     */\n    function pendingReward(address _token, address _user)\n        external\n        view\n        returns (uint256 pending)\n    {\n        require(pools[_token].lastRewardTimestamp > 0, \"Non exist pool\");\n\n        PoolInfo memory pool = pools[_token];\n        UserInfo memory user = newUserInfo[_user][_token];\n\n        uint256 accTokenPerShare = pool.accTokenPerShare;\n\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(farmingPool));\n\n        // If still distributing reward\n        if (pool.rewardPerSecond > 0) {\n            if (block.timestamp > pool.lastRewardTimestamp && lpSupply > 0) {\n                uint256 timeElapsed = block.timestamp -\n                    pool.lastRewardTimestamp;\n\n                uint256 tokenReward = timeElapsed * pool.rewardPerSecond;\n\n                accTokenPerShare += (tokenReward * SCALE) / lpSupply;\n            }\n        }\n\n        pending = ((user.amount * accTokenPerShare) / SCALE) - user.rewardDebt;\n    }\n\n    /**\n     * @notice Get mock reward token address\n     *\n     *         E.g. lpToken = IM_CAI  realRewardToken = CAI\n     *         mockAddress = address(keccak256(abi.encodePacked(IM_CAI_LP, CAI)))\n     *\n     *\n     * @param _lpToken         LP token address\n     * @param _realRewardToken Real reward token address\n     *\n     * @return mockRewardToken Mock reward token address\n     */\n    function getMockRewardToken(address _lpToken, address _realRewardToken)\n        public\n        pure\n        returns (address mockRewardToken)\n    {\n        mockRewardToken = address(\n            uint160(\n                uint256(keccak256(abi.encodePacked(_lpToken, _realRewardToken)))\n            )\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set reward speed for a pool\n     *\n     * @param _lpToken     LP token address\n     * @param _rewardToken Reward token address (real)\n     * @param _reward      Reward per second\n     */\n    function setRewardSpeed(\n        address _lpToken,\n        address _rewardToken,\n        uint256 _reward\n    ) external onlyOwner {\n        uint256 lpSupply = IERC20(_lpToken).balanceOf(address(farmingPool));\n\n        address mockRewardToken = getMockRewardToken(_lpToken, _rewardToken);\n\n        updatePool(mockRewardToken, lpSupply);\n\n        emit RewardRateUpdated(pools[mockRewardToken].rewardPerSecond, _reward);\n\n        pools[mockRewardToken].rewardPerSecond = _reward;\n    }\n\n    /**\n     * @notice Add a new reward token\n     *\n     * @param _rewardToken Reward token address (mock)\n     * @param _lpToken     LP token address\n     */\n    function addRewardToken(address _rewardToken, address _lpToken)\n        public\n        onlyOwner\n    {\n        require(pools[_rewardToken].lastRewardTimestamp == 0, \"Already exist\");\n\n        supportedRewardToken[_rewardToken] = true;\n\n        pools[_rewardToken].lpToken = _lpToken;\n        pools[_rewardToken].lastRewardTimestamp = block.timestamp;\n\n        emit NewRewardTokenAdded(_rewardToken);\n    }\n\n    /**\n     * @notice Add a new reward token but with mocked address\n     *\n     * @param _lpToken         LP token address used for double farming\n     * @param _realRewardToken Real reward token address\n     */\n    function addRewardTokenWithMock(address _lpToken, address _realRewardToken)\n        external\n        onlyOwner\n    {\n        // Unique mock reward token address\n        address mockRewardToken = getMockRewardToken(\n            _lpToken,\n            _realRewardToken\n        );\n\n        addRewardToken(mockRewardToken, _lpToken);\n        realRewardToken[mockRewardToken] = _realRewardToken;\n    }\n\n    /**\n     * @notice Make a reward token claimable\n     *         If the token has been deployed when the farming start,\n     *         then the real reward token should be address(0)\n     *\n     *         Mock reward address should match the real reward address\n     *\n     * @param _rewardToken     Reward token address (mock)\n     * @param _realRewardToken Real reward token adedress\n     */\n    function setClaimable(address _rewardToken, address _realRewardToken)\n        external\n        onlyOwner\n    {\n        require(realRewardToken[_rewardToken] == _realRewardToken, \"Invalid\");\n\n        claimable[_rewardToken] = true;\n\n        emit RewardClaimable(_rewardToken);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update double reward pool\n     *\n     * @param _rewardToken Reward token address\n     * @param _lpSupply    LP token balance of farming pool\n     */\n    function updatePool(address _rewardToken, uint256 _lpSupply) internal {\n        PoolInfo storage pool = pools[_rewardToken];\n\n        if (pool.rewardPerSecond > 0) {\n            if (block.timestamp > pool.lastRewardTimestamp && _lpSupply > 0) {\n                uint256 timeElapsed = block.timestamp -\n                    pool.lastRewardTimestamp;\n\n                uint256 tokenReward = timeElapsed * pool.rewardPerSecond;\n\n                pool.accTokenPerShare += (tokenReward * SCALE) / _lpSupply;\n            }\n        }\n\n        pool.lastRewardTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Distribute reward when user get reward in farming pool\n     *         User lpAmount will be updated here\n     *\n     * @param _lpToken     LP token address\n     * @param _rewardToken Reward token address\n     * @param _user        User address\n     * @param _lpAmount    LP amount of user\n     * @param _lpSupply    LP token balance of farming pool\n     */\n    function distributeReward(\n        address _lpToken,\n        address _rewardToken,\n        address _user,\n        uint256 _lpAmount,\n        uint256 _lpSupply\n    ) external onlyFarmingPool supported(_rewardToken) {\n        require(pools[_rewardToken].lpToken == _lpToken, \"Not match\");\n\n        updatePool(_rewardToken, _lpSupply);\n\n        PoolInfo memory pool = pools[_rewardToken];\n        UserInfo storage user = newUserInfo[_user][_rewardToken];\n\n        // Get pending reward\n        uint256 pending = (user.amount * pool.accTokenPerShare) /\n            SCALE -\n            user.rewardDebt;\n\n        uint256 prevAmount = user.amount;\n\n        // Effects before interactions to prevent re-entrancy\n        user.amount = _lpAmount;\n\n        user.rewardDebt = (_lpAmount * pool.accTokenPerShare) / SCALE;\n\n        if (prevAmount > 0) {\n            // uint256 actualReward = _safeRewardTransfer(\n            //     _rewardToken,\n            //     _user,\n            //     pending\n            // );\n\n            // Record the reward and distribute later\n            userPendingReward[_user][_rewardToken] += pending;\n\n            emit DistributeReward(_user, pending);\n        }\n    }\n\n    /**\n     * @notice Claim pending reward\n     *         During IDO protection, the insured token have not been issued yet\n     *         So we need to claim the pending reward later (after the farming)\n     *\n     * @param _rewardToken Reward token address (mock)\n     */\n    function claim(address _rewardToken) external supported(_rewardToken) {\n        require(claimable[_rewardToken], \"Not claimable\");\n\n        uint256 pending = userPendingReward[msg.sender][_rewardToken];\n\n        // If this reward token need another address as real reward token\n        address realRewardTokenAddress = realRewardToken[_rewardToken] ==\n            address(0)\n            ? _rewardToken\n            : realRewardToken[_rewardToken];\n\n        uint256 actualAmount = _safeRewardTransfer(\n            realRewardTokenAddress,\n            msg.sender,\n            pending\n        );\n\n        // Only record those reward really been transferred\n        userPendingReward[msg.sender][_rewardToken] -= actualAmount;\n\n        emit ClaimReward(_rewardToken, msg.sender, actualAmount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\n     *\n     * @param _to     User address\n     * @param _amount Amount to transfer\n     */\n    function _safeRewardTransfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n\n        if (_amount > balance) {\n            IERC20(_token).safeTransfer(_to, balance);\n            return balance;\n        } else {\n            IERC20(_token).safeTransfer(_to, _amount);\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice Withdraw tokens\n     *         When stopping double reward, first set the reward speed, then withdraw tokens\n     */\n    function emergencyWithdraw(address _token) external onlyOwner {\n        IERC20(_token).safeTransfer(\n            address(msg.sender),\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/farming/FarmingPoolUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\npragma solidity ^0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IDegisToken } from \"../tokens/interfaces/IDegisToken.sol\";\nimport { Math } from \"../libraries/Math.sol\";\nimport { IVeDEG } from \"../governance/interfaces/IVeDEG.sol\";\nimport { IDoubleRewarder } from \"./interfaces/IDoubleRewarder.sol\";\n\n/**\n * @title  Farming Pool\n * @notice This contract is for LPToken mining on Degis.\n * @dev    Differences from MasterChef:\n *           - The pool id starts from 1 rather than 0.\n *           - The degis reward is calculated by timestamp rather than block number.\n *           - Support double reward together with another token. (one lp => mine two tokens) (related contract is DoubleRewarder.sol)\n *\n *         VeDEG will boost the farming speed by having a extra reward field.\n *         Mining Reward = DEG Basic Reward + DEG Bonus Reward + Double Reward\n *           - DEG Basic Reward = Shared by all users who staked lp tokens inside.\n *           - DEG Bonus Reward = Shared by all users who staked lp tokens inside and have veDEG balance at the same time.\n *           - Double Reward = Shared by all users who staked lp tokens inside.\n *\n *         For DEG bonus reward, every time the veDEG balance changes, the reward will be updated. (called from veDEG contract)\n *\n *         The basic reward depends on the liquidity inside the pool (optional)\n *         Update with a piecewise function\n *         liquidity amount:   |---------------|------------------|----------------\n *                             0           threshold 1        threshold 2\n *          reward speed:            speed1          speed2             speed3\n *\n *         The speed update will be updated one tx after the last tx that triggers the threshold\n *         The reward update will be another one tx later\n *\n *         This piecewise-style reward can be used or not for each pool to decide\n *         Ways to start pools: 1) set the basic reward to >0 2) set the piecewise and threshold to >0\n *                 stop pools: 1) set the basic reward to 0 2) set the piecewise and threshold to 0\n *\n */\ncontract FarmingPoolUpgradeable is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IDegisToken;\n    using Math for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // solhint-disable-next-line const-name-snakecase\n    string public constant name = \"Degis LP Farming Pool\";\n\n    // SCALE/Precision used for calculating rewards\n    uint256 public constant SCALE = 1e12;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // solhint-disable-next-line var-name-mixedcase\n    IDegisToken public DEG;\n\n    // The bonus reward depends on veDEG\n    IVeDEG public veDEG;\n\n    // PoolId starts from 1\n    uint256 public nextPoolId;\n\n    // Farming starts from a certain block timestamp\n    // To keep the same with naughty price pools, we change from block numbers to timestamps\n    uint256 public startTimestamp;\n\n    struct PoolInfo {\n        address lpToken; // LPToken address\n        uint256 basicDegisPerSecond; // Basic Reward speed\n        uint256 bonusDegisPerSecond; // Bonus reward speed\n        uint256 lastRewardTimestamp; // Last reward timestamp\n        uint256 accDegisPerShare; // Accumulated degis per share (for those without veDEG boosting)\n        uint256 accDegisPerBonusShare; // Accumulated degis per bonus share (for those with veDEG boosting)\n        uint256 totalBonus; // Total bonus factors\n    }\n    PoolInfo[] public poolList;\n\n    // lptoken address => poolId\n    mapping(address => uint256) public poolMapping;\n\n    // poolId => alreadyFarming\n    mapping(uint256 => bool) public isFarming;\n\n    struct UserInfo {\n        uint256 rewardDebt; // degis reward debt\n        uint256 balance; // the amount of a user's lp token in the pool\n        uint256 bonus; // user bonus point (by veDEG balance)\n    }\n    // poolId => userAddress => userInfo\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    // Extra claimable balance when updating bonus from veDEG\n    mapping(uint256 => mapping(address => uint256)) public extraClaimable;\n\n    // Reward speed change with liquidity inside contract\n    mapping(uint256 => uint256[]) public thresholdBasic;\n    mapping(uint256 => uint256[]) public piecewiseBasic;\n    mapping(uint256 => uint256) public poolRewardLevel;\n\n    IDoubleRewarder public doubleRewarderContract;\n    // Double reward token for a pool\n    mapping(uint256 => address) public doubleRewarder;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event StartTimestampChanged(uint256 startTimestamp);\n    event Stake(address staker, uint256 poolId, uint256 amount);\n    event Withdraw(address staker, uint256 poolId, uint256 amount);\n    event Harvest(\n        address staker,\n        address rewardReceiver,\n        uint256 poolId,\n        uint256 pendingReward\n    );\n    event NewPoolAdded(\n        address lpToken,\n        uint256 basicDegisPerSecond,\n        uint256 bonusDegisPerSecond\n    );\n    event FarmingPoolStarted(uint256 poolId, uint256 timestamp);\n    event FarmingPoolStopped(uint256 poolId, uint256 timestamp);\n    event DegisRewardChanged(\n        uint256 poolId,\n        uint256 basicDegisPerSecond,\n        uint256 bonusDegisPerSecond\n    );\n    event PoolUpdated(\n        uint256 poolId,\n        uint256 accDegisPerShare,\n        uint256 accDegisPerBonusShare\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _DEG) public initializer {\n        require(_DEG != address(0), \"Zero address\");\n\n        __Ownable_init();\n        __ReentrancyGuard_init_unchained();\n        __Pausable_init_unchained();\n\n        DEG = IDegisToken(_DEG);\n\n        // Start from 1\n        nextPoolId = 1;\n\n        poolList.push(\n            PoolInfo({\n                lpToken: address(0),\n                basicDegisPerSecond: 0,\n                bonusDegisPerSecond: 0,\n                lastRewardTimestamp: 0,\n                accDegisPerShare: 0,\n                accDegisPerBonusShare: 0,\n                totalBonus: 0\n            })\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice The address can not be zero\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    /**\n     * @notice The pool is still in farming\n     */\n    modifier stillFarming(uint256 _poolId) {\n        require(isFarming[_poolId], \"Pool is not farming\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** View Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check the amount of pending degis reward\n     * @param _poolId PoolId of this farming pool\n     * @param _user User address\n     * @return pendingDegisAmount Amount of pending degis\n     */\n    function pendingDegis(\n        uint256 _poolId,\n        address _user\n    ) external view returns (uint256) {\n        PoolInfo memory poolInfo = poolList[_poolId];\n\n        if (\n            poolInfo.lastRewardTimestamp == 0 ||\n            block.timestamp < poolInfo.lastRewardTimestamp ||\n            block.timestamp < startTimestamp\n        ) return 0;\n\n        UserInfo memory user = userInfo[_poolId][_user];\n\n        uint256 lpBalance = IERC20(poolInfo.lpToken).balanceOf(address(this));\n\n        // Accumulated shares to be calculated\n        uint256 accDegisPerShare = poolInfo.accDegisPerShare;\n        uint256 accDegisPerBonusShare = poolInfo.accDegisPerBonusShare;\n\n        if (lpBalance == 0) return 0;\n        else {\n            // If the pool is still farming, update the info\n            if (isFarming[_poolId]) {\n                // Deigs amount given to this pool\n                uint256 timePassed = block.timestamp -\n                    poolInfo.lastRewardTimestamp;\n                uint256 basicReward = poolInfo.basicDegisPerSecond * timePassed;\n                // Update accDegisPerShare\n                // LPToken may have different decimals\n                accDegisPerShare += (basicReward * SCALE) / lpBalance;\n\n                // If there is any bonus reward\n                if (poolInfo.totalBonus > 0) {\n                    uint256 bonusReward = poolInfo.bonusDegisPerSecond *\n                        timePassed;\n                    accDegisPerBonusShare +=\n                        (bonusReward * SCALE) /\n                        poolInfo.totalBonus;\n                }\n            }\n\n            // If the pool has stopped, not update the info\n            uint256 pending = (user.balance *\n                accDegisPerShare +\n                user.bonus *\n                accDegisPerBonusShare) /\n                SCALE +\n                extraClaimable[_poolId][_user] -\n                user.rewardDebt;\n\n            return pending;\n        }\n    }\n\n    function pendingDoubleReward(\n        uint256 _poolId,\n        address _user\n    ) external view returns (address doubleRewardToken, uint256 pending) {\n        doubleRewardToken = doubleRewarder[_poolId];\n\n        pending = doubleRewarderContract.pendingReward(\n            doubleRewardToken,\n            _user\n        );\n    }\n\n    /**\n     * @notice Get the total pool list\n     * @return pooList Total pool list\n     */\n    function getPoolList() external view returns (PoolInfo[] memory) {\n        return poolList;\n    }\n\n    /**\n     * @notice Get a user's balance\n     * @param _poolId Id of the pool\n     * @param _user User address\n     * @return balance User's balance (lpToken)\n     */\n    function getUserBalance(\n        uint256 _poolId,\n        address _user\n    ) external view returns (uint256) {\n        return userInfo[_poolId][_user].balance;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Set Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setVeDEG(address _veDEG) external onlyOwner {\n        veDEG = IVeDEG(_veDEG);\n    }\n\n    /**\n     * @notice Set the start block timestamp\n     * @param _startTimestamp New start block timestamp\n     */\n    function setStartTimestamp(\n        uint256 _startTimestamp\n    ) external onlyOwner whenNotPaused {\n        // Can only be set before any pool is added\n        require(nextPoolId == 1, \"Can only set startTime at first\");\n\n        startTimestamp = _startTimestamp;\n        emit StartTimestampChanged(_startTimestamp);\n    }\n\n    /**\n     * @notice Set piecewise reward and threshold\n     * @param _poolId Id of the pool\n     * @param _threshold Piecewise threshold\n     * @param _reward Piecewise reward\n     */\n    function setPiecewise(\n        uint256 _poolId,\n        uint256[] calldata _threshold,\n        uint256[] calldata _reward\n    ) external onlyOwner {\n        thresholdBasic[_poolId] = _threshold;\n        piecewiseBasic[_poolId] = _reward;\n\n        // If reward for mimimum level is > 0, update isFarming\n        if (_reward[0] > 0) isFarming[_poolId] = true;\n        else isFarming[_poolId] = false;\n    }\n\n    /**\n     * @notice Set double rewarder contract\n     */\n    function setDoubleRewarderContract(address _rewarder) external onlyOwner {\n        doubleRewarderContract = IDoubleRewarder(_rewarder);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new lp into the pool\n     * @dev Can only be called by the owner\n     *      The reward speed can be 0 and set later by setDegisReward function\n     *      The pool may have a double reward token\n     *\n     * @param _lpToken             LP token address\n     * @param _basicDegisPerSecond Basic reward speed(per second) for this new pool\n     * @param _bonusDegisPerSecond Bonus reward speed(per second) for this new pool\n     * @param _withUpdate          Whether update all pools' status\n     * @param _doubleRewardToken   Double reward token address\n     *\n     */\n    function add(\n        address _lpToken,\n        uint256 _basicDegisPerSecond,\n        uint256 _bonusDegisPerSecond,\n        bool _withUpdate,\n        address _doubleRewardToken\n    ) public notZeroAddress(_lpToken) onlyOwner whenNotPaused {\n        // Check if already exists, if the poolId is 0, that means not in the pool\n        require(!_alreadyInPool(_lpToken), \"Already in the pool\");\n\n        if (_bonusDegisPerSecond > 0)\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\n\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n\n        uint256 lastRewardTimestamp = block.timestamp > startTimestamp\n            ? block.timestamp\n            : startTimestamp;\n\n        // Push this new pool into the list\n        poolList.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                basicDegisPerSecond: _basicDegisPerSecond,\n                bonusDegisPerSecond: _bonusDegisPerSecond,\n                lastRewardTimestamp: lastRewardTimestamp,\n                accDegisPerShare: 0,\n                accDegisPerBonusShare: 0,\n                totalBonus: 0\n            })\n        );\n\n        // Store the poolId and set the farming status to true\n        if (_basicDegisPerSecond > 0) isFarming[nextPoolId] = true;\n\n        uint256 currentId = nextPoolId++;\n\n        poolMapping[_lpToken] = currentId;\n\n        emit NewPoolAdded(_lpToken, _basicDegisPerSecond, _bonusDegisPerSecond);\n\n        // Record double reward token\n        doubleRewarder[currentId] = _doubleRewardToken;\n    }\n\n    /**\n     * @notice Update the degisPerSecond for a specific pool (set to 0 to stop farming)\n     *\n     * @param _poolId              Id of the farming pool\n     * @param _basicDegisPerSecond New basic reward amount per second\n     * @param _bonusDegisPerSecond New bonus reward amount per second\n     * @param _withUpdate          Whether update all pools\n     */\n    function setDegisReward(\n        uint256 _poolId,\n        uint256 _basicDegisPerSecond,\n        uint256 _bonusDegisPerSecond,\n        bool _withUpdate\n    ) public onlyOwner whenNotPaused {\n        // Ensure there already exists this pool\n        require(poolList[_poolId].lastRewardTimestamp != 0, \"Pool not exists\");\n\n        if (_bonusDegisPerSecond > 0)\n            require(_basicDegisPerSecond > 0, \"Only bonus\");\n\n        if (_withUpdate) massUpdatePools();\n        else updatePool(_poolId);\n\n        // Not farming now + reward > 0 => Restart\n        if (isFarming[_poolId] == false && _basicDegisPerSecond > 0) {\n            isFarming[_poolId] = true;\n            emit FarmingPoolStarted(_poolId, block.timestamp);\n        }\n\n        if (_basicDegisPerSecond == 0) {\n            isFarming[_poolId] = false;\n            poolList[_poolId].basicDegisPerSecond = 0;\n            poolList[_poolId].bonusDegisPerSecond = 0;\n            emit FarmingPoolStopped(_poolId, block.timestamp);\n        } else {\n            poolList[_poolId].basicDegisPerSecond = _basicDegisPerSecond;\n            poolList[_poolId].bonusDegisPerSecond = _bonusDegisPerSecond;\n            emit DegisRewardChanged(\n                _poolId,\n                _basicDegisPerSecond,\n                _bonusDegisPerSecond\n            );\n        }\n    }\n\n    /**\n     * @notice Stake LP token into the farming pool\n     *\n     * @dev Can only stake to the pools that are still farming\n     *\n     * @param _poolId Id of the farming pool\n     * @param _amount Staking amount\n     */\n    function stake(\n        uint256 _poolId,\n        uint256 _amount\n    ) public nonReentrant whenNotPaused stillFarming(_poolId) {\n        require(_amount > 0, \"Can not stake zero\");\n\n        PoolInfo storage pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][msg.sender];\n\n        // Must update first\n        updatePool(_poolId);\n\n        // First distribute the reward if exists\n        if (user.balance > 0) {\n            uint256 pending = (user.balance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n                SCALE +\n                extraClaimable[_poolId][msg.sender] -\n                user.rewardDebt;\n\n            // Clear the extra record (has been distributed)\n            extraClaimable[_poolId][msg.sender] = 0;\n\n            // Real reward amount by safe transfer\n            uint256 reward = _safeDegisTransfer(msg.sender, pending);\n            emit Harvest(msg.sender, msg.sender, _poolId, reward);\n        }\n\n        // Actual deposit amount\n        uint256 actualAmount = _safeLPTransfer(\n            false,\n            pool.lpToken,\n            msg.sender,\n            _amount\n        );\n\n        user.balance += actualAmount;\n\n        if (address(veDEG) != address(0)) {\n            // Update the user's bonus if veDEG boosting is on\n            uint256 oldBonus = user.bonus;\n            user.bonus = (user.balance * veDEG.balanceOf(msg.sender)).sqrt();\n            // Update the pool's total bonus\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\n        }\n\n        // Double reward distribution\n        if (doubleRewarder[_poolId] != address(0)) {\n            uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n            doubleRewarderContract.distributeReward(\n                pool.lpToken,\n                doubleRewarder[_poolId],\n                msg.sender,\n                user.balance,\n                lpSupply - actualAmount\n            );\n        }\n\n        user.rewardDebt =\n            (user.balance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n            SCALE;\n\n        emit Stake(msg.sender, _poolId, actualAmount);\n    }\n\n    /**\n     * @notice Withdraw lptoken from the pool\\\n     *\n     * @param _poolId Id of the farming pool\n     * @param _amount Amount of lp tokens to withdraw\n     */\n    function withdraw(\n        uint256 _poolId,\n        uint256 _amount\n    ) public nonReentrant whenNotPaused {\n        require(_amount > 0, \"Zero amount\");\n\n        PoolInfo storage pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][msg.sender];\n\n        require(user.balance >= _amount, \"Not enough balance\");\n\n        // Update if the pool is still farming\n        // Users can withdraw even after the pool stopped\n        if (isFarming[_poolId]) updatePool(_poolId);\n        else {\n            pool.lastRewardTimestamp = block.timestamp;\n        }\n\n        uint256 pending = (user.balance *\n            pool.accDegisPerShare +\n            user.bonus *\n            pool.accDegisPerBonusShare) /\n            SCALE +\n            extraClaimable[_poolId][msg.sender] -\n            user.rewardDebt;\n\n        // Clear the extra record (has been distributed)\n        extraClaimable[_poolId][msg.sender] = 0;\n\n        // Real reward amount by safe transfer\n        uint256 reward = _safeDegisTransfer(msg.sender, pending);\n        emit Harvest(msg.sender, msg.sender, _poolId, reward);\n\n        uint256 actualAmount = _safeLPTransfer(\n            true,\n            pool.lpToken,\n            msg.sender,\n            _amount\n        );\n\n        user.balance -= actualAmount;\n\n        // Update the user's bonus when veDEG boosting is on\n        if (address(veDEG) != address(0)) {\n            uint256 oldBonus = user.bonus;\n            user.bonus = (user.balance * veDEG.balanceOf(msg.sender)).sqrt();\n            // Update the pool's total bonus\n            pool.totalBonus = pool.totalBonus + user.bonus - oldBonus;\n        }\n\n        // Double reward distribution\n        if (doubleRewarder[_poolId] != address(0)) {\n            uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n            doubleRewarderContract.distributeReward(\n                pool.lpToken,\n                doubleRewarder[_poolId],\n                msg.sender,\n                user.balance,\n                lpSupply + actualAmount\n            );\n        }\n\n        user.rewardDebt =\n            (user.balance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n            SCALE;\n\n        emit Withdraw(msg.sender, _poolId, actualAmount);\n    }\n\n    /**\n     * @notice Harvest the degis reward and can be sent to another address\n     *\n     * @param _poolId Id of the farming pool\n     * @param _to     Receiver of degis rewards\n     */\n    function harvest(\n        uint256 _poolId,\n        address _to\n    ) public nonReentrant whenNotPaused {\n        // Only update the pool when it is still in farming\n        if (isFarming[_poolId]) updatePool(_poolId);\n        else {\n            poolList[_poolId].lastRewardTimestamp = block.timestamp;\n        }\n\n        PoolInfo memory pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][msg.sender];\n\n        uint256 pendingReward = (user.balance *\n            pool.accDegisPerShare +\n            user.bonus *\n            pool.accDegisPerBonusShare) /\n            SCALE +\n            extraClaimable[_poolId][msg.sender] -\n            user.rewardDebt;\n\n        extraClaimable[_poolId][msg.sender] = 0;\n\n        require(pendingReward > 0, \"No pending reward\");\n\n        // Double reward distribution\n        if (doubleRewarder[_poolId] != address(0)) {\n            uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n            doubleRewarderContract.distributeReward(\n                pool.lpToken,\n                doubleRewarder[_poolId],\n                msg.sender,\n                user.balance,\n                lpSupply\n            );\n        }\n\n        // Update the reward debt\n        user.rewardDebt =\n            (user.balance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n            SCALE;\n\n        // Transfer the reward\n        uint256 reward = _safeDegisTransfer(_to, pendingReward);\n\n        emit Harvest(msg.sender, _to, _poolId, reward);\n    }\n\n    /**\n     * @notice Update the pool's reward status\n     * @param _poolId Id of the farming pool\n     */\n    function updatePool(uint256 _poolId) public {\n        PoolInfo storage pool = poolList[_poolId];\n        if (block.timestamp <= pool.lastRewardTimestamp) {\n            return;\n        }\n\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n\n        // No LP deposited, then just update the lastRewardTimestamp\n        if (lpSupply == 0) {\n            pool.lastRewardTimestamp = block.timestamp;\n            return;\n        }\n\n        uint256 timePassed = block.timestamp - pool.lastRewardTimestamp;\n\n        uint256 basicReward = timePassed * pool.basicDegisPerSecond;\n        uint256 bonusReward = timePassed * pool.bonusDegisPerSecond;\n\n        pool.accDegisPerShare += (basicReward * SCALE) / lpSupply;\n\n        if (pool.totalBonus == 0) {\n            pool.accDegisPerBonusShare = 0;\n        } else {\n            pool.accDegisPerBonusShare +=\n                (bonusReward * SCALE) /\n                pool.totalBonus;\n        }\n\n        // Don't forget to set the farming pool as minter\n        DEG.mintDegis(address(this), basicReward + bonusReward);\n\n        pool.lastRewardTimestamp = block.timestamp;\n\n        uint256 currentPoolLevel = poolRewardLevel[_poolId];\n\n        // Update the new reward speed\n        // Only if the threshold are already set\n        if (thresholdBasic[_poolId].length > 0) {\n            uint256 currentLiquidity = thresholdBasic[_poolId][\n                currentPoolLevel\n            ];\n            if (\n                currentPoolLevel < thresholdBasic[_poolId].length - 1 &&\n                lpSupply >= thresholdBasic[_poolId][currentPoolLevel + 1]\n            ) {\n                _updateRewardSpeed(_poolId);\n            } else if (lpSupply < currentLiquidity) {\n                _updateRewardSpeed(_poolId);\n            }\n        }\n\n        emit PoolUpdated(\n            _poolId,\n            pool.accDegisPerShare,\n            pool.accDegisPerBonusShare\n        );\n    }\n\n    /**\n     * @notice Update all farming pools (except for those stopped ones)\n     * @dev Can be called by anyone\n     *      Only update those active pools\n     */\n    function massUpdatePools() public {\n        uint256 length = poolList.length;\n        for (uint256 poolId = 1; poolId < length; ++poolId) {\n            if (isFarming[poolId] == false) {\n                poolList[poolId].lastRewardTimestamp = block.timestamp;\n                continue;\n            } else updatePool(poolId);\n        }\n    }\n\n    /**\n     * @notice Update a user's bonus\n     * @dev When veDEG has balance change\n     *      Only called by veDEG contract\n     * @param _user User address\n     * @param _newVeDEGBalance New veDEG balance\n     */\n    function updateBonus(address _user, uint256 _newVeDEGBalance) external {\n        require(msg.sender == address(veDEG), \"Only veDEG contract\");\n\n        // loop over each pool : beware gas cost!\n        uint256 length = poolList.length;\n\n        for (uint256 poolId; poolId < length; ++poolId) {\n            // Skip if the pool is not farming\n            if (!isFarming[poolId]) continue;\n\n            UserInfo storage user = userInfo[poolId][_user];\n            // Skip if user doesn't have any deposit in the pool\n            if (user.balance == 0) continue;\n\n            PoolInfo storage pool = poolList[poolId];\n\n            // first, update pool\n            updatePool(poolId);\n\n            // Update the extra claimable amount\n            uint256 pending = (user.balance *\n                pool.accDegisPerShare +\n                user.bonus *\n                pool.accDegisPerBonusShare) /\n                SCALE -\n                user.rewardDebt;\n            extraClaimable[poolId][_user] += pending;\n\n            // get oldFactor\n            uint256 oldFactor = user.bonus; // get old factor\n            // calculate newFactor\n            uint256 newFactor = (_newVeDEGBalance * user.balance).sqrt();\n            // update user factor\n            user.bonus = newFactor;\n            // update reward debt, take into account newFactor\n            user.rewardDebt =\n                (user.balance *\n                    pool.accDegisPerShare +\n                    newFactor *\n                    pool.accDegisPerBonusShare) /\n                SCALE;\n\n            // Update the pool's total bonus\n            pool.totalBonus = pool.totalBonus + newFactor - oldFactor;\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ********************************** Internal Functions ********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if a lptoken has been added into the pool before\n     * @dev This can also be written as a modifier\n     * @param _lpToken LP token address\n     * @return _isInPool Wether this lp is already in pool\n     */\n    function _alreadyInPool(\n        address _lpToken\n    ) internal view returns (bool _isInPool) {\n        uint256 poolId = poolMapping[_lpToken];\n\n        _isInPool = (poolId != 0) ? true : false;\n    }\n\n    /**\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\n     * @param _to User's address\n     * @param _amount Amount to transfer\n     */\n    function _safeDegisTransfer(\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 poolDegisBalance = DEG.balanceOf(address(this));\n        require(poolDegisBalance > 0, \"No Degis token in the pool\");\n\n        if (_amount > poolDegisBalance) {\n            DEG.safeTransfer(_to, poolDegisBalance);\n            return (poolDegisBalance);\n        } else {\n            DEG.safeTransfer(_to, _amount);\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice Finish the transfer of LP Token\n     * @dev The lp token may have loss during transfer\n     * @param _out Whether the lp token is out\n     * @param _lpToken LP token address\n     * @param _user User address\n     * @param _amount Amount of lp tokens\n     */\n    function _safeLPTransfer(\n        bool _out,\n        address _lpToken,\n        address _user,\n        uint256 _amount\n    ) internal returns (uint256) {\n        uint256 poolBalanceBefore = IERC20(_lpToken).balanceOf(address(this));\n\n        if (_out) IERC20(_lpToken).safeTransfer(_user, _amount);\n        else IERC20(_lpToken).safeTransferFrom(_user, address(this), _amount);\n\n        uint256 poolBalanceAfter = IERC20(_lpToken).balanceOf(address(this));\n\n        return\n            _out\n                ? poolBalanceBefore - poolBalanceAfter\n                : poolBalanceAfter - poolBalanceBefore;\n    }\n\n    /**\n     * @notice Update the reward speed\n     * @param _poolId Pool ID\n     */\n    function _updateRewardSpeed(uint256 _poolId) internal {\n        uint256 currentBasicBalance = IERC20(poolList[_poolId].lpToken)\n            .balanceOf(address(this));\n\n        uint256 basicRewardSpeed;\n\n        for (uint256 i = thresholdBasic[_poolId].length - 1; i >= 0; --i) {\n            if (currentBasicBalance >= thresholdBasic[_poolId][i]) {\n                basicRewardSpeed = piecewiseBasic[_poolId][i];\n                // record current reward level\n                poolRewardLevel[_poolId] = i;\n                break;\n            } else continue;\n        }\n\n        poolList[_poolId].basicDegisPerSecond = basicRewardSpeed;\n    }\n}\n"
    },
    "contracts/farming/interfaces/IDoubleRewarder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\ninterface IDoubleRewarder {\n    function distributeReward(\n        address lpToken,\n        address rewardToken,\n        address user,\n        uint256 userAmount,\n        uint256 lpSupply\n    ) external;\n\n    // Get the pending reward\n    function pendingReward(address _token, address user)\n        external\n        view\n        returns (uint256);\n\n    // Get the reward token address\n    function rewardToken() external view returns (address);\n}\n"
    },
    "contracts/proxy/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init(address _initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(_initialOwner);\n    }\n\n    function __Ownable_init_unchained(address _initialOwner)\n        internal\n        onlyInitializing\n    {\n        _transferOwnership(_initialOwner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/lucky-box/DegisLotteryV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IRandomNumberGenerator.sol\";\nimport \"./MathLib.sol\";\n\n/**\n * @title DegisLotteryV2\n *\n * @dev This lottery uses DEG as tickets and DEG as rewards also\n *      Users can pay 10 DEG to buy one ticket and choose four digits for each ticket\n *      After the lottery was closed, it will draw a final random number through Chainlink VRF\n *      Users get rewards according to the how many numbers they matched with the final number\n *\n *      Reward distribution:\n *      80% of each round prize pool will be distributed to the winners (breakdowns for different levels)\n *      20% of each round prize pool will be rolled to next round (except for treasury fee)\n *\n */\n\ncontract DegisLotteryV2 is ReentrancyGuardUpgradeable, OwnableUpgradeable {\n    using MathLib for uint256;\n    using MathLib for int128;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Treasury fee\n    uint256 public constant MAX_TREASURY_FEE = 2000; // 20%\n\n    // Ticket numbers\n    uint32 public constant MIN_TICKET_NUMBER = 10000;\n    uint32 public constant MAX_TICKET_NUMBER = 19999;\n\n    // Default ticket price\n    uint256 public constant DEFAULT_PRICE = 10 ether;\n\n    // 98% for each extra ticket\n    uint256 public constant DISCOUNT_DIVISOR = 98;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    IERC20 public DegisToken;\n    IRandomNumberGenerator public randomGenerator;\n\n    // Address to receive treasury fee\n    address public treasury;\n\n    // Current lottery round\n    uint256 public currentLotteryId;\n\n    // Current ticket id (start from 1)\n    uint256 public currentTicketId;\n\n    // Max amount of tickets can be bought each time\n    uint256 public maxNumberTicketsEachTime;\n\n    // Pending reward to be injected to next round\n    uint256 public pendingInjectionNextLottery;\n\n    enum Status {\n        Pending, // Default status\n        Open, // Lottery is open, before closing\n        Close, // Lottery is closed, after closing before drawing final result\n        Claimable // Lottery is claimable, after drawing final result\n    }\n\n    struct Lottery {\n        // Slot 1\n        Status status; // uint8\n        uint32 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%\n        uint32 startTime;\n        uint32 endTime;\n        uint32 finalNumber;\n        // Slot 2,3...\n        uint256 ticketPrice; // 10\n        uint256[4] rewardsBreakdown; // 0: 1 matching number // 3: 4 matching numbers\n        uint256[4] rewardPerTicketInBracket;\n        uint256[4] countWinnersPerBracket;\n        uint256 firstTicketId;\n        uint256 firstTicketIdNextRound;\n        uint256 amountCollected; // Total prize pool\n        uint256 pendingRewards; // Rewards that are not yet claimed\n    }\n    // lotteryId => Lottery Info\n    mapping(uint256 => Lottery) public lotteries;\n\n    struct Ticket {\n        uint32 number;\n        address owner;\n    }\n    // Ticket Id => Ticket Info\n    mapping(uint256 => Ticket) public tickets;\n\n    // lotteryId => (Lucky Number => Total Amount of this number)\n    // e.g. In lottery round 3, 10 Tickets are sold with \"11234\": 3 => (11234 => 10)\n    mapping(uint256 => mapping(uint32 => uint256))\n        public _numberTicketsPerLotteryId;\n\n    // Keep track of user ticket ids for a given lotteryId\n    // User Address => Lottery Round => Tickets\n    mapping(address => mapping(uint256 => uint256[])) public _userTicketIds;\n\n    // Calculator for each bracket\n    mapping(uint32 => uint32) public _bracketCalculator;\n\n    // User address => lotteryId => Amount of tickets has claimed\n    mapping(address => mapping(uint256 => uint256)) public userClaimed;\n\n    // Default config parameters\n    // With global parameters, lottery operations can be set as auto tasks\n    uint256 public treasuryFee;\n    uint256[4] public rewardsBreakdown;\n    uint256 public roundLength;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event MaxNumberTicketsEachTimeChanged(\n        uint256 oldMaxNumber,\n        uint256 newMaxNumber\n    );\n    event RoundLengthChanged(uint256 oldRoundLength, uint256 newRoundLength);\n    event TreasuryChanged(address oldTreasury, address newTreasury);\n    event AdminTokenRecovery(address token, uint256 amount);\n    event LotteryClose(uint256 indexed lotteryId);\n    event LotteryInjection(uint256 indexed lotteryId, uint256 injectedAmount);\n    event LotteryOpen(\n        uint256 indexed lotteryId,\n        uint256 startTime,\n        uint256 roundLength,\n        uint256 priceTicketInDegis,\n        uint256[4] rewardsBreakdown,\n        uint256 injectedAmount\n    );\n    event LotteryNumberDrawn(\n        uint256 indexed lotteryId,\n        uint256 finalNumber,\n        uint256 countWinningTickets\n    );\n\n    event NewRandomGenerator(address indexed randomGenerator);\n    event TicketsPurchased(\n        address indexed buyer,\n        uint256 indexed lotteryId,\n        uint256 number,\n        uint256 totalPrice\n    );\n    event TicketsClaim(\n        address indexed claimer,\n        uint256 amount,\n        uint256 indexed lotteryId\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Initialize function\n     *\n     * @dev RandomNumberGenerator must be deployed prior to this contract\n     *\n     * @param _degis           Address of DEG\n     * @param _randomGenerator Address of the RandomGenerator contract used to work with ChainLink VRF\n     */\n    function initialize(address _degis, address _randomGenerator)\n        public\n        initializer\n    {\n        __Ownable_init();\n        __ReentrancyGuard_init_unchained();\n\n        DegisToken = IERC20(_degis);\n        randomGenerator = IRandomNumberGenerator(_randomGenerator);\n\n        // Set default ticket amount each time\n        maxNumberTicketsEachTime = 10;\n\n        // Set default calculator\n        _bracketCalculator[0] = 1;\n        _bracketCalculator[1] = 11;\n        _bracketCalculator[2] = 111;\n        _bracketCalculator[3] = 1111;\n\n        // Ticket id start from 1\n        currentTicketId = 1;\n\n        // Set default rewards breakdown\n        rewardsBreakdown[0] = 1000;\n        rewardsBreakdown[1] = 2000;\n        rewardsBreakdown[2] = 3000;\n        rewardsBreakdown[3] = 4000;\n\n        // Default treasury fee\n        // treasuryFee = 500;\n\n        // Default round length\n        roundLength = 3 days;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only EOA accounts to participate\n     */\n    modifier notContract() {\n        require(!_isContract(msg.sender), \"Contract not allowed\");\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get a user's ticekts in a given lottery round\n     *\n     * @param _wallet    Address to check owned tickets\n     * @param _lotteryId Lottery id to check\n     *\n     * @return ticketIds Ticket ids this user has in this round\n     */\n    function viewWalletTicketIds(address _wallet, uint256 _lotteryId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory ticketIds = _userTicketIds[_wallet][_lotteryId];\n        return ticketIds;\n    }\n\n    /**\n     * @notice View lottery information\n     *\n     * @param _startId Start lottery id\n     * @param _endId   End lottery id\n     *\n     * @return allLottery Array of lottery information\n     */\n    function viewAllLottery(uint256 _startId, uint256 _endId)\n        external\n        view\n        returns (Lottery[] memory)\n    {\n        Lottery[] memory allLottery = new Lottery[](_endId - _startId + 1);\n        for (uint256 i = _startId; i <= _endId; i++) {\n            allLottery[i - 1] = lotteries[i];\n        }\n        return allLottery;\n    }\n\n    /**\n     * @notice View ticker numbers for an array of ticket ids\n     *\n     * @param _ticketIds Array of ticketId\n     *\n     * @return ticketNumbers Array of ticket numbers\n     */\n    function viewNumbersPerTicketId(uint256[] calldata _ticketIds)\n        external\n        view\n        returns (uint32[] memory)\n    {\n        uint256 length = _ticketIds.length;\n        uint32[] memory ticketNumbers = new uint32[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            ticketNumbers[i] = tickets[_ticketIds[i]].number;\n        }\n\n        return (ticketNumbers);\n    }\n\n    /**\n     * @notice View rewards for a given ticket in a given lottery round\n     *\n     * @dev This function will help to find the highest prize bracket\n     *      But this computation is encouraged to be done off-chain\n     *      Better to get bracket first and then call \"_calculateRewardsForTicketId()\"\n     *\n     * @param _lotteryId Lottery round\n     * @param _ticketId  Ticket id\n     *\n     * @return reward Ticket reward\n     */\n    function viewRewardsForTicketId(uint256 _lotteryId, uint256 _ticketId)\n        public\n        view\n        returns (uint256)\n    {\n        // Check lottery is in claimable status\n        if (lotteries[_lotteryId].status != Status.Claimable) {\n            return 0;\n        }\n\n        // Check ticketId is within range\n        if (\n            lotteries[_lotteryId].firstTicketIdNextRound < _ticketId ||\n            lotteries[_lotteryId].firstTicketId > _ticketId\n        ) {\n            return 0;\n        }\n\n        // Only calculate prize for the highest bracket\n        uint32 highestBracket = _getBracket(_lotteryId, _ticketId);\n\n        return\n            _calculateRewardsForTicketId(_lotteryId, _ticketId, highestBracket);\n    }\n\n    /**\n     * @notice View user rewards between rounds\n     *\n     * @param _user       User address\n     * @param _startRound Start lottery id\n     * @param _endRound   End lottery id\n     *\n     * @return userRewards Array of user rewards (round as index)\n     */\n    function viewUserRewards(\n        address _user,\n        uint256 _startRound,\n        uint256 _endRound\n    ) external view returns (uint256[] memory userRewards) {\n        userRewards = new uint256[](_endRound - _startRound + 1);\n\n        for (uint256 i = _startRound; i <= _endRound; ) {\n            uint256 ticketAmount = _userTicketIds[_user][i].length;\n\n            if (ticketAmount > 0) {\n                uint256[] memory ticketIds = _userTicketIds[_user][i];\n\n                for (uint256 j; j < ticketAmount; ) {\n                    uint256 reward = viewRewardsForTicketId(i, ticketIds[j]);\n                    userRewards[i - 1] += reward;\n\n                    unchecked {\n                        ++j;\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice View reward per ticket in a given round\n     *\n     * @return rewardPerTicketInBracket  Reward per ticket in a given round\n     */\n    function viewRewardPerTicketInBracket(uint256 _lotteryId)\n        external\n        view\n        returns (uint256[4] memory)\n    {\n        return lotteries[_lotteryId].rewardPerTicketInBracket;\n    }\n\n    /**\n     * @notice View winner ticket amount for a given lottery round, for each bracket\n     *\n     * @return countWinnersPerBracket Array of winner ticket amount for each bracket\n     */\n    function viewWinnerAmount(uint256 _lotteryId)\n        external\n        view\n        returns (uint256[4] memory)\n    {\n        return lotteries[_lotteryId].countWinnersPerBracket;\n    }\n\n    /**\n     * @notice View rewards breakdown for a given lottery round\n     */\n    function viewRewardsBreakdown(uint256 _lotteryId)\n        external\n        view\n        returns (uint256[4] memory)\n    {\n        return lotteries[_lotteryId].rewardsBreakdown;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set max number can buy/claim each time\n     *\n     * @param _maxNumber Max number each time\n     */\n    function setMaxNumberTicketsEachTime(uint256 _maxNumber)\n        external\n        onlyOwner\n    {\n        emit MaxNumberTicketsEachTimeChanged(\n            maxNumberTicketsEachTime,\n            _maxNumber\n        );\n        maxNumberTicketsEachTime = _maxNumber;\n    }\n\n    /**\n     * @notice Set treasury wallet address\n     *\n     * @param _treasury Treasury address\n     */\n    function setTreasury(address _treasury) external onlyOwner {\n        emit TreasuryChanged(treasury, _treasury);\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Set round length\n     *\n     * @param _length New round length\n     */\n    function setRoundLength(uint256 _length) external onlyOwner {\n        require(_length > 0, \"Zero round length\");\n        emit RoundLengthChanged(roundLength, _length);\n        roundLength = _length;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Buy tickets for the current lottery round\n     *\n     * @dev Need to transfer the 4-digit number to a 5-digit number to be used here (+10000)\n     *      Can not be called by a smart contract\n     *      Can only purchase in the current round\n     *      E.g. You are selecting the number of 1-2-3-4 (lowest to highest)\n     *           You will need to pass a number \"14321\"\n     *\n     * @param _ticketNumbers Array of ticket numbers between 10,000 and 19,999\n     */\n    function buyTickets(uint32[] calldata _ticketNumbers)\n        external\n        notContract\n        nonReentrant\n    {\n        uint256 amountToBuy = _ticketNumbers.length;\n        require(amountToBuy > 0, \"No tickets are being bought\");\n        require(amountToBuy <= maxNumberTicketsEachTime, \"Too many tickets\");\n\n        // Gas savings\n        Lottery storage lottery = lotteries[currentLotteryId];\n        uint256 currentRound = currentLotteryId;\n        require(lottery.status == Status.Open, \"Round not open\");\n\n        // Calculate the number of DEG to pay\n        uint256 degToPay = _calculateTotalPrice(\n            lottery.ticketPrice,\n            amountToBuy\n        );\n\n        // Transfer degis tokens to this contract\n        DegisToken.transferFrom(msg.sender, address(this), degToPay);\n\n        // Increase prize pool amount\n        lotteries[currentRound].amountCollected += degToPay;\n\n        // Record the tickets bought\n        for (uint256 i; i < amountToBuy; ) {\n            uint32 currentTicketNumber = _ticketNumbers[i];\n\n            require(\n                (currentTicketNumber >= MIN_TICKET_NUMBER) &&\n                    (currentTicketNumber <= MAX_TICKET_NUMBER),\n                \"Ticket number is outside range\"\n            );\n\n            // Used when drawing the prize\n            ++_numberTicketsPerLotteryId[currentRound][\n                1 + (currentTicketNumber % 10)\n            ];\n            ++_numberTicketsPerLotteryId[currentRound][\n                11 + (currentTicketNumber % 100)\n            ];\n            ++_numberTicketsPerLotteryId[currentRound][\n                111 + (currentTicketNumber % 1000)\n            ];\n            ++_numberTicketsPerLotteryId[currentRound][\n                1111 + (currentTicketNumber % 10000)\n            ];\n\n            // Gas savings\n            uint256 ticketId = currentTicketId;\n\n            // Store this ticket number to the user's record\n            _userTicketIds[msg.sender][currentRound].push(ticketId);\n\n            // Store this ticket number to global ticket state\n            Ticket storage newTicket = tickets[ticketId];\n            newTicket.number = currentTicketNumber;\n            newTicket.owner = msg.sender;\n\n            // Increase total lottery ticket number\n            unchecked {\n                ++currentTicketId;\n                ++i;\n            }\n        }\n\n        emit TicketsPurchased(msg.sender, currentRound, amountToBuy, degToPay);\n    }\n\n    /**\n     * @notice Claim winning tickets\n     *\n     * @dev Callable by users only, not contract\n     *\n     * @param _lotteryId Lottery id\n     * @param _ticketIds Array of ticket ids\n     * @param _brackets  Bracket / prize level of each ticket\n     */\n    function claimTickets(\n        uint256 _lotteryId,\n        uint256[] calldata _ticketIds,\n        uint32[] calldata _brackets\n    ) external notContract nonReentrant {\n        require(\n            lotteries[_lotteryId].status == Status.Claimable,\n            \"Round not claimable\"\n        );\n\n        uint256 ticketAmount = _ticketIds.length;\n        require(ticketAmount == _brackets.length, \"Not same length\");\n        require(ticketAmount > 0, \"No tickets\");\n        require(\n            ticketAmount <= maxNumberTicketsEachTime,\n            \"Too many tickets to claim\"\n        );\n\n        uint256 rewardToTransfer;\n\n        Lottery storage lottery = lotteries[_lotteryId];\n\n        for (uint256 i; i < ticketAmount; ) {\n            uint256 thisTicketId = _ticketIds[i];\n\n            // Check the ticket id is inside the range\n            require(\n                thisTicketId >= lottery.firstTicketId,\n                \"Ticket id too small\"\n            );\n            require(\n                thisTicketId < lottery.firstTicketIdNextRound,\n                \"Ticket id too large\"\n            );\n\n            // Check the ticket is owned by the user and reset this ticket\n            // If the owner is zero address, then it has been claimed\n            require(\n                msg.sender == tickets[thisTicketId].owner,\n                \"Not the ticket owner or already claimed\"\n            );\n            tickets[thisTicketId].owner = address(0);\n\n            // Can not pass tickets with no prize\n            uint256 rewardForTicketId = _calculateRewardsForTicketId(\n                _lotteryId,\n                thisTicketId,\n                _brackets[i]\n            );\n            // require(rewardForTicketId > 0, \"No prize\");\n\n            // If not claiming the highest prize, check if the user has a higher prize\n            if (_brackets[i] < 3) {\n                require(\n                    _calculateRewardsForTicketId(\n                        _lotteryId,\n                        thisTicketId,\n                        _brackets[i] + 1\n                    ) == 0,\n                    \"Only highest prize\"\n                );\n            }\n\n            // Increase the reward to transfer\n            rewardToTransfer += rewardForTicketId;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Record the amount has claimed in this round\n        userClaimed[msg.sender][_lotteryId] += ticketAmount;\n\n        // Transfer the prize to the user\n        if (rewardToTransfer > 0) {\n            lotteries[_lotteryId].pendingRewards -= rewardToTransfer;\n\n            DegisToken.transfer(msg.sender, rewardToTransfer);\n        }\n\n        emit TicketsClaim(msg.sender, rewardToTransfer, _lotteryId);\n    }\n\n    /**\n     * @notice Claim all winning tickets for a lottery round\n     *\n     * @dev Callable by users only, not contract\n     *      Gas cost may be oversized, recommended to get brackets offchain first\n     *      Get brackets offchain and call function \"claimTickets\"\n     *\n     * @param _lotteryId Lottery id\n     */\n    function claimAllTickets(uint256 _lotteryId)\n        external\n        notContract\n        nonReentrant\n    {\n        require(\n            lotteries[_lotteryId].status == Status.Claimable,\n            \"Round not claimable\"\n        );\n\n        uint256 rewardToTransfer;\n\n        // Gas savings\n        uint256 ticketAmount = _userTicketIds[msg.sender][_lotteryId].length;\n\n        for (uint256 i; i < ticketAmount; ) {\n            uint256 thisTicketId = _userTicketIds[msg.sender][_lotteryId][i];\n\n            require(\n                msg.sender == tickets[thisTicketId].owner,\n                \"Not the ticket owner\"\n            );\n            tickets[thisTicketId].owner = address(0);\n\n            uint32 highestBracket = _getBracket(_lotteryId, thisTicketId);\n            if (highestBracket < 4) {\n                uint256 rewardForTicketId = _calculateRewardsForTicketId(\n                    _lotteryId,\n                    thisTicketId,\n                    highestBracket\n                );\n                rewardToTransfer += rewardForTicketId;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (rewardToTransfer > 0) {\n            // Transfer the prize to winner\n            DegisToken.transfer(msg.sender, rewardToTransfer);\n\n            lotteries[_lotteryId].pendingRewards -= rewardToTransfer;\n        }\n        // Record the amount has claimed in this round\n        userClaimed[msg.sender][_lotteryId] = ticketAmount;\n\n        emit TicketsClaim(msg.sender, rewardToTransfer, _lotteryId);\n    }\n\n    /**\n     * @notice Start a new lottery round\n     */\n    function startLottery() external {\n        require(\n            (currentLotteryId == 0) ||\n                (lotteries[currentLotteryId].status == Status.Claimable),\n            \"Wrong status\"\n        );\n\n        // Gas savings\n        uint256 currentId = ++currentLotteryId;\n\n        Lottery storage newLottery = lotteries[currentId];\n\n        newLottery.status = Status.Open;\n        newLottery.startTime = uint32(block.timestamp);\n        newLottery.endTime = uint32(block.timestamp + roundLength);\n        newLottery.ticketPrice = DEFAULT_PRICE;\n        newLottery.rewardsBreakdown = rewardsBreakdown;\n        newLottery.treasuryFee = uint32(treasuryFee);\n        newLottery.amountCollected = pendingInjectionNextLottery;\n        newLottery.firstTicketId = currentTicketId;\n\n        emit LotteryOpen(\n            currentId,\n            block.timestamp,\n            roundLength,\n            DEFAULT_PRICE,\n            rewardsBreakdown,\n            pendingInjectionNextLottery\n        );\n\n        // Clear record for pending injection\n        pendingInjectionNextLottery = 0;\n    }\n\n    /**\n     * @notice Close a lottery\n     *\n     * @param _lotteryId Lottery round\n     */\n    function closeLottery(uint256 _lotteryId) external nonReentrant {\n        require(\n            lotteries[_lotteryId].status == Status.Open,\n            \"this lottery is not open currently\"\n        );\n\n        require(\n            block.timestamp > lotteries[_lotteryId].endTime,\n            \"Not reach end time\"\n        );\n\n        // Request a random number from the generator\n        randomGenerator.requestRandomWords();\n\n        // Update the lottery status to \"Close\"\n        lotteries[_lotteryId].status = Status.Close;\n\n        emit LotteryClose(_lotteryId);\n    }\n\n    /**\n     * @notice Draw the final number, calculate reward in Degis for each group,\n               and make this lottery claimable (need to wait for the random generator)\n     *\n     * @param _lotteryId     Lottery round\n     * @param _autoInjection Auto inject funds into next lottery\n     */\n    function drawFinalNumberAndMakeLotteryClaimable(\n        uint256 _lotteryId,\n        bool _autoInjection\n    ) external nonReentrant {\n        require(\n            lotteries[_lotteryId].status == Status.Close,\n            \"Lottery not closed\"\n        );\n        require(\n            _lotteryId == randomGenerator.latestLotteryId(),\n            \"Final number not drawn\"\n        );\n        require(treasury != address(0), \"Treasury is not set\");\n\n        // Get the final lucky numbers from randomGenerator\n        uint32 finalNumber = uint32(randomGenerator.randomResult());\n\n        Lottery storage lottery = lotteries[_lotteryId];\n\n        // Gas savings\n        uint256 totalPrize = lottery.amountCollected;\n\n        // Prize distributed to users\n        uint256 amountToWinners = (totalPrize * 8000) / 10000;\n\n        // (20% - treasuryFee) will go to next round\n        uint256 amountToNextLottery = (totalPrize *\n            (2000 - lottery.treasuryFee)) / 10000;\n\n        // Remaining part goes to treasury\n        uint256 amountToTreasury = totalPrize -\n            amountToWinners -\n            amountToNextLottery;\n\n        // Initialize a number to count addresses in all the previous bracket\n        // Ensure that a ticket is not counted several times in different brackets\n        uint256 numberAddressesInPreviousBracket;\n\n        // Calculate prizes for each bracket, starting from the highest one\n        for (uint32 i; i < 4; ) {\n            uint32 j = 3 - i;\n\n            // Get transformed winning number\n            uint32 transformedWinningNumber = _bracketCalculator[j] +\n                (finalNumber % (uint32(10)**(j + 1)));\n\n            // Amount of winning tickets for this number\n            uint256 winningAmount = _numberTicketsPerLotteryId[_lotteryId][\n                transformedWinningNumber\n            ];\n\n            // Amount of winners for this bracket\n            // Remove those already have higher bracket reward\n            lottery.countWinnersPerBracket[j] =\n                winningAmount -\n                numberAddressesInPreviousBracket;\n\n            // Check if there are winners for this bracket\n            if (winningAmount != numberAddressesInPreviousBracket) {\n                // B. If rewards at this bracket are > 0, calculate, else, report the numberAddresses from previous bracket\n                if (lottery.rewardsBreakdown[j] != 0) {\n                    lottery.rewardPerTicketInBracket[j] =\n                        ((lottery.rewardsBreakdown[j] * amountToWinners) /\n                            (winningAmount -\n                                numberAddressesInPreviousBracket)) /\n                        10000;\n\n                    lottery.pendingRewards +=\n                        (lottery.rewardsBreakdown[j] * amountToWinners) /\n                        10000;\n                }\n                // No winners, prize added to the amount to withdraw to treasury\n            } else {\n                lottery.rewardPerTicketInBracket[j] = 0;\n                amountToNextLottery +=\n                    (lottery.rewardsBreakdown[j] * amountToWinners) /\n                    10000;\n            }\n\n            // Update numberAddressesInPreviousBracket\n            numberAddressesInPreviousBracket = winningAmount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Update internal statuses for this lottery round\n        lottery.finalNumber = finalNumber;\n        lottery.status = Status.Claimable;\n        lottery.firstTicketIdNextRound = currentTicketId;\n\n        // If auto injection is on, reinject funds into next lottery\n        if (_autoInjection) {\n            pendingInjectionNextLottery = amountToNextLottery;\n        }\n\n        // Transfer prize to treasury address\n        if (amountToTreasury > 0) {\n            DegisToken.transfer(treasury, amountToTreasury);\n        }\n\n        emit LotteryNumberDrawn(\n            currentLotteryId,\n            finalNumber, // final result for this round\n            numberAddressesInPreviousBracket // total winners\n        );\n    }\n\n    /**\n     * @notice Change the random generator contract address\n     *\n     * @dev The calls to functions are used to verify the new generator implements them properly.\n     *      It is necessary to wait for the VRF response before starting a round.\n     *\n     * @param _randomGeneratorAddress address of the random generator\n     */\n    function changeRandomGenerator(address _randomGeneratorAddress)\n        external\n        onlyOwner\n    {\n        // We do not change the generator when a round has not been claimable\n        require(\n            lotteries[currentLotteryId].status == Status.Claimable,\n            \"Round not claimable\"\n        );\n\n        // Request a random number from the new generator\n        IRandomNumberGenerator(_randomGeneratorAddress).requestRandomWords();\n\n        // Get the finalNumber based on the randomResult\n        IRandomNumberGenerator(_randomGeneratorAddress).randomResult();\n\n        // Set the new address\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\n\n        emit NewRandomGenerator(_randomGeneratorAddress);\n    }\n\n    /**\n     * @notice Inject funds\n     *\n     * @dev Those DEG transferred to this contract but not by this function\n     *      will not be counted for prize pools\n     *\n     * @param _amount DEG amount to inject\n     */\n    function injectFunds(uint256 _amount) external {\n        uint256 currentRound = currentLotteryId;\n\n        // Only inject when current round is open\n        require(\n            lotteries[currentRound].status == Status.Open,\n            \"Round not open\"\n        );\n\n        // Update the amount collected for this round\n        lotteries[currentRound].amountCollected += _amount;\n\n        // Transfer DEG\n        DegisToken.transferFrom(msg.sender, address(this), _amount);\n\n        emit LotteryInjection(currentRound, _amount);\n    }\n\n    /**\n     * @notice Recover wrong tokens sent to the contract, only by the owner\n     *          All tokens except Degis are wrong tokens\n     *\n     * @param _tokenAddress Address of the token to withdraw\n     * @param _tokenAmount  Token amount to withdraw\n     */\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(_tokenAddress != address(DegisToken), \"Cannot be DEGIS token\");\n\n        IERC20(_tokenAddress).transfer(address(msg.sender), _tokenAmount);\n\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Calculate total price when buying many tickets\n     *         1 ticket = 100%  2 tickets = 98%  3 tickets = 98% * 98 % ...\n     *         Maximum discount: 98% ^ 10 ≈ 82%\n     *\n     * @param _price Ticket price in DEG\n     * @param _num   Number of tickets to be bought\n     *\n     * @return totalPrice Total price in DEG\n     */\n    function _calculateTotalPrice(uint256 _price, uint256 _num)\n        internal\n        pure\n        returns (uint256 totalPrice)\n    {\n        if (_num > 1) {\n            uint256 discountNum = _num - 1;\n\n            totalPrice =\n                (_price * _num * (DISCOUNT_DIVISOR**discountNum)) /\n                100**discountNum;\n        } else {\n            totalPrice = _price;\n        }\n    }\n\n    /**\n     * @notice returns highest bracket a ticket number falls into\n     *\n     * @param _lotteryId Lottery round\n     * @param _ticketId  Ticket id\n     */\n    function _getBracket(uint256 _lotteryId, uint256 _ticketId)\n        internal\n        view\n        returns (uint32 highestBracket)\n    {\n        uint32 userNumber = tickets[_ticketId].number;\n\n        // Retrieve the winning number combination\n        uint32 finalNumber = lotteries[_lotteryId].finalNumber;\n\n        // 3 => highest prize\n        // 4 => no prize\n        highestBracket = 4;\n        for (uint32 i = 1; i <= 4; ++i) {\n            if (finalNumber % (uint32(10)**i) == userNumber % (uint32(10)**i)) {\n                highestBracket = i - 1;\n            } else {\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate rewards for a given ticket\n     *\n     * @param _lotteryId Lottery id\n     * @param _ticketId  Ticket id\n     * @param _bracket   Bracket for the ticketId to verify the claim and calculate rewards\n     */\n    function _calculateRewardsForTicketId(\n        uint256 _lotteryId,\n        uint256 _ticketId,\n        uint32 _bracket\n    ) internal view returns (uint256) {\n        // Retrieve the user number combination from the ticketId\n        uint32 userNumber = tickets[_ticketId].number;\n\n        // Retrieve the winning number combination\n        uint32 finalNumber = lotteries[_lotteryId].finalNumber;\n\n        // Apply transformation to verify the claim provided by the user is true\n        uint32 ts = uint32(10)**(_bracket + 1);\n\n        uint32 transformedWinningNumber = _bracketCalculator[_bracket] +\n            (finalNumber % ts);\n        uint32 transformedUserNumber = _bracketCalculator[_bracket] +\n            (userNumber % ts);\n\n        // Confirm that the two transformed numbers are the same\n        if (transformedWinningNumber == transformedUserNumber) {\n            return lotteries[_lotteryId].rewardPerTicketInBracket[_bracket];\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Reverse the ticket number\n     *         E.g. User want to buy \"1234\"\n     *              The input number will be 11234\n     *              The reversed output will be 14321\n     *\n     * @param _number Input ticket number\n     *\n     * @return reversedNumber Reversed number + 10000\n     */\n    function _reverseTicketNumber(uint256 _number)\n        public\n        pure\n        returns (uint32)\n    {\n        uint256 initNumber = _number - 10**4;\n        uint256 singleNumber = 0;\n        uint256 reversedNumber;\n\n        for (uint256 i; i < 4; ) {\n            singleNumber = initNumber % 10;\n\n            reversedNumber = reversedNumber * 10 + singleNumber;\n\n            initNumber /= 10;\n\n            unchecked {\n                ++i;\n            }\n        }\n        return uint32(reversedNumber + 10000);\n    }\n\n    /**\n     * @notice Check if an address is a contract\n     */\n    function _isContract(address _addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/lucky-box/interfaces/IRandomNumberGenerator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IRandomNumberGenerator {\n    /**\n     * @notice Views random result\n     */\n    function getRandomNumber() external;\n\n    function requestRandomWords() external;\n\n    function randomResult() external view returns (uint256);\n\n    function latestLotteryId() external view returns (uint256);\n}\n"
    },
    "contracts/lucky-box/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary MathLib {\n    /*\n     * Minimum value signed 64.64-bit fixed point number may have.\n     */\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n    /*\n     * Maximum value signed 64.64-bit fixed point number may have.\n     */\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    function log_2(int128 x) internal pure returns (int128) {\n        unchecked {\n            require(x > 0);\n\n            int256 msb = 0;\n            int256 xc = x;\n            if (xc >= 0x10000000000000000) {\n                xc >>= 64;\n                msb += 64;\n            }\n            if (xc >= 0x100000000) {\n                xc >>= 32;\n                msb += 32;\n            }\n            if (xc >= 0x10000) {\n                xc >>= 16;\n                msb += 16;\n            }\n            if (xc >= 0x100) {\n                xc >>= 8;\n                msb += 8;\n            }\n            if (xc >= 0x10) {\n                xc >>= 4;\n                msb += 4;\n            }\n            if (xc >= 0x4) {\n                xc >>= 2;\n                msb += 2;\n            }\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\n\n            int256 result = (msb - 64) << 64;\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n                ux *= ux;\n                uint256 b = ux >> 255;\n                ux >>= 127 + b;\n                result += bit * int256(b);\n            }\n\n            return int128(result);\n        }\n    }\n\n    function mul(int128 x, int128 y) internal pure returns (int128) {\n        unchecked {\n            int256 result = (int256(x) * y) >> 64;\n            require(result >= MIN_64x64 && result <= MAX_64x64);\n            return int128(result);\n        }\n    }\n\n    /**\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x unsigned 256-bit integer number\n     * @return signed 64.64-bit fixed point number\n     */\n    function fromUInt(uint256 x) internal pure returns (int128) {\n        unchecked {\n            require(x <= 0x7FFFFFFFFFFFFFFF);\n            return int128(int256(x << 64));\n        }\n    }\n\n    /**\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n     * number rounding down.  Revert on underflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n     * @return unsigned 64-bit integer number\n     */\n    function toUInt(int128 x) internal pure returns (uint64) {\n        unchecked {\n            require(x >= 0);\n            return uint64(uint128(x >> 64));\n        }\n    }\n\n    function ln(int128 x) internal pure returns (int128) {\n        unchecked {\n            require(x > 0);\n\n            return\n                int128(\n                    int256(\n                        (uint256(int256(log_2(x))) *\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\n                    )\n                );\n        }\n    }\n}\n"
    },
    "contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(\n            _initializing ? _isConstructor() : !_initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.10;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"5c60da1b\"\n        );\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy)\n        public\n        view\n        virtual\n        returns (address)\n    {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(\n            hex\"f851a440\"\n        );\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(\n        TransparentUpgradeableProxy proxy,\n        address newAdmin\n    ) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation)\n        public\n        virtual\n        onlyOwner\n    {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(\n            _ADMIN_SLOT ==\n                bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)\n        );\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation()\n        external\n        ifAdmin\n        returns (address implementation_)\n    {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        ifAdmin\n    {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(\n            msg.sender != _getAdmin(),\n            \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\"\n        );\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/naughty-price/PriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { Ownable } from \"../utils/Ownable.sol\";\n\n/**\n * @title  Price Getter\n * @notice This is the contract for getting price feed from chainlink.\n *         The contract will keep a record from tokenName => priceFeed Address.\n *         Got the sponsorship and collaboration with Chainlink.\n * @dev    The price from chainlink priceFeed has different decimals, be careful.\n */\ncontract PriceGetter is Ownable {\n    struct PriceFeedInfo {\n        address priceFeedAddress;\n        uint256 decimals;\n    }\n    // Use token name (string) as the mapping key\n    // Should set the correct orginal token name\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event PriceFeedChanged(\n        string tokenName,\n        address feedAddress,\n        uint256 decimals\n    );\n\n    event LatestPriceGet(\n        uint80 roundID,\n        int256 price,\n        uint256 startedAt,\n        uint256 timeStamp,\n        uint80 answeredInRound\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor function, initialize some price feeds\n     *         The first supported tokens are ARB, BTC and ETH\n     */\n    constructor() Ownable(msg.sender) {\n        // Arbitrum data feed addresses and decimals\n        priceFeedInfo[\"ARB\"] = PriceFeedInfo(\n            0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6,\n            8\n        );\n\n        priceFeedInfo[\"ETH\"] = PriceFeedInfo(\n            0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612,\n            8\n        );\n\n        priceFeedInfo[\"BTC\"] = PriceFeedInfo(\n            0x6ce185860a4963106506C203335A2910413708e9,\n            8\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Modifiers ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Can not give zero address\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Zero address\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set a price feed oracle address for a token\n     * @dev Only callable by the owner\n     *      The price result decimal should be less than 18\n     * @param _tokenName   Address of the token\n     * @param _feedAddress Price feed oracle address\n     * @param _decimals    Decimals of this price feed service\n     */\n    function setPriceFeed(\n        string memory _tokenName,\n        address _feedAddress,\n        uint256 _decimals\n    ) public onlyOwner notZeroAddress(_feedAddress) {\n        require(_decimals <= 18, \"Too many decimals\");\n        priceFeedInfo[_tokenName] = PriceFeedInfo(_feedAddress, _decimals);\n\n        emit PriceFeedChanged(_tokenName, _feedAddress, _decimals);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get latest price of a token\n     * @param _tokenName Address of the token\n     * @return price The latest price\n     */\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\n        PriceFeedInfo memory priceFeed = priceFeedInfo[_tokenName];\n\n        (\n            uint80 roundID,\n            int256 price,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(priceFeed.priceFeedAddress).latestRoundData();\n\n        // require(price > 0, \"Only accept price that > 0\");\n        if (price < 0) price = 0;\n\n        emit LatestPriceGet(\n            roundID,\n            price,\n            startedAt,\n            timeStamp,\n            answeredInRound\n        );\n        // Transfer the result decimals\n        uint256 finalPrice = uint256(price) * (10 ** (18 - priceFeed.decimals));\n\n        return finalPrice;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/EmergencyPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./utils/Ownable.sol\";\n\n/**\n * @title  Emergency Pool\n * @notice Emergency pool in degis will keep a reserve vault for emergency usage.\n *         The asset comes from part of the product's income (currently 10%).\n *         Users can also stake funds into this contract manually.\n *         The owner has the right to withdraw funds from emergency pool and it would be passed to community governance.\n */\ncontract EmergencyPool is Ownable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    string public name = \"Degis Emergency Pool\";\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Deposit(\n        address indexed tokenAddress,\n        address indexed userAddress,\n        uint256 amount\n    );\n    event Withdraw(\n        address indexed tokenAddress,\n        address indexed userAddress,\n        uint256 amount\n    );\n    event UseFund(\n        address indexed tokenAddress,\n        address indexed userAddress,\n        uint256 amount\n    );\n\n    constructor() Ownable(msg.sender) {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Manually stake into the pool\n     * @param _tokenAddress Address of the ERC20 token\n     * @param _amount The amount that the user want to stake\n     */\n    function deposit(address _tokenAddress, uint256 _amount) external {\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        IERC20(_tokenAddress).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _amount\n        );\n\n        emit Deposit(_tokenAddress, _msgSender(), _amount);\n    }\n\n    /**\n     * @notice Withdraw the asset when emergency (only by the owner)\n     * @dev The ownership need to be transferred to another contract in the future\n     * @param _tokenAddress Address of the ERC20 token\n     * @param _amount The amount that the user want to unstake\n     */\n    function emergencyWithdraw(address _tokenAddress, uint256 _amount)\n        external\n        onlyOwner\n    {\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\n        require(_amount <= balance, \"Insufficient funds\");\n\n        IERC20(_tokenAddress).safeTransfer(owner(), _amount);\n        emit Withdraw(_tokenAddress, owner(), _amount);\n    }\n\n    /**\n     * @notice Use emergency pool fund\n     * @param _tokenAddress Address of the ERC20 token\n     * @param _receiver Address of the receiver\n     * @param _amount The amount to use    \n     */\n    function useFund(\n        address _tokenAddress,\n        address _receiver,\n        uint256 _amount\n    ) external onlyOwner {\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\n        require(_amount <= balance, \"Insufficient funds\");\n\n        IERC20(_tokenAddress).safeTransfer(_receiver, _amount);\n        emit UseFund(_tokenAddress, _receiver, _amount);\n    }\n}\n"
    },
    "contracts/chainlinkMock/VRFMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"../lucky-box/interfaces/IDegisLottery.sol\";\nimport \"../libraries/StringsUtils.sol\";\n\ncontract VRFMock is Ownable {\n    using StringsUtils for uint256;\n\n    IDegisLottery public DegisLottery;\n\n    uint256 public seed;\n\n    uint256 public randomResult;\n\n    uint256 public latestLotteryId;\n\n    constructor() Ownable(msg.sender) {}\n\n    /**\n     * @notice Set the address for the DegisLottery\n     * @param _degisLottery address of the PancakeSwap lottery\n     */\n    function setLotteryAddress(address _degisLottery) external onlyOwner {\n        DegisLottery = IDegisLottery(_degisLottery);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Request randomness from Chainlink VRF\n     */\n    function requestRandomWords() external {\n        require(\n            _msgSender() == address(DegisLottery) || _msgSender() == owner(),\n            \"Only DegisLottery\"\n        );\n\n        randomResult = (_rand(++seed) % 10000) + 10000;\n\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\n    }\n\n    function _rand(uint256 _input) internal pure returns (uint256) {\n        return _input * 12345;\n    }\n}\n"
    },
    "contracts/lucky-box/interfaces/IDegisLottery.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\ninterface IDegisLottery {\n    /**\n     * @notice Inject funds\n     * @param _amount amount to inject in USD\n     * @dev Callable by operator\n     */\n    function injectFunds(uint256 _amount) external;\n\n    /**\n     * @notice View current lottery id\n     */\n    function currentLotteryId() external view returns (uint256);\n}\n"
    },
    "contracts/lucky-box/RandomNumberGeneratorV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.13;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"./interfaces/IDegisLottery.sol\";\n\ncontract RandomNumberGeneratorV2 is VRFConsumerBaseV2 {\n    // Coordinator address based on networks\n    // Fuji: 0x2eD832Ba664535e5886b75D64C46EB9a228C2610\n    // Mainnet: 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634\n    VRFCoordinatorV2Interface public coordinator;\n\n    // Subscription id, created on chainlink website\n    // Fuji: 130\n    // Mainnet: 28 (test)\n    uint64 public subscriptionId;\n\n    // Different networks and gas prices have different keyHash\n    // Fuji: 300gwei 0x354d2f95da55398f44b7cff77da56283d9c6c829a4bdf1bbcaf2ad6a4d081f61\n    // Mainnet: 500gwei 0x89630569c9567e43c4fe7b1633258df9f2531b62f2352fa721cf3162ee4ecb46\n    bytes32 public keyHash;\n\n    // Gas limit for callback\n    uint32 public callbackGasLimit = 100000;\n\n    // Confirmations for each request\n    uint16 public requestConfirmations = 3;\n\n    // Request 1 random number each time\n    uint32 public wordsPerTime = 1;\n\n    // Store the latest result\n    uint256 public randomResult;\n\n    // Store the latest request id\n    uint256 public s_requestId;\n\n    // Owner address\n    address public owner;\n\n    // Latest lottery id\n    uint256 public latestLotteryId;\n\n    address public degisLottery;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event RequestRandomWords(uint256 requestId);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _vrfCoordinator,\n        bytes32 _keyHash,\n        uint64 _subscriptionId\n    ) VRFConsumerBaseV2(_vrfCoordinator) {\n        // Set coordinator address depends on networks\n        coordinator = VRFCoordinatorV2Interface(_vrfCoordinator);\n\n        // Set keyhash depends on networks and gas price\n        keyHash = _keyHash;\n\n        // Subscription id depends on networks\n        subscriptionId = _subscriptionId;\n\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner || msg.sender == degisLottery,\n            \"Only owner or lottery\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function setKeyHash(bytes32 _keyHash) external onlyOwner {\n        keyHash = _keyHash;\n    }\n\n    function setSubscriptionId(uint64 _subscriptionId) external onlyOwner {\n        subscriptionId = _subscriptionId;\n    }\n\n    function setCoordinator(address _coordinator) external onlyOwner {\n        coordinator = VRFCoordinatorV2Interface(_coordinator);\n    }\n\n    function setWordsPerTime(uint32 _wordsPerTime) external onlyOwner {\n        wordsPerTime = _wordsPerTime;\n    }\n\n    function setRequestConfirmations(uint16 _requestConfirmations)\n        external\n        onlyOwner\n    {\n        requestConfirmations = _requestConfirmations;\n    }\n\n    function setDegisLottery(address _lottery) external onlyOwner {\n        degisLottery = _lottery;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function requestRandomWords() external onlyOwner {\n        s_requestId = coordinator.requestRandomWords(\n            keyHash,\n            subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            wordsPerTime\n        );\n\n        emit RequestRandomWords(s_requestId);\n    }\n\n    function fulfillRandomWords(uint256, uint256[] memory _randomWords)\n        internal\n        override\n    {\n        randomResult = (_randomWords[0] % 10000) + 10000;\n\n        // Update latest lottery id\n        // Before this update, lottery can not make that round claimable\n        latestLotteryId = IDegisLottery(degisLottery).currentLotteryId();\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "contracts/income/IncomeMaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-Later\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../naughty-price/interfaces/INaughtyRouter.sol\";\nimport \"../naughty-price/interfaces/INaughtyFactory.sol\";\nimport \"../naughty-price/interfaces/INaughtyPair.sol\";\n\n/**\n * @title Degis Maker Contract\n * @dev This contract will receive the transaction fee from swap pool\n *      Then it will transfer\n */\ncontract IncomeMaker is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    uint256 public constant UINT256_MAX = type(uint256).max;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    INaughtyRouter public router;\n\n    INaughtyFactory public factory;\n\n    address public incomeSharingVault;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event IncomeToUSD(\n        address policyTokenAddress,\n        address stablecoin,\n        uint256 amountOut\n    );\n    event ConvertIncome(\n        address caller,\n        address policyTokenAddress,\n        address stablecoin,\n        uint256 policyTokenAmount, // Amount of policy token by burning lp tokens\n        uint256 stablecoinAmount, // Amount of stablecoin by burning lp tokens\n        uint256 stablecoinBackAmount // Amount of stablecoin by swapping policy tokens\n    );\n    event EmergencyWithdraw(address token, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Initialize function\n     * @param _router Address of the naughty router\n     * @param _factory Address of the naughty factory\n     * @param _vault Address of the income sharing vault\n     */\n    function initialize(\n        address _router,\n        address _factory,\n        address _vault\n    ) public initializer {\n        __Ownable_init();\n\n        router = INaughtyRouter(_router);\n        factory = INaughtyFactory(_factory);\n\n        incomeSharingVault = _vault;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Convert the income to stablecoin and transfer to the incomeSharingVault\n     * @param _policyToken Address of the policy token\n     * @param _stablecoin Address of the stablecoi\n     */\n    function convertIncome(address _policyToken, address _stablecoin) external {\n        // Get the pair\n        INaughtyPair pair = INaughtyPair(\n            factory.getPairAddress(_policyToken, _stablecoin)\n        );\n        require(address(pair) != address(0), \"Pair not exist\");\n\n        // Transfer lp token to the pool and get two tokens\n        IERC20(address(pair)).safeTransfer(\n            address(pair),\n            pair.balanceOf(address(this))\n        );\n\n        // Directly call the pair to burn lp tokens\n        (uint256 amount0, uint256 amount1) = pair.burn(address(this));\n\n        // Finish swap\n        uint256 amountOut = _swap(\n            _policyToken,\n            _stablecoin,\n            amount0,\n            address(this)\n        );\n\n        // Transfer all stablecoins to income sharing vault\n        IERC20(_stablecoin).safeTransfer(\n            incomeSharingVault,\n            IERC20(_stablecoin).balanceOf(address(this))\n        );\n\n        emit ConvertIncome(\n            msg.sender,\n            _policyToken,\n            _stablecoin,\n            amount0,\n            amount1,\n            amountOut\n        );\n    }\n\n    /**\n     * @notice Emergency withdraw by the owner\n     * @param _token Address of the token\n     * @param _amount Amount of the token\n     */\n    function emergencyWithdraw(address _token, uint256 _amount)\n        external\n        onlyOwner\n    {\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n        emit EmergencyWithdraw(_token, _amount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Swap policy tokens to stablecoins\n     * @param _policyToken Address of policy token\n     * @param _stablecoin Address of stablecoin\n     * @param _amount Amount of policy token\n     * @param _to Address of the receiver\n     */\n    function _swap(\n        address _policyToken,\n        address _stablecoin,\n        uint256 _amount,\n        address _to\n    ) internal returns (uint256 amountOut) {\n        // Get the pair\n        INaughtyPair pair = INaughtyPair(\n            factory.getPairAddress(_policyToken, _stablecoin)\n        );\n        require(address(pair) != address(0), \"Pair not exist\");\n\n        (uint256 reserve0, uint256 reserve1) = pair.getReserves();\n\n        uint256 feeRate = pair.feeRate();\n\n        // Calculate amountIn - fee\n        uint256 amountInWithFee = _amount * (1000 - feeRate);\n\n        // Calculate amountOut\n        amountOut =\n            (amountInWithFee * reserve1) /\n            (reserve0 * 1000 + amountInWithFee);\n\n        // Transfer policy token and swap\n        IERC20(_policyToken).safeTransfer(address(pair), _amount);\n        pair.swap(0, amountOut, _to);\n    }\n}\n"
    },
    "contracts/naughty-price/IDOPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IPriceGetter } from \"./interfaces/IPriceGetter.sol\";\nimport { IPolicyCore } from \"./interfaces/IPolicyCore.sol\";\n\nimport { IUniswapV2Pair } from \"./interfaces/IUniswapV2Pair.sol\";\nimport { FixedPoint } from \"../libraries/FixedPoint.sol\";\nimport { UniswapV2OracleLibrary } from \"../libraries/UniswapV2OracleLibrary.sol\";\nimport { UniswapV2Library } from \"../libraries/UniswapV2Library.sol\";\n\n/**\n * @title Price Getter for IDO Protection\n *\n * @notice This is the contract for getting price feed from DEX\n *         IDO projects does not have Chainlink feeds so we use DEX TWAP price as oracle\n *\n *         Workflow:\n *         1. Deploy naughty token for the IDO project and set its type as \"IDO\"\n *         2. Add ido price feed info by calling \"addIDOPair\" function\n *         3. Set auto tasks start within PERIOD to endTime to sample prices from DEX\n *         4. Call \"settleFinalResult\" function in core to settle the final price\n */\n\ncontract IDOPriceGetter is OwnableUpgradeable {\n    using FixedPoint for *;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constants **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // WAVAX address\n    address public constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    // address public constant WAVAX = 0xd00ae08403B9bbb9124bB305C09058E32C39A48c; // fuji\n\n    // Minimum period before endTime to start sampling\n    uint256 public constant PERIOD = 60 * 60 * 24 * 2; // 2 days\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Base price getter to transfer the price into USD\n    IPriceGetter public basePriceGetter;\n\n    // Policy Core contract\n    IPolicyCore public policyCore;\n\n    struct IDOPriceInfo {\n        address pair; // Pair on DEX\n        uint256 decimals; // If no special settings, it would be 0\n        uint256 sampleInterval;\n        uint256 isToken0;\n        uint256 priceAverage;\n        uint256 priceCumulativeLast;\n        uint256 lastTimestamp;\n        uint256 startTime;\n        uint256 endTime;\n    }\n    // Policy Base Token Name => IDO Info\n    mapping(string => IDOPriceInfo) public priceFeeds;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event SamplePrice(\n        string policyToken,\n        uint256 priceAverage,\n        uint256 timestamp\n    );\n\n    event NewIDOPair(\n        string policyToken,\n        address pair,\n        uint256 decimals,\n        uint256 sampleInterval,\n        uint256 isToken0\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _priceGetter, address _policyCore)\n        public\n        initializer\n    {\n        __Ownable_init();\n\n        basePriceGetter = IPriceGetter(_priceGetter);\n        policyCore = IPolicyCore(_policyCore);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function addIDOPair(\n        string calldata _policyToken,\n        address _pair,\n        uint256 _decimals,\n        uint256 _interval,\n        uint256 _startTime\n    ) external onlyOwner {\n        require(IUniswapV2Pair(_pair).token0() != address(0), \"Non exist pair\");\n        require(\n            IUniswapV2Pair(_pair).token0() == WAVAX ||\n                IUniswapV2Pair(_pair).token1() == WAVAX,\n            \"Not avax pair\"\n        );\n        require(\n            priceFeeds[_policyToken].pair == address(0),\n            \"Pair already exists\"\n        );\n\n        IDOPriceInfo storage newFeed = priceFeeds[_policyToken];\n\n        newFeed.pair = _pair;\n        // Decimals should keep the priceAverage to have 18 decimals\n        // WAVAX always have 18 decimals\n        // E.g. Pair token both 18 decimals => price decimals 18\n        //      (5e18, 10e18) real price 0.5 => we show priceAverage 0.5 * 10^18\n        //      Pair token (18, 6) decimals => price decimals 6\n        //      (5e18, 10e6) real price 0.5 => we show priceAverage 0.5 * 10^18\n        newFeed.decimals = _decimals;\n        newFeed.sampleInterval = _interval;\n\n        // Check if the policy base token is token0\n        bool isToken0 = !(IUniswapV2Pair(_pair).token0() == WAVAX);\n\n        newFeed.isToken0 = isToken0 ? 1 : 0;\n\n        (, , newFeed.lastTimestamp) = IUniswapV2Pair(_pair).getReserves();\n\n        // Record the initial priceCumulativeLast\n        newFeed.priceCumulativeLast = isToken0\n            ? IUniswapV2Pair(_pair).price0CumulativeLast()\n            : IUniswapV2Pair(_pair).price1CumulativeLast();\n\n        uint256 endTime = policyCore\n            .getPolicyTokenInfo(_policyToken)\n            .settleTimestamp;\n\n        require(\n            _startTime < endTime && _startTime + PERIOD >= endTime,\n            \"Wrong start time\"\n        );\n\n        newFeed.startTime = _startTime;\n        newFeed.endTime = endTime;\n\n        emit NewIDOPair(\n            _policyToken,\n            _pair,\n            _decimals,\n            _interval,\n            newFeed.isToken0\n        );\n    }\n\n    /**\n     * @notice Set price in avax\n     *         Price in avax should be in 1e18\n     *\n     * @param _policyToken Policy token name\n     * @param _price       Price in avax\n     */\n    function setPrice(string calldata _policyToken, uint256 _price)\n        external\n        onlyOwner\n    {\n        priceFeeds[_policyToken].priceAverage = _price;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function samplePrice(string calldata _policyToken) external {\n        IDOPriceInfo storage priceFeed = priceFeeds[_policyToken];\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 blockTimestamp\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(priceFeed.pair);\n\n        // Time between this sampling and last sampling (seconds)\n        uint32 timeElapsed = blockTimestamp - uint32(priceFeed.lastTimestamp);\n\n        uint256 decimals = priceFeed.decimals;\n\n        require(\n            timeElapsed > priceFeed.sampleInterval,\n            \"Minimum sample interval\"\n        );\n\n        // Update priceAverage and priceCumulativeLast\n        uint256 newPriceAverage;\n\n        if (priceFeed.isToken0 > 0) {\n            newPriceAverage = FixedPoint\n                .uq112x112(\n                    uint224(\n                        ((price0Cumulative - priceFeed.priceCumulativeLast) *\n                            10**decimals) / timeElapsed\n                    )\n                )\n                .decode();\n\n            priceFeed.priceCumulativeLast = price0Cumulative;\n        } else {\n            newPriceAverage = FixedPoint\n                .uq112x112(\n                    uint224(\n                        ((price1Cumulative - priceFeed.priceCumulativeLast) *\n                            10**decimals) / timeElapsed\n                    )\n                )\n                .decode();\n\n            priceFeed.priceCumulativeLast = price1Cumulative;\n        }\n\n        priceFeed.priceAverage = newPriceAverage;\n\n        // Update lastTimestamp\n        priceFeed.lastTimestamp = blockTimestamp;\n\n        emit SamplePrice(_policyToken, newPriceAverage, blockTimestamp);\n    }\n\n    /**\n     * @notice Get latest price\n     *\n     * @param _policyToken Policy token name\n     *\n     * @return price USD price of the base token\n     */\n    function getLatestPrice(string calldata _policyToken)\n        external\n        returns (uint256 price)\n    {\n        uint256 priceInAVAX;\n\n        // If token0 is WAVAX, use price1Average\n        // Else, use price0Average\n        priceInAVAX = priceFeeds[_policyToken].priceAverage;\n\n        require(priceInAVAX > 0, \"Zero Price\");\n\n        // AVAX price, 1e18 scale\n        uint256 avaxPrice = basePriceGetter.getLatestPrice(\"AVAX\");\n\n        // Warning: for DCAR we tempararily double the price because the settlement price is 0.165\n        //          but we set it as 0.33 (they changed the ido price after this round online)\n\n        // This final price is also multiplied by 1e18\n        price = (avaxPrice * priceInAVAX) / 1e18;\n    }\n}\n"
    },
    "contracts/naughty-price/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity ^0.8.10;\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "pragma solidity ^0.8.10;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y)\n        internal\n        pure\n        returns (uq144x112 memory)\n    {\n        uint256 z;\n        require(\n            y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x),\n            \"FixedPoint: MULTIPLICATION_OVERFLOW\"\n        );\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator)\n        internal\n        pure\n        returns (uq112x112 memory)\n    {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity ^0.8.10;\n\nimport \"../naughty-price/interfaces/IUniswapV2Pair.sol\";\nimport \"./FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n    using FixedPoint for *;\n\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2**32);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(address pair)\n        internal\n        view\n        returns (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint32 blockTimestamp\n        )\n    {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        ) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative +=\n                uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n                timeElapsed;\n            // counterfactual\n            price1Cumulative +=\n                uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n                timeElapsed;\n        }\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2Library.sol": {
      "content": "pragma solidity ^0.8.10;\n\nimport \"../naughty-price/interfaces/IUniswapV2Pair.sol\";\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            pairFor(factory, tokenA, tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/naughty-price/ArbitraryPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/*\n //======================================================================\\\\\n //======================================================================\\\\\n    *******         **********     ***********     *****     ***********\n    *      *        *              *                 *       *\n    *        *      *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     *              *                 *       *\n    *         *     **********     *       *****     *       ***********\n    *         *     *              *         *       *                 *\n    *         *     *              *         *       *                 *\n    *        *      *              *         *       *                 *\n    *      *        *              *         *       *                 *\n    *******         **********     ***********     *****     ***********\n \\\\======================================================================//\n \\\\======================================================================//\n*/\n\npragma solidity ^0.8.10;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IPolicyCore } from \"./interfaces/IPolicyCore.sol\";\n\n/**\n * @title Price Getter for arbitrary contract\n *\n * @notice This is the contract for getting price feed from arbitrary contract.\n *         A special case of PriceGetter, not a normal \"token price\" and usually just a variable from another contract.\n * \n *         E.g. A state variable p inside a contract A should be the settlement price of an option token.\n *              Then get latest price = A.p\n */\n\ncontract ArbitraryPriceGetter is OwnableUpgradeable {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Policy Core contract\n    IPolicyCore public policyCore;\n\n    struct PriceInfo {\n        address contractAddress; // Contract address\n        string functionSignature; // Function signature to get price\n        bytes callData;\n    }\n    // Policy Base Token Name => Price Feed Info\n    mapping(string => PriceInfo) public priceFeeds;\n\n    mapping(string => string) public baseTokens;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event SamplePrice(string policyToken, uint256 price);\n\n    event NewPair(\n        string policyToken,\n        address contractAddress,\n        string functionSignature\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    function initialize(address _policyCore) public initializer {\n        __Ownable_init();\n\n        policyCore = IPolicyCore(_policyCore);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new pair\n     * \n     * @param _baseToken         Base toke name (e.g. \"RoboVault\")\n     * @param _contractAddress   Target contract address to get price\n     * @param _functionSignature Target function signature (e.g. \"getPrice() returns(uint256)\")\n     * @param _calldata          Calldata to call the function and get price\n     */\n    function addPair(\n        string calldata _baseToken,\n        address _contractAddress,\n        string calldata _functionSignature,\n        bytes calldata _calldata\n    ) external onlyOwner {\n        require(\n            priceFeeds[_baseToken].contractAddress == address(0),\n            \"Pair already exists\"\n        );\n\n        PriceInfo storage newFeed = priceFeeds[_baseToken];\n\n        newFeed.contractAddress = _contractAddress;\n        newFeed.functionSignature = _functionSignature;\n        newFeed.callData = _calldata;\n\n        require(\n            bytes4(keccak256(bytes(_functionSignature))) ==\n                bytes4(_calldata[0:4]),\n            \"Signature and calldata not match\"\n        );\n        (bool success, bytes memory res) = _contractAddress.call(_calldata);\n\n        require(success, \"Call failed\");\n        uint256 priceResult = abi.decode(res, (uint256));\n\n        require(priceResult > 0, \"Invalid price result\");\n\n        emit NewPair(_baseToken, _contractAddress, _functionSignature);\n    }\n\n    /**\n     * @notice Set base token for a policy token\n     *         E.g. RoboVault <=> RoboVault_1.2_L_0505\n     * \n     *         (This is to keep the same interface with other price getters)\n     * \n     * @param _policyToken Policy token name \n     * @param _baseToken   Base token name \n     */\n    function setBaseToken(string memory _policyToken, string memory _baseToken)\n        external\n        onlyOwner\n    {\n        baseTokens[_policyToken] = _baseToken;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get latest price\n     *\n     * @param _policyToken Policy token name\n     *\n     * @return price USD price of the base token (1e18 decimal)\n     */\n    function getLatestPrice(string calldata _policyToken)\n        external\n        returns (uint256 price)\n    {\n        string memory baseToken = baseTokens[_policyToken];\n\n        bytes memory data = priceFeeds[baseToken].callData;\n\n        (bool success, bytes memory res) = priceFeeds[baseToken]\n            .contractAddress\n            .call(data);\n\n        require(success, \"Call failed\");\n\n        uint256 rawPrice = abi.decode(res, (uint256));\n        require(rawPrice > 0, \"Invalid price result\");\n\n        // Price result should be in 1e18 decimal\n        price = rawPrice * 10**12;\n\n        emit SamplePrice(_policyToken, price);\n    }\n}\n"
    },
    "contracts/mocks/MockUSD.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @notice This is the MockUSD used in testnet\n *         Maximum mint amount is 500k for each user.\n *         Maximum mint amount for every single tx is 100k.\n */\ncontract MockUSD is ERC20 {\n    uint256 public constant INITIAL_SUPPLY = 100000 * 1e6;\n\n    constructor() ERC20(\"MOCKUSD\", \"USDC\") {\n        // When first deployed, give the owner some coins\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\n\n    // Everyone can mint, have fun for test\n    function mint(address _account, uint256 _amount) public {\n        _mint(_account, _amount);\n    }\n\n    // 6 decimals to mock stablecoins\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @notice MockERC20 for test\n * @dev MockUSD has 6 decimals, this contract is 18 decimals\n */\ncontract MockERC20 is ERC20 {\n    constructor() ERC20(\"MockERC20\", \"ERC20\") {}\n\n    // Everyone can mint, have fun for test\n    function mint(address _account, uint256 _amount) public {\n        _mint(_account, _amount);\n    }\n}\n"
    },
    "contracts/governance/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(id, predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(\n        bytes32 id,\n        uint256 index,\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) private {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n}\n"
    },
    "contracts/mocks/MockPTP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockPTP {\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 minimumToAmount,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 actualToAmount, uint256 haircut) {\n        require(block.timestamp < deadline, \"Deadline has passed\");\n        require(fromToken != address(0), \"ZERO\");\n        require(toToken != address(0), \"ZERO\");\n        require(fromToken != toToken, \"SAME_ADDRESS\");\n        require(fromAmount > 0, \"ZERO_FROM_AMOUNT\");\n        require(to != address(0), \"ZERO\");\n\n        IERC20 fromERC20 = IERC20(fromToken);\n        // Asset fromAsset = _assetOf(fromToken);\n        // Asset toAsset = _assetOf(toToken);\n\n        // // Intrapool swapping only\n        // require(\n        //     toAsset.aggregateAccount() == fromAsset.aggregateAccount(),\n        //     \"DIFF_AGG_ACC\"\n        // );\n\n        // (actualToAmount, haircut) = _quoteFrom(fromAsset, toAsset, fromAmount);\n\n        fromERC20.transferFrom(msg.sender, fromToken, fromAmount);\n\n        actualToAmount = fromAmount;\n        haircut = 0;\n\n        require(minimumToAmount <= actualToAmount, \"AMOUNT_TOO_LOW\");\n        // fromAsset.addCash(fromAmount);\n        // toAsset.removeCash(actualToAmount);\n        // toAsset.addLiability(_dividend(haircut, _retentionRatio));\n        // toAsset.transferUnderlyingToken(to, actualToAmount);\n    }\n}\n"
    },
    "contracts/libraries/StringsUtilsTester.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\nimport \"./StringsUtils.sol\";\n\ncontract StringsUtilsTester {\n    function byToString(bytes32 _bytes) public pure returns (string memory) {\n        return StringsUtils.byToString(_bytes);\n    }\n\n    function addressToString(address _addr)\n        public\n        pure\n        returns (string memory)\n    {\n        return StringsUtils.addressToString(_addr);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function uintToString(uint256 value) public pure returns (string memory) {\n        return StringsUtils.uintToString(value);\n    }\n\n    function uintToHexString(uint256 value)\n        public\n        pure\n        returns (string memory)\n    {\n        return StringsUtils.uintToHexString(value);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function uintToHexString(uint256 value, uint256 length)\n        public\n        pure\n        returns (string memory)\n    {\n        return StringsUtils.uintToHexString(value, length);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}