{
  "language": "Solidity",
  "sources": {
    "contracts/chainlinkMock/PriceFeedMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"../libraries/StringsUtils.sol\";\n\ncontract PriceFeedMock is Ownable {\n    using StringsUtils for uint256;\n\n    struct PriceFeedInfo {\n        address priceFeedAddress;\n        uint256 decimals;\n    }\n    // Use token name (string) as the mapping key\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\n\n    uint256 public roundId;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event PriceFeedChanged(\n        string tokenName,\n        address feedAddress,\n        uint256 decimals\n    );\n\n    event LatestPriceGet(uint256 roundID, uint256 price);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor function, initialize some price feed\n     */\n    constructor() {\n        // At first, launch three kind of pools\n\n        // Uncomment below when launched on Avalanche Fuji\n        priceFeedInfo[\"AVAX\"] = PriceFeedInfo(\n            0x5498BB86BC934c8D34FDA08E81D444153d0D06aD,\n            8\n        );\n\n        priceFeedInfo[\"ETH\"] = PriceFeedInfo(\n            0x86d67c3D38D2bCeE722E601025C25a575021c6EA,\n            8\n        );\n\n        priceFeedInfo[\"BTC\"] = PriceFeedInfo(\n            0x31CF013A08c6Ac228C94551d535d5BAfE19c602a,\n            8\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Modifiers ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Can not give zero address\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"can not give zero address\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set a price feed oracle address for a token\n     * @param _tokenName Address of the token\n     * @param _feedAddress Price feed oracle address\n     * @param _decimals Decimals of this price feed service\n     */\n    function setPriceFeed(\n        string memory _tokenName,\n        address _feedAddress,\n        uint256 _decimals\n    ) public onlyOwner notZeroAddress(_feedAddress) {\n        require(_decimals <= 18, \"Too many decimals\");\n        priceFeedInfo[_tokenName] = PriceFeedInfo(_feedAddress, _decimals);\n\n        emit PriceFeedChanged(_tokenName, _feedAddress, _decimals);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get latest price of a token\n     * @param _tokenName Address of the token\n     * @return price The latest price\n     */\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\n        PriceFeedInfo memory priceFeed = priceFeedInfo[_tokenName];\n\n        string memory randInput = string(\n            abi.encodePacked((block.timestamp).uintToString(), address(this))\n        );\n        uint256 price = _rand(randInput) % 10000;\n\n        // require(price > 0, \"Only accept price that > 0\");\n        if (price < 0) price = 0;\n\n        emit LatestPriceGet(roundId, price);\n\n        roundId += 1;\n\n        uint256 finalPrice = uint256(price) * (10**(18 - priceFeed.decimals));\n\n        return finalPrice;\n    }\n\n    function _rand(string memory input) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(input)));\n    }\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./Context.sol\";\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    /**\n     * @notice Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @notice Leaves the contract without owner. It will not be possible to call\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * @dev    Renouncing ownership will leave the contract without an owner,\n     *         thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Can only be called by the current owner.\n     * @param  newOwner Address of the new owner\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Internal function without access restriction.\n     * @param  newOwner Address of the new owner\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/libraries/StringsUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUtils {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @notice Bytes to string (not human-readable form)\n     * @param _bytes Input bytes\n     * @return stringBytes String form of the bytes\n     */\n    function byToString(bytes32 _bytes) internal pure returns (string memory) {\n        return uintToHexString(uint256(_bytes), 32);\n    }\n\n    /**\n     * @notice Transfer address to string (not change the content)\n     * @param _addr Input address\n     * @return stringAddress String form of the address\n     */\n    function addressToString(address _addr)\n        internal\n        pure\n        returns (string memory)\n    {\n        return uintToHexString(uint256(uint160(_addr)), 20);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function uintToString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function uintToHexString(uint256 value)\n        internal\n        pure\n        returns (string memory)\n    {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return uintToHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function uintToHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/naughty-price/PolicyCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../libraries/StringsUtils.sol\";\nimport \"../libraries/SafePRBMath.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"./interfaces/IPriceGetter.sol\";\nimport \"./interfaces/INaughtyFactory.sol\";\nimport \"./interfaces/INPPolicyToken.sol\";\n\n/**\n * @title  PolicyCore\n * @notice Core logic of Naughty Price Product\n *         Preset:\n *              (Done in the naughtyFactory contract)\n *              1. Deploy policyToken contract\n *              2. Deploy policyToken-Stablecoin pool contract\n *         User Interaction:\n *              1. Deposit Stablecoin and mint PolicyTokens\n *              2. Redeem their Stablecoin and burn the PolicyTokens (before settlement)\n *              3. Claim for payout with PolicyTokens (after settlement)\n *         PolicyTokens are minted with the ratio 1:1 to Stablecoin\n *         The PolicyTokens are traded in the pool with CFMM (xy=k)\n *         When the event happens, a PolicyToken can be burned for claiming 1 Stablecoin.\n *         When the event does not happen, the PolicyToken depositors can\n *         redeem their 1 deposited Stablecoin\n * @dev    Most of the functions to be called from outside will use the name of policyToken\n *         rather than the address (easy to read).\n *         Other variables or functions still use address to index.\n *         The rule of policyToken naming is Original Token Name + Strike Price + Lower or Higher + Date\n *         E.g.  AVAX_30_L_2101, BTC_30000_L_2102, ETH_8000_H_2109\n */\n\ncontract PolicyCore is Ownable {\n    using StringsUtils for uint256;\n    using SafePRBMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Factory contract, responsible for deploying new contracts\n    INaughtyFactory public factory;\n\n    // Oracle contract, responsible for getting the final price\n    IPriceGetter public priceGetter;\n\n    // Lottery address\n    address public lottery;\n\n    // Emergency pool contract address\n    address public emergencyPool;\n\n    // Naughty Router contract address\n    address public naughtyRouter;\n\n    // Current distribution index\n    uint256 public currentDistributionIndex;\n\n    struct PolicyTokenInfo {\n        address policyTokenAddress;\n        bool isCall;\n        uint256 decimals; // decimals of the oracle pricefeed\n        uint256 strikePrice;\n        uint256 deadline;\n        uint256 settleTimestamp;\n    }\n    // Policy toke name => Policy token information\n    mapping(string => PolicyTokenInfo) public policyTokenInfoMapping;\n\n    mapping(address => string) public policyTokenAddressToName;\n\n    // Policy token name list\n    string[] public allPolicyTokens;\n\n    // Stablecoin address => Supported or not\n    mapping(address => bool) public supportedStablecoin;\n\n    // Policy token address => Stablecoin address\n    mapping(address => address) public whichStablecoin;\n\n    // PolicyToken => Strike Token (e.g. AVAX30L202101 address => AVAX address)\n    mapping(address => string) public policyTokenToOriginal;\n\n    // User Address => Token Address => User Quota Amount\n    mapping(address => mapping(address => uint256)) userQuota;\n\n    // Policy token address => All the depositors for this round (store all the depositors in an array)\n    mapping(address => address[]) allDepositors;\n\n    struct SettlementInfo {\n        uint256 price;\n        bool isHappened;\n        bool alreadySettled;\n    }\n    // Policy token address => Settlement result information\n    mapping(address => SettlementInfo) public settleResult;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Events ******************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event LotteryChanged(address newLotteryAddress);\n    event EmergencyPoolChanged(address newEmergencyPool);\n    event NaughtyRouterChanged(address newRouter);\n\n    event PolicyTokenDeployed(\n        string tokenName,\n        address tokenAddress,\n        uint256 deadline,\n        uint256 settleTimestamp\n    );\n\n    event PoolDeployed(\n        address poolAddress,\n        address policyTokenAddress,\n        address stablecoin\n    );\n\n    event Deposit(\n        address userAddress,\n        string policyTokenName,\n        address stablecoin,\n        uint256 amount\n    );\n\n    event DelegateDeposit(\n        address payerAddress,\n        address userAddress,\n        string policyTokenName,\n        address stablecoin,\n        uint256 amount\n    );\n\n    event FinalResultSettled(\n        string _policyTokenName,\n        uint256 price,\n        bool isHappened\n    );\n    event NewStablecoinAdded(address _newStablecoin);\n\n    event FinishSettlementPolicies(\n        address _policyTokenAddress,\n        address _stablecoin\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor, for some addresses\n     * @param _usdt USDT is the first stablecoin supported in the pool\n     * @param _factory Address of naughty factory\n     * @param _priceGetter Address of the oracle contract\n     */\n    constructor(\n        address _usdt,\n        address _factory,\n        address _priceGetter\n    ) {\n        // Add the first stablecoin supported\n        supportedStablecoin[_usdt] = true;\n\n        // Initialize the interfaces\n        factory = INaughtyFactory(_factory);\n        priceGetter = IPriceGetter(_priceGetter);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if this stablecoin is supported\n     * @param _stablecoin Stablecoin address\n     */\n    modifier validStablecoin(address _stablecoin) {\n        require(\n            supportedStablecoin[_stablecoin] == true,\n            \"Do not support this stablecoin currently\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Check if the policy token has been deployed, used when deploying pools\n     * @param _policyTokenName Name of the policy token inside the pair\n     */\n    modifier deployedPolicy(string memory _policyTokenName) {\n        require(\n            policyTokenInfoMapping[_policyTokenName].policyTokenAddress !=\n                address(0),\n            \"This policy token has not been deployed, please deploy it first\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Check if there are enough stablecoins in this contract\n     * @param _stablecoin Address of the stablecoin\n     * @param _amount Amount to be checked\n     */\n    modifier enoughUSD(address _stablecoin, uint256 _amount) {\n        require(\n            IERC20(_stablecoin).balanceOf(address(this)) >= _amount,\n            \"Not sufficient stablecoins in the contract\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Deposit/Redeem/Swap only before deadline\n     * @dev Each pool will also have this deadline\n     *      That needs to be set inside naughtyFactory\n     * @param _policyTokenName Name of the policy token\n     */\n    modifier beforeDeadline(string memory _policyTokenName) {\n        uint256 deadline = policyTokenInfoMapping[_policyTokenName].deadline;\n        require(\n            block.timestamp <= deadline,\n            \"Can not deposit/redeem, has passed the deadline\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Can only settle the result after the \"_settleTimestamp\"\n     * @param _policyTokenName Name of the policy token\n     */\n    modifier afterSettlement(string memory _policyTokenName) {\n        uint256 settleTimestamp = policyTokenInfoMapping[_policyTokenName]\n            .settleTimestamp;\n        require(\n            block.timestamp >= settleTimestamp,\n            \"Can not settle/claim, have not reached settleTimestamp\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Avoid multiple settlements\n     * @param _policyTokenName Name of the policy token\n     */\n    modifier notAlreadySettled(string memory _policyTokenName) {\n        address policyTokenAddress = policyTokenInfoMapping[_policyTokenName]\n            .policyTokenAddress;\n        require(\n            settleResult[policyTokenAddress].alreadySettled == false,\n            \"This policy has already been settled\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Find the token address by its name\n     * @param _policyTokenName Name of the policy token (e.g. \"AVAX_30_L_2103\")\n     * @return policyTokenAddress Address of the policy token\n     */\n    // Note: not really needed\n    function findAddressbyName(string memory _policyTokenName)\n        public\n        view\n        returns (address)\n    {\n        return policyTokenInfoMapping[_policyTokenName].policyTokenAddress;\n    }\n\n    /**\n     * @notice Find the token name by its address\n     * @param _policyTokenAddress Address of the policy token\n     * @return policyTokenName Name of the policy token\n     */\n    // Note: not really needed\n    function findNamebyAddress(address _policyTokenAddress)\n        public\n        view\n        returns (string memory)\n    {\n        return policyTokenAddressToName[_policyTokenAddress];\n    }\n\n    /**\n     * @notice Find the token information by its name\n     * @param _policyTokenName Name of the policy token (e.g. \"AVAX30L202103\")\n     * @return policyTokenInfo PolicyToken detail information\n     */\n    function getPolicyTokenInfo(string memory _policyTokenName)\n        public\n        view\n        returns (PolicyTokenInfo memory)\n    {\n        return policyTokenInfoMapping[_policyTokenName];\n    }\n\n    /**\n     * @notice Check a user's quota for a certain policy token\n     * @param _user Address of the user to be checked\n     * @param _policyTokenAddress Address of the policy token\n     * @return _quota User's quota result\n     */\n    function checkUserQuota(address _user, address _policyTokenAddress)\n        external\n        view\n        returns (uint256 _quota)\n    {\n        _quota = userQuota[_user][_policyTokenAddress];\n    }\n\n    /**\n     * @notice Get the information about all the tokens\n     * @return tokensInfo Token information list\n     */\n    function getAllTokens() external view returns (PolicyTokenInfo[] memory) {\n        uint256 length = allPolicyTokens.length;\n        PolicyTokenInfo[] memory tokensInfo = new PolicyTokenInfo[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            tokensInfo[i] = policyTokenInfoMapping[allPolicyTokens[i]];\n        }\n\n        return tokensInfo;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a newly supported stablecoin\n     * @param _newStablecoin Address of the new stablecoin\n     */\n    function addStablecoin(address _newStablecoin) external onlyOwner {\n        supportedStablecoin[_newStablecoin] = true;\n        emit NewStablecoinAdded(_newStablecoin);\n    }\n\n    /**\n     * @notice Change the address of lottery\n     * @param _lotteryAddress Address of the new lottery\n     */\n    function setLottery(address _lotteryAddress) external onlyOwner {\n        lottery = _lotteryAddress;\n        emit LotteryChanged(_lotteryAddress);\n    }\n\n    /**\n     * @notice Change the address of emergency pool\n     * @param _emergencyPool Address of the new emergencyPool\n     */\n    function setEmergencyPool(address _emergencyPool) external onlyOwner {\n        emergencyPool = _emergencyPool;\n        emit EmergencyPoolChanged(_emergencyPool);\n    }\n\n    /**\n     * @notice Change the address of naughty router\n     * @param _router Address of the new naughty router\n     */\n    function setNaughtyRouter(address _router) external onlyOwner {\n        naughtyRouter = _router;\n        emit NaughtyRouterChanged(_router);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy a new policy token and return the token address\n     * @dev Only the owner can deploy new policy token\n     *      The name form is like \"AVAX_50_L_202101\" and is built inside the contract.\n     * @param _tokenName Name of the original token (e.g. AVAX, BTC, ETH...)\n     * @param _isCall The policy is for higher or lower than the strike price (call / put)\n     * @param _decimals Decimals of this token's price (0~18)\n     * @param _strikePrice Strike price of the policy (have already been transferred with 1e18)\n     * @param _deadline Deadline of this policy token (deposit / redeem / swap)\n     * @param _settleTimestamp Can settle after this timestamp (for oracle)\n     * @return policyTokenAddress The address of the policy token just deployed\n     */\n    function deployPolicyToken(\n        string memory _tokenName,\n        bool _isCall,\n        uint256 _decimals,\n        uint256 _strikePrice,\n        uint256 _round,\n        uint256 _deadline,\n        uint256 _settleTimestamp\n    ) external onlyOwner returns (address) {\n        require(_decimals <= 18, \"Too many decimals\");\n        require(_deadline > block.timestamp, \"Wrong deadline\");\n\n        string memory policyTokenName = _generateName(\n            _tokenName,\n            _decimals,\n            _strikePrice,\n            _isCall,\n            _round\n        );\n        // Deploy a new policy token by the factory contract\n        address policyTokenAddress = factory.deployPolicyToken(policyTokenName);\n\n        // Store the policyToken information in the mapping\n        policyTokenInfoMapping[policyTokenName] = PolicyTokenInfo(\n            policyTokenAddress,\n            _isCall,\n            _decimals,\n            _strikePrice,\n            _deadline,\n            _settleTimestamp\n        );\n\n        // Keep the record from policy token to original token\n        policyTokenToOriginal[policyTokenAddress] = _tokenName;\n\n        // Record the address to name mapping\n        policyTokenAddressToName[policyTokenAddress] = policyTokenName;\n\n        // Push the policytokenName into the list\n        allPolicyTokens.push(policyTokenName);\n\n        emit PolicyTokenDeployed(\n            policyTokenName,\n            policyTokenAddress,\n            _deadline,\n            _settleTimestamp\n        );\n\n        // You can not get the return value from outside, but keep it here.\n        return policyTokenAddress;\n    }\n\n    /**\n     * @notice Deploy a new pair (pool)\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the stable coin\n     * @param _poolDeadline Swapping deadline of the pool (normally the same as the token's deadline)\n     * @param _feeRate Fee rate given to LP holders\n     * @return poolAddress The address of the pool just deployed\n     */\n    function deployPool(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _poolDeadline,\n        uint256 _feeRate\n    )\n        external\n        onlyOwner\n        validStablecoin(_stablecoin)\n        deployedPolicy(_policyTokenName)\n        returns (address)\n    {\n        require(_poolDeadline > block.timestamp, \"Wrong deadline\");\n\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Deploy a new pool (policyToken <=> stablecoin)\n        address poolAddress = factory.deployPool(\n            policyTokenAddress,\n            _stablecoin,\n            _poolDeadline,\n            _feeRate\n        );\n\n        // Record the mapping\n        whichStablecoin[policyTokenAddress] = _stablecoin;\n\n        emit PoolDeployed(poolAddress, policyTokenAddress, _stablecoin);\n\n        return poolAddress;\n    }\n\n    /**\n     * @notice Deposit stablecoins and get policy tokens\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the sable coin\n     * @param _amount Amount of stablecoin (also the amount of policy tokens)\n     */\n    function deposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    ) external beforeDeadline(_policyTokenName) {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Check if the user gives the right stablecoin\n        require(\n            whichStablecoin[policyTokenAddress] == _stablecoin,\n            \"PolicyToken and stablecoin not matched\"\n        );\n\n        // Check if the user has enough balance\n        require(\n            IERC20(_stablecoin).balanceOf(_msgSender()) >= _amount,\n            \"User's stablecoin balance not sufficient\"\n        );\n\n        // Transfer stablecoins to this contract\n        IERC20(_stablecoin).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _amount\n        );\n\n        _mintPolicyToken(policyTokenAddress, _amount, msg.sender);\n\n        emit Deposit(_msgSender(), _policyTokenName, _stablecoin, _amount);\n    }\n\n    /**\n     * @notice Delegate deposit (deposit and mint for other addresses)\n     * @dev Only called by the router contract\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the sable coin\n     * @param _amount Amount of stablecoin (also the amount of policy tokens)\n     * @param _user Address to receive the policy tokens\n     */\n    function delegateDeposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    ) external beforeDeadline(_policyTokenName) {\n        require(\n            _msgSender() == naughtyRouter,\n            \"Only the router contract can delegate\"\n        );\n\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Check if the user gives the right stablecoin\n        require(\n            whichStablecoin[policyTokenAddress] == _stablecoin,\n            \"PolicyToken and stablecoin not matched\"\n        );\n\n        // Check if the user has enough balance\n        require(\n            IERC20(_stablecoin).balanceOf(_user) >= _amount,\n            \"User's stablecoin balance not sufficient\"\n        );\n\n        // Transfer stablecoins to this contract\n        IERC20(_stablecoin).safeTransferFrom(_user, address(this), _amount);\n\n        _mintPolicyToken(policyTokenAddress, _amount, _user);\n\n        emit DelegateDeposit(\n            _msgSender(),\n            _user,\n            _policyTokenName,\n            _stablecoin,\n            _amount\n        );\n    }\n\n    /**\n     * @notice Burn policy tokens and redeem USDT\n     * @dev Redeem happens before the deadline and is different from claim/settle\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the stablecoin\n     * @param _amount Amount of USDT (also the amount of policy tokens)\n     */\n    function redeem(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    ) public enoughUSD(_stablecoin, _amount) beforeDeadline(_policyTokenName) {\n        address policyTokenAddress = policyTokenInfoMapping[_policyTokenName]\n            .policyTokenAddress;\n\n        // Check if the user has enough quota (quota is only for those who mint policy tokens)\n        require(\n            userQuota[msg.sender][policyTokenAddress] >= _amount,\n            \"User's quota not sufficient\"\n        );\n\n        _redeemPolicyToken(policyTokenAddress, _stablecoin, _amount);\n\n        userQuota[msg.sender][policyTokenAddress] -= _amount;\n\n        if (userQuota[msg.sender][policyTokenAddress] == 0)\n            delete userQuota[msg.sender][policyTokenAddress];\n    }\n\n    /**\n     * @notice Redeem policy tokens and get stablecoins by the user himeself\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the stablecoin\n     */\n    function redeemAfterSettlement(\n        string memory _policyTokenName,\n        address _stablecoin\n    ) public {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Copy to memory (will not change the result)\n        SettlementInfo memory result = settleResult[policyTokenAddress];\n\n        // Must have got the final price\n        require(\n            result.price != 0 && result.alreadySettled,\n            \"Have not got the oracle result\"\n        );\n\n        // The event must be \"not happend\"\n        require(\n            result.isHappened == false,\n            \"Only call this function when the event does not happen\"\n        );\n\n        // User must have quota because this is for depositors when event not happens\n        require(\n            userQuota[msg.sender][policyTokenAddress] > 0,\n            \"No quota, you did not deposit and mint policy tokens before\"\n        );\n\n        // Charge 1% Fee when redeem / claim\n        uint256 amount = userQuota[msg.sender][policyTokenAddress];\n        uint256 amountWithFee = (amount * 990) / 1000;\n\n        // Burn policy tokens and send back stablecoins\n        _redeemPolicyToken(policyTokenAddress, _stablecoin, amountWithFee);\n\n        // Delete the userQuota storage\n        delete userQuota[msg.sender][policyTokenAddress];\n    }\n\n    /**\n     * @notice Claim a payoff based on policy tokens\n     * @dev It is done after result settlement and only if the result is true\n     * @param _policyTokenName Name of the policy token\n     * @param _stablecoin Address of the stable coin\n     * @param _amount Amount of USDT (also the amount of policy tokens)\n     */\n    function claim(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    ) public enoughUSD(_stablecoin, _amount) afterSettlement(_policyTokenName) {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n\n        // Check if we have already settle the final price\n        require(\n            settleResult[policyTokenAddress].alreadySettled,\n            \"Have not got the oracle result\"\n        );\n\n        // Check if the event happens\n        require(\n            settleResult[policyTokenAddress].isHappened,\n            \"The result does not happen, you can not claim\"\n        );\n\n        // Charge 1% fee\n        uint256 amountWithFee = (_amount * 990) / 1000;\n\n        // Users must have enough policy tokens to claim\n        INPPolicyToken policyToken = INPPolicyToken(policyTokenAddress);\n        require(\n            policyToken.balanceOf(msg.sender) >= _amount,\n            \"You do not have sufficient policy tokens to claim\"\n        );\n\n        // Burn the policy tokens and redeem payoff\n        _redeemPolicyToken(policyTokenAddress, _stablecoin, amountWithFee);\n    }\n\n    /**\n     * @notice Get the final price from the PriceGetter contract\n     * @param _policyTokenName Name of the policy token\n     */\n    function settleFinalResult(string memory _policyTokenName)\n        public\n        afterSettlement(_policyTokenName)\n        notAlreadySettled(_policyTokenName)\n    {\n        PolicyTokenInfo memory policyTokenInfo = policyTokenInfoMapping[\n            _policyTokenName\n        ];\n\n        address policyTokenAddress = policyTokenInfo.policyTokenAddress;\n        require(\n            policyTokenAddress != address(0),\n            \"This policy token does not exist, maybe you input a wrong name\"\n        );\n\n        SettlementInfo storage result = settleResult[policyTokenAddress];\n\n        // Get the final price from oracle\n        string memory originalTokenName = policyTokenToOriginal[\n            policyTokenAddress\n        ];\n\n        uint256 price = IPriceGetter(priceGetter).getLatestPrice(\n            originalTokenName\n        );\n\n        result.price = price;\n\n        // Get the final result\n        bool situationT1 = (price >= policyTokenInfo.strikePrice) &&\n            policyTokenInfo.isCall;\n        bool situationT2 = (price <= policyTokenInfo.strikePrice) &&\n            !policyTokenInfo.isCall;\n\n        result.isHappened = (situationT1 || situationT2) ? true : false;\n\n        result.alreadySettled = true;\n\n        emit FinalResultSettled(_policyTokenName, price, result.isHappened);\n    }\n\n    /**\n     * @notice Settle the policies when then insurance event do not happen\n     *         Funds are automatically distributed back to the depositors\n     * @dev    Take care of the gas cost and can use the _startIndex and _stopIndex to control the size\n     * @param _policyTokenName Name of policy token\n     * @param _stablecoin Address of stablecoin\n     * @param _startIndex Settlement start index\n     * @param _stopIndex Settlement stop index\n     */\n    function settleAllPolicyTokens(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _startIndex,\n        uint256 _stopIndex\n    ) public onlyOwner {\n        address policyTokenAddress = findAddressbyName(_policyTokenName);\n        // Copy to memory (will not change the result)\n        SettlementInfo memory result = settleResult[policyTokenAddress];\n\n        // Must have got the final price\n        require(\n            result.price != 0 && result.alreadySettled == true,\n            \"Have not got the oracle result\"\n        );\n\n        // The event must be \"not happend\"\n        require(\n            result.isHappened == false,\n            \"Only call this function when the event does not happen\"\n        );\n\n        // Settle the policies in [_startIndex, _stopIndex)\n        if (_startIndex == 0 && _stopIndex == 0) {\n            uint256 length = allDepositors[policyTokenAddress].length;\n            _settlePolicy(policyTokenAddress, _stablecoin, 0, length);\n            currentDistributionIndex = length;\n        } else {\n            require(\n                currentDistributionIndex == _startIndex,\n                \"You need to start from the last distribution point\"\n            );\n            _settlePolicy(\n                policyTokenAddress,\n                _stablecoin,\n                _startIndex,\n                _stopIndex\n            );\n            currentDistributionIndex = _stopIndex;\n        }\n\n        if (\n            currentDistributionIndex == allDepositors[policyTokenAddress].length\n        ) {\n            _finishSettlement(policyTokenAddress, _stablecoin);\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Finish settlement process\n     * @param _policyTokenAddress Address of the policy token\n     * @param _stablecoin Address of stable coin\n     */\n    function _finishSettlement(address _policyTokenAddress, address _stablecoin)\n        internal\n    {\n        currentDistributionIndex = 0;\n\n        uint256 balanceRemain = IERC20(_stablecoin).balanceOf(address(this));\n\n        uint256 feeToLottery = (balanceRemain * 8) / 10;\n        uint256 feeToEmergency = balanceRemain - feeToLottery;\n\n        require(\n            lottery != address(0) && emergencyPool != address(0),\n            \"Please set the lottery address\"\n        );\n\n        IERC20(_stablecoin).safeTransfer(lottery, feeToLottery);\n        IERC20(_stablecoin).safeTransfer(emergencyPool, feeToEmergency);\n\n        emit FinishSettlementPolicies(_policyTokenAddress, _stablecoin);\n    }\n\n    /**\n     * @notice Mint Policy Token 1:1 USD\n     *         The policy token need to be deployed first!\n     * @param _policyTokenAddress Address of the policy token\n     * @param _amount Amount to mint\n     * @param _user Address to receive the policy token\n     */\n    function _mintPolicyToken(\n        address _policyTokenAddress,\n        uint256 _amount,\n        address _user\n    ) internal {\n        INPPolicyToken policyToken = INPPolicyToken(_policyTokenAddress);\n\n        // Mint new policy tokens\n        policyToken.mint(_user, _amount);\n\n        // If this is the first deposit, store the user address\n        if (userQuota[_user][_policyTokenAddress] == 0) {\n            allDepositors[_policyTokenAddress].push(_user);\n        }\n\n        // Update the user quota\n        userQuota[_user][_policyTokenAddress] += _amount;\n    }\n\n    /**\n     * @notice Finish the process of redeeming policy tokens\n     * @dev This internal function is used for redeeming and claiming\n     * @param _policyTokenAddress Address of policy token\n     * @param _stablecoin Address of stable coin\n     * @param _amount Amount to claim\n     */\n    function _redeemPolicyToken(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _amount\n    ) internal {\n        IERC20(_stablecoin).safeTransfer(msg.sender, _amount);\n\n        INPPolicyToken(_policyTokenAddress).burn(_msgSender(), _amount);\n    }\n\n    /**\n     * @notice Settle the policy when the event does not happen\n     * @param _policyTokenAddress Address of policy token\n     * @param _stablecoin Address of stable coin\n     * @param _start Start index\n     * @param _stop Stop index\n     */\n    function _settlePolicy(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _start,\n        uint256 _stop\n    ) internal {\n        for (uint256 i = _start; i < _stop; i++) {\n            address user = allDepositors[_policyTokenAddress][i];\n            uint256 amount = userQuota[user][_policyTokenAddress];\n            uint256 amountWithFee = (amount * 990) / 1000;\n\n            if (amountWithFee > 0) {\n                IERC20(_stablecoin).safeTransfer(user, amountWithFee);\n                delete userQuota[user][_policyTokenAddress];\n            } else continue;\n        }\n    }\n\n    /**\n     * @notice Generate the policy token name\n     * @param _tokenName Name of the token\n     * @param _decimals Decimals of the name generation (0,1=>1)\n     * @param _strikePrice Strike price of the policy\n     * @param _isCall The policy's payoff is triggered when higher or lower\n     * @param _round Round of the policy (e.g. 2112, 2201)\n     */\n    function _generateName(\n        string memory _tokenName,\n        uint256 _decimals,\n        uint256 _strikePrice,\n        bool _isCall,\n        uint256 _round\n    ) public pure returns (string memory) {\n        string memory direction = _isCall ? \"H\" : \"L\";\n\n        uint256 intPart = _strikePrice / 1e18;\n        uint256 decimalPart = _strikePrice.frac() / (10**(18 - _decimals));\n\n        string memory name = string(\n            abi.encodePacked(\n                _tokenName,\n                \"_\",\n                intPart.uintToString(),\n                \".\",\n                decimalPart.uintToString(),\n                \"_\",\n                direction,\n                \"_\",\n                _round.uintToString()\n            )\n        );\n        return name;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafePRBMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"prb-math/contracts/PRBMath.sol\";\n\n/**\n * @notice This prb-math version is 2.4.1\n *         https://github.com/hifi-finance/prb-math\n */\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary SafePRBMath {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    },
    "contracts/naughty-price/interfaces/IPriceGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IPriceGetter {\n    function getPriceFeedAddress(string memory _tokenName)\n        external\n        view\n        returns (address);\n\n    function setPriceFeed(string memory _tokenName, address _feedAddress)\n        external;\n\n    function getLatestPrice(string memory _tokenName)\n        external\n        returns (uint256 _price);\n}\n"
    },
    "contracts/naughty-price/interfaces/INaughtyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface INaughtyFactory {\n    function getPairAddress(address _tokenAddress1, address _tokenAddress2)\n        external\n        view\n        returns (address);\n\n    function deployPolicyToken(string memory _policyTokenName)\n        external\n        returns (address);\n\n    function deployPool(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external returns (address);\n}\n"
    },
    "contracts/naughty-price/interfaces/INPPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface INPPolicyToken is IERC20 {\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the closest power of two that is higher than x.\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "contracts/naughty-price/NaughtyRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../tokens/interfaces/IBuyerToken.sol\";\n\nimport \"./interfaces/INPPolicyToken.sol\";\nimport \"./interfaces/INaughtyPair.sol\";\nimport \"./interfaces/INaughtyFactory.sol\";\nimport \"./interfaces/IPolicyCore.sol\";\n\nimport \"../utils/Ownable.sol\";\nimport \"../libraries/SafePRBMath.sol\";\n\n/**\n * @title  NaughtyRouter\n * @notice Router for the pool, you can add/remove liquidity or swap A for B.\n *         Swapping fee rate is 2% and all of them are given to LP.\n *         Very similar logic with Uniswap V2.\n *\n */\ncontract NaughtyRouter is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for INaughtyPair;\n    using SafePRBMath for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Some other contracts\n    address public factory;\n    address public policyCore;\n    address public buyerToken;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event LiquidityAdded(\n        address indexed pairAddress,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n\n    event LiquidityRemoved(\n        address indexed pairAddress,\n        uint256 amountA,\n        uint256 amountB,\n        uint256 liquidity\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(address _factory, address _buyerToken) {\n        factory = _factory;\n        buyerToken = _buyerToken;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Transactions are available only before the deadline\n     * @param _deadLine Deadline of the pool\n     */\n    modifier beforeDeadline(uint256 _deadLine) {\n        require(block.timestamp < _deadLine, \"expired transaction\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set the address of policyCore\n     * @param _coreAddress Address of new policyCore\n     */\n    function setPolicyCore(address _coreAddress) external onlyOwner {\n        policyCore = _coreAddress;\n    }\n\n    /**\n     * @notice Set the address of buyer token\n     * @param _buyerToken Address of new buyer token\n     */\n    function setBuyerToken(address _buyerToken) external onlyOwner {\n        buyerToken = _buyerToken;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Helper Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add liquidity but only provide stablecoins\n     * @param _tokenA Address of policyToken\n     * @param _tokenB Address of stablecoin\n     * @param _amountUSD Amount of stablecoins provided\n     * @param _to Address that receive the lp token, normally the user himself\n     * @param _minRatio Minimum ratio (divided by 100)(amountMin / amountDesired)\n     * @param _deadline Transaction will revert after this deadline\n     */\n    function addLiquidityWithUSD(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountUSD,\n        address _to,\n        uint256 _minRatio,\n        uint256 _deadline\n    ) external beforeDeadline(_deadline) {\n        require(_minRatio <= 100, \"Minimum ratio can not exceed 100\");\n\n        require(_checkStablecoin(_tokenB), \"Please put stablecoin as tokenB\");\n\n        (uint256 reserveA, uint256 reserveB) = _getReserves(_tokenA, _tokenB);\n\n        require(reserveA > 0 && reserveB > 0, \"No tokens in the pool\");\n\n        uint256 _amountADesired = _amountUSD.mul(reserveA).div(\n            reserveA + reserveB\n        );\n        uint256 _amountBDesired = _amountUSD.mul(reserveB).div(\n            reserveA + reserveB\n        );\n\n        // Mint _amountADesired policy tokens for users\n        mintPolicyTokensForUser(\n            _tokenA,\n            _tokenB,\n            _amountADesired,\n            _msgSender()\n        );\n\n        {\n            addLiquidity(\n                _tokenA,\n                _tokenB,\n                _amountADesired,\n                _amountBDesired,\n                _amountADesired.mul(_minRatio).div(100),\n                _amountBDesired.mul(_minRatio).div(100),\n                _to,\n                _deadline\n            );\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add liquidity function\n     * @param _tokenA Address of policyToken\n     * @param _tokenB Address of stablecoin\n     * @param _amountADesired Amount of policyToken desired\n     * @param _amountBDesired Amount of stablecoin desired\n     * @param _amountAMin Minimum amoutn of policy token\n     * @param _amountBMin Minimum amount of stablecoin\n     * @param _to Address that receive the lp token, normally the user himself\n     * @param _deadline Transaction will revert after this deadline\n     * @return amountA Amount of tokenA to be input\n     * @return amountB Amount of tokenB to be input\n     * @return liquidity LP token to be mint\n     */\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        beforeDeadline(_deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        {\n            (amountA, amountB) = _addLiquidity(\n                _tokenA,\n                _tokenB,\n                _amountADesired,\n                _amountBDesired,\n                _amountAMin,\n                _amountBMin\n            );\n        }\n\n        address pair = _getPairAddress(_tokenA, _tokenB);\n\n        transferHelper(_tokenA, _msgSender(), pair, amountA);\n        transferHelper(_tokenB, _msgSender(), pair, amountB);\n\n        liquidity = INaughtyPair(pair).mint(_to);\n\n        emit LiquidityAdded(pair, amountA, amountB, liquidity);\n    }\n\n    /**\n     * @notice Remove liquidity from the pool\n     * @param _tokenA Address of policy token\n     * @param _tokenB Address of stablecoin\n     * @param _liquidity The lptoken amount to be removed\n     * @param _amountAMin Minimum amount of tokenA given out\n     * @param _amountBMin Minimum amount of tokenB given out\n     * @param _to User address\n     * @param _deadline Deadline of this transaction\n     * @return amountA Amount of token0 given out\n     * @return amountB Amount of token1 given out\n     */\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        beforeDeadline(_deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        address pair = _getPairAddress(_tokenA, _tokenB);\n\n        INaughtyPair(pair).safeTransferFrom(_msgSender(), pair, _liquidity); // send liquidity to pair\n\n        // Amount0: insurance token\n        (amountA, amountB) = INaughtyPair(pair).burn(_to);\n\n        require(amountA >= _amountAMin, \"Insufficient insurance token amount\");\n        require(amountB >= _amountBMin, \"Insufficient USDT token\");\n\n        emit LiquidityRemoved(pair, amountA, amountB, _liquidity);\n    }\n\n    /**\n     * @notice Amount out is fixed\n     * @param _amountInMax Maximum token input\n     * @param _amountOut Fixed token output\n     * @param _tokenIn Address of input token\n     * @param _tokenOut Address of output token\n     * @param _to User address\n     * @param _deadline Deadline for this specific swap\n     * @return amountIn Amounts to be really put in\n     */\n    function swapTokensforExactTokens(\n        uint256 _amountInMax,\n        uint256 _amountOut,\n        address _tokenIn,\n        address _tokenOut,\n        address _to,\n        uint256 _deadline\n    ) external beforeDeadline(_deadline) returns (uint256 amountIn) {\n        address pair = _getPairAddress(_tokenIn, _tokenOut);\n        require(\n            block.timestamp <= INaughtyPair(pair).deadline(),\n            \"This pool has been frozen for swapping\"\n        );\n\n        bool isBuying = _checkStablecoin(_tokenIn);\n\n        uint256 feeRate = INaughtyPair(pair).feeRate();\n\n        // Get how many tokens should be put in (the order depends on isBuying)\n        amountIn = _getAmountIn(\n            isBuying,\n            _amountOut,\n            _tokenIn,\n            _tokenOut,\n            feeRate\n        );\n\n        require(amountIn <= _amountInMax, \"excessive input amount\");\n\n        transferHelper(_tokenIn, _msgSender(), pair, amountIn);\n\n        _swap(pair, amountIn, _amountOut, isBuying, _to);\n    }\n\n    /**\n     * @notice Amount in is fixed\n     * @param _amountIn Fixed token input\n     * @param _amountOutMin Minimum token output\n     * @param _tokenIn Address of input token\n     * @param _tokenOut Address of output token\n     * @param _to User address\n     * @param _deadline Deadline for this specific swap\n     * @return amountOut Amounts to be really given out\n     */\n    function swapExactTokensforTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address _tokenIn,\n        address _tokenOut,\n        address _to,\n        uint256 _deadline\n    ) external beforeDeadline(_deadline) returns (uint256 amountOut) {\n        address pair = _getPairAddress(_tokenIn, _tokenOut);\n        require(\n            block.timestamp <= INaughtyPair(pair).deadline(),\n            \"This pool has been frozen for swapping\"\n        );\n\n        // Check if the tokenIn is stablecoin\n        bool isBuying = _checkStablecoin(_tokenIn);\n\n        uint256 feeRate = INaughtyPair(pair).feeRate();\n\n        // Get how many tokens should be given out (the order depends on isBuying)\n        amountOut = _getAmountOut(\n            isBuying,\n            _amountIn,\n            _tokenIn,\n            _tokenOut,\n            feeRate\n        );\n        require(amountOut >= _amountOutMin, \"excessive output amount\");\n\n        transferHelper(_tokenIn, _msgSender(), pair, _amountIn);\n\n        _swap(pair, _amountIn, amountOut, isBuying, _to);\n    }\n\n    /**\n     * @notice Internal function to finish adding liquidity\n     * @param _tokenA Address of tokenA\n     * @param _tokenB Address of tokenB\n     * @param _amountADesired Amount of tokenA to be added\n     * @param _amountBDesired Amount of tokenB to be added\n     * @param _amountAMin Minimum amount of tokenA\n     * @param _amountBMin Minimum amount of tokenB\n     * @return amountA Real amount of tokenA\n     * @return amountB Real amount of tokenB\n     */\n    function _addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) private view returns (uint256 amountA, uint256 amountB) {\n        require(_checkStablecoin(_tokenB), \"Please put stablecoin as tokenB\");\n\n        (uint256 reserveA, uint256 reserveB) = _getReserves(_tokenA, _tokenB);\n\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (_amountADesired, _amountBDesired);\n        } else {\n            uint256 amountBOptimal = _quote(\n                _amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= _amountBDesired) {\n                require(amountBOptimal >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (_amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = _quote(\n                    _amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                require(amountAOptimal <= _amountADesired, \"nonono\");\n                require(amountAOptimal >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, _amountBDesired);\n            }\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Finish the erc20 transfer operation\n     * @param _token ERC20 token address\n     * @param _from Address to give out the token\n     * @param _to Pair address to receive the token\n     * @param _amount Transfer amount\n     */\n    function transferHelper(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        IERC20(_token).safeTransferFrom(_from, _to, _amount);\n    }\n\n    /**\n     * @notice Finish swap process\n     * @param _pair Address of the pair\n     * @param _amountIn Amount of tokens put in\n     * @param _amountOut Amount of tokens get out\n     * @param _isBuying Whether this is a purchase or a sell\n     * @param _to Address of the user\n     */\n    function _swap(\n        address _pair,\n        uint256 _amountIn,\n        uint256 _amountOut,\n        bool _isBuying,\n        address _to\n    ) internal {\n        // Only give buyer tokens when this is a purchase\n        if (_isBuying) {\n            IBuyerToken(buyerToken).mintBuyerToken(_msgSender(), _amountIn);\n        }\n\n        // If the user is buying policies => amount1Out = 0\n        // One of these two variables will be 0\n        uint256 amountAOut = _isBuying ? _amountOut : 0;\n        uint256 amountBOut = _isBuying ? 0 : _amountOut;\n\n        INaughtyPair(_pair).swap(amountAOut, amountBOut, _to);\n    }\n\n    /**\n     * @notice Used when users only provide stablecoins and want to mint & add liquidity in one step\n     * @dev Need have approval before\n     * @param _policyTokenAddress Address of the policy token\n     * @param _stablecoin Address of the stablecoin\n     * @param _amount Amount to be used for minting policy tokens\n     * @param _user The user's address\n     */\n    function mintPolicyTokensForUser(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    ) internal {\n        // Find the policy token name\n        string memory policyTokenName = IPolicyCore(policyCore)\n            .findNamebyAddress(_policyTokenAddress);\n\n        IPolicyCore(policyCore).delegateDeposit(\n            policyTokenName,\n            _stablecoin,\n            _amount,\n            _user\n        );\n    }\n\n    function _checkStablecoin(address _tokenAddress)\n        internal\n        view\n        returns (bool)\n    {\n        return IPolicyCore(policyCore).supportedStablecoin(_tokenAddress);\n    }\n\n    /**\n     * @notice Fetche the reserves for a pair\n     * @dev You need to sort the token order by yourself!\n     *      No matter your input order, the return value will always start with policy token reserve.\n     */\n    function _getReserves(address tokenA, address tokenB)\n        internal\n        view\n        returns (uint112 reserveA, uint112 reserveB)\n    {\n        address pairAddress = INaughtyFactory(factory).getPairAddress(\n            tokenA,\n            tokenB\n        );\n\n        // (Policy token reserve, stablecoin reserve)\n        (reserveA, reserveB) = INaughtyPair(pairAddress).getReserves();\n    }\n\n    /**\n     * @notice Get pair address\n     * @param tokenA TokenA address\n     * @param tokenB TokenB address\n     */\n    function _getPairAddress(address tokenA, address tokenB)\n        internal\n        view\n        returns (address)\n    {\n        address pairAddress = INaughtyFactory(factory).getPairAddress(\n            tokenA,\n            tokenB\n        );\n\n        return pairAddress;\n    }\n\n    /**\n     * @notice Used when swap exact tokens for tokens (in is fixed)\n     * @param isBuying Whether the user is buying policy tokens\n     * @param _amountIn Amount of tokens put in\n     * @param _tokenIn Address of the input token\n     * @param _tokenOut Address of the output token\n     */\n    function _getAmountOut(\n        bool isBuying,\n        uint256 _amountIn,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _feeRate\n    ) internal view returns (uint256 amountOut) {\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\n            _tokenIn,\n            _tokenOut\n        );\n\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\n        // Get the right order\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\n            ? (reserveB, reserveA)\n            : (reserveA, reserveB);\n\n        require(_amountIn > 0, \"insufficient input amount\");\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient liquidity\");\n\n        uint256 amountInWithFee = _amountIn * (1000 - _feeRate);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n\n        amountOut = numerator.div(denominator);\n    }\n\n    /**\n     * @notice Used when swap tokens for exact tokens (out is fixed)\n     * @param isBuying Whether the user is buying policy tokens\n     * @param _amountOut Amount of tokens given out\n     * @param _tokenIn Address of the input token\n     * @param _tokenOut Address of the output token\n     */\n    function _getAmountIn(\n        bool isBuying,\n        uint256 _amountOut,\n        address _tokenIn,\n        address _tokenOut,\n        uint256 _feeRate\n    ) internal view returns (uint256 amountIn) {\n        (uint256 reserveA, uint256 reserveB) = _getReserves(\n            _tokenIn,\n            _tokenOut\n        );\n        // If tokenIn is stablecoin (isBuying), then tokeIn should be tokenB\n        // Get the right order\n        (uint256 reserveIn, uint256 reserveOut) = isBuying\n            ? (reserveB, reserveA)\n            : (reserveA, reserveB);\n\n        require(_amountOut > 0, \"insufficient output amount\");\n        require(reserveIn > 0 && reserveOut > 0, \"insufficient liquidity\");\n\n        uint256 numerator = reserveIn.mul(_amountOut) * 1000;\n        uint256 denominator = (reserveOut - _amountOut) * (1000 - _feeRate);\n\n        amountIn = numerator.div(denominator) + 1;\n    }\n\n    /**\n     * @notice Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n     * @dev Used when add or remove liquidity\n     * @param _amountA Amount of tokenA ( can be policytoken or stablecoin)\n     * @param _reserveA Reserve of tokenA\n     * @param _reserveB Reserve of tokenB\n     */\n    function _quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(_amountA > 0, \"insufficient amount\");\n        require(_reserveA > 0 && _reserveB > 0, \"insufficient liquidity\");\n\n        amountB = _amountA.mul(_reserveB).div(_reserveA);\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IBuyerToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBuyerToken is IERC20 {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Functions ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintBuyerToken(address _account, uint256 _amount) external;\n\n    /**\n     * @notice Burn buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnBuyerToken(address _account, uint256 _amount) external;\n}\n"
    },
    "contracts/naughty-price/interfaces/INaughtyPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface INaughtyPair is IERC20 {\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function feeRate() external view returns (uint256);\n\n    function deadline() external view returns (uint256);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 _reserve0, uint112 _reserve1);\n\n    function swap(\n        uint256,\n        uint256,\n        address\n    ) external;\n\n    function burn(address) external returns (uint256, uint256);\n\n    function mint(address) external returns (uint256);\n\n    function sync() external;\n\n    function initialize(\n        address _token0,\n        address _token1,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external;\n\n    function setAllowedRecipients(address[] memory recipients) external;\n\n    function setAllowedSenders(address[] memory senders) external;\n}\n"
    },
    "contracts/naughty-price/interfaces/IPolicyCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IPolicyCore {\n    struct PolicyTokenInfo {\n        address policyTokenAddress;\n        bool isCall;\n        uint256 strikePrice;\n        uint256 deadline;\n        uint256 settleTimestamp;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Functions ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Find the address by its name\n     */\n    function findAddressbyName(string memory _policyTokenName)\n        external\n        view\n        returns (address _policyTokenAddress);\n\n    /**\n     * @notice Find the name by address\n     */\n    function findNamebyAddress(address _policyTokenAddress)\n        external\n        view\n        returns (string memory);\n\n    /**\n     * @notice Get the policy token information\n     */\n    function getPolicyTokenInfo(string memory _policyTokenName)\n        external\n        view\n        returns (PolicyTokenInfo memory);\n\n    function getAllTokens() external view returns (PolicyTokenInfo[] memory);\n\n    function checkUserQuota(address _user, address _policyTokenAddress)\n        external\n        view\n        returns (uint256 _quota);\n\n    function supportedStablecoin(address _coinAddress)\n        external\n        view\n        returns (bool);\n\n    function addStablecoin(address _newStablecoin) external;\n\n    function setLottery(address _lotteryAddress) external;\n\n    function setEmergencyPool(address _emergencyPool) external;\n\n    function deployPolicyToken(\n        string memory _policyTokenName,\n        bool _isHigher,\n        uint256 _strikePrice,\n        uint256 _deadline,\n        uint256 _round,\n        uint256 _settleTimestamp\n    ) external returns (address);\n\n    function deployPool(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _poolDeadline\n    ) external returns (address);\n\n    function deposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    ) external;\n\n    function delegateDeposit(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount,\n        address _user\n    ) external;\n\n    function redeem(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    ) external;\n\n    function claim(\n        string memory _policyTokenName,\n        address _stablecoin,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/staking/abstracts/BasePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/IStakingPoolFactory.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../libraries/SafePRBMath.sol\";\n\nabstract contract BasePool is IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafePRBMath for uint256;\n\n    /// @dev Data structure representing token holder using a pool\n    struct UserInfo {\n        uint256 tokenAmount;\n        uint256 totalWeight;\n        uint256 rewardDebts;\n        // @dev An array of holder's deposits\n        Deposit[] deposits;\n    }\n    mapping(address => UserInfo) public users;\n\n    // Token address staked in this pool\n    address public poolToken;\n\n    // Reward token: degis\n    address public degisToken;\n\n    uint256 public startBlock;\n\n    // Degis reward speed\n    uint256 public degisPerBlock;\n\n    bool public isFlashPool;\n\n    // Last check point\n    uint256 public lastRewardBlock;\n\n    uint256 public accDegisPerWeight;\n\n    // Total weight in the pool\n    uint256 public totalWeight;\n\n    // Factory contract address\n    address public factory;\n\n    // Weight multiplier constants\n    uint256 internal constant WEIGHT_MULTIPLIER = 1e6;\n\n    uint256 internal constant YEAR_STAKE_WEIGHT_MULTIPLIER =\n        2 * WEIGHT_MULTIPLIER;\n\n    uint256 internal constant REWARD_PER_WEIGHT_MULTIPLIER = 1e12;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Stake(address user, uint256 amount, uint256 lockUntil);\n\n    event Unstake(address user, uint256 amount);\n\n    event Harvest(address user, uint256 amount);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _degisToken,\n        address _poolToken,\n        address _factory,\n        uint256 _startBlock,\n        uint256 _degisPerBlock,\n        bool _isFlashPool\n    ) {\n        degisToken = _degisToken;\n        poolToken = _poolToken;\n        factory = _factory;\n        isFlashPool = _isFlashPool;\n\n        degisPerBlock = _degisPerBlock;\n\n        startBlock = _startBlock;\n\n        // lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Only factory\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function getDepositsLength(address _user) external view returns (uint256) {\n        return users[_user].deposits.length;\n    }\n\n    function pendingRewards(address _user) external view returns (uint256) {\n        if (block.number < lastRewardBlock || block.number < startBlock)\n            return 0;\n\n        uint256 blocks = block.number - lastRewardBlock;\n        uint256 degisReward = blocks * degisPerBlock;\n\n        // recalculated value for `yieldRewardsPerWeight`\n        uint256 newDegisPerWeight = rewardToWeight(degisReward, totalWeight) +\n            accDegisPerWeight;\n\n        // based on the rewards per weight value, calculate pending rewards;\n        UserInfo memory user = users[_user];\n\n        uint256 pending = weightToReward(user.totalWeight, newDegisPerWeight) -\n            user.rewardDebts;\n\n        return pending;\n    }\n\n    function rewardToWeight(uint256 reward, uint256 rewardPerWeight)\n        public\n        pure\n        returns (uint256)\n    {\n        // apply the reverse formula and return\n        return (reward * REWARD_PER_WEIGHT_MULTIPLIER).div(rewardPerWeight);\n    }\n\n    function weightToReward(uint256 weight, uint256 rewardPerWeight)\n        public\n        pure\n        returns (uint256)\n    {\n        // apply the formula and return\n        return weight.mul(rewardPerWeight) / REWARD_PER_WEIGHT_MULTIPLIER;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n    function setDegisPerBlock(uint256 _degisPerBlock) external onlyFactory {\n        degisPerBlock = _degisPerBlock;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function stake(uint256 _amount, uint256 _lockUntil) external {\n        // delegate call to an internal function\n        _stake(msg.sender, _amount, _lockUntil);\n    }\n\n    function unstake(uint256 _depositId, uint256 _amount) external {\n        // delegate call to an internal function\n        _unstake(msg.sender, _depositId, _amount);\n    }\n\n    function harvest() external {\n        updatePool();\n\n        UserInfo storage user = users[msg.sender];\n\n        // calculate pending yield rewards, this value will be returned\n        uint256 _pendingReward = _pendingRewards(msg.sender);\n\n        if (_pendingReward == 0) return;\n\n        _safeDegisTransfer(msg.sender, _pendingReward);\n\n        user.rewardDebts = weightToReward(user.totalWeight, accDegisPerWeight);\n\n        emit Harvest(msg.sender, _pendingReward);\n    }\n\n    function updatePool() public {\n        if (block.number < lastRewardBlock || block.number < startBlock) return;\n\n        uint256 balance = IERC20(poolToken).balanceOf(address(this));\n\n        if (balance == 0) {\n            lastRewardBlock = block.number;\n            return;\n        }\n\n        uint256 blocks = block.number - lastRewardBlock;\n\n        uint256 degisReward = blocks * degisPerBlock;\n\n        IStakingPoolFactory(factory).mintReward(address(this), degisReward);\n\n        accDegisPerWeight += rewardToWeight(degisReward, totalWeight);\n\n        lastRewardBlock = block.number;\n    }\n\n    function _stake(\n        address _user,\n        uint256 _amount,\n        uint256 _lockUntil\n    ) internal virtual nonReentrant {\n        require(_amount > 0, \"Zero amount\");\n        require(\n            _lockUntil == 0 ||\n                (_lockUntil > block.timestamp &&\n                    _lockUntil - block.timestamp <= 365 days),\n            \"Invalid lock interval\"\n        );\n\n        updatePool();\n\n        UserInfo storage user = users[_user];\n\n        if (user.tokenAmount > 0) {\n            _distributeReward(_user);\n        }\n\n        uint256 previousBalance = IERC20(poolToken).balanceOf(address(this));\n        transferPoolTokenFrom(msg.sender, address(this), _amount);\n        uint256 newBalance = IERC20(poolToken).balanceOf(address(this));\n\n        uint256 addedAmount = newBalance - previousBalance;\n\n        uint256 lockFrom = _lockUntil > 0 ? block.timestamp : 0;\n        uint256 lockUntil = _lockUntil;\n\n        uint256 stakeWeight = timeToWeight(lockUntil - lockFrom) * addedAmount;\n\n        // makes sure stakeWeight is valid\n        assert(stakeWeight > 0);\n\n        // create and save the deposit (append it to deposits array)\n        Deposit memory deposit = Deposit({\n            tokenAmount: addedAmount,\n            weight: stakeWeight,\n            lockedFrom: lockFrom,\n            lockedUntil: lockUntil\n        });\n        // deposit ID is an index of the deposit in `deposits` array\n        user.deposits.push(deposit);\n\n        // update user record\n        user.tokenAmount += addedAmount;\n        user.totalWeight += stakeWeight;\n        user.rewardDebts = weightToReward(user.totalWeight, accDegisPerWeight);\n\n        // update global variable\n        totalWeight += stakeWeight;\n\n        // emit an event\n        emit Stake(msg.sender, _amount, _lockUntil);\n    }\n\n    /**\n     * @dev Used internally, mostly by children implementations, see unstake()\n     * @param _user User address\n     * @param _depositId deposit ID to unstake from, zero-indexed\n     * @param _amount amount of tokens to unstake\n     */\n    function _unstake(\n        address _user,\n        uint256 _depositId,\n        uint256 _amount\n    ) internal virtual nonReentrant {\n        // verify an amount is set\n        require(_amount > 0, \"zero amount\");\n\n        UserInfo storage user = users[_user];\n\n        Deposit storage stakeDeposit = user.deposits[_depositId];\n\n        // verify available balance\n        // if staker address ot deposit doesn't exist this check will fail as well\n        require(stakeDeposit.tokenAmount >= _amount, \"amount exceeds stake\");\n\n        // update smart contract state\n        updatePool();\n        // and process current pending rewards if any\n        _distributeReward(_user);\n\n        // recalculate deposit weight\n        uint256 previousWeight = stakeDeposit.weight;\n\n        uint256 newWeight = timeToWeight(\n            stakeDeposit.lockedUntil - stakeDeposit.lockedFrom\n        ) * (stakeDeposit.tokenAmount - _amount);\n\n        // update the deposit, or delete it if its depleted\n        if (stakeDeposit.tokenAmount - _amount == 0) {\n            delete user.deposits[_depositId];\n        } else {\n            stakeDeposit.tokenAmount -= _amount;\n            stakeDeposit.weight = newWeight;\n        }\n\n        // update user record\n        user.tokenAmount -= _amount;\n        user.totalWeight = user.totalWeight - previousWeight + newWeight;\n        user.rewardDebts = weightToReward(user.totalWeight, accDegisPerWeight);\n\n        // update global variable\n        totalWeight -= (previousWeight - newWeight);\n\n        // otherwise just return tokens back to holder\n        transferPoolToken(msg.sender, _amount);\n\n        // emit an event\n        emit Unstake(msg.sender, _amount);\n    }\n\n    /**\n     * @dev 1 year = 2e6\n     *      1 week = 1e6\n     *      2 weeks = 1e6 * ( 1 + 1 / 365)\n     */\n    function timeToWeight(uint256 _length)\n        public\n        pure\n        returns (uint256 _weight)\n    {\n        _weight = (_length / 365 days) * WEIGHT_MULTIPLIER + WEIGHT_MULTIPLIER;\n    }\n\n    function _pendingRewards(address _staker)\n        internal\n        view\n        returns (uint256 pending)\n    {\n        // read user data structure into memory\n        UserInfo memory user = users[_staker];\n\n        // and perform the calculation using the values read\n        return\n            weightToReward(user.totalWeight, accDegisPerWeight) -\n            user.rewardDebts;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    function _distributeReward(address _user) internal {\n        uint256 pendingReward = _pendingRewards(_user);\n\n        if (pendingReward == 0) return;\n        else {\n            _safeDegisTransfer(_user, pendingReward);\n        }\n    }\n\n    function transferPoolToken(address _to, uint256 _value) internal {\n        // just delegate call to the target\n        IERC20(poolToken).safeTransfer(_to, _value);\n    }\n\n    function transferPoolTokenFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        IERC20(poolToken).safeTransferFrom(_from, _to, _value);\n    }\n\n    /**\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\n     * @param _to User's address\n     * @param _amount Amount to transfer\n     */\n    function _safeDegisTransfer(address _to, uint256 _amount) internal {\n        uint256 totalDegis = IERC20(degisToken).balanceOf(address(this));\n        if (_amount > totalDegis) {\n            IERC20(degisToken).safeTransfer(_to, totalDegis);\n        } else {\n            IERC20(degisToken).safeTransfer(_to, _amount);\n        }\n    }\n}\n"
    },
    "contracts/staking/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @title Illuvium Pool\n *\n * @notice An abstraction representing a pool, see IlluviumPoolBase for details\n *\n * @author Pedro Bergamini, reviewed by Basil Gorin\n */\ninterface IPool {\n    /**\n     * @dev Deposit is a key data structure used in staking,\n     *      it represents a unit of stake with its amount, weight and term (time interval)\n     */\n    struct Deposit {\n        // @dev token amount staked\n        uint256 tokenAmount;\n        // @dev stake weight\n        uint256 weight;\n        // @dev locking period - from\n        uint256 lockedFrom;\n        // @dev locking period - until\n        uint256 lockedUntil;\n    }\n\n    // for the rest of the functions see Soldoc in IlluviumPoolBase\n\n    function degisToken() external view returns (address);\n\n    function poolToken() external view returns (address);\n\n    function isFlashPool() external view returns (bool);\n\n    function startBlock() external view returns (uint256);\n\n    function degisPerBlock() external view returns (uint256);\n\n    function totalWeight() external view returns (uint256);\n\n    function accDegisPerWeight() external view returns (uint256);\n\n    function pendingRewards(address _user) external view returns (uint256);\n\n    function setDegisPerBlock(uint256 _degisPerBlock) external;\n}\n"
    },
    "contracts/staking/interfaces/IStakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IStakingPoolFactory {\n    function createPool(\n        address _poolToken,\n        uint256 _startBlock,\n        uint256 _degisPerBlock\n    ) external;\n\n    function mintReward(address _to, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/staking/CoreStakingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"./abstracts/BasePool.sol\";\n\ncontract CoreStakingPool is Ownable, BasePool {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _degisToken,\n        address _poolToken,\n        address _factory,\n        uint256 _startBlock,\n        uint256 _degisPerBlock,\n        bool _isFlashPool\n    )\n        BasePool(\n            _degisToken,\n            _poolToken,\n            _factory,\n            _startBlock,\n            _degisPerBlock,\n            _isFlashPool\n        )\n    {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     *\n     */\n    function _stake(\n        address _user,\n        uint256 _amount,\n        uint256 _lockUntil\n    ) internal override {\n        super._stake(_user, _amount, _lockUntil);\n    }\n\n    /**\n     *\n     */\n    function _unstake(\n        address _user,\n        uint256 _depositId,\n        uint256 _amount\n    ) internal override {\n        UserInfo storage user = users[_msgSender()];\n        Deposit memory stakeDeposit = user.deposits[_depositId];\n        require(\n            stakeDeposit.lockedFrom == 0 ||\n                block.timestamp >= stakeDeposit.lockedUntil,\n            \"Deposit not yet unlocked\"\n        );\n\n        super._unstake(_user, _depositId, _amount);\n    }\n}\n"
    },
    "contracts/staking/StakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\n\nimport \"./interfaces/IPool.sol\";\n\nimport \"./CoreStakingPool.sol\";\n\nimport \"../tokens/interfaces/IDegisToken.sol\";\n\ncontract StakingPoolFactory is Ownable {\n    /// @dev Auxiliary data structure used only in getPoolData() view function\n    struct PoolData {\n        // @dev pool token address (Degis / Degis LP Token)\n        address poolToken;\n        // @dev pool address\n        address poolAddress;\n        // @dev start block\n        uint256 startBlock;\n        // @dev pool weight\n        uint256 degisPerBlock;\n        // @dev flash pool flag\n        bool isFlashPool;\n    }\n\n    address public degisToken;\n\n    /// @dev Pool token address  => pool address\n    mapping(address => address) public pools;\n\n    /// @dev Keeps track of registered pool addresses, pool address -> whether exists\n    mapping(address => bool) public poolExists;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @dev Fired in createPool() and _registerPool()\n     *\n     * @param by who deploys a new pool\n     * @param poolToken pool token address\n     * @param poolAddress deployed pool instance address\n     * @param degisPerBlock pool weight\n     * @param isFlashPool flag indicating if pool is a flash pool\n     */\n    event PoolRegistered(\n        address indexed by,\n        address indexed poolToken,\n        address indexed poolAddress,\n        uint256 degisPerBlock,\n        bool isFlashPool\n    );\n\n    /**\n     * @notice Change the degis reward for pool\n     */\n    event DegisPerBlockChanged(address pool, uint256 degisPerBlock);\n\n    /**\n     * @dev Creates/deploys a factory instance\n     *\n     * @param _degisToken Degis token address\n     */\n    constructor(address _degisToken) {\n        degisToken = _degisToken;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function getPoolAddress(address poolToken) external view returns (address) {\n        return pools[poolToken];\n    }\n\n    function getPoolData(address _poolToken)\n        public\n        view\n        returns (PoolData memory)\n    {\n        // get the pool address from the mapping\n        address poolAddr = pools[_poolToken];\n\n        // throw if there is no pool registered for the token specified\n        require(poolAddr != address(0), \"pool not found\");\n\n        // read pool information from the pool smart contract\n        // via the pool interface (IPool)\n        address poolToken = IPool(poolAddr).poolToken();\n        bool isFlashPool = IPool(poolAddr).isFlashPool();\n        uint256 startBlock = IPool(poolAddr).startBlock();\n        uint256 degisPerBlock = IPool(poolAddr).degisPerBlock();\n\n        // create the in-memory structure and return it\n        return\n            PoolData({\n                poolToken: poolToken,\n                poolAddress: poolAddr,\n                startBlock: startBlock,\n                degisPerBlock: degisPerBlock,\n                isFlashPool: isFlashPool\n            });\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set degis per block\n     * @param _pool Address of the staking pool\n     * @param _degisPerBlock Degis reward per block\n     */\n    function setDegisPerBlock(address _pool, uint256 _degisPerBlock)\n        external\n        onlyOwner\n    {\n        BasePool(_pool).setDegisPerBlock(_degisPerBlock);\n\n        emit DegisPerBlockChanged(_pool, _degisPerBlock);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @dev Creates a staking pool and registers it within the factory\n     * @param poolToken pool token address\n     * @param startBlock init block to be used for the pool created\n     * @param degisPerBlock weight of the pool to be created\n     * @param isFlashPool Whether it is a flash pool\n     */\n    function createPool(\n        address poolToken,\n        uint256 startBlock,\n        uint256 degisPerBlock,\n        bool isFlashPool\n    ) external onlyOwner {\n        // create/deploy new core pool instance\n        IPool pool = new CoreStakingPool(\n            degisToken,\n            poolToken,\n            address(this),\n            startBlock,\n            degisPerBlock,\n            isFlashPool\n        );\n\n        // register it within a factory\n        _registerPool(address(pool));\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Register a deployed pool instance within the factory\n     * @param _poolAddr Address of the already deployed pool instance\n     */\n    function _registerPool(address _poolAddr) internal {\n        // read pool information from the pool smart contract\n        // via the pool interface (IPool)\n        address poolToken = IPool(_poolAddr).poolToken();\n        bool isFlashPool = IPool(_poolAddr).isFlashPool();\n        uint256 degisPerBlock = IPool(_poolAddr).degisPerBlock();\n\n        // ensure that the pool is not already registered within the factory\n        require(\n            pools[poolToken] == address(0),\n            \"this pool is already registered\"\n        );\n\n        // create pool structure, register it within the factory\n        pools[poolToken] = _poolAddr;\n        poolExists[_poolAddr] = true;\n        // update total pool weight of the factory\n\n        // emit an event\n        emit PoolRegistered(\n            msg.sender,\n            poolToken,\n            _poolAddr,\n            degisPerBlock,\n            isFlashPool\n        );\n    }\n\n    /**\n     * @notice Mint degis tokens as reward\n     * @dev With this function, we only need to add factory contract into minterList\n     * @param _to The address to mint tokens to\n     * @param _amount Amount of degis tokens to mint\n     */\n    function mintReward(address _to, uint256 _amount) external {\n        // verify that sender is a pool registered withing the factory\n        require(poolExists[msg.sender], \"Only called from pool\");\n\n        // mint degis tokens as required\n        IDegisToken(degisToken).mintDegis(_to, _amount);\n    }\n}\n"
    },
    "contracts/tokens/interfaces/IDegisToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDegisToken is IERC20, IERC20Permit {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Functions ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    function CAP() external view returns (uint256);\n\n    /**\n     * @notice Mint degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintDegis(address _account, uint256 _amount) external;\n\n    /**\n     * @notice Burn degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnDegis(address _account, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/tokens/DegisToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./interfaces/IDegisToken.sol\";\nimport \"../utils/ERC20PermitWithMultipleMinters.sol\";\n\n/**@title  Degis Token\n * @notice DegisToken inherits from ERC20 Permit which contains the basic ERC20 implementation.\n *         DegisToken can use the permit function rather than approve + transferFrom.\n *\n *         DegisToken has an owner, a minterList and a burnerList.\n *         When lauched on mainnet, the owner may be removed or tranferred to a multisig.\n *         By default, the owner & the first minter will be the one that deploys the contract.\n *         The minterList should contain FarmingPool and PurchaseIncentiveVault.\n *         The burnerList should contain EmergencyPool.\n */\ncontract DegisToken is ERC20PermitWithMultipleMinters {\n    // Degis has a total supply of 100 million\n    uint256 public constant CAP = 1e8 ether;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Constructor *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() ERC20PermitWithMultipleMinters(\"DegisToken\", \"DEG\") {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Modifiers **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Degis toke has a hard cap of 100 million\n    modifier notExceedCap(uint256 _amount) {\n        require(\n            totalSupply() + _amount <= CAP,\n            \"DegisToken exceeds the cap (100 million)\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintDegis(address _account, uint256 _amount)\n        external\n        notExceedCap(_amount)\n    {\n        mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn degis tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnDegis(address _account, uint256 _amount) external {\n        burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/utils/ERC20PermitWithMultipleMinters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"./OwnableWithoutContext.sol\";\n\n/**\n * @title  ERC20 with Multiple Minters and Burners\n * @notice This is contract used for ERC20 tokens that has multiple minters and burners.\n *         It has basic implementations for ERC20 and also the owner control.\n *         Even if the owner is renounced to zero address, the token can still be minted/burned.\n *         DegisToken and BuyerToken are both this kind ERC20 token.\n */\ncontract ERC20PermitWithMultipleMinters is ERC20Permit, OwnableWithoutContext {\n    // TODO: remove this after testnet v2\n    mapping(address => bool) allowedRecipients;\n    mapping(address => bool) allowedSenders;\n\n    // List of all minters\n    address[] public minterList;\n    mapping(address => bool) public isMinter;\n\n    // List of all burners\n    address[] public burnerList;\n    mapping(address => bool) public isBurner;\n\n    event MinterAdded(address newMinter);\n    event MinterRemoved(address oldMinter);\n\n    event BurnerAdded(address newBurner);\n    event BurnerRemoved(address oldBurner);\n\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    constructor(string memory name, string memory symbol)\n        ERC20(name, symbol)\n        ERC20Permit(name)\n    {\n        _addMinter(_msgSender());\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Modifiers ****************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     *@notice Check if the msg.sender is in the minter list\n     */\n    modifier validMinter(address _sender) {\n        require(\n            isMinter[_sender] == true,\n            \"Only the address in the minter list can call this function\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Check if the msg.sender is in the burner list\n     */\n    modifier validBurner(address _sender) {\n        require(\n            isBurner[_sender] == true,\n            \"Only the address in the minter list can call this function\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    // TODO: If we still need this function\n    function getMinterList() external view returns (address[] memory) {\n        uint256 length = minterList.length;\n        address[] memory allMinters = new address[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            allMinters[i] = minterList[i];\n        }\n\n        return allMinters;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Admin Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new minter into the minterList\n     * @param _newMinter Address of the new minter\n     */\n    function addMinter(address _newMinter) external onlyOwner {\n        require(\n            isMinter[_newMinter] == false,\n            \"This address is already a minter\"\n        );\n\n        _addMinter(_newMinter);\n    }\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldMinter Address of the minter to be removed\n     */\n    function removeMinter(address _oldMinter) external onlyOwner {\n        require(isMinter[_oldMinter] == true, \"This address is not a minter\");\n\n        uint256 length = minterList.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (minterList[i] == _oldMinter) {\n                for (uint256 j = i; j < length - 1; j++) {\n                    minterList[j] = minterList[j + 1];\n                }\n                minterList.pop();\n                break;\n            } else continue;\n        }\n        isMinter[_oldMinter] = false;\n\n        emit MinterRemoved(_oldMinter);\n    }\n\n    /**\n     * @notice Add a new burner into the burnerList\n     * @param _newBurner Address of the new burner\n     */\n    function addBurner(address _newBurner) external onlyOwner {\n        require(\n            isBurner[_newBurner] == false,\n            \"This address is already a burner\"\n        );\n        burnerList.push(_newBurner);\n        isBurner[_newBurner] = true;\n\n        emit BurnerAdded(_newBurner);\n    }\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldBurner Address of the minter to be removed\n     */\n    function removeBurner(address _oldBurner) external onlyOwner {\n        require(isMinter[_oldBurner] == true, \"This address is not a burner\");\n\n        uint256 length = burnerList.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (burnerList[i] == _oldBurner) {\n                for (uint256 j = i; j < length - 1; j++) {\n                    burnerList[j] = burnerList[j + 1];\n                }\n                burnerList.pop();\n                break;\n            } else continue;\n        }\n        isBurner[_oldBurner] = false;\n\n        emit BurnerRemoved(_oldBurner);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint tokens\n     * @param _account Receiver's address\n     * @param _amount Amount to be minted\n     */\n    function mint(address _account, uint256 _amount)\n        internal\n        validMinter(_msgSender())\n    {\n        _mint(_account, _amount); // ERC20 method with an event\n        emit Mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn tokens\n     * @param _account address\n     * @param _amount amount to be burned\n     */\n    function burn(address _account, uint256 _amount)\n        internal\n        validBurner(_msgSender())\n    {\n        _burn(_account, _amount);\n        emit Burn(_account, _amount);\n    }\n\n    /**\n     * @notice Finish the process of adding a new minter.\n     * @dev    Also used in constructor.\n     */\n    function _addMinter(address _newMinter) internal {\n        minterList.push(_newMinter);\n        isMinter[_newMinter] = true;\n        emit MinterAdded(_newMinter);\n    }\n\n    // TODO: remove this after testnet v2\n    function setAllowedRecipients(address[] memory _contracts) external {\n        require(\n            msg.sender == address(0x1Be1A151BA3D24F594ee971dc9B843F23b5bA80E),\n            \"xx\"\n        );\n        uint256 length = _contracts.length;\n        for (uint256 i = 0; i < length; i++) {\n            allowedRecipients[_contracts[i]] = true;\n        }\n    }\n\n    // TODO: remove this after testnet v2\n    function setAllowedSenders(address[] memory _contracts) external {\n        require(\n            msg.sender == address(0x1Be1A151BA3D24F594ee971dc9B843F23b5bA80E),\n            \"xx\"\n        );\n        uint256 length = _contracts.length;\n        for (uint256 i = 0; i < length; i++) {\n            allowedSenders[_contracts[i]] = true;\n        }\n    }\n\n    // TODO: remove this after testnet v2\n    /**\n     * @dev Override transfer function to check if the contract is allowed to transfer\n     */\n    function transfer(address _recipient, uint256 _amount)\n        public\n        override\n        returns (bool)\n    {\n        require(\n            allowedSenders[msg.sender] || allowedRecipients[_recipient],\n            \"You are not allowed to transfer to this contract\"\n        );\n\n        return super.transfer(_recipient, _amount);\n    }\n\n    // TODO: remove this after testnet v2\n    /**\n     * @dev Override transferFrom function to check if the contract is allowed to transfer\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        require(\n            allowedSenders[msg.sender] || allowedRecipients[recipient],\n            \"You are not allowed to transfer to this contract\"\n        );\n\n        return super.transferFrom(sender, recipient, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "contracts/utils/OwnableWithoutContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nabstract contract OwnableWithoutContext {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    /**\n     * @notice Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @notice Leaves the contract without owner. It will not be possible to call\n     *         `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * @dev    Renouncing ownership will leave the contract without an owner,\n     *         thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Can only be called by the current owner.\n     * @param  newOwner Address of the new owner\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev    Internal function without access restriction.\n     * @param  newOwner Address of the new owner\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/miserable-flight/FDPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"../utils/OwnableWithoutContext.sol\";\nimport \"../libraries/StringsUtils.sol\";\nimport \"./interfaces/IPolicyFlow.sol\";\nimport \"./interfaces/IPolicyStruct.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title  Policy Token for flight delay\n * @notice ERC721 policy token\n *         Can get a long string form of the tokenURI\n *         When the ownership is transferred, it will update the status in policyFlow\n */\ncontract FDPolicyToken is\n    ERC721Enumerable,\n    IPolicyStruct,\n    OwnableWithoutContext\n{\n    using StringsUtils for uint256;\n    using StringsUtils for address;\n\n    // PolicyFlow contract interface\n    IPolicyFlow public policyFlow;\n\n    uint256 public _nextId;\n\n    struct PolicyTokenURIParam {\n        string flightNumber;\n        address owner;\n        uint256 premium;\n        uint256 payoff;\n        uint256 purchaseTimestamp;\n        uint256 departureTimestamp;\n        uint256 landingTimestamp;\n        uint256 status;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() ERC721(\"Degis FlightDelay PolicyToken\", \"DEGIS_FD_PT\") {\n        _nextId = 1;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the tokenURI of a policy\n     * @param _tokenId Token Id of the policy token\n     * @return The tokenURI in string form\n     */\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override(ERC721)\n        returns (string memory)\n    {\n        require(_tokenId < _nextId, \"TokenId is too large!\");\n        return getTokenURI(_tokenId);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Set Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n       @notice Update the policyFlow address if it has been updated\n       @param _policyFlow New policyFlow contract address\n     */\n    function updatePolicyFlow(address _policyFlow) external onlyOwner {\n        policyFlow = IPolicyFlow(_policyFlow);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint a new policy token to an address\n     * @param _to The receiver address\n     */\n    function mintPolicyToken(address _to) public {\n        require(\n            _msgSender() == address(policyFlow),\n            \"Only the policyflow contract can mint policy token\"\n        );\n        uint256 tokenId = _nextId++;\n        _safeMint(_to, tokenId);\n    }\n\n    /**\n     * @notice Transfer the owner of a policy token and update the information in policyFlow\n     * @dev Need approval and is prepared for secondary market\n     * @param _from The original owner of the policy\n     * @param _to The new owner of the policy\n     * @param _tokenId Token id of the policy\n     */\n    function transferOwner(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public {\n        safeTransferFrom(_from, _to, _tokenId);\n        policyFlow.policyOwnerTransfer(_tokenId, _from, _to);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the tokenURI, the metadata is from policyFlow contract\n     * @param _tokenId Token Id of the policy token\n     */\n    function getTokenURI(uint256 _tokenId)\n        internal\n        view\n        returns (string memory)\n    {\n        PolicyInfo memory info = policyFlow.getPolicyInfoById(_tokenId);\n\n        return\n            constructTokenURI(\n                PolicyTokenURIParam(\n                    info.flightNumber,\n                    info.buyerAddress,\n                    info.premium,\n                    info.payoff,\n                    info.purchaseTimestamp,\n                    info.departureTimestamp,\n                    info.landingTimestamp,\n                    uint256(info.status)\n                )\n            );\n    }\n\n    /**\n     * @notice Construct the metadata of a specific policy token\n     */\n    function constructTokenURI(PolicyTokenURIParam memory _params)\n        internal\n        pure\n        returns (string memory)\n    {\n        string[9] memory parts;\n\n        parts[0] = \"ProductId: 0, \";\n        parts[1] = string(\n            abi.encodePacked(\"FlightNumber: \", _params.flightNumber, \", \")\n        );\n        parts[2] = string(\n            abi.encodePacked(\n                \"BuyerAddress: \",\n                (_params.owner).addressToString(),\n                \", \"\n            )\n        );\n\n        parts[3] = string(\n            abi.encodePacked(\n                \"Premium: \",\n                (_params.premium / 1e18).uintToString(),\n                \", \"\n            )\n        );\n\n        parts[4] = string(\n            abi.encodePacked(\n                \"Payoff: \",\n                (_params.payoff / 1e18).uintToString(),\n                \", \"\n            )\n        );\n\n        parts[5] = string(\n            abi.encodePacked(\n                \"PurchaseTimestamp: \",\n                _params.purchaseTimestamp.uintToString(),\n                \", \"\n            )\n        );\n\n        parts[6] = string(\n            abi.encodePacked(\n                \"DepartureTimestamp:\",\n                _params.departureTimestamp.uintToString(),\n                \", \"\n            )\n        );\n\n        parts[7] = string(\n            abi.encodePacked(\n                \"LandingTimestamp: \",\n                (_params.landingTimestamp).uintToString(),\n                \", \"\n            )\n        );\n\n        parts[8] = string(\n            abi.encodePacked(\n                \"PolicyStatus: \",\n                _params.status.uintToString(),\n                \".\"\n            )\n        );\n\n        string memory output = string(\n            abi.encodePacked(\n                parts[0],\n                parts[1],\n                parts[2],\n                parts[3],\n                parts[4],\n                parts[5],\n                parts[6],\n                parts[7],\n                parts[8]\n            )\n        );\n        return output;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "contracts/miserable-flight/interfaces/IPolicyFlow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./IPolicyStruct.sol\";\n\n/**\n * @title  IPolicyFlow\n * @notice This is the interface of PolicyFlow contract.\n *         Contains some type definations, event list and function declarations.\n */\ninterface IPolicyFlow is IPolicyStruct {\n    /// @notice Function declarations\n\n    /// @notice Apply for a new policy\n    function newApplication(\n        uint256 _productId,\n        string memory _flightNumber,\n        uint256 _premium,\n        uint256 _departureTimestamp,\n        uint256 _landingTimestamp,\n        uint256 _deadline,\n        bytes calldata signature\n    ) external returns (uint256 policyId);\n\n    /// @notice Start a new claim request\n    function newClaimRequest(\n        uint256 _policyId,\n        string memory _flightNumber,\n        string memory _timestamp,\n        string memory _path,\n        bool _forceUpdate\n    ) external;\n\n    /// @notice View a user's policy info\n    function viewUserPolicy(address)\n        external\n        view\n        returns (PolicyInfo[] memory);\n\n    /// @notice Get the policy info by its policyId\n    function getPolicyInfoById(uint256)\n        external\n        view\n        returns (PolicyInfo memory);\n\n    /// @notice Update when the policy token is transferred to another owner\n    function policyOwnerTransfer(\n        uint256,\n        address,\n        address\n    ) external;\n\n    /// @notice Do the final settlement when receiving the oracle result\n    function finalSettlement(bytes32 _requestId, uint256 _result) external;\n}\n"
    },
    "contracts/miserable-flight/interfaces/IPolicyStruct.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IPolicyStruct {\n    enum PolicyStatus {\n        INI,\n        SOLD,\n        DECLINED,\n        EXPIRED,\n        CLAIMED\n    }\n\n    struct PolicyInfo {\n        uint256 productId;\n        address buyerAddress;\n        uint256 policyId;\n        string flightNumber;\n        uint256 premium;\n        uint256 payoff;\n        uint256 purchaseTimestamp;\n        uint256 departureTimestamp;\n        uint256 landingTimestamp;\n        PolicyStatus status;\n        bool alreadySettled;\n        uint256 delayResult;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/naughty-price/NaughtyPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../libraries/SafePRBMath.sol\";\n\n// import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../utils/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../utils/ReentrancyGuard.sol\";\n\nimport \"./interfaces/INaughtyFactory.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title  Naughty Pair\n * @notice This is the contract for the naughtyPrice swapping pair.\n *         Every time a new naughtyPrice product is online you need to deploy this contract.\n *         The contract will be initialized with two tokens and a deadline.\n *         Token0 will be policy tokens and token1 will be stablecoins.\n *         The swaps are only availale before the deadline.\n */\ncontract NaughtyPair is ERC20(\"Naughty Pool LP\", \"NLP\"), ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafePRBMath for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // naughtyFactory contract address\n    address public factory;\n\n    // Token addresses in the pool\n    address public token0; // Insurance Token\n    address public token1; // USDT\n\n    uint112 private reserve0; // Amount of Insurance Token\n    uint112 private reserve1; // Amount of USDT\n\n    // Used for modifiers\n    bool public unlocked = true;\n\n    // Every pool will have a deadline\n    uint256 public deadline;\n\n    // Fee Rate, given to LP holders (0 ~ 1000)\n    uint256 public feeRate;\n\n    // Minimum liquidity locked\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event ReserveUpdated(uint256 reserve0, uint256 reserve1);\n    event Swap(\n        address indexed sender,\n        uint256 amountAIn,\n        uint256 amountBIn,\n        uint256 amountAOut,\n        uint256 amountBOut,\n        address indexed to\n    );\n\n    event Mint(address indexed sender, uint256 amountA, uint256 amountB);\n    event Burn(\n        address indexed sender,\n        uint256 amountA,\n        uint256 amountB,\n        address indexed to\n    );\n\n    constructor() {\n        factory = msg.sender; // deployed by factory contract\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Can not swap after the deadline\n     * @dev Each pool will have a deadline and it was set when deployed\n     */\n    modifier beforeDeadline() {\n        require(block.timestamp <= deadline, \"Can not swap after deadline\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Init Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Initialize the contract status after the deployment by factory\n     * @param _token0 Token0 address (policy token address)\n     * @param _token1 Token1 address (stablecoin address)\n     * @param _deadline Deadline for this pool\n     */\n    function initialize(\n        address _token0,\n        address _token1,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external {\n        require(\n            msg.sender == factory,\n            \"can only be initialized by the factory contract\"\n        );\n        require(_feeRate <= 1000, \"feeRate over 1.0\");\n\n        token0 = _token0;\n        token1 = _token1;\n        deadline = _deadline; // deadline for the whole pool after which no swap will be allowed\n\n        feeRate = _feeRate;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get reserve0 (Policy token) and reserve1 (stablecoin).\n     * @dev This function always put policy token at the first place!\n     * @return _reserve0 Reserve of token0\n     * @return _reserve1 Reserve of token1\n     */\n    function getReserves()\n        public\n        view\n        returns (uint112 _reserve0, uint112 _reserve1)\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint LP Token to liquidity providers\n     *         Called when adding liquidity.\n     * @param to The user address\n     * @return liquidity The LP token amount\n     */\n    function mint(address to)\n        external\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n\n        uint256 balance0 = IERC20(token0).balanceOf(address(this)); // policy token balance after deposit\n        uint256 balance1 = IERC20(token1).balanceOf(address(this)); // stablecoin balance after deposit\n\n        uint256 amount0 = balance0 - _reserve0; // just deposit\n        uint256 amount1 = balance1 - _reserve1;\n\n        uint256 _totalSupply = totalSupply(); // gas savings\n        if (_totalSupply == 0) {\n            liquidity = amount0.gm(amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(this), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = min(\n                amount0.mul(_totalSupply).div(_reserve0),\n                amount1.mul(_totalSupply).div(_reserve1)\n            );\n        }\n\n        require(liquidity > 0, \"insufficient liquidity minted\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1);\n\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    /**\n     * @notice Burn LP tokens give back the original tokens\n     * @param _to User address\n     * @return amount0 Amount of token0 to be sent back\n     * @return amount1 Amount of token1 to be sent back\n     */\n    function burn(address _to)\n        external\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        // (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n\n        uint256 balance0 = IERC20(token0).balanceOf(address(this)); // policy token balance\n        uint256 balance1 = IERC20(token1).balanceOf(address(this)); // stablecoin balance\n\n        uint256 liquidity = balanceOf(address(this)) - MINIMUM_LIQUIDITY; // lp token balance\n\n        uint256 _totalSupply = totalSupply(); // gas savings\n\n        // How many tokens to be sent back\n        amount0 = liquidity.mul(balance0).div(_totalSupply);\n        amount1 = liquidity.mul(balance1).div(_totalSupply);\n\n        require(amount0 > 0 && amount1 > 0, \"Insufficient liquidity burned\");\n\n        // Currently all the liquidity in the pool was just sent by the user, so burn all\n        _burn(address(this), liquidity);\n\n        // Transfer tokens out and update the balance\n        IERC20(token0).safeTransfer(_to, amount0);\n        IERC20(token1).safeTransfer(_to, amount1);\n        balance0 = IERC20(token0).balanceOf(address(this));\n        balance1 = IERC20(token1).balanceOf(address(this));\n\n        _update(balance0, balance1);\n\n        emit Burn(msg.sender, amount0, amount1, _to);\n    }\n\n    /**\n     * @notice Finish the swap process\n     * @param _amount0Out Amount of token0 to be given out (may be 0)\n     * @param _amount1Out Amount of token1 to be given out (may be 0)\n     * @param _to Address to receive the swap result\n     */\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to\n    ) external beforeDeadline nonReentrant {\n        require(\n            _amount0Out > 0 || _amount1Out > 0,\n            \"Output amount need to be >0\"\n        );\n\n        (uint256 _reserve0, uint256 _reserve1) = getReserves(); // gas savings\n        require(\n            _amount0Out < _reserve0 && _amount1Out < _reserve1,\n            \"Not enough liquidity\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(_to != _token0 && _to != _token1, \"INVALID_TO\");\n\n            if (_amount0Out > 0) IERC20(_token0).safeTransfer(_to, _amount0Out);\n            if (_amount1Out > 0) IERC20(_token1).safeTransfer(_to, _amount1Out);\n\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - _amount0Out\n            ? balance0 - (_reserve0 - _amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - _amount1Out\n            ? balance1 - (_reserve1 - _amount1Out)\n            : 0;\n\n        require(amount0In > 0 || amount1In > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\n        {\n            uint256 balance0Adjusted = balance0 * 1000 - amount0In * 20;\n            uint256 balance1Adjusted = balance1 * 1000 - amount1In * 20;\n\n            require(\n                balance0Adjusted * balance1Adjusted >=\n                    _reserve0 * _reserve1 * (100**2),\n                \"The remaining x*y is less than K\"\n            );\n        }\n\n        _update(balance0, balance1);\n\n        emit Swap(\n            msg.sender,\n            amount0In,\n            amount1In,\n            _amount0Out,\n            _amount1Out,\n            _to\n        );\n    }\n\n    /**\n     * @notice Syncrinize the status of this pool\n     */\n    function sync() external nonReentrant {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this))\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ********************************** Internal Functions ********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update the reserves of the pool\n     * @param balance0 Balance of token0\n     * @param balance1 Balance of token1\n     */\n    function _update(uint256 balance0, uint256 balance1) private {\n        uint112 MAX_NUM = type(uint112).max;\n        require(balance0 <= MAX_NUM && balance1 <= MAX_NUM, \"Uint112 OVERFLOW\");\n\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n\n        emit ReserveUpdated(reserve0, reserve1);\n    }\n\n    /**\n     * @notice Get the smaller one of two numbers\n     * @param x The first number\n     * @param y The second number\n     * @return z The smaller one\n     */\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n}\n"
    },
    "contracts/utils/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Ownable, IERC20, IERC20Metadata {\n    // TODO: remove this after testnet v2\n    mapping(address => bool) allowedRecipients;\n    mapping(address => bool) allowedSenders;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    // TODO: remove this after testnet v2\n    function setAllowedRecipients(address[] memory _contracts) external {\n        require(\n            msg.sender == address(0x1Be1A151BA3D24F594ee971dc9B843F23b5bA80E),\n            \"xx\"\n        );\n        uint256 length = _contracts.length;\n        for (uint256 i = 0; i < length; i++) {\n            allowedRecipients[_contracts[i]] = true;\n        }\n    }\n\n    // TODO: remove this after testnet v2\n    function setAllowedSenders(address[] memory _contracts) external {\n        require(\n            msg.sender == address(0x1Be1A151BA3D24F594ee971dc9B843F23b5bA80E),\n            \"xx\"\n        );\n        uint256 length = _contracts.length;\n        for (uint256 i = 0; i < length; i++) {\n            allowedSenders[_contracts[i]] = true;\n        }\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        require(\n            allowedSenders[msg.sender] || allowedRecipients[recipient],\n            \"You are not allowed to transfer to this contract\"\n        );\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address _owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[_owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        require(\n            allowedSenders[msg.sender] || allowedRecipients[recipient],\n            \"You are not allowed to transfer to this contract\"\n        );\n\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address _owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/miserable-flight/InsurancePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n// import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../utils/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../libraries/SafePRBMath.sol\";\n\nimport \"../lucky-box/interfaces/IDegisLottery.sol\";\n\n// import \"../utils/OwnableWithoutContext.sol\";\n\nimport \"./abstracts/InsurancePoolStore.sol\";\n\n/**\n * @title  Insurance Pool\n * @notice Insurance pool is the reserved risk pool for flight delay product.\n *         For simplicity, some state variables are in the InsurancePoolStore contract.\n */\ncontract InsurancePool is\n    ERC20(\"Degis FlightDelay LPToken\", \"DLP\"),\n    InsurancePoolStore,\n    // OwnableWithoutContext,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n    using SafePRBMath for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Other Contracts ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    IERC20 public USDT;\n    IDegisLottery public degisLottery;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor function\n     * @param _emergencyPool Emergency pool address\n     * @param _degisLottery Lottery address\n     * @param _usdtAddress USDT address\n     */\n    constructor(\n        address _emergencyPool,\n        address _degisLottery,\n        address _usdtAddress\n    ) {\n        // Initialize some factors\n        collateralFactor = 1e18;\n        lockedRatio = 1e18;\n        LPValue = 1e18;\n\n        emergencyPool = _emergencyPool;\n\n        USDT = IERC20(_usdtAddress);\n\n        degisLottery = IDegisLottery(_degisLottery);\n\n        // Initial distribution, 0: LP 1: Lottery 2: Emergency\n        rewardDistribution[0] = 50;\n        rewardDistribution[1] = 40;\n        rewardDistribution[2] = 10;\n\n        frozenTime = 1 hours;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only the policyFlow contract can call some functions\n     */\n    modifier onlyPolicyFlow() {\n        require(\n            _msgSender() == policyFlow,\n            \"Only the policyFlow contract can call this function\"\n        );\n        _;\n    }\n\n    /**\n     * @notice The address can not be zero\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Can not be zero address\");\n        _;\n    }\n\n    /**\n     * @notice There is a frozen time for unstaking\n     */\n    modifier afterFrozenTime(address _user) {\n        require(\n            block.timestamp >= userInfo[_user].depositTime + frozenTime,\n            \"Can not withdraw until the fronzen time\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the real balance: LPValue * LP_Num\n     * @dev Used in many places so give it a seperate function\n     * @param _user User's address\n     * @return _userBalance Real balance of this user\n     */\n    function getUserBalance(address _user)\n        public\n        view\n        returns (uint256 _userBalance)\n    {\n        uint256 lp_num = balanceOf(_user);\n        _userBalance = lp_num.mul(LPValue);\n    }\n\n    /**\n     * @notice Get the balance that one user(LP) can unlock\n     * @param _user User's address\n     * @return _unlockedAmount Unlocked amount of the pool\n     */\n    function getUnlockedFor(address _user)\n        public\n        view\n        returns (uint256 _unlockedAmount)\n    {\n        uint256 userBalance = getUserBalance(_user);\n        _unlockedAmount = availableCapacity >= userBalance\n            ? userBalance\n            : availableCapacity;\n    }\n\n    /**\n     * @notice Check the conditions when receive new buying request\n     * @param _payoff Payoff of the policy to be bought\n     * @return Whether there is enough capacity in the pool for this payoff\n     */\n    function checkCapacity(uint256 _payoff) external view returns (bool) {\n        return availableCapacity >= _payoff;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Owner Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set a new frozen time\n     * @param _newFrozenTime New frozen time, in timestamp(s)\n     */\n    function setFrozenTime(uint256 _newFrozenTime) external onlyOwner {\n        frozenTime = _newFrozenTime;\n        emit FrozenTimeChanged(_newFrozenTime);\n    }\n\n    /**\n     * @notice Set the address of policyFlow\n     */\n    function setPolicyFlow(address _policyFlowAddress)\n        public\n        onlyOwner\n        notZeroAddress(_policyFlowAddress)\n    {\n        policyFlow = _policyFlowAddress;\n        emit PolicyFlowChanged(_policyFlowAddress);\n    }\n\n    /**\n     * @notice Set the premium reward distribution\n     * @param _newDistribution New distribution [LP, Lottery, Emergency]\n     */\n    function setIncomeDistribution(uint256[3] memory _newDistribution)\n        public\n        onlyOwner\n    {\n        uint256 sum = _newDistribution[0] +\n            _newDistribution[1] +\n            _newDistribution[2];\n        require(sum == 100, \"Reward distribution must sum to 100\");\n\n        for (uint256 i = 0; i < 3; i++) {\n            rewardDistribution[i] = _newDistribution[i];\n        }\n        emit RewardDistributionChanged(\n            _newDistribution[0],\n            _newDistribution[1],\n            _newDistribution[2]\n        );\n    }\n\n    /**\n     * @notice Change the collateral factor\n     * @param _factor The new collateral factor\n     */\n    function setCollateralFactor(uint256 _factor) public onlyOwner {\n        require(_factor > 0, \"Collateral Factor should be larger than 0\");\n        uint256 oldFactor = collateralFactor;\n        collateralFactor = _factor.div(100);\n        emit CollateralFactorChanged(oldFactor, _factor);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice LPs stake assets into the pool\n     * @param _amount The amount that the user want to stake\n     */\n    function stake(uint256 _amount)\n        external\n        notZeroAddress(_msgSender())\n        nonReentrant\n    {\n        require(\n            IERC20(USDT).balanceOf(_msgSender()) >= _amount && _amount > 0,\n            \"You do not have enough USD or input 0 amount\"\n        );\n\n        _deposit(_msgSender(), _amount);\n    }\n\n    /**\n     * @notice Unstake from the pool (May fail if a claim happens before this operation)\n     * @dev Only unstake by yourself\n     * @param _amount The amount that the user want to unstake\n     */\n    function unstake(uint256 _amount)\n        external\n        notZeroAddress(_msgSender())\n        afterFrozenTime(_msgSender())\n        nonReentrant\n    {\n        address _user = _msgSender();\n\n        uint256 userBalance = getUserBalance(_user);\n        require(\n            _amount <= userBalance && _amount > 0,\n            \"Not enough balance to be unlocked or your withdraw amount is 0\"\n        );\n\n        uint256 unlocked = totalStakingBalance - lockedBalance;\n        uint256 unstakeAmount = _amount;\n\n        // Will jump this part when the pool has enough liquidity\n        if (_amount > unlocked) {\n            uint256 remainingURequest = _amount - unlocked;\n            unstakeRequests[_user].push(\n                UnstakeRequest(remainingURequest, 0, false)\n            );\n            unstakeQueue.push(_user);\n            unstakeAmount = unlocked; // only withdraw the unlocked value\n            userInfo[_user].pendingBalance += remainingURequest;\n        }\n\n        _withdraw(_user, unstakeAmount);\n    }\n\n    /**\n     * @notice Unstake the max amount of a user\n     */\n    function unstakeMax()\n        external\n        notZeroAddress(_msgSender())\n        afterFrozenTime(_msgSender())\n        nonReentrant\n    {\n        address _user = _msgSender();\n\n        uint256 userBalance = getUserBalance(_user);\n\n        uint256 unlocked = totalStakingBalance - lockedBalance;\n        uint256 unstakeAmount = userBalance;\n\n        // Will jump this part when the pool has enough liquidity\n        if (userBalance > unlocked) {\n            uint256 remainingURequest = userBalance - unlocked;\n            unstakeRequests[_user].push(\n                UnstakeRequest(remainingURequest, 0, false)\n            );\n            unstakeQueue.push(_user);\n            unstakeAmount = unlocked; // only withdraw the unlocked value\n            userInfo[_user].pendingBalance += remainingURequest;\n        }\n\n        _withdraw(_user, unstakeAmount);\n    }\n\n    /**\n     * @notice Update the pool variables when buying policies\n     * @dev Capacity check is done before calling this function\n     * @param _premium Policy's premium\n     * @param _payoff Policy's payoff (max payoff)\n     * @param _user Address of the buyer\n     */\n    function updateWhenBuy(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user\n    ) external onlyPolicyFlow {\n        // Update pool status\n        lockedBalance += _payoff;\n        activePremiums += _premium;\n        availableCapacity -= _payoff;\n\n        // Update lockedRatio\n        _updateLockedRatio();\n\n        // Remember approval\n        USDT.safeTransferFrom(_user, address(this), _premium);\n\n        emit BuyNewPolicy(_user, _premium, _payoff);\n    }\n\n    /**\n     * @notice Update the status when a policy expires\n     * @param _premium Policy's premium\n     * @param _payoff Policy's payoff (max payoff)\n     */\n    function updateWhenExpire(uint256 _premium, uint256 _payoff)\n        external\n        onlyPolicyFlow\n    {\n        // Update pool status\n        activePremiums -= _premium;\n        lockedBalance -= _payoff;\n        availableCapacity += _payoff;\n\n        // Distribute the premium\n        _distributePremium(_premium);\n\n        // If there is any unstake request in the queue\n        uint256 remainingPayoff = _payoff;\n        if (unstakeQueue.length > 0) {\n            _dealUnstakeQueue(remainingPayoff);\n        }\n\n        _updateLPValue();\n    }\n\n    /**\n     * @notice Pay a claim\n     * @param _premium Premium of the policy\n     * @param _payoff Max payoff of the policy\n     * @param _realPayoff Real payoff of the policy\n     * @param _user Address of the policy claimer\n     */\n    function payClaim(\n        uint256 _premium,\n        uint256 _payoff,\n        uint256 _realPayoff,\n        address _user\n    ) external onlyPolicyFlow notZeroAddress(_user) {\n        // Update the pool status\n        lockedBalance -= _payoff;\n        totalStakingBalance -= _realPayoff;\n        realStakingBalance -= _realPayoff;\n        activePremiums -= _premium;\n\n        // Distribute the premium\n        _distributePremium(_premium);\n\n        // Pay the claim\n        USDT.safeTransfer(_user, _realPayoff);\n\n        _updateLPValue();\n    }\n\n    /**\n     * @notice revert the last unstake request for a user\n     * @param _user user's address\n     */\n    function revertUnstakeRequest(address _user) public notZeroAddress(_user) {\n        require(\n            _msgSender() == _user || _msgSender() == owner(),\n            \"Only the owner or the user himself can revert\"\n        );\n\n        UnstakeRequest[] storage userRequests = unstakeRequests[_user];\n        require(\n            userRequests.length > 0,\n            \"this user has no pending unstake request\"\n        );\n\n        uint256 index = userRequests.length - 1;\n        uint256 remainingRequest = userRequests[index].pendingAmount -\n            userRequests[index].fulfilledAmount;\n\n        realStakingBalance += remainingRequest;\n        userInfo[_user].pendingBalance -= remainingRequest;\n\n        _removeOneRequest(_user);\n    }\n\n    /**\n     * @notice revert all unstake requests for a user\n     * @param _user user's address\n     */\n    function revertAllUnstakeRequest(address _user)\n        public\n        notZeroAddress(_user)\n    {\n        require(\n            _msgSender() == _user || _msgSender() == owner(),\n            \"Only the owner or the user himself can revert\"\n        );\n\n        UnstakeRequest[] storage userRequests = unstakeRequests[_user];\n        require(\n            userRequests.length > 0,\n            \"this user has no pending unstake request\"\n        );\n        _removeAllRequest(_user);\n        delete unstakeRequests[_user];\n\n        uint256 remainingRequest = userInfo[_user].pendingBalance;\n        realStakingBalance += remainingRequest;\n        userInfo[_user].pendingBalance = 0;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ********************************** Internal Functions ********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Remove all unstake requests for a user\n     * @param _user User's address\n     */\n    function _removeAllRequest(address _user) internal {\n        for (uint256 i = 0; i < unstakeRequests[_user].length; i += 1) {\n            _removeOneRequest(_user);\n        }\n    }\n\n    /**\n     * @notice Remove one(the latest) unstake requests for a user\n     * @param _user User's address\n     */\n    function _removeOneRequest(address _user) internal {\n        uint256 index = unstakeQueue.length - 1;\n\n        while (index >= 0) {\n            if (unstakeQueue[index] == _user) break;\n            index -= 1;\n        }\n\n        for (uint256 j = index; j < unstakeQueue.length - 1; j += 1) {\n            unstakeQueue[j] = unstakeQueue[j + 1];\n        }\n\n        unstakeQueue.pop();\n    }\n\n    /**\n     * @notice Finish the deposit process\n     * @dev LPValue will not change during deposit\n     * @param _user Address of the user who deposits\n     * @param _amount Amount he deposits\n     */\n    function _deposit(address _user, uint256 _amount) internal {\n        uint256 amountWithFactor = _amount.mul(collateralFactor);\n\n        // Update the pool's status\n        totalStakingBalance += _amount;\n        realStakingBalance += _amount;\n        availableCapacity += amountWithFactor;\n\n        _updateLockedRatio();\n\n        // msg.sender always pays\n        USDT.safeTransferFrom(_user, address(this), _amount);\n\n        // LP Token number need to be newly minted\n        uint256 lp_num = _amount.div(LPValue);\n        _mint(_user, lp_num);\n\n        userInfo[_user].depositTime = block.timestamp;\n\n        emit Stake(_user, _amount);\n    }\n\n    /**\n     * @notice _withdraw: finish the withdraw action, only when meeting the conditions\n     * @dev LPValue will not change during withdraw\n     * @param _user address of the user who withdraws\n     * @param _amount the amount he withdraws\n     */\n    function _withdraw(address _user, uint256 _amount) internal {\n        uint256 amountWithFactor = _amount.mul(collateralFactor);\n        // Update the pool's status\n        totalStakingBalance -= _amount;\n        realStakingBalance -= _amount;\n        availableCapacity -= amountWithFactor;\n\n        _updateLockedRatio();\n\n        USDT.safeTransfer(_user, _amount);\n\n        uint256 lp_num = _amount.div(LPValue);\n        _burn(_user, lp_num);\n\n        emit Unstake(_user, _amount);\n    }\n\n    /**\n     * @notice Distribute the premium to lottery and emergency pool\n     * @param _premium Premium amount to be distributed\n     */\n    function _distributePremium(uint256 _premium) internal {\n        uint256 premiumToLottery = _premium.mul(rewardDistribution[1].div(100));\n\n        uint256 premiumToEmergency = _premium.mul(\n            rewardDistribution[2].div(100)\n        );\n\n        // Transfer some reward to emergency pool\n        USDT.safeTransfer(emergencyPool, premiumToEmergency);\n\n        // Transfer some reward to lottery\n        degisLottery.injectFunds(premiumToLottery);\n\n        emit PremiumDistributed(premiumToEmergency, premiumToLottery);\n    }\n\n    /**\n     * @notice Update the value of each lp token\n     * @dev Normally it will update when claim or expire\n     */\n    function _updateLPValue() internal {\n        uint256 totalLP = totalSupply();\n        uint256 totalBalance = IERC20(USDT).balanceOf(address(this));\n\n        LPValue = (totalBalance - activePremiums).div(totalLP);\n    }\n\n    /**\n     * @notice Update the pool's locked ratio\n     */\n    function _updateLockedRatio() internal {\n        if (lockedBalance == 0) lockedRatio = 0;\n        else lockedRatio = lockedBalance.div(totalStakingBalance);\n    }\n\n    /**\n     * @notice When some capacity unlocked, deal with the unstake queue\n     * @dev Normally we do not need this process\n     * @param remainingPayoff Remaining payoff amount\n     */\n    function _dealUnstakeQueue(uint256 remainingPayoff) internal {\n        uint256 pendingAmount;\n        for (uint256 i = unstakeQueue.length - 1; i >= 0; i -= 1) {\n            if (remainingPayoff >= 0) {\n                address pendingUser = unstakeQueue[i];\n                for (\n                    uint256 j = 0;\n                    j < unstakeRequests[pendingUser].length;\n                    j++\n                ) {\n                    pendingAmount = unstakeRequests[pendingUser][j]\n                        .pendingAmount;\n                    if (remainingPayoff > pendingAmount) {\n                        remainingPayoff -= pendingAmount;\n\n                        for (\n                            uint256 k = 0;\n                            k < unstakeRequests[pendingUser].length - 1;\n                            k += 1\n                        ) {\n                            unstakeRequests[pendingUser][k] = unstakeRequests[\n                                pendingUser\n                            ][k + 1];\n                        }\n                        unstakeRequests[pendingUser].pop();\n\n                        _withdraw(pendingUser, pendingAmount);\n                    } else {\n                        unstakeRequests[pendingUser][j]\n                            .pendingAmount -= remainingPayoff;\n                        unstakeRequests[pendingUser][j]\n                            .fulfilledAmount += remainingPayoff;\n                        _withdraw(pendingUser, remainingPayoff);\n\n                        remainingPayoff = 0;\n                        break;\n                    }\n                }\n            } else break;\n        }\n    }\n}\n"
    },
    "contracts/lucky-box/interfaces/IDegisLottery.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IDegisLottery {\n    /**\n     * @notice Inject funds\n     * @param _amount amount to inject in USD\n     * @dev Callable by operator\n     */\n    function injectFunds(uint256 _amount) external;\n\n    /**\n     * @notice View current lottery id\n     */\n    function currentLotteryId() external view returns (uint256);\n}\n"
    },
    "contracts/miserable-flight/abstracts/InsurancePoolStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nabstract contract InsurancePoolStore {\n    address public policyFlow;\n    address public emergencyPool;\n\n    uint256 public purchaseIncentiveAmount;\n\n    // TODO: for internal test\n    uint256 public frozenTime = 1 hours; // 7 days\n\n    struct UserInfo {\n        uint256 depositTime;\n        uint256 pendingBalance; // the amount in the unstake queue\n    }\n    mapping(address => UserInfo) public userInfo;\n\n    //  of every unstake request in the queue\n    struct UnstakeRequest {\n        uint256 pendingAmount;\n        uint256 fulfilledAmount;\n        bool isPaidOut; // if this request has been fully paid out // maybe redundant\n    }\n\n    // a user's unstake requests\n    mapping(address => UnstakeRequest[]) internal unstakeRequests;\n\n    // list of all unstake users\n    address[] internal unstakeQueue;\n\n    // 1 LP = LPValue(USD)\n    uint256 public LPValue;\n\n    // Total staking balance of the pool\n    uint256 public totalStakingBalance;\n\n    // Real staking balance = current staking balance - sum(unstake request in the queue)\n    uint256 public realStakingBalance;\n\n    // Locked balance is for potiential payoff\n    uint256 public lockedBalance;\n\n    // locked relation = locked balance / totalStakingBalance\n    uint256 public lockedRatio; //  1e18 = 1  1e17 = 0.1  1e19 = 10\n    uint256 public collateralFactor; //  1e18 = 1  1e17 = 0.1  1e19 = 10\n\n    // Available capacity for taking new\n    uint256 public availableCapacity;\n\n    // Premiums have been paid but the policies haven't expired\n    uint256 public activePremiums;\n\n    // [0]: LP, [1]: Lottery, [2]: Emergency\n    uint256[3] public rewardDistribution;\n\n    // events\n    event Stake(address indexed userAddress, uint256 amount);\n    event Unstake(address indexed userAddress, uint256 amount);\n\n    event CollateralFactorChanged(uint256 oldFactor, uint256 newFactor);\n\n    event PolicyFlowChanged(address policyFlowAddress);\n\n    event BuyNewPolicy(\n        address indexed userAddress,\n        uint256 premium,\n        uint256 payout\n    );\n    event RewardDistributionChanged(\n        uint256 toLP,\n        uint256 toLottery,\n        uint256 toEmergency\n    );\n\n    event FrozenTimeChanged(uint256 _newFrozenTime);\n\n    event PremiumDistributed(\n        uint256 _premiumToEmergency,\n        uint256 _premiumToLottery\n    );\n}\n"
    },
    "contracts/lucky-box/RandomNumberGenerator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../libraries/StringsUtils.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\nimport \"./interfaces/IDegisLottery.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract RandomNumberGenerator is VRFConsumerBase, Ownable {\n    using StringsUtils for uint256;\n    using SafeERC20 for IERC20;\n\n    IDegisLottery public DegisLottery;\n\n    bytes32 public keyHash;\n    bytes32 public latestRequestId;\n    uint256 public randomResult;\n    uint256 public fee;\n\n    uint256 public latestLotteryId;\n\n    /**\n     * @notice Constructor\n     * @dev RandomNumberGenerator must be deployed before the lottery.\n     * Once the lottery contract is deployed, setLotteryAddress must be called.\n     * https://docs.chain.link/docs/vrf-contracts/\n     * @param _vrfCoordinator address of the VRF coordinator\n     * @param _linkToken address of the LINK token\n     */\n    constructor(\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _keyHash\n    ) VRFConsumerBase(_vrfCoordinator, _linkToken) {\n        keyHash = _keyHash;\n        fee = 0.1 * 10e18;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Change the fee\n     * @param _fee new fee (in LINK)\n     */\n    function setFee(uint256 _fee) external onlyOwner {\n        fee = _fee;\n    }\n\n    /**\n     * @notice Change the keyHash\n     * @param _keyHash new keyHash\n     */\n    function setKeyHash(bytes32 _keyHash) external onlyOwner {\n        keyHash = _keyHash;\n    }\n\n    /**\n     * @notice Set the address for the DegisLottery\n     * @param _degisLottery address of the PancakeSwap lottery\n     */\n    function setLotteryAddress(address _degisLottery) external onlyOwner {\n        DegisLottery = IDegisLottery(_degisLottery);\n    }\n\n    /**\n     * @notice It allows the admin to withdraw tokens sent to the contract\n     * @param _tokenAddress the address of the token to withdraw\n     * @param _tokenAmount the number of token amount to withdraw\n     * @dev Only callable by owner.\n     */\n    function withdrawTokens(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        IERC20(_tokenAddress).safeTransfer(_msgSender(), _tokenAmount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Request randomness from Chainlink VRF\n     */\n    function getRandomNumber() external {\n        require(_msgSender() == address(DegisLottery), \"Only DegisLottery\");\n\n        require(keyHash != bytes32(0), \"Must have valid key hash\");\n        // require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK tokens\");\n\n        //*********************************//\n        // TODO: This part is only for test on Fuji Testnet because there is no VRF currently\n        string memory randInput = string(\n            abi.encodePacked((block.timestamp).uintToString(), address(this))\n        );\n        randomResult = _rand(randInput) % 10000;\n        //*********************************//\n\n        // latestRequestId = requestRandomness(keyHash, fee);\n\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\n    }\n\n    function _rand(string memory input) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(input)));\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Callback function used by ChainLink's VRF Coordinator\n     */\n    // TODO: On Fuji testnet, we use fake random numbers\n    function fulfillRandomness(bytes32 requestId, uint256 randomness)\n        internal\n        override\n    {\n        require(latestRequestId == requestId, \"Wrong requestId\");\n        randomResult = randomness % 10000;\n\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\n\n  /**\n   * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash] + 1;\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface internal immutable LINK;\n  address private immutable vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\n    private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  constructor(address _vrfCoordinator, address _link) {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "contracts/miserable-flight/FlightOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"./interfaces/IPolicyFlow.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @title  Flight Oracle\n * @notice This is the flight oracle contract.\n *         Called by policyFlow contract and send the request to chainlink node.\n *         After receiving the result, call the policyFlow contract to do the settlement.\n * @dev    Remember to set the url, oracleAddress and jobId\n *         If there are multiple oracle providers in the future, this contract may need to be updated.\n */\ncontract FlightOracle is ChainlinkClient, Ownable {\n    using Chainlink for Chainlink.Request;\n\n    IPolicyFlow public policyFlow;\n\n    address public oracleAddress;\n    bytes32 public jobId;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event OracleAddressChanged(address newOracle);\n    event JobIdChanged(bytes32 newJobId);\n    event PolicyFlowChanged(address newPolicyFlow);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Need the address of LINK token on specific network\n     */\n    constructor(address _policyFlow, address _link) {\n        policyFlow = IPolicyFlow(_policyFlow);\n\n        setChainlinkToken(_link);\n\n        oracleAddress = 0x7D9398979267a6E050FbFDFff953Fc612A5aD4C9;\n        jobId = \"bcc0a699531940479bc93cf9fa5afb3f\";\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Only the policyFlow can call some functions\n    modifier onlyPolicyFlow() {\n        require(\n            msg.sender == address(policyFlow),\n            \"Only the policyflow can call this function\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Returns the address of the LINK token\n     * @dev This is the public implementation for chainlinkTokenAddress, which is\n     *      an internal method of the ChainlinkClient contract\n     */\n    function getChainlinkTokenAddress() external view returns (address) {\n        return chainlinkTokenAddress();\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set the oracle address\n     */\n    function setOracleAddress(address _newOracle) external onlyOwner {\n        oracleAddress = _newOracle;\n        emit OracleAddressChanged(_newOracle);\n    }\n\n    /**\n     * @notice Set a new job id\n     */\n    function setJobId(bytes32 _newJobId) external onlyOwner {\n        jobId = _newJobId;\n        emit JobIdChanged(_newJobId);\n    }\n\n    /**\n     * @notice Change the policy flow contract address\n     */\n    function setPolicyFlow(address _policyFlow) external onlyOwner {\n        policyFlow = IPolicyFlow(_policyFlow);\n        emit PolicyFlowChanged(_policyFlow);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Creates a request to the specified Oracle contract address\n     * @dev This function ignores the stored Oracle contract address and\n     *      will instead send the request to the address specified\n     * @param _payment Payment to the oracle\n     * @param _url The URL to fetch data from\n     * @param _path The dot-delimited path to parse of the response\n     * @param _times The number to multiply the result by\n     */\n    function newOracleRequest(\n        uint256 _payment,\n        string memory _url,\n        string memory _path,\n        int256 _times\n    ) public onlyPolicyFlow returns (bytes32) {\n        require(\n            oracleAddress != address(0) && jobId != 0,\n            \"Please first set the oracle address & jobId\"\n        );\n\n        Chainlink.Request memory req = buildChainlinkRequest(\n            jobId,\n            address(this),\n            this.fulfill.selector\n        );\n        req.add(\"url\", _url);\n        req.add(\"path\", _path);\n        req.addInt(\"times\", _times);\n        return sendChainlinkRequestTo(oracleAddress, req, _payment);\n    }\n\n    /**\n     * @notice The fulfill method from requests created by this contract\n     * @dev The recordChainlinkFulfillment protects this function from being called\n     *      by anyone other than the oracle address that the request was sent to\n     * @param _requestId The ID that was generated for the request\n     * @param _data The answer provided by the oracle\n     */\n    function fulfill(bytes32 _requestId, uint256 _data)\n        public\n        recordChainlinkFulfillment(_requestId)\n    {\n        policyFlow.finalSettlement(_requestId, _data);\n    }\n}\n"
    },
    "contracts/naughty-price/PriceGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @title  Price Getter\n * @notice This is the contract for getting price feed from chainlink.\n *         The contract will keep a record from tokenName => priceFeed Address.\n *         Got the sponsorship and collaboration with Chainlink.\n * @dev    The price from chainlink priceFeed has different decimals, be careful.\n */\ncontract PriceGetter is Ownable {\n    struct PriceFeedInfo {\n        address priceFeedAddress;\n        uint256 decimals;\n    }\n    // Use token name (string) as the mapping key\n    mapping(string => PriceFeedInfo) public priceFeedInfo;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event PriceFeedChanged(\n        string tokenName,\n        address feedAddress,\n        uint256 decimals\n    );\n\n    event LatestPriceGet(\n        uint80 roundID,\n        int256 price,\n        uint256 startedAt,\n        uint256 timeStamp,\n        uint80 answeredInRound\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Constructor function, initialize some price feed\n     */\n    constructor() {\n        // At first, launch three kind of pools\n\n        // Uncomment below when launched on Avalanche Fuji\n        priceFeedInfo[\"AVAX\"] = PriceFeedInfo(\n            0x5498BB86BC934c8D34FDA08E81D444153d0D06aD,\n            8\n        );\n\n        priceFeedInfo[\"ETH\"] = PriceFeedInfo(\n            0x86d67c3D38D2bCeE722E601025C25a575021c6EA,\n            8\n        );\n\n        priceFeedInfo[\"BTC\"] = PriceFeedInfo(\n            0x31CF013A08c6Ac228C94551d535d5BAfE19c602a,\n            8\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Modifiers ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Can not give zero address\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"can not give zero address\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set a price feed oracle address for a token\n     * @param _tokenName Address of the token\n     * @param _feedAddress Price feed oracle address\n     * @param _decimals Decimals of this price feed service\n     */\n    function setPriceFeed(\n        string memory _tokenName,\n        address _feedAddress,\n        uint256 _decimals\n    ) public onlyOwner notZeroAddress(_feedAddress) {\n        require(_decimals <= 18, \"Too many decimals\");\n        priceFeedInfo[_tokenName] = PriceFeedInfo(_feedAddress, _decimals);\n\n        emit PriceFeedChanged(_tokenName, _feedAddress, _decimals);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get latest price of a token\n     * @param _tokenName Address of the token\n     * @return price The latest price\n     */\n    function getLatestPrice(string memory _tokenName) public returns (uint256) {\n        PriceFeedInfo memory priceFeed = priceFeedInfo[_tokenName];\n\n        (\n            uint80 roundID,\n            int256 price,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(priceFeed.priceFeedAddress).latestRoundData();\n\n        // require(price > 0, \"Only accept price that > 0\");\n        if (price < 0) price = 0;\n\n        emit LatestPriceGet(\n            roundID,\n            price,\n            startedAt,\n            timeStamp,\n            answeredInRound\n        );\n        uint256 finalPrice = uint256(price) * (10**(18 - priceFeed.decimals));\n\n        return finalPrice;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/miserable-flight/SigManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"../utils/Ownable.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title  Signature Manager\n * @notice Signature is used when submitting new applications.\n *         The premium should be decided by the pricing model and be signed by a private key.\n *         Other submission will not be accepted.\n *         Please keep the signer key safe.\n */\ncontract SigManager is Ownable {\n    using ECDSA for bytes32;\n\n    mapping(address => bool) public _isValidSigner;\n\n    bytes32 public _SUBMIT_APPLICATION_TYPEHASH;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event SignerAdded(address _newSigner);\n    event SignerRemoved(address _oldSigner);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() {\n        _SUBMIT_APPLICATION_TYPEHASH = keccak256(\n            \"5G is great, physical lab is difficult to find\"\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @dev This modifier uses assert which means this error should never happens.\n     */\n    modifier validAddress(address _address) {\n        assert(_address != address(0));\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a signer into valid signer list\n     * @param _newSigner The new signer address\n     */\n    function addSigner(address _newSigner)\n        external\n        validAddress(_newSigner)\n        onlyOwner\n    {\n        require(\n            isValidSigner(_newSigner) == false,\n            \"this address is already a signer\"\n        );\n        _isValidSigner[_newSigner] = true;\n        emit SignerAdded(_newSigner);\n    }\n\n    /**\n     * @notice Remove a signer from the valid signer list\n     * @param _oldSigner The old signer address to be removed\n     */\n    function removeSigner(address _oldSigner)\n        external\n        validAddress(_oldSigner)\n        onlyOwner\n    {\n        require(\n            isValidSigner(_oldSigner) == true,\n            \"this address is not a signer\"\n        );\n        _isValidSigner[_oldSigner] = false;\n        emit SignerRemoved(_oldSigner);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check whether the address is a valid signer\n     * @param _address The input address\n     * @return isValidSigner Whether this address is\n     */\n    function isValidSigner(address _address) public view returns (bool) {\n        return _isValidSigner[_address];\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check signature when buying a new policy (avoid arbitrary premium amount)\n     * @param signature 65 bytes array: [[v (1)], [r (32)], [s (32)]]\n     * @param _flightNumber Flight number\n     * @param _user User address\n     * @param _premium Policy premium\n     * @param _deadline Deadline of a policy\n     */\n    function checkSignature(\n        bytes calldata signature,\n        string memory _flightNumber,\n        address _user,\n        uint256 _premium,\n        uint256 _deadline\n    ) external view {\n        console.log(\"signature\");\n        console.logBytes(signature);\n        bytes32 hashedFlightNumber = keccak256(bytes(_flightNumber));\n\n        bytes32 hashData = keccak256(\n            abi.encodePacked(\n                _SUBMIT_APPLICATION_TYPEHASH,\n                hashedFlightNumber,\n                _user,\n                _premium,\n                _deadline\n            )\n        );\n        address signer = hashData.toEthSignedMessageHash().recover(signature);\n        console.logBytes32(hashData);\n        console.log(\"SIgner:\");\n        console.log(signer);\n\n        require(\n            _isValidSigner[signer],\n            \"Can only be submitted by authorized signer\"\n        );\n    }\n}\n"
    },
    "contracts/miserable-flight/interfaces/IFDPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\n\ninterface IFDPolicyToken is IERC721Enumerable {\n    function mintPolicyToken(address _receiver) external;\n\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n\n    function getTokenURI(uint256 _tokenId)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/miserable-flight/PolicyFlow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\n\nimport \"../tokens/interfaces/IBuyerToken.sol\";\nimport \"./interfaces/ISigManager.sol\";\nimport \"./interfaces/IFDPolicyToken.sol\";\nimport \"./interfaces/IFlightOracle.sol\";\nimport \"./interfaces/IInsurancePool.sol\";\n\nimport \"./interfaces/IPolicyStruct.sol\";\nimport \"./abstracts/PolicyParameters.sol\";\n\ncontract PolicyFlow is IPolicyStruct, PolicyParameters, Ownable {\n    // Other contracts\n    IBuyerToken public buyerToken;\n    ISigManager public sigManager;\n    IFDPolicyToken public policyToken;\n    IFlightOracle public flightOracle;\n    IInsurancePool public insurancePool;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    string public FLIGHT_STATUS_URL =\n        \"https://18.163.254.50:3207/flight_status?\";\n\n    uint256 public totalPolicies;\n\n    uint256 public fee;\n\n    mapping(uint256 => PolicyInfo) public policyList;\n\n    mapping(address => uint256[]) userPolicyList;\n\n    mapping(bytes32 => uint256) requestList;\n\n    mapping(uint256 => uint256) delayResultList;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event FeeChanged(uint256 newFee);\n    event MaxPayoffChanged(uint256 newMaxPayoff);\n    event MinTimeBeforeDepartureChanged(uint256 newMinTime);\n    event FlightOracleChanged(address newOracle);\n    event OracleUrlChanged(string newUrl);\n    event DelayThresholdChanged(uint256 thresholdMin, uint256 thresholdMax);\n\n    event NewPolicyApplication(uint256 _policyID, address indexed user);\n    event PolicySold(uint256 policyID, address indexed user);\n    event PolicyDeclined(uint256 policyID, address indexed user);\n    event PolicyClaimed(uint256 policyID, address indexed user);\n    event PolicyExpired(uint256 policyID, address indexed user);\n    event FulfilledOracleRequest(uint256 policyId, bytes32 requestId);\n    event PolicyOwnerTransfer(uint256 indexed tokenId, address newOwner);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(\n        address _insurancePool,\n        address _policyToken,\n        address _sigManager,\n        address _buyerToken\n    ) {\n        insurancePool = IInsurancePool(_insurancePool);\n        policyToken = IFDPolicyToken(_policyToken);\n        sigManager = ISigManager(_sigManager);\n        buyerToken = IBuyerToken(_buyerToken);\n\n        fee = 0.1 * 10**18;\n    }\n\n    // ----------------------------------------------------------------------------------- //\n    // ************************************ Modifiers ************************************ //\n    // ----------------------------------------------------------------------------------- //\n\n    /**\n     * @dev This modifier uses assert which means this error should never happens.\n     */\n    modifier validAddress() {\n        assert(msg.sender != address(0));\n        _;\n    }\n\n    // ----------------------------------------------------------------------------------- //\n    // ********************************* View Functions ********************************** //\n    // ----------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Show a user's policies (all)\n     * @param _user User's address\n     * @return userPolicies User's all policy details\n     */\n    function viewUserPolicy(address _user)\n        external\n        view\n        returns (PolicyInfo[] memory)\n    {\n        uint256 userPolicyAmount = userPolicyList[_user].length;\n        require(userPolicyAmount > 0, \"No policy for this user\");\n\n        PolicyInfo[] memory result = new PolicyInfo[](userPolicyAmount);\n\n        for (uint256 i = 0; i < userPolicyAmount; i++) {\n            uint256 policyId = userPolicyList[_user][i];\n\n            result[i] = policyList[policyId];\n        }\n        return result;\n    }\n\n    /**\n     * @notice Get the policyInfo from its count/order\n     * @param _policyId Total count/order of the policy = NFT tokenId\n     * @return policy A struct of information about this policy\n     */\n    // TODO: If still need this function\n    function getPolicyInfoById(uint256 _policyId)\n        public\n        view\n        returns (PolicyInfo memory policy)\n    {\n        policy = policyList[_policyId];\n    }\n\n    /**\n     * @notice Get the policy buyer by policyId\n     * @param _policyId Unique policy Id (uint256)\n     * @return buyerAddress The buyer of this policy\n     */\n    // TODO: If still need this function\n    function findPolicyBuyerById(uint256 _policyId)\n        public\n        view\n        returns (address buyerAddress)\n    {\n        buyerAddress = policyList[_policyId].buyerAddress;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Change the oracle fee\n     * @param _fee New oracle fee\n     */\n    function changeFee(uint256 _fee) external onlyOwner {\n        fee = _fee;\n        emit FeeChanged(_fee);\n    }\n\n    /**\n     * @notice Change the max payoff\n     * @param _newMaxPayoff New maxpayoff amount\n     */\n    function changeMaxPayoff(uint256 _newMaxPayoff) external onlyOwner {\n        MAX_PAYOFF = _newMaxPayoff;\n        emit MaxPayoffChanged(_newMaxPayoff);\n    }\n\n    /**\n     * @notice How long before departure when users can not buy new policies\n     * @param _newMinTime New time set\n     */\n    function changeMinTimeBeforeDeparture(uint256 _newMinTime)\n        external\n        onlyOwner\n    {\n        MIN_TIME_BEFORE_DEPARTURE = _newMinTime;\n        emit MinTimeBeforeDepartureChanged(_newMinTime);\n    }\n\n    /**\n     * @notice Change the oracle address\n     * @param _oracleAddress New oracle address\n     */\n    function setFlightOracle(address _oracleAddress) external onlyOwner {\n        flightOracle = IFlightOracle(_oracleAddress);\n        emit FlightOracleChanged(_oracleAddress);\n    }\n\n    /**\n     * @notice Set a new url\n     */\n    function setURL(string memory _url) external onlyOwner {\n        FLIGHT_STATUS_URL = _url;\n        emit OracleUrlChanged(_url);\n    }\n\n    /**\n     * @notice Set the new delay threshold used for calculating payoff\n     * @param _thresholdMin New minimum threshold\n     * @param _thresholdMax New maximum threshold\n     */\n    function setDelayThreshold(uint256 _thresholdMin, uint256 _thresholdMax)\n        external\n        onlyOwner\n    {\n        DELAY_THRESHOLD_MIN = _thresholdMin;\n        DELAY_THRESHOLD_MAX = _thresholdMax;\n        emit DelayThresholdChanged(_thresholdMin, _thresholdMax);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Buy a new flight delay policy\n     * @dev The transaction should have the signature from the backend server\n     * @param _productId ID of the purchased product (0: flightdelay; 1,2,3...: others)\n     * @param _flightNumber Flight number in string (e.g. \"AQ1299\")\n     * @param _premium Premium of this policy (decimals: 18)\n     * @param _departureTimestamp Departure date of this flight (unix timestamp in s, not ms!)\n     * @param _landingDate Landing date of this flight (uinx timestamp in s, not ms!)\n     * @param _deadline Deadline for this purchase request\n     * @param signature Use web3.eth.sign(hash(data), account) to generate the signature\n     */\n    function newApplication(\n        uint256 _productId,\n        string memory _flightNumber,\n        uint256 _premium,\n        uint256 _departureTimestamp,\n        uint256 _landingDate,\n        uint256 _deadline,\n        bytes calldata signature\n    ) public returns (uint256 _policyId) {\n        uint256 currentTimestamp = block.timestamp;\n        require(\n            currentTimestamp <= _deadline,\n            \"Expired deadline, please resubmit a transaction\"\n        );\n\n        require(\n            _productId == PRODUCT_ID,\n            \"You are calling the wrong product contract\"\n        );\n\n        require(\n            _departureTimestamp >= currentTimestamp + MIN_TIME_BEFORE_DEPARTURE,\n            \"It's too close to the departure time, you cannot buy this policy\"\n        );\n\n        // Should be signed by operators\n        _checkSignature(\n            signature,\n            _flightNumber,\n            _msgSender(),\n            _premium,\n            _deadline\n        );\n\n        // Generate the policy\n        uint256 currentPolicyId = totalPolicies;\n        policyList[currentPolicyId] = PolicyInfo(\n            PRODUCT_ID,\n            _msgSender(),\n            currentPolicyId,\n            _flightNumber,\n            _premium,\n            MAX_PAYOFF,\n            currentTimestamp,\n            _departureTimestamp,\n            _landingDate,\n            PolicyStatus.INI,\n            false,\n            404\n        );\n\n        // Check the policy with the insurance pool status\n        // May be accepted or rejected, if accepted then update the status of insurancePool\n        _policyCheck(_premium, MAX_PAYOFF, msg.sender, currentPolicyId);\n\n        // Give buyer tokens depending on the usd value they spent\n        buyerToken.mintBuyerToken(msg.sender, _premium);\n\n        // Store the policy's total order with userAddress\n        userPolicyList[msg.sender].push(totalPolicies);\n\n        // Update total policies\n        totalPolicies += 1;\n\n        emit NewPolicyApplication(currentPolicyId, msg.sender);\n\n        return currentPolicyId;\n    }\n\n    /** @notice Make a claim request\n     *  @param _policyId The total order/id of the policy\n     *  @param _flightNumber The flight number\n     *  @param _timestamp The flight departure timestamp\n     *  @param _path Which data in json needs to get\n     *  @param _forceUpdate Owner can force to update\n     */\n    function newClaimRequest(\n        uint256 _policyId,\n        string memory _flightNumber,\n        string memory _timestamp,\n        string memory _path,\n        bool _forceUpdate\n    ) public {\n        // Can not get the result before landing date\n        // Landing date may not be true, may be a fixed interval (4hours)\n        require(\n            block.timestamp >= policyList[_policyId].landingTimestamp,\n            \"Can only claim a policy after its expected landing timestamp\"\n        );\n\n        // Check if the policy has been settled\n        require(\n            (!policyList[_policyId].alreadySettled) ||\n                (_forceUpdate && (_msgSender() == owner())),\n            \"The policy status has already been settled, or you need to make a force update\"\n        );\n\n        // Check if the flight number is correct\n        require(\n            keccak256(abi.encodePacked(_flightNumber)) ==\n                keccak256(abi.encodePacked(policyList[_policyId].flightNumber)),\n            \"Wrong flight number provided\"\n        );\n\n        // Check if the departure date is correct\n        // require(\n        //     keccak256(abi.encodePacked(_timestamp)) ==\n        //         keccak256(\n        //             abi.encodePacked(policyList[_policyId].departureTimestamp)\n        //         ),\n        //     \"Wrong departure timestamp provided\"\n        // );\n\n        // Construct the url for oracle\n        string memory _url = string(\n            abi.encodePacked(\n                FLIGHT_STATUS_URL,\n                \"flight_no=\",\n                _flightNumber,\n                \"&timestamp=\",\n                _timestamp\n            )\n        );\n\n        // Start a new oracle request\n        bytes32 requestId = flightOracle.newOracleRequest(fee, _url, _path, 1);\n\n        // Record this request\n        requestList[requestId] = _policyId;\n        policyList[_policyId].alreadySettled = true;\n    }\n\n    /**\n     * @notice Update information when a policy token's ownership has been transferred\n     * @dev This function is called by the ERC721 contract of PolicyToken\n     * @param _tokenId Token Id of the policy token\n     * @param _oldOwner The initial owner\n     * @param _newOwner The new owner\n     */\n    function policyOwnerTransfer(\n        uint256 _tokenId,\n        address _oldOwner,\n        address _newOwner\n    ) external {\n        // Check the call is from policy token contract\n        require(\n            _msgSender() == address(policyToken),\n            \"only called from the flight delay policy token contract\"\n        );\n\n        // Check the previous owner record\n        uint256 policyId = _tokenId;\n        require(\n            _oldOwner == policyList[policyId].buyerAddress,\n            \"The previous owner is wrong\"\n        );\n\n        // Update the new buyer address\n        policyList[policyId].buyerAddress = _newOwner;\n        emit PolicyOwnerTransfer(_tokenId, _newOwner);\n    }\n\n    // ----------------------------------------------------------------------------------- //\n    // ********************************* Oracle Functions ******************************** //\n    // ----------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Do the final settlement, called by FlightOracle contract\n     * @param _requestId Chainlink request id\n     * @param _result Delay result (minutes) given by oracle\n     */\n    function finalSettlement(bytes32 _requestId, uint256 _result) public {\n        // Check if the call is from flight oracle\n        require(\n            msg.sender == address(flightOracle),\n            \"this function should be called by FlightOracle contract\"\n        );\n\n        uint256 policyId = requestList[_requestId];\n\n        PolicyInfo storage policy = policyList[policyId];\n        policy.delayResult = _result;\n\n        uint256 premium = policy.premium;\n        address buyerAddress = policy.buyerAddress;\n\n        require(\n            _result <= DELAY_THRESHOLD_MAX || _result == 400,\n            \"Abnormal oracle result, result should be [0 - 240] or 400\"\n        );\n\n        if (_result == 0) {\n            // 0: on time\n            policyExpired(premium, MAX_PAYOFF, buyerAddress, policyId);\n        } else if (_result <= DELAY_THRESHOLD_MAX) {\n            uint256 real_payoff = calcPayoff(_result);\n            _policyClaimed(premium, real_payoff, buyerAddress, policyId);\n        } else if (_result == 400) {\n            // 400: cancelled\n            _policyClaimed(premium, MAX_PAYOFF, buyerAddress, policyId);\n        }\n\n        emit FulfilledOracleRequest(policyId, _requestId);\n    }\n\n    // ----------------------------------------------------------------------------------- //\n    // ******************************** Internal Functions ******************************* //\n    // ----------------------------------------------------------------------------------- //\n\n    /**\n     * @notice check the policy and then determine whether we can afford it\n     * @param _payoff the payoff of the policy sold\n     * @param _user user's address\n     * @param _policyId the unique policy ID\n     */\n    function _policyCheck(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user,\n        uint256 _policyId\n    ) internal {\n        // Whether there are enough capacity in the pool\n        bool _isAccepted = insurancePool.checkCapacity(_payoff);\n\n        if (_isAccepted) {\n            insurancePool.updateWhenBuy(_premium, _payoff, _user);\n            policyList[_policyId].status = PolicyStatus.SOLD;\n            emit PolicySold(_policyId, _user);\n\n            policyToken.mintPolicyToken(_user);\n        } else {\n            policyList[_policyId].status = PolicyStatus.DECLINED;\n            emit PolicyDeclined(_policyId, _user);\n            revert(\"not sufficient capacity in the insurance pool\");\n        }\n    }\n\n    /**\n     * @notice update the policy when it is expired\n     * @param _premium the premium of the policy sold\n     * @param _payoff the payoff of the policy sold\n     * @param _user user's address\n     * @param _policyId the unique policy ID\n     */\n    function policyExpired(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user,\n        uint256 _policyId\n    ) internal {\n        insurancePool.updateWhenExpire(_premium, _payoff, _user);\n        policyList[_policyId].status = PolicyStatus.EXPIRED;\n        emit PolicyExpired(_policyId, _user);\n    }\n\n    /**\n     * @notice Update the policy when it is claimed\n     * @param _premium Premium of the policy sold\n     * @param _payoff Payoff of the policy sold\n     * @param _user User's address\n     * @param _policyId The unique policy ID\n     */\n    function _policyClaimed(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user,\n        uint256 _policyId\n    ) internal {\n        insurancePool.payClaim(_premium, MAX_PAYOFF, _payoff, _user);\n        policyList[_policyId].status = PolicyStatus.CLAIMED;\n        emit PolicyClaimed(_policyId, _user);\n    }\n\n    /**\n     * @notice The payoff formula\n     * @param _delay Delay in minutes\n     * @return the final payoff volume\n     */\n    function calcPayoff(uint256 _delay) internal view returns (uint256) {\n        uint256 payoff = 0;\n\n        // payoff model 1 - linear\n        if (_delay <= DELAY_THRESHOLD_MIN) {\n            payoff = 0;\n        } else if (\n            _delay > DELAY_THRESHOLD_MIN && _delay <= DELAY_THRESHOLD_MAX\n        ) {\n            payoff = (_delay * _delay) / 480;\n        } else if (_delay > DELAY_THRESHOLD_MAX) {\n            payoff = MAX_PAYOFF;\n        }\n\n        payoff = payoff * 1e18;\n        return payoff;\n    }\n\n    /**\n     * @notice Check whether the signature is valid\n     * @param signature 65 byte array: [[v (1)], [r (32)], [s (32)]]\n     * @param _flightNumber Flight number\n     * @param _address userAddress\n     * @param _premium Premium of the policy\n     * @param _deadline Deadline of the application\n     */\n    function _checkSignature(\n        bytes calldata signature,\n        string memory _flightNumber,\n        address _address,\n        uint256 _premium,\n        uint256 _deadline\n    ) internal view {\n        sigManager.checkSignature(\n            signature,\n            _flightNumber,\n            _address,\n            _premium,\n            _deadline\n        );\n    }\n}\n"
    },
    "contracts/miserable-flight/interfaces/ISigManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface ISigManager {\n    event SignerAdded(address indexed _newSigner);\n    event SignerRemoved(address indexed _oldSigner);\n\n    function addSigner(address) external;\n\n    function removeSigner(address) external;\n\n    function isValidSigner(address) external view returns (bool);\n\n    function checkSignature(\n        bytes calldata signature,\n        string memory _flightNumber,\n        address _address,\n        uint256 _premium,\n        uint256 _deadline\n    ) external view;\n}\n"
    },
    "contracts/miserable-flight/interfaces/IFlightOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IFlightOracle {\n    function newOracleRequest(\n        uint256 _payment,\n        string memory _url,\n        string memory _path,\n        int256 times\n    ) external returns (bytes32);\n\n    // Set a new url\n    function setURL(string memory _url) external;\n\n    // Set the oracle address\n    function setOracleAddress(address _newOracle) external;\n\n    // Set a new job id\n    function setJobId(bytes32 _newJobId) external;\n\n    // Set a new policy flow\n    function setPolicyFlow(address _policyFlow) external;\n\n    function getChainlinkTokenAddress() external view returns (address);\n}\n"
    },
    "contracts/miserable-flight/interfaces/IInsurancePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IInsurancePool {\n    // view functions\n\n    function getUserBalance(address) external view returns (uint256);\n\n    function getPoolUnlocked() external view returns (uint256);\n\n    function getUnlockedFor(address _user)\n        external\n        view\n        returns (uint256);\n\n    function getLockedFor(address _user) external view returns (uint256);\n\n    function checkCapacity(uint256 _payoff) external view returns (bool);\n\n    // set functions\n\n    function setPurchaseIncentive(uint256 _newIncentive) external;\n\n    function setFrozenTime(uint256 _newFrozenTime) external;\n\n    function setPolicyFlow(address _policyFlowAddress) external;\n\n    function setIncomeDistribution(uint256[3] memory _newDistribution) external;\n\n    function setCollateralFactor(uint256 _factor) external;\n\n    function transferOwnership(address _newOwner) external;\n\n    // main functions\n\n    function stake(address _user, uint256 _amount) external;\n\n    function unstake(uint256 _amount) external;\n\n    function unstakeMax() external;\n\n    function updateWhenBuy(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user\n    ) external;\n\n    function updateWhenExpire(\n        uint256 _premium,\n        uint256 _payoff,\n        address _user\n    ) external;\n\n    function payClaim(\n        uint256 _premium,\n        uint256 _payoff,\n        uint256 _realPayoff,\n        address _user\n    ) external;\n\n    function revertUnstakeRequest(address _user) external;\n\n    function revertAllUnstakeRequest(address _user) external;\n}\n"
    },
    "contracts/miserable-flight/abstracts/PolicyParameters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nabstract contract PolicyParameters {\n    // Product parameter\n    uint256 public constant PRODUCT_ID = 0;\n\n    // Parameters about the claim curve\n    uint256 public MAX_PAYOFF = 180 ether;\n    uint256 public DELAY_THRESHOLD_MIN = 30;\n    uint256 public DELAY_THRESHOLD_MAX = 240;\n\n    // Minimum time before departure for applying\n    // TODO: internal test\n    uint256 public MIN_TIME_BEFORE_DEPARTURE = 0;\n}\n"
    },
    "contracts/utils/interfaces/IERC20PermitWithMultipleMinters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\ninterface IERC20PermitWithMultipleMinters is IERC20, IERC20Permit {\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Functions ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    /**\n     * @notice Add a new minter into the minterList\n     * @param _newMinter Address of the new minter\n     */\n    function addMinter(address _newMinter) external;\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldMinter Address of the minter to be removed\n     */\n    function removeMinter(address _oldMinter) external;\n\n    /**\n     * @notice Add a new burner into the burnerList\n     * @param _newBurner Address of the new burner\n     */\n    function addBurner(address _newBurner) external;\n\n    /**\n     * @notice Remove a minter from the minterList\n     * @param _oldBurner Address of the minter to be removed\n     */\n    function removeBurner(address _oldBurner) external;\n}\n"
    },
    "contracts/naughty-price/NPPolicyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n// import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../utils/ERC20.sol\";\n\n/**\n * @title  Policy Token for Naughty Price\n * @notice This is the contract for token price policy token.\n *         It is a ERC20 token with an owner and a minter.\n *         The owner should be the deployer at first.\n *         The minter should be the policyCore contract.\n * @dev    It is different from the flight delay token.\n *         That is an ERC721 NFT and this is an ERC20 token.\n */\ncontract NPPolicyToken is ERC20 {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    address public minter;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Mint(address account, uint256 amount);\n    event Burn(address account, uint256 amount);\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _minter\n    ) ERC20(_name, _symbol) {\n        minter = _minter;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Modifiers **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Only the minter can mint\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"only minter can call this function\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint some policy tokens\n     * @param _account Address to receive the tokens\n     * @param _amount Amount to be minted\n     */\n    function mint(address _account, uint256 _amount) public onlyMinter {\n        _mint(_account, _amount);\n        emit Mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn some policy tokens\n     * @param _account Address to burn tokens\n     * @param _amount Amount to be burned\n     */\n    function burn(address _account, uint256 _amount) public onlyMinter {\n        _burn(_account, _amount);\n        emit Burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/naughty-price/NaughtyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\nimport \"./NPPolicyToken.sol\";\nimport \"./NaughtyPair.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/INaughtyPair.sol\";\nimport \"./interfaces/IPolicyCore.sol\";\nimport \"../libraries/StringsUtils.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * @title Naughty Factory\n * @dev Factory contract to deploy new pools periodically\n *      Each pool(product) will have a unique naughtyId\n *      Each pool will have its pool token\n *      PolicyToken - Stablecoin\n *      Token 0 may change but Token 1 is always stablecoin.\n */\n\ncontract NaughtyFactory {\n    using StringsUtils for address;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // PolicyToken Address => StableCoin Address => Pool Address\n    mapping(address => mapping(address => address)) getPair;\n\n    // Store all the pairs' addresses\n    address[] public allPairs;\n\n    // Store all policy tokens' addresses\n    address[] public allTokens;\n\n    uint256 public _nextId;\n\n    // Address of policyCore\n    address public policyCore;\n\n    // INIT_CODE_HASH for NaughtyPair, may be used in frontend\n    bytes32 public constant PAIR_INIT_CODE_HASH =\n        keccak256(abi.encodePacked(type(NaughtyPair).creationCode));\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Modifiers ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Ensure the policyCore address is already set\n     * @dev The naughty pair token may not have minter without this modifier\n     */\n    modifier alreadySetPolicyCore() {\n        require(policyCore != address(0), \"Please set the policyCore address\");\n        _;\n    }\n\n    /**\n     * @notice Only called by policyCore contract\n     */\n    modifier onlyPolicyCore() {\n        require(msg.sender == policyCore, \"Only called by policyCore contract\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Next token to be deployed\n     * @return Latest token address\n     */\n    function getLatestTokenAddress() external view returns (address) {\n        uint256 currentToken = _nextId - 1;\n        return allTokens[currentToken];\n    }\n\n    /**\n     * @notice Get the INIT_CODE_HASH for policy tokens with parameters\n     * @param _policyTokenName Name of the policy token to be deployed\n     */\n    function getInitCodeHashForPolicyToken(string memory _policyTokenName)\n        external\n        view\n        returns (bytes32)\n    {\n        bytes memory bytecode = type(NPPolicyToken).creationCode;\n        return\n            keccak256(\n                abi.encodePacked(\n                    bytecode,\n                    abi.encode(_policyTokenName, _policyTokenName, policyCore)\n                )\n            );\n    }\n\n    /**\n     * @notice Get the pair address deployed by the factory\n     *         PolicyToken address first, and then stablecoin address\n     *         The order of the tokens will be sorted inside the function\n     * @param _tokenAddress1 Address of token1\n     * @param _tokenAddress2 Address of toekn2\n     * @return Pool address of the two tokens\n     */\n    function getPairAddress(address _tokenAddress1, address _tokenAddress2)\n        public\n        view\n        returns (address)\n    {\n        // Policy token address at the first place\n        (address token0, address token1) = IPolicyCore(policyCore)\n            .supportedStablecoin(_tokenAddress2)\n            ? (_tokenAddress1, _tokenAddress2)\n            : (_tokenAddress2, _tokenAddress1);\n\n        address _pairAddress = getPair[token0][token1];\n\n        return _pairAddress;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Set Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Remember to call this function to set the policyCore address\n     *         < PolicyCore should be the owner of policyToken >\n     * @param _policyCore: Address of policyCore contract\n     */\n    function setPolicyCoreAddress(address _policyCore) external {\n        policyCore = _policyCore;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Main Functions *********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice After deploy the policytoken and get the address,\n     *         we deploy the policyToken - stablecoin pool contract\n     * @param _policyTokenAddress Address of policy token\n     * @param _stablecoin Address of the stable coin\n     * @param _deadline Deadline of the pool\n     * @param _feeRate Fee rate given to LP holders\n     * @return Address of the pool\n     */\n    function deployPool(\n        address _policyTokenAddress,\n        address _stablecoin,\n        uint256 _deadline,\n        uint256 _feeRate\n    ) external alreadySetPolicyCore onlyPolicyCore returns (address) {\n        bytes memory bytecode = type(NaughtyPair).creationCode;\n\n        bytes32 salt = keccak256(\n            abi.encodePacked(\n                _policyTokenAddress.addressToString(),\n                _stablecoin.addressToString()\n            )\n        );\n\n        address _poolAddress = _deploy(bytecode, salt);\n\n        INaughtyPair(_poolAddress).initialize(\n            _policyTokenAddress,\n            _stablecoin,\n            _deadline,\n            _feeRate\n        );\n\n        getPair[_policyTokenAddress][_stablecoin] = _poolAddress;\n\n        allPairs.push(_poolAddress);\n\n        return _poolAddress;\n    }\n\n    /**\n     * @notice For each round we need to first create the policytoken(ERC20)\n     * @param _policyTokenName Name of the policyToken\n     * @return PolicyToken address\n     */\n    function deployPolicyToken(string memory _policyTokenName)\n        external\n        alreadySetPolicyCore\n        onlyPolicyCore\n        returns (address)\n    {\n        bytes32 salt = keccak256(abi.encodePacked(_policyTokenName));\n\n        bytes memory bytecode = getPolicyTokenBytecode(_policyTokenName);\n\n        address _policTokenAddress = _deploy(bytecode, salt);\n\n        allTokens.push(_policTokenAddress);\n\n        _nextId++;\n\n        return _policTokenAddress;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Deploy function with create2\n     */\n    function _deploy(bytes memory code, bytes32 salt)\n        internal\n        returns (address addr)\n    {\n        assembly {\n            addr := create2(0, add(code, 0x20), mload(code), salt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    /**\n     * @notice Get the policyToken bytecode (with parameters)\n     * @dev It is public for test convinience\n     * @param _tokenName Name of policyToken\n     */\n    function getPolicyTokenBytecode(string memory _tokenName)\n        public\n        view\n        returns (bytes memory)\n    {\n        bytes memory bytecode = type(NPPolicyToken).creationCode;\n\n        // Encodepacked the parameters\n        // The minter is set to be the policyCore address\n        return\n            abi.encodePacked(\n                bytecode,\n                abi.encode(_tokenName, _tokenName, policyCore)\n            );\n    }\n\n}\n"
    },
    "contracts/mocks/MockUSD.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n// import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../utils/ERC20.sol\";\n\n/**\n * @notice This is the MockUSD used in testnet\n *         Maximum mint amount is 500k for each user.\n *         Maximum mint amount for every single tx is 100k.\n */\ncontract MockUSD is ERC20 {\n    uint256 public constant INITIAL_SUPPLY = 500000 ether;\n\n    uint256 public USER_CAP = 10000 ether;\n\n    mapping(address => uint256) userHaveMinted;\n    address[] allUsers;\n\n    constructor() ERC20(\"MOCKUSD\", \"USDC\") {\n        // When first deployed, give the owner some coins\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\n\n    // For testnet check\n    function getAllUsers() external view returns (address[] memory) {\n        return allUsers;\n    }\n\n    // Everyone can mint, have fun for test\n    function mint(address _account, uint256 _amount) public {\n        require(_amount <= 10000e18, \"Please mint less than 10k every time\");\n        require(\n            userHaveMinted[_account] + _amount <= USER_CAP,\n            \"You have minted too many usd (maximum 10k)\"\n        );\n\n        if (userHaveMinted[_account] == 0) allUsers.push(_account);\n\n        _mint(_account, _amount);\n        userHaveMinted[_account] += _amount;\n    }\n}\n"
    },
    "contracts/lucky-box/DegisLottery.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/IRandomNumberGenerator.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract DegisLottery is ReentrancyGuard, Ownable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    IERC20 public DEGToken;\n    IERC20 public USDToken;\n    IRandomNumberGenerator public randomGenerator;\n\n    address public operatorAddress;\n\n    uint256 public constant TICKET_PRICE = 10 ether;\n\n    struct Tickets {\n        mapping(uint256 => uint256) ticketsWeight;\n        mapping(uint256 => uint256) ticketsAmount;\n    }\n    Tickets poolTickets;\n    mapping(address => Tickets) usersTickets;\n\n    enum Status {\n        Pending,\n        Open,\n        Close,\n        Claimable\n    }\n    struct LotteryInfo {\n        Status status;\n        uint256 startTime;\n        uint256 endTime;\n        uint256[4] stageProportion;\n        uint256[4] stageReward;\n        uint256[4] stageAmount;\n        uint256[4] stageWeight;\n        uint256 totalRewards;\n        uint256 pendingRewards;\n        uint256 finalNumber;\n    }\n    mapping(uint256 => LotteryInfo) public lotteries;\n\n    uint256 public RewardsToNextLottery;\n\n    uint256 public allPendingRewards;\n\n    uint256 public currentLotteryId; // Total Rounds\n\n    mapping(address => uint256) public userCheckPoint;\n    mapping(address => uint256) public usersTotalRewards;\n\n    mapping(address => mapping(uint256 => uint256)) public usersRewards;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event TicketsPurchase(\n        address indexed buyer,\n        uint256 indexed lotteryId,\n        uint256 totalAmount\n    );\n    event TicketsRedeem(\n        address indexed redeemer,\n        uint256 indexed lotteryId,\n        uint256 totalAmount\n    );\n    event LotteryOpen(\n        uint256 indexed lotteryId,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 totalRewards\n    );\n    event LotteryNumberDrawn(\n        uint256 indexed lotteryId,\n        uint256 finalNumber,\n        uint256 pendingRewards\n    );\n\n    event ReceiveRewards(\n        address indexed claimer,\n        uint256 amount,\n        uint256 indexed lotteryId\n    );\n\n    event LotteryClose(uint256 indexed lotteryId);\n\n    event LotteryFundInjection(\n        uint256 indexed lotteryId,\n        uint256 injectedAmount\n    );\n    event RandomNumberGeneratorChanged(address randomGenerator);\n    event OperatorAddressChanged(address operator);\n    event AdminTokenRecovery(address indexed token, uint256 amount);\n\n    /**\n     * @notice Constructor function\n     * @dev RandomNumberGenerator must be deployed prior to this contract\n     * @param _DEGTokenAddress Address of the DEG token (for buying tickets)\n     * @param _USDTokenAddress Address of the USD token (for prize distribution)\n     * @param _randomGeneratorAddress Address of the RandomGenerator contract used to work with ChainLink VRF\n     */\n    constructor(\n        address _DEGTokenAddress,\n        address _USDTokenAddress,\n        address _randomGeneratorAddress\n    ) {\n        DEGToken = IERC20(_DEGTokenAddress);\n        USDToken = IERC20(_USDTokenAddress);\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    modifier notContract() {\n        require(!_isContract(_msgSender()), \"Contract not allowed\");\n        require(_msgSender() == tx.origin, \"Proxy contract not allowed\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(\n            _msgSender() == operatorAddress || _msgSender() == owner(),\n            \"Not operator\"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    function getCurrentRoundWeight() public view returns (uint256) {\n        return ((currentLotteryId + 24) * 1000000) / (currentLotteryId + 12);\n    }\n\n    /**\n     * @notice Get pool tickets info\n     * @dev May be a huge number, avoid reading this frequently\n     * @param _startIndex Start number\n     * @param _stopIndex Stop number\n     * @param _position Which level to check (0, 1, 2, 3), use 0 to check the 4-digit number\n     */\n    function getPoolTicketsInfo(\n        uint256 _startIndex,\n        uint256 _stopIndex,\n        uint256 _position\n    )\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        uint256[] memory ticketsNumber = new uint256[](\n            _stopIndex - _startIndex + 1\n        );\n        uint256[] memory ticketsAmount = new uint256[](\n            _stopIndex - _startIndex + 1\n        );\n        uint256[] memory ticketsWeight = new uint256[](\n            _stopIndex - _startIndex + 1\n        );\n\n        for (uint256 i = _startIndex; i <= _stopIndex; i++) {\n            uint256 encodedNumber = _encodedNumber(i, _position);\n\n            ticketsNumber[i - _startIndex] = i;\n            ticketsAmount[i - _startIndex] = poolTickets.ticketsAmount[\n                encodedNumber\n            ];\n            ticketsWeight[i - _startIndex] = poolTickets.ticketsWeight[\n                encodedNumber\n            ];\n        }\n        return (ticketsNumber, ticketsAmount, ticketsWeight);\n    }\n\n    /**\n     * @notice Get user tickets info\n     */\n    function getUserTicketsInfo(\n        address user,\n        uint256 _startIndex,\n        uint256 _stopIndex,\n        uint256 position\n    )\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        uint256 length = _stopIndex - _startIndex + 1;\n\n        uint256[] memory ticketsNumber = new uint256[](length);\n        uint256[] memory ticketsAmount = new uint256[](length);\n        uint256[] memory ticketsWeight = new uint256[](length);\n\n        for (uint256 i = _startIndex; i <= _stopIndex; i++) {\n            uint256 encodedNumber = _encodedNumber(i, position);\n            ticketsNumber[i - _startIndex] = i;\n            ticketsAmount[i - _startIndex] = usersTickets[user].ticketsAmount[\n                encodedNumber\n            ];\n            ticketsWeight[i - _startIndex] = usersTickets[user].ticketsWeight[\n                encodedNumber\n            ];\n        }\n        return (ticketsNumber, ticketsAmount, ticketsWeight);\n    }\n\n    /**\n     * @notice Get lottery stage info\n     */\n    function getLotteriesStageInfo(uint256 _lotteryId)\n        external\n        view\n        returns (\n            uint256[] memory stageProportion,\n            uint256[] memory stageReward,\n            uint256[] memory stageAmount,\n            uint256[] memory stageWeight\n        )\n    {\n        stageProportion = new uint256[](4);\n        stageReward = new uint256[](4);\n        stageAmount = new uint256[](4);\n        stageWeight = new uint256[](4);\n\n        for (uint256 i = 0; i < 4; i++) {\n            stageProportion[i] = lotteries[_lotteryId].stageProportion[i];\n            stageReward[i] = lotteries[_lotteryId].stageReward[i];\n            stageAmount[i] = lotteries[_lotteryId].stageAmount[i];\n            stageWeight[i] = lotteries[_lotteryId].stageWeight[i];\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set operator, treasury, and injector addresses\n     * @dev Only callable by the owner\n     * @param _operatorAddress address of the operator\n     */\n    function setOperatorAddress(address _operatorAddress) external onlyOwner {\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\n\n        operatorAddress = _operatorAddress;\n\n        emit OperatorAddressChanged(_operatorAddress);\n    }\n\n    function setRandomNumberGenerator(address _randomNumberGenerator)\n        external\n        onlyOwner\n    {\n        require(\n            _randomNumberGenerator != address(0),\n            \"Can not be zero address\"\n        );\n\n        randomGenerator = IRandomNumberGenerator(_randomNumberGenerator);\n\n        emit RandomNumberGeneratorChanged(_randomNumberGenerator);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Start the lottery\n     * @dev Callable only by operator\n     * @param _endTime endTime of the lottery (timestamp in s)\n     * @param _stageProportion breakdown of rewards per bracket (must sum to 10,000)(100 <=> 1)\n     */\n    function startLottery(\n        uint256 _endTime,\n        uint256[4] calldata _stageProportion\n    ) external onlyOperator {\n        require(\n            (currentLotteryId == 0) ||\n                (lotteries[currentLotteryId].status == Status.Claimable),\n            \"Not time to start lottery\"\n        );\n\n        require(\n            (_stageProportion[0] +\n                _stageProportion[1] +\n                _stageProportion[2] +\n                _stageProportion[3]) <= 10000,\n            \"Total rewards of each bracket should <= 10000\"\n        );\n\n        currentLotteryId++;\n\n        lotteries[currentLotteryId] = LotteryInfo({\n            status: Status.Open,\n            startTime: block.timestamp,\n            endTime: _endTime,\n            stageProportion: _stageProportion,\n            stageReward: [uint256(0), uint256(0), uint256(0), uint256(0)],\n            stageAmount: [uint256(0), uint256(0), uint256(0), uint256(0)],\n            stageWeight: [uint256(0), uint256(0), uint256(0), uint256(0)],\n            totalRewards: RewardsToNextLottery,\n            pendingRewards: 0,\n            finalNumber: 0\n        });\n        RewardsToNextLottery = 0;\n\n        emit LotteryOpen(\n            currentLotteryId,\n            lotteries[currentLotteryId].startTime,\n            lotteries[currentLotteryId].endTime,\n            lotteries[currentLotteryId].totalRewards\n        );\n    }\n\n    /**\n     * @notice Close a lottery\n     * @dev Callable only by the operator\n     */\n    function closeLottery() external onlyOperator nonReentrant {\n        require(\n            lotteries[currentLotteryId].status == Status.Open,\n            \"Current lottery is not open\"\n        );\n\n        lotteries[currentLotteryId].endTime = block.timestamp;\n\n        // Request a random number from the generator\n        randomGenerator.getRandomNumber();\n\n        // Update the lottery status\n        lotteries[currentLotteryId].status = Status.Close;\n\n        emit LotteryClose(currentLotteryId);\n    }\n\n    /**\n     * @notice Buy tickets for the current lottery round\n     * @dev Can not be called by a smart contract\n     * @param _ticketNumbers array of ticket numbers between 0 and 9999\n     * @param _ticketAmounts array of ticket amount\n     */\n    function buyTickets(\n        uint256[] calldata _ticketNumbers,\n        uint256[] calldata _ticketAmounts\n    ) external notContract nonReentrant {\n        require(_ticketNumbers.length != 0, \"No tickets are being bought\");\n        require(\n            _ticketNumbers.length == _ticketAmounts.length,\n            \"Different lengths\"\n        );\n\n        require(\n            lotteries[currentLotteryId].status == Status.Open,\n            \"Current lottery is not open\"\n        );\n\n        if (userCheckPoint[_msgSender()] == 0) {\n            userCheckPoint[_msgSender()] = currentLotteryId;\n        }\n\n        if (userCheckPoint[_msgSender()] < currentLotteryId) {\n            receiveRewards(currentLotteryId - 1);\n        }\n\n        uint256 roundWeight = getCurrentRoundWeight();\n\n        uint256 totalAmount = 0;\n\n        for (uint256 i = 0; i < _ticketNumbers.length; i++) {\n            _buyTicket(\n                poolTickets,\n                _ticketNumbers[i],\n                _ticketAmounts[i],\n                roundWeight * _ticketAmounts[i]\n            );\n            _buyTicket(\n                usersTickets[_msgSender()],\n                _ticketNumbers[i],\n                _ticketAmounts[i],\n                roundWeight * _ticketAmounts[i]\n            );\n            totalAmount += _ticketAmounts[i];\n        }\n\n        DEGToken.safeTransferFrom(\n            address(_msgSender()),\n            address(this),\n            totalAmount * TICKET_PRICE\n        );\n\n        emit TicketsPurchase(_msgSender(), currentLotteryId, totalAmount);\n    }\n\n    /**\n     * @notice Redeem tickets for all lottery\n     * @param _ticketNumbers Array of ticket numbers\n     * @dev Callable by users\n     */\n    function redeemTickets(uint256[] calldata _ticketNumbers)\n        external\n        notContract\n        nonReentrant\n    {\n        require(_ticketNumbers.length != 0, \"No tickets are being redeem\");\n\n        require(\n            lotteries[currentLotteryId].status == Status.Open,\n            \"Sorry, current lottery is not open\"\n        );\n\n        if (userCheckPoint[msg.sender] == 0) {\n            userCheckPoint[msg.sender] = currentLotteryId;\n        }\n\n        if (userCheckPoint[msg.sender] < currentLotteryId) {\n            receiveRewards(currentLotteryId - 1);\n        }\n\n        uint256 totalAmount = 0;\n        for (uint256 i = 0; i < _ticketNumbers.length; i++) {\n            uint256 encodedNumber = _encodedNumber(_ticketNumbers[i], 3);\n\n            uint256 ticketAmount = usersTickets[msg.sender].ticketsAmount[\n                encodedNumber\n            ];\n            uint256 ticketWight = usersTickets[msg.sender].ticketsWeight[\n                encodedNumber\n            ];\n            _redeemTicket(\n                poolTickets,\n                _ticketNumbers[i],\n                ticketAmount,\n                ticketWight\n            );\n            _redeemTicket(\n                usersTickets[_msgSender()],\n                _ticketNumbers[i],\n                ticketAmount,\n                ticketWight\n            );\n            totalAmount += ticketAmount;\n        }\n\n        require(totalAmount != 0, \"No tickets are being bought\");\n\n        DEGToken.safeTransfer(_msgSender(), totalAmount * TICKET_PRICE);\n\n        emit TicketsRedeem(_msgSender(), currentLotteryId, totalAmount);\n    }\n\n    /**\n     * @notice Inject funds\n     * @param _amount amount to inject \n     * @dev Callable by owner(incentive) or injector address(insurancePool income)\n            First transfer USD and then call this function to record\n     */\n    function injectFunds(uint256 _amount) external onlyOperator nonReentrant {\n        USDToken.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        if (lotteries[currentLotteryId].status == Status.Open) {\n            lotteries[currentLotteryId].totalRewards += _amount;\n        } else RewardsToNextLottery += _amount;\n\n        // tag: This place may need change\n        require(\n            allPendingRewards + lotteries[currentLotteryId].totalRewards <=\n                USDToken.balanceOf(address(this)),\n            \"Wrong USD amount\"\n        );\n\n        emit LotteryFundInjection(currentLotteryId, _amount);\n    }\n\n    /**\n     * @notice Draw the final number, calculate reward in DEG for each group,\n     *         and make this lottery claimable (need to wait for the random generator)\n     * @dev Callable only by the operator\n     */\n    function drawLottery() external onlyOperator nonReentrant {\n        require(\n            lotteries[currentLotteryId].status == Status.Close,\n            \"this lottery has not closed, you should first close it\"\n        );\n        require(\n            currentLotteryId == randomGenerator.latestLotteryId(),\n            \"the final number has not been drawn\"\n        );\n\n        // Get the final lucky numbers from randomGenerator\n        uint256 finalNumber = randomGenerator.randomResult();\n\n        uint256 lastAmount = 0;\n        uint256 lastWeight = 0;\n\n        LotteryInfo storage currentLottery = lotteries[currentLotteryId];\n\n        uint256 tempPendingRewards = 0;\n\n        for (uint256 j = 0; j < 4; j++) {\n            uint256 i = 3 - j;\n\n            uint256 encodedNumber = _encodedNumber(finalNumber, i);\n\n            currentLottery.stageAmount[i] =\n                poolTickets.ticketsAmount[encodedNumber] -\n                lastAmount;\n            lastAmount = poolTickets.ticketsAmount[encodedNumber];\n\n            currentLottery.stageWeight[i] =\n                poolTickets.ticketsWeight[encodedNumber] -\n                lastWeight;\n            lastWeight = poolTickets.ticketsWeight[encodedNumber];\n\n            if (currentLottery.stageAmount[i] == 0)\n                currentLottery.stageReward[i] = 0;\n            else\n                currentLottery.stageReward[i] =\n                    (currentLottery.stageProportion[i] *\n                        currentLottery.totalRewards) /\n                    10000;\n\n            tempPendingRewards += currentLottery.stageReward[i];\n        }\n        currentLottery.pendingRewards += tempPendingRewards;\n\n        RewardsToNextLottery =\n            currentLottery.totalRewards -\n            currentLottery.pendingRewards;\n\n        require(\n            allPendingRewards + currentLottery.totalRewards <=\n                USDToken.balanceOf(address(this)),\n            \"Wrong USD amount\"\n        );\n\n        // Update internal statuses for this lottery round\n        currentLottery.finalNumber = finalNumber;\n        currentLottery.status = Status.Claimable;\n\n        // Update all pending rewards\n        allPendingRewards += currentLottery.pendingRewards;\n\n        emit LotteryNumberDrawn(\n            currentLotteryId,\n            finalNumber, // final result for this round\n            lotteries[currentLotteryId].pendingRewards\n        );\n    }\n\n    /**\n     * @notice Receive award from a lottery\n     * @param _lotteryId lottery id\n     * @param user user address\n     */\n    function receiveRward(uint256 _lotteryId, address user)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 award = 0;\n        uint256 lastWeight = 0;\n        uint256 finalNumber = lotteries[_lotteryId].finalNumber;\n        for (uint256 j = 0; j < 4; j++) {\n            uint256 i = 3 - j;\n            uint256 encodedNumber = _encodedNumber(finalNumber, i);\n            uint256 weight = usersTickets[user].ticketsWeight[encodedNumber] -\n                lastWeight;\n            lastWeight = usersTickets[user].ticketsWeight[encodedNumber];\n            if (lotteries[_lotteryId].stageWeight[i] != 0) {\n                award +=\n                    (lotteries[_lotteryId].stageReward[i] * weight) /\n                    lotteries[_lotteryId].stageWeight[i];\n            }\n        }\n\n        return award;\n    }\n\n    /**\n     * @notice Receive all awards from lottery before lottery id\n     * @param _lotteryId lottery id\n     * @dev Callable by users only, not contract!\n     */\n    function receiveRewards(uint256 _lotteryId) public notContract {\n        require(\n            lotteries[_lotteryId].status == Status.Claimable,\n            \"this round of lottery are not ready for claiming\"\n        );\n\n        require(\n            userCheckPoint[msg.sender] <= _lotteryId,\n            \"all awards have been received\"\n        );\n\n        uint256 awards = 0;\n\n        for (uint256 i = userCheckPoint[msg.sender]; i <= _lotteryId; i++) {\n            uint256 award = receiveRward(i, msg.sender);\n            awards += award;\n            lotteries[i].pendingRewards -= award;\n\n            usersRewards[msg.sender][i] = award;\n            usersTotalRewards[msg.sender] += award;\n        }\n        userCheckPoint[msg.sender] = _lotteryId + 1;\n\n        allPendingRewards -= awards;\n\n        // require(awards != 0, \"no awards\");\n\n        // Transfer the prize to winner\n        if (awards != 0) {\n            USDToken.safeTransfer(msg.sender, awards);\n        }\n        emit ReceiveRewards(msg.sender, awards, _lotteryId);\n    }\n\n    /**\n     * @notice Recover wrong tokens sent to the contract, only by the owner\n               All tokens except DEG and USD are wrong tokens\n     * @param _tokenAddress the address of the token to withdraw\n     * @param _tokenAmount token amount to withdraw\n     */\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount)\n        external\n        onlyOwner\n    {\n        require(_tokenAddress != address(DEGToken), \"Cannot recover DEG token\");\n\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\n\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Update the status to finish buying a ticket\n     * @param tickets Tickets to update\n     * @param _ticketNumber Original number of the ticket\n     * @param _ticketAmount Amount of this number are being bought\n     * @param _ticketWeight Weight of this ticket, depends on round\n     */\n    function _buyTicket(\n        Tickets storage tickets,\n        uint256 _ticketNumber,\n        uint256 _ticketAmount,\n        uint256 _ticketWeight\n    ) internal {\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 encodedNumber = _encodedNumber(_ticketNumber, i);\n            tickets.ticketsWeight[encodedNumber] += _ticketWeight;\n            tickets.ticketsAmount[encodedNumber] += _ticketAmount;\n        }\n    }\n\n    /**\n     * @notice Update the status to finish redeeming a ticket\n     * @param tickets Tickets to update\n     * @param _ticketNumber Original number of the ticket\n     * @param _ticketAmount Amount of this number are being redeemed\n     * @param _ticketWeight Weight of this ticket, depends on round\n     */\n    function _redeemTicket(\n        Tickets storage tickets,\n        uint256 _ticketNumber,\n        uint256 _ticketAmount,\n        uint256 _ticketWeight\n    ) internal {\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 encodedNumber = _encodedNumber(_ticketNumber, i);\n            tickets.ticketsWeight[encodedNumber] -= _ticketWeight;\n            tickets.ticketsAmount[encodedNumber] -= _ticketAmount;\n        }\n    }\n\n    /**\n     * @notice Get the encoded number form\n     * @param _number The original number\n     * @param _position The number's position/level (0, 1, 2, 3)\n     */\n    function _encodedNumber(uint256 _number, uint256 _position)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_number % (10**(_position + 1))) + _position * 10000;\n    }\n\n    /**\n     * @notice Check if an address is a contract\n     */\n    function _isContract(address _addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return size > 0;\n    }\n\n    //\n    //\n\n    ///\n\n    //\n\n    //\n\n    function _viewUserTicetAmount(address user, uint256 encodedNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        return usersTickets[user].ticketsAmount[encodedNumber];\n    }\n\n    function _viewUserTicetWeight(address user, uint256 encodedNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        return usersTickets[user].ticketsWeight[encodedNumber];\n    }\n\n    function viewUserAllTicketsInfo(address user, uint256 maxAmount)\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256\n        )\n    {\n        uint256[] memory ticketsNumber = new uint256[](maxAmount);\n        uint256[] memory ticketsAmount = new uint256[](maxAmount);\n        uint256[] memory ticketsWeight = new uint256[](maxAmount);\n\n        uint256 amount = 0;\n        uint256 number = 0;\n        uint256 i0 = 0;\n        uint256 i1 = 0;\n        uint256 i2 = 0;\n        uint256 i3 = 0;\n\n        for (i0 = 0; i0 <= 9; i0++) {\n            number = i0;\n            if (_viewUserTicetAmount(user, _encodedNumber(number, 0)) == 0)\n                continue;\n            for (i1 = 0; i1 <= 9; i1++) {\n                number = i0 + i1 * 10;\n                if (_viewUserTicetAmount(user, _encodedNumber(number, 1)) == 0)\n                    continue;\n                for (i2 = 0; i2 <= 9; i2++) {\n                    number = i0 + i1 * 10 + i2 * 100;\n                    if (\n                        _viewUserTicetAmount(user, _encodedNumber(number, 2)) ==\n                        0\n                    ) continue;\n                    for (i3 = 0; i3 <= 9; i3++) {\n                        number = i0 + i1 * 10 + i2 * 100 + i3 * 1000;\n                        if (\n                            _viewUserTicetAmount(\n                                user,\n                                _encodedNumber(number, 3)\n                            ) == 0\n                        ) continue;\n                        ticketsNumber[amount] = number;\n                        ticketsAmount[amount] = _viewUserTicetAmount(\n                            user,\n                            _encodedNumber(number, 3)\n                        );\n                        ticketsWeight[amount] = _viewUserTicetWeight(\n                            user,\n                            _encodedNumber(number, 3)\n                        );\n                        amount++;\n                        if (amount >= maxAmount)\n                            return (\n                                ticketsNumber,\n                                ticketsAmount,\n                                ticketsWeight,\n                                amount\n                            );\n                    }\n                }\n            }\n        }\n        return (ticketsNumber, ticketsAmount, ticketsWeight, amount);\n    }\n\n    function viewUserRewardsInfo(\n        address user,\n        uint256 _startRound,\n        uint256 _endRound\n    )\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        require(\n            _startRound <= _endRound,\n            \"End lottery smaller than start lottery\"\n        );\n        require(_endRound <= currentLotteryId, \"End lottery round not open\");\n\n        require(\n            lotteries[_endRound].status == Status.Claimable,\n            \"this round of lottery are not ready for claiming\"\n        );\n\n        uint256[] memory lotteryIds = new uint256[](\n            _endRound - _startRound + 1\n        );\n        uint256[] memory userRewards = new uint256[](\n            _endRound - _startRound + 1\n        );\n        uint256[] memory userDrawed = new uint256[](\n            _endRound - _startRound + 1\n        );\n        uint256 userStartLotteryId = userCheckPoint[user];\n        for (uint256 i = _startRound; i <= _endRound; i++) {\n            lotteryIds[i - _startRound] = i;\n            if (i < userStartLotteryId) {\n                userDrawed[i - _startRound] = 1;\n                userRewards[i - _startRound] = usersRewards[user][i];\n            } else {\n                userDrawed[i - _startRound] = 0;\n                userRewards[i - _startRound] = receiveRward(i, user);\n            }\n        }\n        return (lotteryIds, userRewards, userDrawed);\n    }\n}\n"
    },
    "contracts/lucky-box/interfaces/IRandomNumberGenerator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IRandomNumberGenerator {\n    /**\n     * @notice Views random result\n     */\n    function getRandomNumber() external;\n\n    function randomResult() external view returns (uint32);\n\n    function latestLotteryId() external view returns (uint256);\n}\n"
    },
    "contracts/farming/FarmingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../libraries/SafePRBMath.sol\";\n\nimport \"../utils/Ownable.sol\";\n\nimport \"../tokens/interfaces/IDegisToken.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title  Farming Pool\n * @notice This contract is for LPToken mining on Degis\n * @dev    The pool id starts from 1 not 0\n */\ncontract FarmingPool is Ownable, ReentrancyGuard {\n    using SafePRBMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IDegisToken;\n\n    // PoolId starts from 1\n    uint256 public _nextPoolId;\n\n    struct PoolInfo {\n        address lpToken;\n        uint256 degisPerBlock;\n        uint256 lastRewardBlock;\n        uint256 accDegisPerShare;\n    }\n    PoolInfo[] public poolList;\n\n    // lptoken address => poolId\n    mapping(address => uint256) public poolMapping;\n\n    // poolId => alreadyFarming\n    mapping(uint256 => bool) public isFarming;\n\n    struct UserInfo {\n        uint256 rewardDebt; // degis reward debt\n        uint256 stakingBalance; // the amount of a user's staking in the pool\n    }\n    // poolId => userAddress => userInfo\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    // The reward token is degis\n    IDegisToken public degis;\n\n    uint256 public startBlock; // Farming starts from a certain block number\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n    event StartBlockChanged(uint256 startBlock);\n    event Stake(address staker, uint256 poolId, uint256 amount);\n    event Withdraw(address staker, uint256 poolId, uint256 amount);\n    event Harvest(\n        address staker,\n        address rewardReceiver,\n        uint256 poolId,\n        uint256 pendingReward\n    );\n    event HarvestAndCompound(\n        address staker,\n        uint256 poolId,\n        uint256 pendingReward\n    );\n    event NewPoolAdded(address lpToken, uint256 degisPerBlock);\n    event RestartFarmingPool(uint256 poolId, uint256 blockNumber);\n    event FarmingPoolStopped(uint256 poolId, uint256 blockNumber);\n    event PoolUpdated(uint256 poolId);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(address _degis) {\n        degis = IDegisToken(_degis);\n\n        // Start from 1\n        _nextPoolId = 1;\n\n        // Manually fit the poolList[0] to avoid potential misleading\n        poolList.push(\n            PoolInfo({\n                lpToken: address(0),\n                degisPerBlock: 0,\n                lastRewardBlock: 0,\n                accDegisPerShare: 0\n            })\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice The address can not be zero\n     */\n    modifier notZeroAddress(address _address) {\n        require(_address != address(0), \"Can not be zero address\");\n        _;\n    }\n\n    modifier stillFarming(uint256 _poolId) {\n        require(isFarming[_poolId], \"Pool is not farming\");\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** View Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check the amount of pending degis reward\n     * @param _poolId PoolId of this farming pool\n     * @param _user User address\n     * @return pendingDegisAmount Amount of pending degis\n     */\n    function pendingDegis(uint256 _poolId, address _user)\n        external\n        view\n        notZeroAddress(_user)\n        returns (uint256)\n    {\n        PoolInfo memory poolInfo = poolList[_poolId];\n\n        if (\n            poolInfo.lastRewardBlock == 0 ||\n            block.number < poolInfo.lastRewardBlock ||\n            block.number < startBlock\n        ) return 0;\n\n        UserInfo memory user = userInfo[_poolId][_user];\n\n        uint256 lp_balance = IERC20(poolInfo.lpToken).balanceOf(address(this));\n\n        uint256 accDegisPerShare = poolInfo.accDegisPerShare;\n\n        if (lp_balance == 0) return 0;\n        else {\n            // Deigs amount given to this pool\n            uint256 blocks = block.number - poolInfo.lastRewardBlock;\n            uint256 degisReward = poolInfo.degisPerBlock * blocks;\n\n            // Update accDegisPerShare\n            accDegisPerShare += degisReward.div(lp_balance);\n\n            uint256 pending = user.stakingBalance.mul(accDegisPerShare) -\n                user.rewardDebt;\n            return pending;\n        }\n    }\n\n    /**\n     * @notice Get the total pool list\n     */\n    function getPoolList() external view returns (PoolInfo[] memory) {\n        return poolList;\n    }\n\n    /**\n     * @notice Get user balance\n     * @param _poolId Id of the pool\n     * @param _user Address of the user\n     * @return _balance User's balance (lpToken)\n     */\n    function getUserBalance(uint256 _poolId, address _user)\n        external\n        view\n        returns (uint256 _balance)\n    {\n        return userInfo[_poolId][_user].stakingBalance;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Set Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set the start block number\n     * @param _startBlock New start block number\n     */\n    function setStartBlock(uint256 _startBlock) external onlyOwner {\n        startBlock = _startBlock;\n        emit StartBlockChanged(_startBlock);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Add a new lp to the pool. Can only be called by the owner.\n     * @param _lpToken LP token address\n     * @param _degisPerBlock Reward distribution per block for this new pool\n     * @param _withUpdate Whether update all pools' status\n     */\n    function add(\n        address _lpToken,\n        uint256 _degisPerBlock,\n        bool _withUpdate\n    ) public notZeroAddress(_lpToken) onlyOwner {\n        // Check if already exists, if the poolId is 0, that means not in the pool\n        require(\n            !_alreadyInPool(_lpToken),\n            \"This lptoken is already in the farming pool\"\n        );\n\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n\n        uint256 lastRewardBlock = block.number > startBlock\n            ? block.number\n            : startBlock;\n\n        // Push this new pool into the list\n        poolList.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                degisPerBlock: _degisPerBlock,\n                lastRewardBlock: lastRewardBlock,\n                accDegisPerShare: 0\n            })\n        );\n\n        // Store the poolId and set the farming status to true\n        poolMapping[_lpToken] = _nextPoolId;\n        isFarming[_nextPoolId] = true;\n\n        _nextPoolId += 1;\n\n        emit NewPoolAdded(_lpToken, _degisPerBlock);\n    }\n\n    /**\n     * @notice Update the degisPerBlock for a specific pool (set to 0 to stop farming)\n     * @param _poolId Id of the farming pool\n     * @param _degisPerBlock New reward amount per block\n     * @param _withUpdate Whether update all the pool\n     */\n    function setDegisReward(\n        uint256 _poolId,\n        uint256 _degisPerBlock,\n        bool _withUpdate\n    ) public onlyOwner {\n        // Ensure there already exists this pool\n        require(poolList[_poolId].lastRewardBlock != 0, \"Pool not exists\");\n\n        if (_withUpdate) massUpdatePools();\n        else updatePool(_poolId);\n\n        if (isFarming[_poolId] == false && _degisPerBlock > 0) {\n            isFarming[_poolId] = true;\n            emit RestartFarmingPool(_poolId, block.number);\n        }\n\n        if (_degisPerBlock == 0) {\n            isFarming[_poolId] = false;\n            emit FarmingPoolStopped(_poolId, block.number);\n        } else {\n            poolList[_poolId].degisPerBlock = _degisPerBlock;\n        }\n    }\n\n    /**\n     * @notice Stake LP token into the farming pool\n     * @param _poolId Id of the farming pool\n     * @param _amount Staking amount\n     */\n    function stake(uint256 _poolId, uint256 _amount)\n        public\n        nonReentrant\n        stillFarming(_poolId)\n    {\n        require(_amount > 0, \"Can not stake zero\");\n\n        PoolInfo storage pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][_msgSender()];\n\n        // Must update first!!\n        updatePool(_poolId);\n\n        if (user.stakingBalance > 0) {\n            uint256 pending = user.stakingBalance.mul(pool.accDegisPerShare) -\n                user.rewardDebt;\n\n            _safeDegisTransfer(_msgSender(), pending);\n        }\n\n        // Transfer the lptoken into farming pool\n        IERC20(pool.lpToken).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _amount\n        );\n\n        user.stakingBalance += _amount;\n        user.rewardDebt = user.stakingBalance.mul(pool.accDegisPerShare);\n\n        emit Stake(_msgSender(), _poolId, _amount);\n    }\n\n    /**\n     * @notice Withdraw lptoken from the pool\n     * @param _poolId Id of the farming pool\n     * @param _amount Amount of lp tokens to withdraw\n     */\n    function withdraw(uint256 _poolId, uint256 _amount) public nonReentrant {\n        require(_amount > 0, \"Zero amount\");\n\n        PoolInfo storage pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][_msgSender()];\n\n        require(user.stakingBalance >= _amount, \"Not enough stakingBalance\");\n\n        if (isFarming[_poolId]) updatePool(_poolId);\n\n        uint256 pending = user.stakingBalance.mul(pool.accDegisPerShare) -\n            user.rewardDebt;\n\n        _safeDegisTransfer(_msgSender(), pending);\n\n        user.stakingBalance -= _amount;\n        user.rewardDebt = user.stakingBalance.mul(pool.accDegisPerShare);\n\n        IERC20(pool.lpToken).safeTransfer(_msgSender(), _amount);\n\n        emit Withdraw(_msgSender(), _poolId, _amount);\n    }\n\n    /**\n     * @notice Update the pool's reward status\n     * @param _poolId Id of the farming pool\n     */\n    function updatePool(uint256 _poolId) public {\n        PoolInfo storage pool = poolList[_poolId];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n\n        uint256 blocks = block.number - pool.lastRewardBlock;\n        uint256 degisReward = blocks * pool.degisPerBlock;\n\n        // Don't forget to set the farming pool as minter\n        degis.mintDegis(address(this), degisReward);\n\n        pool.accDegisPerShare += degisReward.div(lpSupply);\n\n        pool.lastRewardBlock = block.number;\n\n        emit PoolUpdated(_poolId);\n    }\n\n    /**\n     * @notice Harvest the degis reward and can be sent to another address\n     * @param _poolId: Id of the farming pool\n     * @param _to Receiver of degis rewards.\n     */\n    function harvest(uint256 _poolId, address _to) public nonReentrant {\n        if (isFarming[_poolId]) updatePool(_poolId);\n\n        PoolInfo memory pool = poolList[_poolId];\n        UserInfo storage user = userInfo[_poolId][_msgSender()];\n\n        uint256 pendingReward = user.stakingBalance.mul(pool.accDegisPerShare) -\n            user.rewardDebt;\n\n        // Effects\n        user.rewardDebt = user.stakingBalance.mul(pool.accDegisPerShare);\n\n        // Interactions\n        if (pendingReward != 0) {\n            degis.safeTransfer(_to, pendingReward);\n        }\n\n        emit Harvest(_msgSender(), _to, _poolId, pendingReward);\n    }\n\n\n    /**\n     * @notice Update all farming pools (except for those stopped ones)\n     */\n    function massUpdatePools() public {\n        uint256 length = poolList.length;\n        for (uint256 poolId = 0; poolId < length; poolId++) {\n            if (isFarming[poolId] == false) continue;\n            else updatePool(poolId);\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ********************************** Internal Functions ********************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if a lptoken has been added into the pool before\n     * @dev This can be written as a modifier, I just want to test the error form\n     * @param _lpTokenAddress LP token address\n     * @return _isInPool Wether this lp already in pool\n     */\n    function _alreadyInPool(address _lpTokenAddress)\n        internal\n        view\n        returns (bool _isInPool)\n    {\n        uint256 poolId = poolMapping[_lpTokenAddress];\n\n        _isInPool = (poolId != 0) ? true : false;\n    }\n\n    /**\n     * @notice Safe degis transfer (check if the pool has enough DEGIS token)\n     * @param _to User's address\n     * @param _amount Amount to transfer\n     */\n    function _safeDegisTransfer(address _to, uint256 _amount) internal {\n        uint256 totalDegis = degis.balanceOf(address(this));\n        if (_amount > totalDegis) {\n            degis.transfer(_to, totalDegis);\n        } else {\n            degis.transfer(_to, _amount);\n        }\n    }\n}\n"
    },
    "contracts/farming/PurchaseIncentiveVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../tokens/interfaces/IBuyerToken.sol\";\nimport \"../tokens/interfaces/IDegisToken.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../libraries/SafePRBMath.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title  Purchase Incentive Vault\n * @notice This is the purchase incentive vault for staking buyer tokens.\n *         Users first stake their buyer tokens and wait for distribution.\n *         About every 24 hours, the reward will be calculated to users' account.\n *         After disrtribution, users' reward balance will update but they still need to manually claim the reward.\n */\ncontract PurchaseIncentiveVault is Ownable {\n    using SafeERC20 for IBuyerToken;\n    using SafePRBMath for uint256;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    // Other contracts\n    IBuyerToken buyerToken;\n    IDegisToken degis;\n\n    // Current round number\n    uint256 public currentRound;\n\n    // Degis reward per round\n    uint256 public degisPerRound;\n\n    // The interval will only limit the distribution (not the staking)\n    uint256 public distributionInterval;\n\n    // Last distribution block\n    uint256 public lastDistributionBlock;\n\n    uint256 public MAX_ROUND = 50;\n\n    // Current distribution index\n    uint256 currentDistributionIndex;\n\n    struct RoundInfo {\n        uint256 shares;\n        address[] users;\n        bool hasDistributed;\n        uint256 degisPerShare;\n    }\n    mapping(uint256 => RoundInfo) public roundInfo;\n\n    struct UserInfo {\n        uint256 lastRewardRound;\n        uint256[] pendingRounds;\n    }\n    mapping(address => UserInfo) public userInfo;\n\n    // User address => Round number => User shares\n    mapping(address => mapping(uint256 => uint256)) public userSharesInRound;\n\n    // User address => Pending rewards\n    mapping(address => uint256) public userRewards;\n\n    mapping(address => uint256) public userLastRewardRound;\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event DegisPerRoundChanged(uint256 oldPerRound, uint256 newPerRound);\n    event DistributionIntervalChanged(uint256 oldInterval, uint256 newInterval);\n    event Stake(address userAddress, uint256 currentRound, uint256 amount);\n    event Redeem(address userAddress, uint256 currentRound, uint256 amount);\n    event RewardClaimed(address userAddress, uint256 userReward);\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Constructor ************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor(address _buyerToken, address _degisToken) {\n        // Initialize two tokens\n        buyerToken = IBuyerToken(_buyerToken);\n        degis = IDegisToken(_degisToken);\n\n        // Initialize the last distribution block\n        lastDistributionBlock = block.number;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************** Modifiers *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Check if admins can distribute at this time\n     */\n    modifier hasPassedInterval() {\n        require(\n            block.number - lastDistributionBlock > distributionInterval,\n            \"Two distributions need to have an interval \"\n        );\n        _;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ View Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Get the amount of users in _round, used for distribution\n     * @param _round Round number to check\n     * @return totalUsers Total amount of users in _round\n     */\n    function getTotalUsersInRound(uint256 _round)\n        public\n        view\n        returns (uint256)\n    {\n        return roundInfo[_round].users.length;\n    }\n\n    /**\n     * @notice Get your shares in the current round\n     * @param _user Address of the user\n     */\n    function getUserShares(address _user) public view returns (uint256) {\n        return userSharesInRound[_user][currentRound];\n    }\n\n    /**\n     * @notice Get a user's pending reward\n     * @return userPendingReward User's pending reward\n     */\n    function pendingReward() public view returns (uint256) {\n        UserInfo memory user = userInfo[_msgSender()];\n\n        uint256 length = user.pendingRounds.length - user.lastRewardRound;\n        uint256 startIndex = user.lastRewardRound;\n\n        uint256 userPendingReward;\n        for (uint256 i = startIndex; i < startIndex + length; i++) {\n            uint256 round = user.pendingRounds[i];\n\n            userPendingReward += roundInfo[round].degisPerShare.mul(\n                userSharesInRound[_msgSender()][round]\n            );\n        }\n\n        return userPendingReward;\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Set Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Set degis distribution per round\n     * @param _degisPerRound Degis distribution per round to be set\n     */\n    function setDegisPerRound(uint256 _degisPerRound) external onlyOwner {\n        uint256 oldPerRound = degisPerRound;\n        degisPerRound = _degisPerRound;\n        emit DegisPerRoundChanged(oldPerRound, _degisPerRound);\n    }\n\n    /**\n     * @notice Set a new distribution interval\n     * @param _newInterval The new interval\n     */\n    function setDistributionInterval(uint256 _newInterval) external onlyOwner {\n        uint256 oldInterval = distributionInterval;\n        distributionInterval = _newInterval;\n        emit DistributionIntervalChanged(oldInterval, _newInterval);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Stake buyer tokens into this contract\n     * @param _amount Amount of buyer tokens to stake\n     */\n    function stake(uint256 _amount) external {\n        buyerToken.safeTransferFrom(_msgSender(), address(this), _amount);\n\n        if (userSharesInRound[_msgSender()][currentRound] == 0) {\n            roundInfo[currentRound].users.push(_msgSender());\n        }\n\n        userSharesInRound[_msgSender()][currentRound] += _amount;\n\n        if (userInfo[_msgSender()].pendingRounds.length == 0)\n            userInfo[_msgSender()].lastRewardRound = currentRound;\n\n        userInfo[_msgSender()].pendingRounds.push(currentRound);\n\n        roundInfo[currentRound].shares += _amount;\n\n        emit Stake(_msgSender(), currentRound, _amount);\n    }\n\n    /**\n     * @notice Redeem buyer token from the vault\n     * @param _amount Amount to redeem\n     */\n    function redeem(uint256 _amount) external {\n        uint256 userBalance = userSharesInRound[_msgSender()][currentRound];\n        require(\n            userBalance >= _amount,\n            \"Not enough buyer tokens for you to redeem\"\n        );\n\n        buyerToken.safeTransfer(_msgSender(), _amount);\n\n        userSharesInRound[_msgSender()][currentRound] -= _amount;\n\n        userInfo[_msgSender()].pendingRounds.pop();\n\n        roundInfo[currentRound].shares -= _amount;\n\n        emit Redeem(_msgSender(), currentRound, _amount);\n    }\n\n    /**\n     * @notice Setttle the current round\n     */\n    function settleCurrentRound() external onlyOwner {\n        RoundInfo storage info = roundInfo[currentRound];\n        require(info.hasDistributed == false, \"Already distributed this round\");\n\n        uint256 totalShares = info.shares;\n\n        info.degisPerShare = degisPerRound.div(totalShares);\n        info.hasDistributed = true;\n\n        currentRound += 1;\n        lastDistributionBlock = block.number;\n    }\n\n    /**\n     * @notice User can claim his own reward\n     */\n    function claimOwnReward() external {\n        UserInfo memory user = userInfo[_msgSender()];\n\n        require(user.pendingRounds.length != 0, \"You have no shares ever\");\n\n        uint256 length = user.pendingRounds.length - user.lastRewardRound;\n        uint256 startIndex = user.lastRewardRound;\n        if (length > MAX_ROUND) {\n            length = MAX_ROUND;\n\n            userInfo[_msgSender()].lastRewardRound = user.pendingRounds[\n                MAX_ROUND\n            ];\n        } else\n            userInfo[_msgSender()].lastRewardRound =\n                user.pendingRounds[length - 1] +\n                1;\n\n        uint256 userPendingReward;\n\n        for (uint256 i = startIndex; i < startIndex + length; i++) {\n            uint256 round = user.pendingRounds[i];\n\n            userPendingReward += roundInfo[round].degisPerShare.mul(\n                userSharesInRound[_msgSender()][round]\n            );\n        }\n\n        degis.mintDegis(_msgSender(), userPendingReward);\n    }\n\n    // /**\n    //  * @notice Distribute the reward in this round, the total number depends on the blocks during this period\n    //  * @param _startIndex Distribution start index\n    //  * @param _stopIndex Distribution stop index\n    //  */\n    // function distributeReward(uint256 _startIndex, uint256 _stopIndex)\n    //     external\n    //     onlyOwner\n    //     hasPassedInterval\n    // {\n    //     require(\n    //         degisPerRound > 0,\n    //         \"Currently no Degis reward, please set degisPerRound first\"\n    //     );\n    //     require(\n    //         roundInfo[currentRound].hasDistributed == false,\n    //         \"Current round has been distributed\"\n    //     );\n\n    //     uint256 totalShares = roundInfo[currentRound].shares;\n    //     uint256 degisPerShare = degisPerRound.div(totalShares);\n\n    //     uint256 length = getTotalUsersInRound(currentRound);\n\n    //     // Distribute all at once\n    //     // Maybe not enough gas in one tx, the judgement should be done by backend)\n    //     if (_startIndex == 0 && _stopIndex == 0) {\n    //         _distributeReward(currentRound, 0, length, degisPerShare);\n    //         currentDistributionIndex = length;\n    //     }\n    //     // Distribute in a certain range (need several times distribution)\n    //     else {\n    //         // Check if you start from the last check point\n    //         require(\n    //             currentDistributionIndex == _startIndex,\n    //             \"You need to start from the last distribution point\"\n    //         );\n    //         // Check if the stopindex exceeds the length\n    //         _stopIndex = _stopIndex > length ? length : _stopIndex;\n\n    //         if (_stopIndex != 0) {\n    //             _distributeReward(\n    //                 currentRound,\n    //                 _startIndex,\n    //                 _stopIndex,\n    //                 degisPerShare\n    //             );\n    //         }\n\n    //         currentDistributionIndex = _stopIndex;\n    //     }\n\n    //     if (currentDistributionIndex == length) {\n    //         _finishDistribution();\n    //     }\n    // }\n\n    // /**\n    //  * @notice Users need to claim their overall rewards\n    //  */\n    // function claimReward() external {\n    //     uint256 userReward = userRewards[_msgSender()];\n\n    //     require(userReward > 0, \"You do not have any rewards to claim\");\n\n    //     degis.mintDegis(_msgSender(), userReward);\n\n    //     delete userRewards[_msgSender()];\n\n    //     emit RewardClaimed(_msgSender(), userReward);\n    // }\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Internal Functions ********************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    // /**\n    //  * @notice Finish the distribution process\n    //  * @param _round Distribution round\n    //  * @param _startIndex Start index\n    //  * @param _stopIndex Stop index\n    //  * @param _degisPerShare Amount of degis per share\n    //  */\n    // function _distributeReward(\n    //     uint256 _round,\n    //     uint256 _startIndex,\n    //     uint256 _stopIndex,\n    //     uint256 _degisPerShare\n    // ) internal {\n    //     for (uint256 i = _startIndex; i < _stopIndex; i++) {\n    //         address userAddress = usersInRound[_round][i];\n    //         uint256 userShares = userSharesInRound[userAddress][_round];\n\n    //         buyerToken.burnBuyerToken(address(this), userShares);\n\n    //         if (userShares != 0) {\n    //             // Update the pending reward of a user\n    //             userRewards[userAddress] += userShares.mul(_degisPerShare);\n    //             delete userSharesInRound[userAddress][_round];\n    //         } else continue;\n    //     }\n    // }\n\n    // /**\n    //  * @notice Finish the distribution process and move to next round\n    //  */\n    // function _finishDistribution() internal {\n    //     currentDistributionIndex = 0;\n    //     hasDistributed[currentRound] = true;\n    //     currentRound += 1;\n    //     lastDistributionBlock = block.number;\n    // }\n}\n"
    },
    "contracts/EmergencyPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./utils/Ownable.sol\";\n\n/**\n * @title  Emergency Pool\n * @notice Emergency pool in degis will keep a reserve vault for emergency usage.\n *         The asset comes from part of the product's income (currently 10%).\n *         Users can also stake funds into this contract manually.\n *         The owner has the right to withdraw funds from emergency pool and it would be passed to community governance.\n */\ncontract EmergencyPool is Ownable {\n    using SafeERC20 for IERC20;\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************* Variables **************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    string public name = \"Degis Emergency Pool\";\n\n    // ---------------------------------------------------------------------------------------- //\n    // *************************************** Events ***************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    event Deposit(\n        address indexed tokenAddress,\n        address indexed userAddress,\n        uint256 amount\n    );\n    event Withdraw(\n        address indexed tokenAddress,\n        address indexed userAddress,\n        uint256 amount\n    );\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Manually stake into the pool\n     * @param _tokenAddress Address of the ERC20 token\n     * @param _amount The amount that the user want to stake\n     */\n    function deposit(address _tokenAddress, uint256 _amount) external {\n        require(_amount > 0, \"Please deposit some funds\");\n\n        IERC20(_tokenAddress).safeTransferFrom(\n            _msgSender(),\n            address(this),\n            _amount\n        );\n\n        emit Deposit(_tokenAddress, _msgSender(), _amount);\n    }\n\n    /**\n     * @notice Withdraw the asset when emergency (only by the owner)\n     * @dev The ownership need to be transferred to another contract in the future\n     * @param _tokenAddress Address of the ERC20 token\n     * @param _amount The amount that the user want to unstake\n     */\n    function emergencyWithdraw(address _tokenAddress, uint256 _amount)\n        external\n        onlyOwner\n    {\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\n        require(_amount <= balance, \"Not enough balance to withdraw\");\n\n        IERC20(_tokenAddress).safeTransfer(owner(), _amount);\n        emit Withdraw(_tokenAddress, owner(), _amount);\n    }\n}\n"
    },
    "contracts/chainlinkMock/VRFMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../utils/Ownable.sol\";\nimport \"../lucky-box/interfaces/IDegisLottery.sol\";\n\nimport \"../libraries/StringsUtils.sol\";\n\ncontract VRFMock is Ownable {\n    using StringsUtils for uint256;\n\n    IDegisLottery public DegisLottery;\n\n    uint256 public randomResult;\n\n    uint256 public latestLotteryId;\n\n    /**\n     * @notice Set the address for the DegisLottery\n     * @param _degisLottery address of the PancakeSwap lottery\n     */\n    function setLotteryAddress(address _degisLottery) external onlyOwner {\n        DegisLottery = IDegisLottery(_degisLottery);\n    }\n\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Main Functions ************************************ //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Request randomness from Chainlink VRF\n     */\n    function getRandomNumber() external {\n        require(_msgSender() == address(DegisLottery), \"Only DegisLottery\");\n\n        // TODO: This part is only for test on Fuji Testnet because there is no VRF currently\n        string memory randInput = string(\n            abi.encodePacked((block.timestamp).uintToString(), address(this))\n        );\n        randomResult = _rand(randInput) % 10000;\n\n        latestLotteryId = IDegisLottery(DegisLottery).currentLotteryId();\n    }\n\n    function _rand(string memory input) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(input)));\n    }\n}\n"
    },
    "contracts/tokens/BuyerToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"../utils/ERC20PermitWithMultipleMinters.sol\";\n\n/**\n * @title  Buyer Token\n * @notice Buyer tokens are distributed to buyers corresponding to the usd value they spend.\n *         Users can deposit their buyer tokens into purchaseIncentiveVault.\n *         Periodical reward will be given to the participants in purchaseIncentiveVault.\n *         When distributing purchase incentive reward, the buyer tokens will be burned.\n * @dev    Need to set the correct minters and burners when reploying this contract.\n */\ncontract BuyerToken is ERC20PermitWithMultipleMinters {\n    // ---------------------------------------------------------------------------------------- //\n    // ************************************ Constructor *************************************** //\n    // ---------------------------------------------------------------------------------------- //\n\n    constructor() ERC20PermitWithMultipleMinters(\"DegisBuyerToken\", \"DBT\") {}\n\n    // ---------------------------------------------------------------------------------------- //\n    // *********************************** Main Functions ************************************* //\n    // ---------------------------------------------------------------------------------------- //\n\n    /**\n     * @notice Mint buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be minted\n     */\n    function mintBuyerToken(address _account, uint256 _amount) external {\n        mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burn buyer tokens\n     * @param  _account Receiver's address\n     * @param  _amount Amount to be burned\n     */\n    function burnBuyerToken(address _account, uint256 _amount) external {\n        burn(_account, _amount);\n    }\n}\n"
    },
    "contracts/libraries/SafePRBMathTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./SafePRBMath.sol\";\n\ncontract SafePRBMathTester {\n    function avg(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.avg(x, y);\n    }\n\n    function ceil(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.ceil(x);\n    }\n\n    function div(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.div(x, y);\n    }\n\n    function e() public pure returns (uint256 result) {\n        return SafePRBMath.e();\n    }\n\n    function exp(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.exp(x);\n    }\n\n    function exp2(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.exp2(x);\n    }\n\n    function floor(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.floor(x);\n    }\n\n    function frac(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.frac(x);\n    }\n\n    function fromUint(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.fromUint(x);\n    }\n\n    function gm(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.gm(x, y);\n    }\n\n    function inv(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.inv(x);\n    }\n\n    function ln(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.ln(x);\n    }\n\n    function log10(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.log10(x);\n    }\n\n    function log2(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.log2(x);\n    }\n\n    function mul(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.mul(x, y);\n    }\n\n    function pi() public pure returns (uint256 result) {\n        return SafePRBMath.pi();\n    }\n\n    function pow(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.pow(x, y);\n    }\n\n    function powu(uint256 x, uint256 y) public pure returns (uint256 result) {\n        return SafePRBMath.powu(x, y);\n    }\n\n    function scale() public pure returns (uint256 result) {\n        return SafePRBMath.scale();\n    }\n\n    function sqrt(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.sqrt(x);\n    }\n\n    function toUint(uint256 x) public pure returns (uint256 result) {\n        return SafePRBMath.toUint(x);\n    }\n}\n"
    },
    "contracts/libraries/StringsUtilsTester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./StringsUtils.sol\";\n\ncontract StringsUtilsTester {\n    function byToString(bytes32 _bytes) public pure returns (string memory) {\n        return StringsUtils.byToString(_bytes);\n    }\n\n    function addressToString(address _addr)\n        public\n        pure\n        returns (string memory)\n    {\n        return StringsUtils.addressToString(_addr);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function uintToString(uint256 value) public pure returns (string memory) {\n        return StringsUtils.uintToString(value);\n    }\n\n    function uintToHexString(uint256 value)\n        public\n        pure\n        returns (string memory)\n    {\n        return StringsUtils.uintToHexString(value);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function uintToHexString(uint256 value, uint256 length)\n        public\n        pure\n        returns (string memory)\n    {\n        return StringsUtils.uintToHexString(value, length);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}